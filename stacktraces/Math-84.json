{"tours": [{"failing_test": {"className": " org.apache.commons.math.optimization.direct.MultiDirectionalTest", "methodName": "testMinimizeMaximize", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java", "method_name": "iterateSimplex", "content": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }", "javadoc_start_line": 59, "annotations_start_line": 60, "method_start_line": 62, "end_line": 99}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java", "method_name": "testMinimizeMaximize", "content": "  public void testMinimizeMaximize()\n      throws FunctionEvaluationException, ConvergenceException {\n\n      // the following function has 4 local extrema:\n      final double xM        = -3.841947088256863675365;\n      final double yM        = -1.391745200270734924416;\n      final double xP        =  0.2286682237349059125691;\n      final double yP        = -yM;\n      final double valueXmYm =  0.2373295333134216789769; // local  maximum\n      final double valueXmYp = -valueXmYm;                // local  minimum\n      final double valueXpYm = -0.7290400707055187115322; // global minimum\n      final double valueXpYp = -valueXpYm;                // global maximum\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\n          private static final long serialVersionUID = -7039124064449091152L;\n          public double value(double[] variables) throws FunctionEvaluationException {\n              final double x = variables[0];\n              final double y = variables[1];\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) / (x * y));\n          }\n      };\n\n      MultiDirectional optimizer = new MultiDirectional();\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\n      optimizer.setMaxIterations(200);\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\n      RealPointValuePair optimum;\n\n      // minimization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n      // maximization\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\n      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\n\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\n      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\n      Assert.assertTrue(optimizer.getEvaluations() > 180);\n      Assert.assertTrue(optimizer.getEvaluations() < 220);\n\n  }", "javadoc_start_line": 70, "annotations_start_line": 69, "method_start_line": 71, "end_line": 128}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java", "method_name": "optimize", "content": "    /** {@inheritDoc} */\n    public RealPointValuePair optimize(final MultivariateRealFunction f,\n                                         final GoalType goalType,\n                                         final double[] startPoint)\n        throws FunctionEvaluationException, OptimizationException,\n        IllegalArgumentException {\n\n        if (startConfiguration == null) {\n            // no initial configuration has been set up for simplex\n            // build a default one from a unit hypercube\n            final double[] unit = new double[startPoint.length];\n            Arrays.fill(unit, 1.0);\n            setStartConfiguration(unit);\n        }\n\n        this.f = f;\n        final Comparator<RealPointValuePair> comparator =\n            new Comparator<RealPointValuePair>() {\n                public int compare(final RealPointValuePair o1,\n                                   final RealPointValuePair o2) {\n                    final double v1 = o1.getValue();\n                    final double v2 = o2.getValue();\n                    return (goalType == GoalType.MINIMIZE) ?\n                            Double.compare(v1, v2) : Double.compare(v2, v1);\n                }\n            };\n\n        // initialize search\n        iterations  = 0;\n        evaluations = 0;\n        buildSimplex(startPoint);\n        evaluateSimplex(comparator);\n\n        RealPointValuePair[] previous = new RealPointValuePair[simplex.length];\n        while (true) {\n\n            if (iterations > 0) {\n                boolean converged = true;\n                for (int i = 0; i < simplex.length; ++i) {\n                    converged &= checker.converged(iterations, previous[i], simplex[i]);\n                }\n                if (converged) {\n                    // we have found an optimum\n                    return simplex[0];\n                }\n            }\n\n            // we still need to search\n            System.arraycopy(simplex, 0, previous, 0, simplex.length);\n            iterateSimplex(comparator);\n\n        }\n\n    }", "javadoc_start_line": 258, "annotations_start_line": 259, "method_start_line": 263, "end_line": 311}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java", "method_name": "iterateSimplex", "content": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }", "javadoc_start_line": 59, "annotations_start_line": 60, "method_start_line": 62, "end_line": 99}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.direct.MultiDirectionalTest", "methodName": "testMath283", "error": "org.apache.commons.math.optimization.OptimizationException", "message": "org.apache.commons.math.MaxIterationsExceededException: Maximal number of iterations (100) exceeded"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java", "method_name": "iterateSimplex", "content": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }", "javadoc_start_line": 59, "annotations_start_line": 60, "method_start_line": 62, "end_line": 99}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java", "method_name": "testMath283", "content": "  public void testMath283()\n      throws FunctionEvaluationException, OptimizationException {\n      // fails because MultiDirectional.iterateSimplex is looping forever\n      // the while(true) should be replaced with a convergence check\n      MultiDirectional multiDirectional = new MultiDirectional();\n      multiDirectional.setMaxIterations(100);\n      multiDirectional.setMaxEvaluations(1000);\n\n      final Gaussian2D function = new Gaussian2D(0.0, 0.0, 1.0);\n\n      RealPointValuePair estimate = multiDirectional.optimize(function,\n                                    GoalType.MAXIMIZE, function.getMaximumPosition());\n\n      final double EPSILON = 1e-5;\n\n      final double expectedMaximum = function.getMaximum();\n      final double actualMaximum = estimate.getValue();\n      Assert.assertEquals(expectedMaximum, actualMaximum, EPSILON);\n\n      final double[] expectedPosition = function.getMaximumPosition();\n      final double[] actualPosition = estimate.getPoint();\n      Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );\n      Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n      \n  }", "javadoc_start_line": 193, "annotations_start_line": 192, "method_start_line": 194, "end_line": 217}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java", "method_name": "optimize", "content": "    /** {@inheritDoc} */\n    public RealPointValuePair optimize(final MultivariateRealFunction f,\n                                         final GoalType goalType,\n                                         final double[] startPoint)\n        throws FunctionEvaluationException, OptimizationException,\n        IllegalArgumentException {\n\n        if (startConfiguration == null) {\n            // no initial configuration has been set up for simplex\n            // build a default one from a unit hypercube\n            final double[] unit = new double[startPoint.length];\n            Arrays.fill(unit, 1.0);\n            setStartConfiguration(unit);\n        }\n\n        this.f = f;\n        final Comparator<RealPointValuePair> comparator =\n            new Comparator<RealPointValuePair>() {\n                public int compare(final RealPointValuePair o1,\n                                   final RealPointValuePair o2) {\n                    final double v1 = o1.getValue();\n                    final double v2 = o2.getValue();\n                    return (goalType == GoalType.MINIMIZE) ?\n                            Double.compare(v1, v2) : Double.compare(v2, v1);\n                }\n            };\n\n        // initialize search\n        iterations  = 0;\n        evaluations = 0;\n        buildSimplex(startPoint);\n        evaluateSimplex(comparator);\n\n        RealPointValuePair[] previous = new RealPointValuePair[simplex.length];\n        while (true) {\n\n            if (iterations > 0) {\n                boolean converged = true;\n                for (int i = 0; i < simplex.length; ++i) {\n                    converged &= checker.converged(iterations, previous[i], simplex[i]);\n                }\n                if (converged) {\n                    // we have found an optimum\n                    return simplex[0];\n                }\n            }\n\n            // we still need to search\n            System.arraycopy(simplex, 0, previous, 0, simplex.length);\n            iterateSimplex(comparator);\n\n        }\n\n    }", "javadoc_start_line": 258, "annotations_start_line": 259, "method_start_line": 263, "end_line": 311}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java", "method_name": "iterateSimplex", "content": "    /** {@inheritDoc} */\n    @Override\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }", "javadoc_start_line": 59, "annotations_start_line": 60, "method_start_line": 62, "end_line": 99}]}], "project": {"name": "Math", "version": 84}}