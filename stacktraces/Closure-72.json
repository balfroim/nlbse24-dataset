{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testInlineFunctions31", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionToBlockMutator.java", "method_name": "makeLocalNamesUnique", "content": "  /**\n   * Fix-up all local names to be unique for this subtree.\n   * @param fnNode A mutable instance of the function to be inlined.\n   */\n  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(\n        compiler, fnNode, new MakeDeclaredNamesUnique(\n            new InlineRenamer(\n                idSupplier,\n                \"inline_\",\n                isCallInLoop)));\n    // Make label names unique to this instance.\n  }", "javadoc_start_line": 138, "annotations_start_line": 142, "method_start_line": 142, "end_line": 152}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineFunctions.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions(fnNames);\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "javadoc_start_line": 106, "annotations_start_line": 105, "method_start_line": 106, "end_line": 142}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 416, "annotations_start_line": 419, "method_start_line": 420, "end_line": 423}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 241, "annotations_start_line": 244, "method_start_line": 244, "end_line": 254}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "inline", "content": "  /**\n   * Inline a function into the call site.\n   */\n  Node inline(\n      NodeTraversal t, Node callNode, String fnName, Node fnNode,\n      InliningMode mode) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    if (mode == InliningMode.DIRECT) {\n      return inlineReturnValue(callNode, fnNode);\n    } else {\n      return inlineFunction(callNode, fnNode, fnName);\n    }\n  }", "javadoc_start_line": 212, "annotations_start_line": 215, "method_start_line": 217, "end_line": 225}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "inlineFunction", "content": "  /**\n   * Inline a function which fulfills the requirements of\n   * canInlineReferenceAsStatementBlock into the call site, replacing the\n   * parent expression.\n   */\n  private Node inlineFunction(\n      Node callNode, Node fnNode, String fnName) {\n    Node parent = callNode.getParent();\n    Node grandParent = parent.getParent();\n\n    // TODO(johnlenz): Consider storing the callSite classification in the\n    // reference object and passing it in here.\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    Preconditions.checkArgument(callSiteType != CallSiteType.UNSUPPORTED);\n\n    // Store the name for the result. This will be used to\n    // replace \"return expr\" statements with \"resultName = expr\"\n    // to replace\n    String resultName = null;\n    boolean needsDefaultReturnResult = true;\n    switch (callSiteType) {\n      case SIMPLE_ASSIGNMENT:\n        resultName = parent.getFirstChild().getString();\n        break;\n\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        resultName = parent.getString();\n        break;\n\n      case SIMPLE_CALL:\n        resultName = null;  // \"foo()\" doesn't need a result.\n        needsDefaultReturnResult = false;\n        break;\n\n      case EXPRESSION:\n        resultName = getUniqueResultName();\n        needsDefaultReturnResult = false; // The intermediary result already\n                                          // has the default value.\n        break;\n\n      case DECOMPOSABLE_EXPRESSION:\n        throw new IllegalStateException(\n            \"Decomposable expressions must decomposed before inlining.\");\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    boolean isCallInLoop = NodeUtil.isWithinLoop(callNode);\n\n    FunctionToBlockMutator mutator = new FunctionToBlockMutator(\n        compiler, this.safeNameIdSupplier);\n\n    Node newBlock = mutator.mutate(\n        fnName, fnNode, callNode, resultName,\n        needsDefaultReturnResult, isCallInLoop);\n\n    // TODO(nicksantos): Create a common mutation function that\n    // can replace either a VAR name assignment, assignment expression or\n    // a EXPR_RESULT.\n    Node greatGrandParent = grandParent.getParent();\n    switch (callSiteType) {\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        // Remove the call from the name node.\n        parent.removeChild(parent.getFirstChild());\n        Preconditions.checkState(parent.getFirstChild() == null);\n        // Add the call, after the VAR.\n        greatGrandParent.addChildAfter(newBlock, grandParent);\n        break;\n\n      case SIMPLE_ASSIGNMENT:\n        // The assignment is now part of the inline function so\n        // replace it completely.\n        Preconditions.checkState(NodeUtil.isExpressionNode(grandParent));\n        greatGrandParent.replaceChild(grandParent, newBlock);\n        break;\n\n      case SIMPLE_CALL:\n        // If nothing is looking at the result just replace the call.\n        Preconditions.checkState(NodeUtil.isExpressionNode(parent));\n        grandParent.replaceChild(parent, newBlock);\n        break;\n\n      case EXPRESSION:\n        // TODO(johnlenz): Maybe change this so that movable and decomposable\n        // expressions are handled the same way: The call is moved and\n        // then handled by one the three basic cases, rather than\n        // introducing a new case.\n        Node injectionPoint = ExpressionDecomposer.findInjectionPoint(callNode);\n        Preconditions.checkNotNull(injectionPoint);\n        Node injectionPointParent = injectionPoint.getParent();\n        Preconditions.checkNotNull(injectionPointParent);\n        Preconditions.checkState(\n            NodeUtil.isStatementBlock(injectionPointParent));\n\n        // Declare the intermediate result name.\n        newBlock.addChildrenToFront(\n            NodeUtil.newVarNode(resultName, null)\n                 .copyInformationFromForTree(callNode));\n        // Inline the function before the selected injection point (before\n        // the call).\n        injectionPointParent.addChildBefore(newBlock, injectionPoint);\n        // Replace the call site with a reference to the intermediate\n        // result name.\n        parent.replaceChild(callNode, Node.newString(Token.NAME, resultName));\n        break;\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    return newBlock;\n  }", "javadoc_start_line": 372, "annotations_start_line": 377, "method_start_line": 378, "end_line": 484}, {"file_path": "/src/com/google/javascript/jscomp/FunctionToBlockMutator.java", "method_name": "mutate", "content": "  /**\n   * @param fnName The name to use when preparing human readable names.\n   * @param fnNode The function to prepare.\n   * @param callNode The call node that will be replaced.\n   * @param resultName Function results should be assigned to this name.\n   * @param needsDefaultResult Whether the result value must be set.\n   * @param isCallInLoop Whether the function body must be prepared to be\n   *   injected into the body of a loop.\n   * @return A clone of the function body mutated to be suitable for injection\n   *   as a statement into another code block.\n   */\n  Node mutate(String fnName, Node fnNode, Node callNode,\n      String resultName, boolean needsDefaultResult, boolean isCallInLoop) {\n    Node newFnNode = fnNode.cloneTree();\n    // Now that parameter names have been replaced, make sure all the local\n    // names are unique, to allow functions to be inlined multiple times\n    // without causing conflicts.\n    makeLocalNamesUnique(newFnNode, isCallInLoop);\n\n    // TODO(johnlenz): Mark NAME nodes constant for parameters that are not\n    // modified.\n    Set<String> namesToAlias =\n        FunctionArgumentInjector.findModifiedParameters(newFnNode);\n    LinkedHashMap<String, Node> args =\n        FunctionArgumentInjector.getFunctionCallParameterMap(\n            newFnNode, callNode, this.safeNameIdSupplier);\n    boolean hasArgs = !args.isEmpty();\n    if (hasArgs) {\n      FunctionArgumentInjector.maybeAddTempsForCallArguments(\n          newFnNode, args, namesToAlias, compiler.getCodingConvention());\n    }\n\n    Node newBlock = NodeUtil.getFunctionBody(newFnNode);\n    // Make the newBlock insertable .\n    newBlock.detachFromParent();\n\n    if (hasArgs) {\n      Node inlineResult = aliasAndInlineArguments(newBlock,\n          args, namesToAlias);\n      Preconditions.checkState(newBlock == inlineResult);\n    }\n\n    //\n    // For calls inlined into loops, VAR declarations are not reinitialized to\n    // undefined as they would have been if the function were called, so ensure\n    // that they are properly initialized.\n    //\n    if (isCallInLoop) {\n      fixUnitializedVarDeclarations(newBlock);\n    }\n\n    String labelName = getLabelNameForFunction(fnName);\n    Node injectableBlock = replaceReturns(\n        newBlock, resultName, labelName, needsDefaultResult);\n    Preconditions.checkState(injectableBlock != null);\n\n    return injectableBlock;\n  }", "javadoc_start_line": 50, "annotations_start_line": 61, "method_start_line": 62, "end_line": 107}, {"file_path": "/src/com/google/javascript/jscomp/FunctionToBlockMutator.java", "method_name": "makeLocalNamesUnique", "content": "  /**\n   * Fix-up all local names to be unique for this subtree.\n   * @param fnNode A mutable instance of the function to be inlined.\n   */\n  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(\n        compiler, fnNode, new MakeDeclaredNamesUnique(\n            new InlineRenamer(\n                idSupplier,\n                \"inline_\",\n                isCallInLoop)));\n    // Make label names unique to this instance.\n  }", "javadoc_start_line": 138, "annotations_start_line": 142, "method_start_line": 142, "end_line": 152}]}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testInlineFunctions31", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/RenameLabels.java", "method_name": "visitLabel", "content": "    /**\n     * Rename or remove labels.\n     * @param node  The label node.\n     * @param parent The parent of the label node.\n     */\n    private void visitLabel(Node node, Node parent) {\n      Node nameNode = node.getFirstChild();\n      Preconditions.checkState(nameNode != null);\n      String name = nameNode.getString();\n      LabelInfo li = getLabelInfo(name);\n      // This is a label...\n      if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n          // ... and it is used, give it the short name.\n          nameNode.setString(newName);\n          compiler.reportCodeChange();\n        }\n      } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n          NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n      }\n\n      // Remove the label from the current stack of labels.\n      namespaceStack.peek().renameMap.remove(name);\n    }", "javadoc_start_line": 204, "annotations_start_line": 209, "method_start_line": 209, "end_line": 235}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/72/results/stacktrace-testInlineFunctions31-visitLabel.csv'"}}], "project": {"name": "Closure", "version": 72}}