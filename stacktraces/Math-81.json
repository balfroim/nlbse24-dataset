{"tours": [{"failing_test": {"className": " org.apache.commons.math.linear.EigenDecompositionImplTest", "methodName": "testMath308", "error": "java.lang.ArrayIndexOutOfBoundsException", "message": "-1"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "computeShiftIncrement", "content": "    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }", "javadoc_start_line": 1423, "annotations_start_line": 1430, "method_start_line": 1430, "end_line": 1672}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java", "method_name": "testMath308", "content": "    public void testMath308() {\n\n        double[] mainTridiagonal = {\n            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n        };\n        double[] secondaryTridiagonal = {\n            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n        };\n\n        // the reference values have been computed using routine DSTEMR\n        // from the fortran library LAPACK version 3.2.1\n        double[] refEigenValues = {\n            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n        };\n        RealVector[] refEigenVectors = {\n            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\n            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n            new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\n            new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })\n        };\n\n        EigenDecomposition decomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n        double[] eigenValues = decomposition.getRealEigenvalues();\n        for (int i = 0; i < refEigenValues.length; ++i) {\n            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n            assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n        }\n\n    }", "javadoc_start_line": 112, "annotations_start_line": 112, "method_start_line": 112, "end_line": 143}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "EigenDecompositionImpl", "content": "    /**\n     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.\n     * @param main the main diagonal of the matrix (will be copied)\n     * @param secondary the secondary diagonal of the matrix (will be copied)\n     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n     * geometric mean to split the tridiagonal matrix (a suggested value is\n     * {@link MathUtils#SAFE_MIN})\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public EigenDecompositionImpl(final double[] main, double[] secondary,\n            final double splitTolerance)\n        throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        // pre-compute some elements\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }", "javadoc_start_line": 179, "annotations_start_line": 189, "method_start_line": 191, "end_line": 207}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "decompose", "content": "    /**\n     * Decompose a tridiagonal symmetric matrix.\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        // compute the Gershgorin circles\n        computeGershgorinCircles();\n\n        // find all the realEigenvalues\n        findEigenvalues();\n\n        // we will search for eigenvectors only if required\n        eigenvectors = null;\n\n    }", "javadoc_start_line": 230, "annotations_start_line": 235, "method_start_line": 235, "end_line": 251}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "findEigenvalues", "content": "    /**\n     * Find the realEigenvalues.\n     * @exception InvalidMatrixException if a block cannot be diagonalized\n     */\n    private void findEigenvalues()\n        throws InvalidMatrixException {\n\n        // compute splitting points\n        List<Integer> splitIndices = computeSplits();\n\n        // find realEigenvalues in each block\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n\n            case 1:\n                // apply dedicated method for dimension 1\n                process1RowBlock(begin);\n                break;\n\n            case 2:\n                // apply dedicated method for dimension 2\n                process2RowsBlock(begin);\n                break;\n\n            case 3:\n                // apply dedicated method for dimension 3\n                process3RowsBlock(begin);\n                break;\n\n            default:\n\n                // choose an initial shift for LDL<sup>T</sup> decomposition\n                final double[] range       = eigenvaluesRange(begin, n);\n                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n                final double lambda        = chooseLeft ? range[0] : range[1];\n\n                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n                // decompose T-&lambda;I as LDL<sup>T</sup>\n                ldlTDecomposition(lambda, begin, n);\n\n                // apply general dqd/dqds method\n                processGeneralBlock(n);\n\n                // extract realEigenvalues\n                if (chooseLeft) {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                    }\n                } else {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                    }\n                }\n\n            }\n            begin = end;\n        }\n\n        // sort the realEigenvalues in decreasing order\n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n\n    }", "javadoc_start_line": 607, "annotations_start_line": 611, "method_start_line": 612, "end_line": 684}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "processGeneralBlock", "content": "    /**\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     */\n    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n        flipIfWarranted(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }", "javadoc_start_line": 811, "annotations_start_line": 822, "method_start_line": 823, "end_line": 928}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "goodStep", "content": "    /**\n     * Perform one \"good\" dqd/dqds step.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLAZQ3.</p>\n     * @param start start index\n     * @param end end index\n     * @return new end (maybe deflated)\n     */\n    private int goodStep(final int start, final int end) {\n\n        g = 0.0;\n\n        // step 1: accepting realEigenvalues\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n\n            if (start >= deflatedEnd) {\n                // the array has been completely deflated\n                return deflatedEnd;\n            }\n\n            final int k = 4 * deflatedEnd + pingPong - 1;\n\n            if ((start == deflatedEnd - 1) ||\n                ((start != deflatedEnd - 2) &&\n                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n\n                // one eigenvalue found, deflate array\n                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n                deflatedEnd -= 1;\n\n            } else if ((start == deflatedEnd - 2) ||\n                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n\n                // two realEigenvalues found, deflate array\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n\n                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n                    } else {\n                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7]  = t;\n                }\n                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n\n                // no more realEigenvalues found, we need to iterate\n                deflating = false;\n\n            }\n\n        }\n\n        final int l = 4 * deflatedEnd + pingPong - 1;\n\n        // step 2: flip array if needed\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = Math.min(dMin2, work[l - 1]);\n                work[l - 1] =\n                    Math.min(work[l - 1],\n                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - 2 * pingPong] =\n                    Math.min(work[l - 2 * pingPong],\n                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin  = -0.0;\n            }\n        }\n\n        if ((dMin < 0) ||\n            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n                                                  Math.min(work[l - 9],\n                                                           dMin2 + work[l - 2 * pingPong])))) {\n            // step 3: choose a shift\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n\n            // step 4a: dqds\n            for (boolean loop = true; loop;) {\n\n                // perform one dqds step with the chosen shift\n                dqds(start, deflatedEnd);\n\n                // check result of the dqds step\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    // the shift was good\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((dMin < 0.0) &&\n                           (dMin1 > 0.0) &&\n                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n                           (Math.abs(dN) < TOLERANCE * sigma)) {\n                   // convergence hidden by negative DN.\n                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    // tau too big. Select new tau and try again.\n                    if (tType < -22) {\n                        // failed twice. Play it safe.\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        // late failure. Gives excellent shift.\n                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n                        tType -= 11;\n                    } else {\n                        // early failure. Divide by 4.\n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    // possible underflow. Play it safe.\n                    loop = false;\n                }\n            }\n\n        }\n\n        // perform a dqd step (i.e. no shift)\n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }", "javadoc_start_line": 979, "annotations_start_line": 990, "method_start_line": 990, "end_line": 1122}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "computeShiftIncrement", "content": "    /**\n     * Compute the shift increment as an estimate of the smallest eigenvalue.\n     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n     * @param start start index\n     * @param end end index\n     * @param deflated number of realEigenvalues just deflated\n     */\n    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 2) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }", "javadoc_start_line": 1423, "annotations_start_line": 1430, "method_start_line": 1430, "end_line": 1672}]}, {"failing_test": {"className": " org.apache.commons.math.linear.EigenDecompositionImplTest", "methodName": "testMath308", "error": "java.lang.ArrayIndexOutOfBoundsException", "message": "-1"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "processGeneralBlock", "content": "    /**\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     */\n    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n        flipIfWarranted(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }", "javadoc_start_line": 811, "annotations_start_line": 822, "method_start_line": 823, "end_line": 928}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java", "method_name": "testMath308", "content": "    public void testMath308() {\n\n        double[] mainTridiagonal = {\n            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n        };\n        double[] secondaryTridiagonal = {\n            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n        };\n\n        // the reference values have been computed using routine DSTEMR\n        // from the fortran library LAPACK version 3.2.1\n        double[] refEigenValues = {\n            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n        };\n        RealVector[] refEigenVectors = {\n            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\n            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n            new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\n            new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })\n        };\n\n        EigenDecomposition decomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n        double[] eigenValues = decomposition.getRealEigenvalues();\n        for (int i = 0; i < refEigenValues.length; ++i) {\n            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n            assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n        }\n\n    }", "javadoc_start_line": 112, "annotations_start_line": 112, "method_start_line": 112, "end_line": 143}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "EigenDecompositionImpl", "content": "    /**\n     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.\n     * @param main the main diagonal of the matrix (will be copied)\n     * @param secondary the secondary diagonal of the matrix (will be copied)\n     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n     * geometric mean to split the tridiagonal matrix (a suggested value is\n     * {@link MathUtils#SAFE_MIN})\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public EigenDecompositionImpl(final double[] main, double[] secondary,\n            final double splitTolerance)\n        throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        // pre-compute some elements\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }", "javadoc_start_line": 179, "annotations_start_line": 189, "method_start_line": 191, "end_line": 207}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "decompose", "content": "    /**\n     * Decompose a tridiagonal symmetric matrix.\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        // compute the Gershgorin circles\n        computeGershgorinCircles();\n\n        // find all the realEigenvalues\n        findEigenvalues();\n\n        // we will search for eigenvectors only if required\n        eigenvectors = null;\n\n    }", "javadoc_start_line": 230, "annotations_start_line": 235, "method_start_line": 235, "end_line": 251}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "findEigenvalues", "content": "    /**\n     * Find the realEigenvalues.\n     * @exception InvalidMatrixException if a block cannot be diagonalized\n     */\n    private void findEigenvalues()\n        throws InvalidMatrixException {\n\n        // compute splitting points\n        List<Integer> splitIndices = computeSplits();\n\n        // find realEigenvalues in each block\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n\n            case 1:\n                // apply dedicated method for dimension 1\n                process1RowBlock(begin);\n                break;\n\n            case 2:\n                // apply dedicated method for dimension 2\n                process2RowsBlock(begin);\n                break;\n\n            case 3:\n                // apply dedicated method for dimension 3\n                process3RowsBlock(begin);\n                break;\n\n            default:\n\n                // choose an initial shift for LDL<sup>T</sup> decomposition\n                final double[] range       = eigenvaluesRange(begin, n);\n                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n                final double lambda        = chooseLeft ? range[0] : range[1];\n\n                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n                // decompose T-&lambda;I as LDL<sup>T</sup>\n                ldlTDecomposition(lambda, begin, n);\n\n                // apply general dqd/dqds method\n                processGeneralBlock(n);\n\n                // extract realEigenvalues\n                if (chooseLeft) {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                    }\n                } else {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                    }\n                }\n\n            }\n            begin = end;\n        }\n\n        // sort the realEigenvalues in decreasing order\n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n\n    }", "javadoc_start_line": 607, "annotations_start_line": 611, "method_start_line": 612, "end_line": 684}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "processGeneralBlock", "content": "    /**\n     * Find realEigenvalues using dqd/dqds algorithms.\n     * <p>This implementation is based on Beresford N. Parlett\n     * and Osni A. Marques paper <a\n     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n     * corresponding LAPACK routine DLASQ2.</p>\n     * @param n number of rows of the block\n     * @exception InvalidMatrixException if block cannot be diagonalized\n     * after 30 * n iterations\n     */\n    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n        flipIfWarranted(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }", "javadoc_start_line": 811, "annotations_start_line": 822, "method_start_line": 823, "end_line": 928}]}, {"failing_test": {"className": " org.apache.commons.math.linear.EigenDecompositionImplTest", "methodName": "testMath308", "error": "java.lang.ArrayIndexOutOfBoundsException", "message": "-1"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "computeGershgorinCircles", "content": "    /**\n     * Compute the Gershgorin circles for all rows.\n     */\n    private void computeGershgorinCircles() {\n\n        final int m     = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = Double.POSITIVE_INFINITY;\n        upperSpectra = Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n\n        double eCurrent = 0;\n        for (int i = 0; i < m - 1; ++i) {\n\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = Math.abs(secondary[i]);\n            eMax = Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = Math.min(lowerSpectra, lower);\n\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = Math.max(upperSpectra, upper);\n\n        }\n\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[lowerStart + m - 1] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[upperStart + m - 1] = upper;\n        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n    }", "javadoc_start_line": 566, "annotations_start_line": 569, "method_start_line": 569, "end_line": 605}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java", "method_name": "testMath308", "content": "    public void testMath308() {\n\n        double[] mainTridiagonal = {\n            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n        };\n        double[] secondaryTridiagonal = {\n            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n        };\n\n        // the reference values have been computed using routine DSTEMR\n        // from the fortran library LAPACK version 3.2.1\n        double[] refEigenValues = {\n            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n        };\n        RealVector[] refEigenVectors = {\n            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\n            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n            new ArrayRealVector(new double[] {  0.713933751051495, -0.190582113553930,  0.671410443368332, -0.056056055955050,  0.006541576993581 }),\n            new ArrayRealVector(new double[] {  0.584677060845929, -0.367177264979103, -0.721453187784497,  0.052971054621812, -0.005740715188257 })\n        };\n\n        EigenDecomposition decomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\n\n        double[] eigenValues = decomposition.getRealEigenvalues();\n        for (int i = 0; i < refEigenValues.length; ++i) {\n            assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n            assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n        }\n\n    }", "javadoc_start_line": 112, "annotations_start_line": 112, "method_start_line": 112, "end_line": 143}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "EigenDecompositionImpl", "content": "    /**\n     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.\n     * @param main the main diagonal of the matrix (will be copied)\n     * @param secondary the secondary diagonal of the matrix (will be copied)\n     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n     * geometric mean to split the tridiagonal matrix (a suggested value is\n     * {@link MathUtils#SAFE_MIN})\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    public EigenDecompositionImpl(final double[] main, double[] secondary,\n            final double splitTolerance)\n        throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        // pre-compute some elements\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }", "javadoc_start_line": 179, "annotations_start_line": 189, "method_start_line": 191, "end_line": 207}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "decompose", "content": "    /**\n     * Decompose a tridiagonal symmetric matrix.\n     * @exception InvalidMatrixException (wrapping a {@link\n     * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n     */\n    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        // compute the Gershgorin circles\n        computeGershgorinCircles();\n\n        // find all the realEigenvalues\n        findEigenvalues();\n\n        // we will search for eigenvectors only if required\n        eigenvectors = null;\n\n    }", "javadoc_start_line": 230, "annotations_start_line": 235, "method_start_line": 235, "end_line": 251}, {"file_path": "/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java", "method_name": "computeGershgorinCircles", "content": "    /**\n     * Compute the Gershgorin circles for all rows.\n     */\n    private void computeGershgorinCircles() {\n\n        final int m     = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = Double.POSITIVE_INFINITY;\n        upperSpectra = Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n\n        double eCurrent = 0;\n        for (int i = 0; i < m - 1; ++i) {\n\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = Math.abs(secondary[i]);\n            eMax = Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = Math.min(lowerSpectra, lower);\n\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = Math.max(upperSpectra, upper);\n\n        }\n\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[lowerStart + m - 1] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[upperStart + m - 1] = upper;\n        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n    }", "javadoc_start_line": 566, "annotations_start_line": 569, "method_start_line": 569, "end_line": 605}]}], "project": {"name": "Math", "version": 81}}