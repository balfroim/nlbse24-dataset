{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression1a", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression1a", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "canInline", "content": "    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }", "javadoc_start_line": 280, "annotations_start_line": 280, "method_start_line": 280, "end_line": 411}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }", "javadoc_start_line": 176, "annotations_start_line": 175, "method_start_line": 176, "end_line": 178}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression1a", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "apply", "content": "              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }", "javadoc_start_line": 366, "annotations_start_line": 365, "method_start_line": 366, "end_line": 377}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }", "javadoc_start_line": 176, "annotations_start_line": 175, "method_start_line": 176, "end_line": 178}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}, {"file_path": "/src/com/google/javascript/jscomp/NodeUtil.java", "method_name": "has", "content": "  /**\n   * @return Whether the predicate is true for the node or any of its children.\n   */\n  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "javadoc_start_line": 2674, "annotations_start_line": 2677, "method_start_line": 2679, "end_line": 2695}, {"file_path": "/src/com/google/javascript/jscomp/NodeUtil.java", "method_name": "has", "content": "  /**\n   * @return Whether the predicate is true for the node or any of its children.\n   */\n  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "javadoc_start_line": 2674, "annotations_start_line": 2677, "method_start_line": 2679, "end_line": 2695}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression1", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression1", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "canInline", "content": "    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }", "javadoc_start_line": 280, "annotations_start_line": 280, "method_start_line": 280, "end_line": 411}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }", "javadoc_start_line": 176, "annotations_start_line": 175, "method_start_line": 176, "end_line": 178}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression1", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "apply", "content": "              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }", "javadoc_start_line": 366, "annotations_start_line": 365, "method_start_line": 366, "end_line": 377}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }", "javadoc_start_line": 176, "annotations_start_line": 175, "method_start_line": 176, "end_line": 178}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}, {"file_path": "/src/com/google/javascript/jscomp/NodeUtil.java", "method_name": "has", "content": "  /**\n   * @return Whether the predicate is true for the node or any of its children.\n   */\n  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "javadoc_start_line": 2674, "annotations_start_line": 2677, "method_start_line": 2679, "end_line": 2695}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression3", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression3", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "canInline", "content": "    private boolean canInline() {\n      // Cannot inline a parameter.\n      if (getDefCfgNode().isFunction()) {\n        return false;\n      }\n\n      // If one of our dependencies has been inlined, then our dependency\n      // graph is wrong. Re-computing it would take another CFG computation,\n      // so we just back off for now.\n      for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n          return false;\n        }\n      }\n\n      getDefinition(getDefCfgNode(), null);\n      getNumUseInUseCfgNode(useCfgNode, null);\n\n      // Definition was not found.\n      if (def == null) {\n        return false;\n      }\n\n      // Check that the assignment isn't used as a R-Value.\n      // TODO(user): Certain cases we can still inline.\n      if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n      }\n\n      // The right of the definition has side effect:\n      // Example, for x:\n      // x = readProp(b), modifyProp(b); print(x);\n      if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // Similar check as the above but this time, all the sub-expressions\n      // left of the use of the variable.\n      // x = readProp(b); modifyProp(b), print(x);\n      if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n      }\n\n      // TODO(user): Side-effect is OK sometimes. As long as there are no\n      // side-effect function down all paths to the use. Once we have all the\n      // side-effect analysis tool.\n      if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n      }\n\n      // TODO(user): We could inline all the uses if the expression is short.\n\n      // Finally we have to make sure that there are no more than one use\n      // in the program and in the CFG node. Even when it is semantically\n      // correctly inlining twice increases code size.\n      if (numUseWithinUseCfgNode != 1) {\n        return false;\n      }\n\n      // Make sure that the name is not within a loop\n      if (NodeUtil.isWithinLoop(use)) {\n        return false;\n      }\n\n\n      Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n      if (uses.size() != 1) {\n        return false;\n      }\n\n      // We give up inlining stuff with R-Value that has:\n      // 1) GETPROP, GETELEM,\n      // 2) anything that creates a new object.\n      // 3) a direct reference to a catch expression.\n      // Example:\n      // var x = a.b.c; j.c = 1; print(x);\n      // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n      // TODO(user): We could get more accuracy by looking more in-detail\n      // what j is and what x is trying to into to.\n      // TODO(johnlenz): rework catch expression handling when we\n      // have lexical scope support so catch expressions don't\n      // need to be special cased.\n      if (NodeUtil.has(def.getLastChild(),\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }\n          },\n          new Predicate<Node>() {\n              @Override\n              public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n              }\n          })) {\n        return false;\n      }\n\n      // We can skip the side effect check along the paths of two nodes if\n      // they are just next to each other.\n      if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n          getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>\n          pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n                 cfg,\n                 cfg.getDirectedGraphNode(getDefCfgNode()),\n                 cfg.getDirectedGraphNode(useCfgNode),\n                 SIDE_EFFECT_PREDICATE,\n                 Predicates.\n                     <DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                 false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n          return false;\n        }\n      }\n\n      return true;\n    }", "javadoc_start_line": 280, "annotations_start_line": 280, "method_start_line": 280, "end_line": 411}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }", "javadoc_start_line": 176, "annotations_start_line": 175, "method_start_line": 176, "end_line": 178}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testDoNotInlineCatchExpression3", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "apply", "content": "              public boolean apply(Node input) {\n                switch (input.getType()) {\n                  case Token.GETELEM:\n                  case Token.GETPROP:\n                  case Token.ARRAYLIT:\n                  case Token.OBJECTLIT:\n                  case Token.REGEXP:\n                  case Token.NEW:\n                    return true;\n                }\n                return false;\n              }", "javadoc_start_line": 366, "annotations_start_line": 365, "method_start_line": 366, "end_line": 377}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }", "javadoc_start_line": 176, "annotations_start_line": 175, "method_start_line": 176, "end_line": 178}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}, {"file_path": "/src/com/google/javascript/jscomp/NodeUtil.java", "method_name": "has", "content": "  /**\n   * @return Whether the predicate is true for the node or any of its children.\n   */\n  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }", "javadoc_start_line": 2674, "annotations_start_line": 2677, "method_start_line": 2679, "end_line": 2695}]}], "project": {"name": "Closure", "version": 3}}