{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.FunctionInjectorTest", "methodName": "testIssue1101a", "error": "junit.framework.AssertionFailedError", "message": "expected:<NO> but was:<YES>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}, {"failing_test": {"className": " com.google.javascript.jscomp.FunctionInjectorTest", "methodName": "testIssue1101b", "error": "junit.framework.AssertionFailedError", "message": "expected:<NO> but was:<YES>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testBug4944818", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineFunctions.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions();\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "javadoc_start_line": 111, "annotations_start_line": 110, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /** Traverses a function. */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 543, "annotations_start_line": 544, "method_start_line": 544, "end_line": 577}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testDoubleInlining2", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineFunctions.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions();\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "javadoc_start_line": 111, "annotations_start_line": 110, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testIssue1101", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineFunctions.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions();\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "javadoc_start_line": 111, "annotations_start_line": 110, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testInlineIfParametersModified8", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineFunctions.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions();\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "javadoc_start_line": 111, "annotations_start_line": 110, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testInlineIfParametersModified9", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineFunctions.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions();\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "javadoc_start_line": 111, "annotations_start_line": 110, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineFunctionsTest", "methodName": "testInlineFunctions6", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineFunctions.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions();\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }", "javadoc_start_line": 111, "annotations_start_line": 110, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceToFunction", "content": "  /**\n   * @param t  The traversal use to reach the call site.\n   * @param callNode The CALL node.\n   * @param fnNode The function to evaluate for inlining.\n   * @param needAliases A set of function parameter names that can not be\n   *     used without aliasing. Returned by getUnsafeParameterNames().\n   * @param mode Inlining mode to be used.\n   * @param referencesThis Whether fnNode contains references to its this\n   *     object.\n   * @param containsFunctions Whether fnNode contains inner functions.\n   * @return Whether the inlining can occur.\n   */\n  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }", "javadoc_start_line": 161, "annotations_start_line": 173, "method_start_line": 175, "end_line": 213}, {"file_path": "/src/com/google/javascript/jscomp/FunctionInjector.java", "method_name": "canInlineReferenceDirectly", "content": "  /**\n   * Determines whether a function can be inlined at a particular call site.\n   * There are several criteria that the function and reference must hold in\n   * order for the functions to be inlined:\n   * 1) If a call's arguments have side effects,\n   * the corresponding argument in the function must only be referenced once.\n   * For instance, this will not be inlined:\n   * <pre>\n   *     function foo(a) { return a + a }\n   *     x = foo(i++);\n   * </pre>\n   */\n  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }", "javadoc_start_line": 677, "annotations_start_line": 689, "method_start_line": 690, "end_line": 749}]}], "project": {"name": "Closure", "version": 116}}