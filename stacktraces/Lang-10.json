{"tours": [{"failing_test": {"className": " org.apache.commons.lang3.time.FastDateFormat_ParserTest", "methodName": "testLANG_831", "error": "junit.framework.AssertionFailedError", "message": "Parsed dates should be equal expected:<null> but was:<Mon Mar 02 21:00:00 PST 1970>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "escapeRegex", "content": "    /**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }", "javadoc_start_line": 296, "annotations_start_line": 303, "method_start_line": 303, "end_line": 343}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testLANG_831", "content": "    public void testLANG_831() throws Exception {\n        testSdfAndFdp(\"M E\",\"3  Tue\", true);\n    }", "javadoc_start_line": 347, "annotations_start_line": 346, "method_start_line": 347, "end_line": 349}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testSdfAndFdp", "content": "    private void testSdfAndFdp(String format, String date, boolean shouldFail)\n            throws Exception {\n        Date dfdp = null;\n        Date dsdf = null;\n        Throwable f = null;\n        Throwable s = null;\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);\n            sdf.setTimeZone(NEW_YORK);\n            dsdf = sdf.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected SDF failure, but got \" + dsdf + \" for [\"+format+\",\"+date+\"]\");\n            }\n        } catch (Exception e) {\n            s = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"sdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n\n        try {\n            DateParser fdp = getInstance(format, NEW_YORK, Locale.US);\n            dfdp = fdp.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected FDF failure, but got \" + dfdp + \" for [\"+format+\",\"+date+\"] using \"+((FastDateParser)fdp).getParsePattern());\n            }\n        } catch (Exception e) {\n            f = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"fdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n        // SDF and FDF should produce equivalent results\n        assertTrue(\"Should both or neither throw Exceptions\", (f==null)==(s==null));\n        assertEquals(\"Parsed dates should be equal\", dsdf, dfdp);\n    }", "javadoc_start_line": 351, "annotations_start_line": 351, "method_start_line": 352, "end_line": 389}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "getInstance", "content": "    /**\n     * Override this method in derived tests to change the construction of instances\n     */\n    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n        return new FastDateParser(format, timeZone, locale);\n    }", "javadoc_start_line": 77, "annotations_start_line": 80, "method_start_line": 80, "end_line": 82}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "FastDateParser", "content": "    /**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */\n    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }", "javadoc_start_line": 96, "annotations_start_line": 104, "method_start_line": 104, "end_line": 109}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "init", "content": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }", "javadoc_start_line": 111, "annotations_start_line": 115, "method_start_line": 115, "end_line": 150}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "<clinit>", "content": "public class FastDateParser implements DateParser, Serializable {", "javadoc_start_line": 68, "annotations_start_line": 68, "method_start_line": 68, "end_line": 68}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "escapeRegex", "content": "    /**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }", "javadoc_start_line": 296, "annotations_start_line": 303, "method_start_line": 303, "end_line": 343}]}, {"failing_test": {"className": " org.apache.commons.lang3.time.FastDateParserTest", "methodName": "testLANG_831", "error": "junit.framework.AssertionFailedError", "message": "Expected FDF failure, but got Mon Mar 02 21:00:00 PST 1970 for [M E,3  Tue] using (\\p{IsNd}++)\\s*+(Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "escapeRegex", "content": "    /**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }", "javadoc_start_line": 296, "annotations_start_line": 303, "method_start_line": 303, "end_line": 343}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testLANG_831", "content": "    public void testLANG_831() throws Exception {\n        testSdfAndFdp(\"M E\",\"3  Tue\", true);\n    }", "javadoc_start_line": 347, "annotations_start_line": 346, "method_start_line": 347, "end_line": 349}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testSdfAndFdp", "content": "    private void testSdfAndFdp(String format, String date, boolean shouldFail)\n            throws Exception {\n        Date dfdp = null;\n        Date dsdf = null;\n        Throwable f = null;\n        Throwable s = null;\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);\n            sdf.setTimeZone(NEW_YORK);\n            dsdf = sdf.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected SDF failure, but got \" + dsdf + \" for [\"+format+\",\"+date+\"]\");\n            }\n        } catch (Exception e) {\n            s = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"sdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n\n        try {\n            DateParser fdp = getInstance(format, NEW_YORK, Locale.US);\n            dfdp = fdp.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected FDF failure, but got \" + dfdp + \" for [\"+format+\",\"+date+\"] using \"+((FastDateParser)fdp).getParsePattern());\n            }\n        } catch (Exception e) {\n            f = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"fdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n        // SDF and FDF should produce equivalent results\n        assertTrue(\"Should both or neither throw Exceptions\", (f==null)==(s==null));\n        assertEquals(\"Parsed dates should be equal\", dsdf, dfdp);\n    }", "javadoc_start_line": 351, "annotations_start_line": 351, "method_start_line": 352, "end_line": 389}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "getInstance", "content": "    /**\n     * Override this method in derived tests to change the construction of instances\n     */\n    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n        return new FastDateParser(format, timeZone, locale);\n    }", "javadoc_start_line": 77, "annotations_start_line": 80, "method_start_line": 80, "end_line": 82}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "FastDateParser", "content": "    /**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */\n    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }", "javadoc_start_line": 96, "annotations_start_line": 104, "method_start_line": 104, "end_line": 109}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "init", "content": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }", "javadoc_start_line": 111, "annotations_start_line": 115, "method_start_line": 115, "end_line": 150}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "<clinit>", "content": "public class FastDateParser implements DateParser, Serializable {", "javadoc_start_line": 68, "annotations_start_line": 68, "method_start_line": 68, "end_line": 68}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "escapeRegex", "content": "    /**\n     * Escape constant fields into regular expression\n     * @param regex The destination regex\n     * @param value The source field\n     * @param unquote If true, replace two success quotes ('') with single quote (')\n     * @return The <code>StringBuilder</code>\n     */\n    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }", "javadoc_start_line": 296, "annotations_start_line": 303, "method_start_line": 303, "end_line": 343}]}], "project": {"name": "Lang", "version": 10}}