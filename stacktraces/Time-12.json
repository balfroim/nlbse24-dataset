{"tours": [{"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero1", "content": "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 142, "annotations_start_line": 142, "method_start_line": 142, "end_line": 148}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero1-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero1", "content": "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 142, "annotations_start_line": 142, "method_start_line": 142, "end_line": 148}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero1-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero3", "content": "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 150, "annotations_start_line": 150, "method_start_line": 150, "end_line": 156}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero3-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero3", "content": "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 150, "annotations_start_line": 150, "method_start_line": 150, "end_line": 156}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero3-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero1-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero1", "content": "    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 104, "annotations_start_line": 104, "method_start_line": 104, "end_line": 110}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero1-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03T04:05:06.007> but was:<0001-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero1", "content": "    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 104, "annotations_start_line": 104, "method_start_line": 104, "end_line": 110}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero3-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero3", "content": "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 112, "annotations_start_line": 112, "method_start_line": 112, "end_line": 118}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero3-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDateTime_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03T04:05:06.007> but was:<0003-02-03T04:05:06.007>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero3", "content": "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 112, "annotations_start_line": 112, "method_start_line": 112, "end_line": 118}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero1", "content": "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 142, "annotations_start_line": 142, "method_start_line": 142, "end_line": 148}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero1-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero1", "content": "    public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 142, "annotations_start_line": 142, "method_start_line": 142, "end_line": 148}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero1-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero3", "content": "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 150, "annotations_start_line": 150, "method_start_line": 150, "end_line": 156}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero3-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromDateFields_beforeYearZero3", "content": "    public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n    }", "javadoc_start_line": 150, "annotations_start_line": 150, "method_start_line": 150, "end_line": 156}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromDateFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromDateFields_beforeYearZero3-fromCalendarFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero1-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero1", "content": "    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 104, "annotations_start_line": 104, "method_start_line": 104, "end_line": 110}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero1-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero1", "error": "junit.framework.AssertionFailedError", "message": "expected:<0000-02-03> but was:<0001-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero1", "content": "    public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(0, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 104, "annotations_start_line": 104, "method_start_line": 104, "end_line": 110}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDate.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDate with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDate fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDate(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate()\n        );\n    }", "javadoc_start_line": 218, "annotations_start_line": 238, "method_start_line": 239, "end_line": 249}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero3-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero3", "content": "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 112, "annotations_start_line": 112, "method_start_line": 112, "end_line": 118}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromDateFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Date</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Date and assigned to the LocalDateTime.\n     * This is useful if you have been using the Date as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method always creates a LocalDateTime with ISO chronology.\n     *\n     * @param date  the Date to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    @SuppressWarnings(\"deprecation\")\n    public static LocalDateTime fromDateFields(Date date) {\n        if (date == null) {\n            throw new IllegalArgumentException(\"The date must not be null\");\n        }\n            // handle years in era BC\n        return new LocalDateTime(\n            date.getYear() + 1900,\n            date.getMonth() + 1,\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            (((int) (date.getTime() % 1000)) + 1000) % 1000\n        );\n    }", "javadoc_start_line": 211, "annotations_start_line": 231, "method_start_line": 232, "end_line": 246}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/12/results/stacktrace-testFactory_fromCalendarFields_beforeYearZero3-fromDateFields.csv'"}}, {"failing_test": {"className": " org.joda.time.TestLocalDate_Constructors", "methodName": "testFactory_fromCalendarFields_beforeYearZero3", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-02-03> but was:<0003-02-03>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/LocalDateTime.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDateTime.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDateTime with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date-time, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDateTime fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDateTime(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH),\n            calendar.get(Calendar.HOUR_OF_DAY),\n            calendar.get(Calendar.MINUTE),\n            calendar.get(Calendar.SECOND),\n            calendar.get(Calendar.MILLISECOND)\n        );\n    }", "javadoc_start_line": 172, "annotations_start_line": 195, "method_start_line": 195, "end_line": 209}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestLocalDate_Constructors.java", "method_name": "testFactory_fromCalendarFields_beforeYearZero3", "content": "    public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n        GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n        cal.set(Calendar.ERA, GregorianCalendar.BC);\n        cal.set(Calendar.MILLISECOND, 7);\n        LocalDate expected = new LocalDate(-2, 2, 3);\n        assertEquals(expected, LocalDate.fromCalendarFields(cal));\n    }", "javadoc_start_line": 112, "annotations_start_line": 112, "method_start_line": 112, "end_line": 118}, {"file_path": "/src/main/java/org/joda/time/LocalDate.java", "method_name": "fromCalendarFields", "content": "    /**\n     * Constructs a LocalDate from a <code>java.util.Calendar</code>\n     * using exactly the same field values.\n     * <p>\n     * Each field is queried from the Calendar and assigned to the LocalDate.\n     * This is useful if you have been using the Calendar as a local date,\n     * ignoring the zone.\n     * <p>\n     * One advantage of this method is that this method is unaffected if the\n     * version of the time zone data differs between the JDK and Joda-Time.\n     * That is because the local field values are transferred, calculated using\n     * the JDK time zone data and without using the Joda-Time time zone data.\n     * <p>\n     * This factory method ignores the type of the calendar and always\n     * creates a LocalDate with ISO chronology. It is expected that you\n     * will only pass in instances of <code>GregorianCalendar</code> however\n     * this is not validated.\n     *\n     * @param calendar  the Calendar to extract fields from, not null\n     * @return the created local date, not null\n     * @throws IllegalArgumentException if the calendar is null\n     * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n     */\n    public static LocalDate fromCalendarFields(Calendar calendar) {\n        if (calendar == null) {\n            throw new IllegalArgumentException(\"The calendar must not be null\");\n        }\n        int yearOfEra = calendar.get(Calendar.YEAR);\n        return new LocalDate(\n            yearOfEra,\n            calendar.get(Calendar.MONTH) + 1,\n            calendar.get(Calendar.DAY_OF_MONTH)\n        );\n    }", "javadoc_start_line": 183, "annotations_start_line": 206, "method_start_line": 206, "end_line": 216}]}], "project": {"name": "Time", "version": 12}}