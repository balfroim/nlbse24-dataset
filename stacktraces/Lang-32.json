{"tours": [{"failing_test": {"className": " org.apache.commons.lang3.builder.HashCodeBuilderTest", "methodName": "testReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: []"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "unregister", "content": "    /**\n     * <p>\n     * Unregisters the given object.\n     * </p>\n     * \n     * <p>\n     * Used by the reflection methods to avoid infinite loops.\n     * \n     * @param value\n     *            The object to unregister.\n     * @since 2.3\n     */\n    static void unregister(Object value) {\n        getRegistry().remove(new IDKey(value));\n    }", "javadoc_start_line": 525, "annotations_start_line": 537, "method_start_line": 537, "end_line": 539}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java", "method_name": "testReflectionObjectCycle", "content": "    /**\n     * Test Objects pointing to each other.\n     */\n    public void testReflectionObjectCycle() {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        \n        // Used to caused:\n        // java.lang.StackOverflowError\n        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n        // at java.lang.Class.getDeclaredFields(Class.java:992)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n\n        a.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n        b.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n    }", "javadoc_start_line": 497, "annotations_start_line": 500, "method_start_line": 500, "end_line": 527}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionHashCode", "content": "    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object) {\n        return reflectionHashCode(17, 37, object, false, null, null);\n    }", "javadoc_start_line": 369, "annotations_start_line": 399, "method_start_line": 399, "end_line": 401}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionHashCode", "content": "    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be included. Superclass fields will be included up to and including the specified\n     * superclass. A null superclass is treated as java.lang.Object.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     * @since 2.0\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }", "javadoc_start_line": 308, "annotations_start_line": 353, "method_start_line": 354, "end_line": 367}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionAppend", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n     * </p>\n     * \n     * @param object\n     *            the object to append details of\n     * @param clazz\n     *            the class to append details of\n     * @param builder\n     *            the builder to append to\n     * @param useTransients\n     *            whether to use transient fields\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     */\n    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n            String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName())\n                    && (field.getName().indexOf('$') == -1)\n                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                    && (!Modifier.isStatic(field.getModifiers()))) {\n                    try {\n                        Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    } catch (IllegalAccessException e) {\n                        // this can't happen. Would get a Security exception instead\n                        // throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(object);\n        }\n    }", "javadoc_start_line": 155, "annotations_start_line": 171, "method_start_line": 172, "end_line": 198}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "unregister", "content": "    /**\n     * <p>\n     * Unregisters the given object.\n     * </p>\n     * \n     * <p>\n     * Used by the reflection methods to avoid infinite loops.\n     * \n     * @param value\n     *            The object to unregister.\n     * @since 2.3\n     */\n    static void unregister(Object value) {\n        getRegistry().remove(new IDKey(value));\n    }", "javadoc_start_line": 525, "annotations_start_line": 537, "method_start_line": 537, "end_line": 539}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.HashCodeBuilderTest", "methodName": "testReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: []"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "register", "content": "    /**\n     * <p>\n     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to register.\n     */\n    static void register(Object value) {\n        getRegistry().add(new IDKey(value));\n    }", "javadoc_start_line": 513, "annotations_start_line": 521, "method_start_line": 521, "end_line": 523}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java", "method_name": "testReflectionObjectCycle", "content": "    /**\n     * Test Objects pointing to each other.\n     */\n    public void testReflectionObjectCycle() {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        \n        // Used to caused:\n        // java.lang.StackOverflowError\n        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n        // at java.lang.Class.getDeclaredFields(Class.java:992)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n\n        a.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n        b.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n    }", "javadoc_start_line": 497, "annotations_start_line": 500, "method_start_line": 500, "end_line": 527}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionHashCode", "content": "    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\n     * <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be tested. Superclass fields will be included.\n     * </p>\n     * \n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the object is <code>null</code>\n     */\n    public static int reflectionHashCode(Object object) {\n        return reflectionHashCode(17, 37, object, false, null, null);\n    }", "javadoc_start_line": 369, "annotations_start_line": 399, "method_start_line": 399, "end_line": 401}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionHashCode", "content": "    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be included. Superclass fields will be included up to and including the specified\n     * superclass. A null superclass is treated as java.lang.Object.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     * @since 2.0\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }", "javadoc_start_line": 308, "annotations_start_line": 353, "method_start_line": 354, "end_line": 367}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionAppend", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n     * </p>\n     * \n     * @param object\n     *            the object to append details of\n     * @param clazz\n     *            the class to append details of\n     * @param builder\n     *            the builder to append to\n     * @param useTransients\n     *            whether to use transient fields\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     */\n    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n            String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName())\n                    && (field.getName().indexOf('$') == -1)\n                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                    && (!Modifier.isStatic(field.getModifiers()))) {\n                    try {\n                        Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    } catch (IllegalAccessException e) {\n                        // this can't happen. Would get a Security exception instead\n                        // throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(object);\n        }\n    }", "javadoc_start_line": 155, "annotations_start_line": 171, "method_start_line": 172, "end_line": 198}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "register", "content": "    /**\n     * <p>\n     * Registers the given object. Used by the reflection methods to avoid infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to register.\n     */\n    static void register(Object value) {\n        getRegistry().add(new IDKey(value));\n    }", "javadoc_start_line": 513, "annotations_start_line": 521, "method_start_line": 521, "end_line": 523}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.HashCodeBuilderTest", "methodName": "testReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: []"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n     * infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given object.\n     * @since 2.3\n     */\n    static boolean isRegistered(Object value) {\n        return getRegistry().contains(new IDKey(value));\n    }", "javadoc_start_line": 140, "annotations_start_line": 151, "method_start_line": 151, "end_line": 153}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java", "method_name": "testReflectionObjectCycle", "content": "    /**\n     * Test Objects pointing to each other.\n     */\n    public void testReflectionObjectCycle() {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        \n        // Used to caused:\n        // java.lang.StackOverflowError\n        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n        // at java.lang.Class.getDeclaredFields(Class.java:992)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n\n        a.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n        b.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n    }", "javadoc_start_line": 497, "annotations_start_line": 500, "method_start_line": 500, "end_line": 527}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionHashCode", "content": "    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be included. Superclass fields will be included up to and including the specified\n     * superclass. A null superclass is treated as java.lang.Object.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     * @since 2.0\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }", "javadoc_start_line": 308, "annotations_start_line": 353, "method_start_line": 354, "end_line": 367}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionAppend", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n     * </p>\n     * \n     * @param object\n     *            the object to append details of\n     * @param clazz\n     *            the class to append details of\n     * @param builder\n     *            the builder to append to\n     * @param useTransients\n     *            whether to use transient fields\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     */\n    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n            String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName())\n                    && (field.getName().indexOf('$') == -1)\n                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                    && (!Modifier.isStatic(field.getModifiers()))) {\n                    try {\n                        Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    } catch (IllegalAccessException e) {\n                        // this can't happen. Would get a Security exception instead\n                        // throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(object);\n        }\n    }", "javadoc_start_line": 155, "annotations_start_line": 171, "method_start_line": 172, "end_line": 198}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object. Used by the reflection methods to avoid\n     * infinite loops.\n     * </p>\n     * \n     * @param value\n     *            The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given object.\n     * @since 2.3\n     */\n    static boolean isRegistered(Object value) {\n        return getRegistry().contains(new IDKey(value));\n    }", "javadoc_start_line": 140, "annotations_start_line": 151, "method_start_line": 151, "end_line": 153}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.HashCodeBuilderTest", "methodName": "testReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: []"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "initialValue", "content": "        protected Set<IDKey> initialValue() {\n            return new HashSet<IDKey>();\n        }", "javadoc_start_line": 106, "annotations_start_line": 105, "method_start_line": 106, "end_line": 108}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/HashCodeBuilderTest.java", "method_name": "testReflectionObjectCycle", "content": "    /**\n     * Test Objects pointing to each other.\n     */\n    public void testReflectionObjectCycle() {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        \n        // Used to caused:\n        // java.lang.StackOverflowError\n        // at java.lang.ClassLoader.getCallerClassLoader(Native Method)\n        // at java.lang.Class.getDeclaredFields(Class.java:992)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\n        // at\n        // org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\n        // at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\n\n        a.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n        b.hashCode();\n        assertNull(HashCodeBuilder.getRegistry());\n    }", "javadoc_start_line": 497, "annotations_start_line": 500, "method_start_line": 500, "end_line": 527}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionHashCode", "content": "    /**\n     * <p>\n     * This method uses reflection to build a valid hash code.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the TestTransients parameter is set to <code>true</code>, transient members will be tested, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object</code>.\n     * </p>\n     * \n     * <p>\n     * Static fields will not be included. Superclass fields will be included up to and including the specified\n     * superclass. A null superclass is treated as java.lang.Object.\n     * </p>\n     * \n     * <p>\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\n     * </p>\n     * \n     * @param initialNonZeroOddNumber\n     *            a non-zero, odd number used as the initial value\n     * @param multiplierNonZeroOddNumber\n     *            a non-zero, odd number used as the multiplier\n     * @param object\n     *            the Object to create a <code>hashCode</code> for\n     * @param testTransients\n     *            whether to include transient fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @param excludeFields\n     *            array of field names to exclude from use in calculation of hash code\n     * @return int hash code\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @throws IllegalArgumentException\n     *             if the number is zero or even\n     * @since 2.0\n     */\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\n            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\n\n        if (object == null) {\n            throw new IllegalArgumentException(\"The object to build a hash code for must not be null\");\n        }\n        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\n        Class<?> clazz = object.getClass();\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\n            clazz = clazz.getSuperclass();\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\n        }\n        return builder.toHashCode();\n    }", "javadoc_start_line": 308, "annotations_start_line": 353, "method_start_line": 354, "end_line": 367}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "reflectionAppend", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given <code>Class</code>.\n     * </p>\n     * \n     * @param object\n     *            the object to append details of\n     * @param clazz\n     *            the class to append details of\n     * @param builder\n     *            the builder to append to\n     * @param useTransients\n     *            whether to use transient fields\n     * @param excludeFields\n     *            Collection of String field names to exclude from use in calculation of hash code\n     */\n    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\n            String[] excludeFields) {\n        if (isRegistered(object)) {\n            return;\n        }\n        try {\n            register(object);\n            Field[] fields = clazz.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (Field field : fields) {\n                if (!ArrayUtils.contains(excludeFields, field.getName())\n                    && (field.getName().indexOf('$') == -1)\n                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\n                    && (!Modifier.isStatic(field.getModifiers()))) {\n                    try {\n                        Object fieldValue = field.get(object);\n                        builder.append(fieldValue);\n                    } catch (IllegalAccessException e) {\n                        // this can't happen. Would get a Security exception instead\n                        // throw a runtime exception in case the impossible happens.\n                        throw new InternalError(\"Unexpected IllegalAccessException\");\n                    }\n                }\n            }\n        } finally {\n            unregister(object);\n        }\n    }", "javadoc_start_line": 155, "annotations_start_line": 171, "method_start_line": 172, "end_line": 198}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.HashCodeBuilderTest", "methodName": "testReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: []"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java", "method_name": "", "content": "    private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {", "javadoc_start_line": 104, "annotations_start_line": 104, "method_start_line": 104, "end_line": 104}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "Command failed: defects4j test -w ./projects/Lang/32\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Lang/32 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Lang/32 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\ntest-offline:\n\nget-deps:\n\ncompile:\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Lang/32/maven-build.xml:75: warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Lang/32/target/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Lang/32/src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java:106: error: <identifier> expected\n    [javac] recorder.recordStackTrace();\n    [javac]                          ^\n    [javac] 1 error\n    [javac] 1 warning\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Lang/32/maven-build.xml:75: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"}}], "project": {"name": "Lang", "version": 32}}