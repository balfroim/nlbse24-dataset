{"tours": [{"failing_test": {"className": " org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest", "methodName": "testPerformClusterAnalysisDegenerate", "error": "java.lang.NullPointerException", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/util/MathUtils.java", "method_name": "distance", "content": "    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }", "javadoc_start_line": 1616, "annotations_start_line": 1623, "method_start_line": 1623, "end_line": 1630}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClustererTest.java", "method_name": "testPerformClusterAnalysisDegenerate", "content": "    /**\n     * JIRA: MATH-305\n     * \n     * Two points, one cluster, one iteration\n     */\n    @Test\n    public void testPerformClusterAnalysisDegenerate() {\n        KMeansPlusPlusClusterer<EuclideanIntegerPoint> transformer = new KMeansPlusPlusClusterer<EuclideanIntegerPoint>(\n                new Random(1746432956321l));\n        EuclideanIntegerPoint[] points = new EuclideanIntegerPoint[] {\n                new EuclideanIntegerPoint(new int[] { 1959, 325100 }),\n                new EuclideanIntegerPoint(new int[] { 1960, 373200 }), };\n        List<Cluster<EuclideanIntegerPoint>> clusters = transformer.cluster(Arrays.asList(points), 1, 1);\n        assertEquals(1, clusters.size());\n        assertEquals(2, (clusters.get(0).getPoints().size()));\n        EuclideanIntegerPoint pt1 = new EuclideanIntegerPoint(new int[] { 1959, 325100 });\n        EuclideanIntegerPoint pt2 = new EuclideanIntegerPoint(new int[] { 1960, 373200 });\n        assertTrue(clusters.get(0).getPoints().contains(pt1));\n        assertTrue(clusters.get(0).getPoints().contains(pt2));\n\n    } ", "javadoc_start_line": 97, "annotations_start_line": 102, "method_start_line": 103, "end_line": 117}, {"file_path": "/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java", "method_name": "cluster", "content": "    /**\n     * Runs the K-means++ clustering algorithm.\n     *\n     * @param points the points to cluster\n     * @param k the number of clusters to split the data into\n     * @param maxIterations the maximum number of iterations to run the algorithm\n     *     for.  If negative, no maximum will be used\n     * @return a list of clusters containing the points\n     */\n    public List<Cluster<T>> cluster(final Collection<T> points,\n                                    final int k, final int maxIterations) {\n        // create the initial clusters\n        List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\n        assignPointsToClusters(clusters, points);\n\n        // iterate through updating the centers until we're done\n        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n        for (int count = 0; count < max; count++) {\n            boolean clusteringChanged = false;\n            List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n            for (final Cluster<T> cluster : clusters) {\n                final T newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\n                if (!newCenter.equals(cluster.getCenter())) {\n                    clusteringChanged = true;\n                }\n                newClusters.add(new Cluster<T>(newCenter));\n            }\n            if (!clusteringChanged) {\n                return clusters;\n            }\n            assignPointsToClusters(newClusters, points);\n            clusters = newClusters;\n        }\n        return clusters;\n    }", "javadoc_start_line": 44, "annotations_start_line": 53, "method_start_line": 54, "end_line": 78}, {"file_path": "/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java", "method_name": "assignPointsToClusters", "content": "    /**\n     * Adds the given points to the closest {@link Cluster}.\n     *\n     * @param <T> type of the points to cluster\n     * @param clusters the {@link Cluster}s to add the points to\n     * @param points the points to add to the given {@link Cluster}s\n     */\n    private static <T extends Clusterable<T>> void\n        assignPointsToClusters(final Collection<Cluster<T>> clusters, final Collection<T> points) {\n        for (final T p : points) {\n            Cluster<T> cluster = getNearestCluster(clusters, p);\n            cluster.addPoint(p);\n        }\n    }", "javadoc_start_line": 80, "annotations_start_line": 88, "method_start_line": 88, "end_line": 93}, {"file_path": "/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java", "method_name": "getNearestCluster", "content": "    /**\n     * Returns the nearest {@link Cluster} to the given point\n     *\n     * @param <T> type of the points to cluster\n     * @param clusters the {@link Cluster}s to search\n     * @param point the point to find the nearest {@link Cluster} for\n     * @return the nearest {@link Cluster} to the given point\n     */\n    private static <T extends Clusterable<T>> Cluster<T>\n        getNearestCluster(final Collection<Cluster<T>> clusters, final T point) {\n        double minDistance = Double.MAX_VALUE;\n        Cluster<T> minCluster = null;\n        for (final Cluster<T> c : clusters) {\n            final double distance = point.distanceFrom(c.getCenter());\n            if (distance < minDistance) {\n                minDistance = distance;\n                minCluster = c;\n            }\n        }\n        return minCluster;\n    }", "javadoc_start_line": 143, "annotations_start_line": 152, "method_start_line": 152, "end_line": 163}, {"file_path": "/src/main/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java", "method_name": "<clinit>", "content": "public class EuclideanIntegerPoint implements Clusterable<EuclideanIntegerPoint>, Serializable {", "javadoc_start_line": 30, "annotations_start_line": 30, "method_start_line": 30, "end_line": 30}, {"file_path": "/src/main/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java", "method_name": "distanceFrom", "content": "    /** {@inheritDoc} */\n    public double distanceFrom(final EuclideanIntegerPoint p) {\n        return MathUtils.distance(point, p.getPoint());\n    }", "javadoc_start_line": 55, "annotations_start_line": 56, "method_start_line": 56, "end_line": 58}, {"file_path": "/src/main/java/org/apache/commons/math/util/MathUtils.java", "method_name": "distance", "content": "    /**\n     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>2</sub> distance between the two points\n     */\n    public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }", "javadoc_start_line": 1616, "annotations_start_line": 1623, "method_start_line": 1623, "end_line": 1630}]}], "project": {"name": "Math", "version": 79}}