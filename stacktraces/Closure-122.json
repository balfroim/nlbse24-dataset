{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testSuspiciousBlockCommentWarning3", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 228, "end_line": 320}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "Command failed: defects4j test -w ./projects/Closure/122\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/122 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/122 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/IRFactory.java:229: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testSuspiciousBlockCommentWarning3\", \"arrayCompTransformHelper\", \"./results/stacktrace-testSuspiciousBlockCommentWarning3-arrayCompTransformHelper.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 41 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/build.xml:102: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/build.xml:45: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/build.xml:38: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"}}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testSuspiciousBlockCommentWarning3", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "handleBlockComment", "content": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }", "javadoc_start_line": 248, "annotations_start_line": 251, "method_start_line": 251, "end_line": 258}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/parsing/ParserRunner.java", "method_name": "parse", "content": "  /**\n   * Parses the JavaScript text given by a reader.\n   *\n   * @param sourceString Source code from the file.\n   * @param errorReporter An error.\n   * @param logger A logger.\n   * @return The AST of the given text.\n   * @throws IOException\n   */\n  public static ParseResult parse(StaticSourceFile sourceFile,\n                                  String sourceString,\n                                  Config config,\n                                  ErrorReporter errorReporter,\n                                  Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    compilerEnv.setReservedKeywordAsIdentifier(true);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return new ParseResult(root, astRoot);\n  }", "javadoc_start_line": 98, "annotations_start_line": 107, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transformTree", "content": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }", "javadoc_start_line": 186, "annotations_start_line": 186, "method_start_line": 190, "end_line": 209}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformArrayComp", "content": "    private Node transformArrayComp(ArrayComprehension node) {\n        // An array comprehension expression such as\n        //\n        //   [expr for (x in foo) for each ([y, z] in bar) if (cond)]\n        //\n        // is rewritten approximately as\n        //\n        // new Scope(ARRAYCOMP) {\n        //   new Node(BLOCK) {\n        //     let tmp1 = new Array;\n        //     for (let x in foo) {\n        //       for each (let tmp2 in bar) {\n        //         if (cond) {\n        //           tmp1.push([y, z] = tmp2, expr);\n        //         }\n        //       }\n        //     }\n        //   }\n        //   createName(tmp1)\n        // }\n\n        int lineno = node.getLineno();\n        Scope scopeNode = createScopeNode(Token.ARRAYCOMP, lineno);\n        String arrayName = currentScriptOrFn.getNextTempName();\n        pushScope(scopeNode);\n        try {\n            defineSymbol(Token.LET, arrayName, false);\n            Node block = new Node(Token.BLOCK, lineno);\n            Node newArray = createCallOrNew(Token.NEW, createName(\"Array\"));\n            Node init = new Node(Token.EXPR_VOID,\n                                 createAssignment(Token.ASSIGN,\n                                                  createName(arrayName),\n                                                  newArray),\n                                 lineno);\n            block.addChildToBack(init);\n            block.addChildToBack(arrayCompTransformHelper(node, arrayName));\n            scopeNode.addChildToBack(block);\n            scopeNode.addChildToBack(createName(arrayName));\n            return scopeNode;\n        } finally {\n            popScope();\n        }\n    }", "javadoc_start_line": 183, "annotations_start_line": 183, "method_start_line": 183, "end_line": 225}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 228, "end_line": 320}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "handleBlockComment", "content": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }", "javadoc_start_line": 248, "annotations_start_line": 251, "method_start_line": 251, "end_line": 258}]}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testSuspiciousBlockCommentWarning4", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 228, "end_line": 320}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "Command failed: defects4j test -w ./projects/Closure/122\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/122 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/122 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/IRFactory.java:229: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testSuspiciousBlockCommentWarning4\", \"arrayCompTransformHelper\", \"./results/stacktrace-testSuspiciousBlockCommentWarning4-arrayCompTransformHelper.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 41 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/build.xml:102: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/build.xml:45: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/build.xml:38: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"}}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testSuspiciousBlockCommentWarning4", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "handleBlockComment", "content": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }", "javadoc_start_line": 248, "annotations_start_line": 251, "method_start_line": 251, "end_line": 258}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/parsing/ParserRunner.java", "method_name": "parse", "content": "  /**\n   * Parses the JavaScript text given by a reader.\n   *\n   * @param sourceString Source code from the file.\n   * @param errorReporter An error.\n   * @param logger A logger.\n   * @return The AST of the given text.\n   * @throws IOException\n   */\n  public static ParseResult parse(StaticSourceFile sourceFile,\n                                  String sourceString,\n                                  Config config,\n                                  ErrorReporter errorReporter,\n                                  Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    compilerEnv.setReservedKeywordAsIdentifier(true);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return new ParseResult(root, astRoot);\n  }", "javadoc_start_line": 98, "annotations_start_line": 107, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transformTree", "content": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }", "javadoc_start_line": 186, "annotations_start_line": 186, "method_start_line": 190, "end_line": 209}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformArrayComp", "content": "    private Node transformArrayComp(ArrayComprehension node) {\n        // An array comprehension expression such as\n        //\n        //   [expr for (x in foo) for each ([y, z] in bar) if (cond)]\n        //\n        // is rewritten approximately as\n        //\n        // new Scope(ARRAYCOMP) {\n        //   new Node(BLOCK) {\n        //     let tmp1 = new Array;\n        //     for (let x in foo) {\n        //       for each (let tmp2 in bar) {\n        //         if (cond) {\n        //           tmp1.push([y, z] = tmp2, expr);\n        //         }\n        //       }\n        //     }\n        //   }\n        //   createName(tmp1)\n        // }\n\n        int lineno = node.getLineno();\n        Scope scopeNode = createScopeNode(Token.ARRAYCOMP, lineno);\n        String arrayName = currentScriptOrFn.getNextTempName();\n        pushScope(scopeNode);\n        try {\n            defineSymbol(Token.LET, arrayName, false);\n            Node block = new Node(Token.BLOCK, lineno);\n            Node newArray = createCallOrNew(Token.NEW, createName(\"Array\"));\n            Node init = new Node(Token.EXPR_VOID,\n                                 createAssignment(Token.ASSIGN,\n                                                  createName(arrayName),\n                                                  newArray),\n                                 lineno);\n            block.addChildToBack(init);\n            block.addChildToBack(arrayCompTransformHelper(node, arrayName));\n            scopeNode.addChildToBack(block);\n            scopeNode.addChildToBack(createName(arrayName));\n            return scopeNode;\n        } finally {\n            popScope();\n        }\n    }", "javadoc_start_line": 183, "annotations_start_line": 183, "method_start_line": 183, "end_line": 225}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 228, "end_line": 320}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "handleBlockComment", "content": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }", "javadoc_start_line": 248, "annotations_start_line": 251, "method_start_line": 251, "end_line": 258}]}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testSuspiciousBlockCommentWarning5", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 228, "end_line": 320}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "Command failed: defects4j test -w ./projects/Closure/122\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/122 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/122 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/IRFactory.java:229: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testSuspiciousBlockCommentWarning5\", \"arrayCompTransformHelper\", \"./results/stacktrace-testSuspiciousBlockCommentWarning5-arrayCompTransformHelper.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 41 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/build.xml:102: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/build.xml:45: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/122/lib/rhino/src/build.xml:38: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"}}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testSuspiciousBlockCommentWarning5", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "handleBlockComment", "content": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }", "javadoc_start_line": 248, "annotations_start_line": 251, "method_start_line": 251, "end_line": 258}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/parsing/ParserRunner.java", "method_name": "parse", "content": "  /**\n   * Parses the JavaScript text given by a reader.\n   *\n   * @param sourceString Source code from the file.\n   * @param errorReporter An error.\n   * @param logger A logger.\n   * @return The AST of the given text.\n   * @throws IOException\n   */\n  public static ParseResult parse(StaticSourceFile sourceFile,\n                                  String sourceString,\n                                  Config config,\n                                  ErrorReporter errorReporter,\n                                  Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    compilerEnv.setReservedKeywordAsIdentifier(true);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return new ParseResult(root, astRoot);\n  }", "javadoc_start_line": 98, "annotations_start_line": 107, "method_start_line": 111, "end_line": 147}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transformTree", "content": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }", "javadoc_start_line": 186, "annotations_start_line": 186, "method_start_line": 190, "end_line": 209}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformArrayComp", "content": "    private Node transformArrayComp(ArrayComprehension node) {\n        // An array comprehension expression such as\n        //\n        //   [expr for (x in foo) for each ([y, z] in bar) if (cond)]\n        //\n        // is rewritten approximately as\n        //\n        // new Scope(ARRAYCOMP) {\n        //   new Node(BLOCK) {\n        //     let tmp1 = new Array;\n        //     for (let x in foo) {\n        //       for each (let tmp2 in bar) {\n        //         if (cond) {\n        //           tmp1.push([y, z] = tmp2, expr);\n        //         }\n        //       }\n        //     }\n        //   }\n        //   createName(tmp1)\n        // }\n\n        int lineno = node.getLineno();\n        Scope scopeNode = createScopeNode(Token.ARRAYCOMP, lineno);\n        String arrayName = currentScriptOrFn.getNextTempName();\n        pushScope(scopeNode);\n        try {\n            defineSymbol(Token.LET, arrayName, false);\n            Node block = new Node(Token.BLOCK, lineno);\n            Node newArray = createCallOrNew(Token.NEW, createName(\"Array\"));\n            Node init = new Node(Token.EXPR_VOID,\n                                 createAssignment(Token.ASSIGN,\n                                                  createName(arrayName),\n                                                  newArray),\n                                 lineno);\n            block.addChildToBack(init);\n            block.addChildToBack(arrayCompTransformHelper(node, arrayName));\n            scopeNode.addChildToBack(block);\n            scopeNode.addChildToBack(createName(arrayName));\n            return scopeNode;\n        } finally {\n            popScope();\n        }\n    }", "javadoc_start_line": 183, "annotations_start_line": 183, "method_start_line": 183, "end_line": 225}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 228, "end_line": 320}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "handleBlockComment", "content": "  /**\n   * Check to see if the given block comment looks like it should be JSDoc.\n   */\n  private void handleBlockComment(Comment comment) {\n    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n      errorReporter.warning(\n          SUSPICIOUS_COMMENT_WARNING,\n          sourceName,\n          comment.getLineno(), \"\", 0);\n    }\n  }", "javadoc_start_line": 248, "annotations_start_line": 251, "method_start_line": 251, "end_line": 258}]}], "project": {"name": "Closure", "version": 122}}