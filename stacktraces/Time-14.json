{"tours": [{"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testPlusMonths_int_negativeFromLeap", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testPlusMonths_int_negativeFromLeap", "content": "    public void testPlusMonths_int_negativeFromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusMonths(-1);\n        MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 458, "annotations_start_line": 458, "method_start_line": 458, "end_line": 463}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "plusMonths", "content": "    /**\n     * Returns a copy of this month-day plus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusMonths(6);\n     * MonthDay added = md.plus(Period.months(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new month-day plus the increased months, never null\n     */\n    public MonthDay plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "javadoc_start_line": 574, "annotations_start_line": 591, "method_start_line": 591, "end_line": 593}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}]}, {"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testMinusDays_int_negativeFromLeap", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testMinusDays_int_negativeFromLeap", "content": "    public void testMinusDays_int_negativeFromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusDays(-1);\n        MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 608, "annotations_start_line": 608, "method_start_line": 608, "end_line": 613}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "minusDays", "content": "    /**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusDays(6);\n     * MonthDay subtracted = md.minus(Period.days(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.days(), -6);\n     * </pre>\n     *\n     * @param days  the amount of days to subtract, may be negative\n     * @return the new month-day minus the increased days, never null\n     */\n    public MonthDay minusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n    }", "javadoc_start_line": 655, "annotations_start_line": 671, "method_start_line": 671, "end_line": 673}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/field/BaseDateTimeField.java", "method_name": "add", "content": "    /**\n     * Adds a value (which may be negative) to the partial instant,\n     * throwing an exception if the maximum size of the instant is reached.\n     * <p>\n     * The value will be added to this field, overflowing into larger fields\n     * if necessary. Smaller fields should be unaffected, except where the\n     * result would be an invalid value for a smaller field. In this case the\n     * smaller field is adjusted to be in range.\n     * <p>\n     * Partial instants only contain some fields. This may result in a maximum\n     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this\n     * limit is breached by the add an exception is thrown.\n     * <p>\n     * For example, in the ISO chronology:<br>\n     * 2000-08-20 add six months is 2000-02-20<br>\n     * 2000-08-20 add twenty months is 2000-04-20<br>\n     * 2000-08-20 add minus nine months is 2000-11-20<br>\n     * 2001-01-31 add one month  is 2001-02-28<br>\n     * 2001-01-31 add two months is 2001-03-31<br>\n     * \n     * @param instant  the partial instant\n     * @param fieldIndex  the index of this field in the partial\n     * @param values  the values of the partial instant which should be updated\n     * @param valueToAdd  the value to add, in the units of the field\n     * @return the passed in values\n     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n     */\n    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // there are more efficient algorithms than this (especially for time only fields)\n        // trouble is when dealing with days and months, so we use this technique of\n        // adding/removing one from the larger field at a time\n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                // test only works if this field is UTC (ie. local)\n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add\n            values = nextField.add(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field\n            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero\n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add\n            values = nextField.add(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field\n            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value\n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n    }", "javadoc_start_line": 270, "annotations_start_line": 297, "method_start_line": 297, "end_line": 349}]}, {"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testPlusMonths_int_fromLeap", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testPlusMonths_int_fromLeap", "content": "    public void testPlusMonths_int_fromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusMonths(1);\n        MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 451, "annotations_start_line": 451, "method_start_line": 451, "end_line": 456}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "plusMonths", "content": "    /**\n     * Returns a copy of this month-day plus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusMonths(6);\n     * MonthDay added = md.plus(Period.months(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new month-day plus the increased months, never null\n     */\n    public MonthDay plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "javadoc_start_line": 574, "annotations_start_line": 591, "method_start_line": 591, "end_line": 593}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}]}, {"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testPlusMonths_int_negativeEndOfMonthAdjust", "error": "junit.framework.AssertionFailedError", "message": "expected:<--02-29> but was:<--02-28>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testPlusMonths_int_negativeEndOfMonthAdjust", "content": "    public void testPlusMonths_int_negativeEndOfMonthAdjust() {\n        MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusMonths(-1);\n        MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 472, "annotations_start_line": 472, "method_start_line": 472, "end_line": 477}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "plusMonths", "content": "    /**\n     * Returns a copy of this month-day plus the specified number of months.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusMonths(6);\n     * MonthDay added = md.plus(Period.months(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\n     * </pre>\n     *\n     * @param months  the amount of months to add, may be negative\n     * @return the new month-day plus the increased months, never null\n     */\n    public MonthDay plusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), months);\n    }", "javadoc_start_line": 574, "annotations_start_line": 591, "method_start_line": 591, "end_line": 593}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}]}, {"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testMinusMonths_int_endOfMonthAdjust", "error": "junit.framework.AssertionFailedError", "message": "expected:<--02-29> but was:<--02-28>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testMinusMonths_int_endOfMonthAdjust", "content": "    public void testMinusMonths_int_endOfMonthAdjust() {\n        MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusMonths(1);\n        MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 559, "annotations_start_line": 559, "method_start_line": 559, "end_line": 564}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "minusMonths", "content": "    /**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This MonthDay instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusMonths(6);\n     * MonthDay subtracted = md.minus(Period.months(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new month-day minus the increased months, never null\n     */\n    public MonthDay minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "javadoc_start_line": 634, "annotations_start_line": 651, "method_start_line": 651, "end_line": 653}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}]}, {"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testMinusMonths_int_negativeFromLeap", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testMinusMonths_int_negativeFromLeap", "content": "    public void testMinusMonths_int_negativeFromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusMonths(-1);\n        MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 552, "annotations_start_line": 552, "method_start_line": 552, "end_line": 557}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "minusMonths", "content": "    /**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This MonthDay instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusMonths(6);\n     * MonthDay subtracted = md.minus(Period.months(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new month-day minus the increased months, never null\n     */\n    public MonthDay minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "javadoc_start_line": 634, "annotations_start_line": 651, "method_start_line": 651, "end_line": 653}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}]}, {"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testMinusMonths_int_fromLeap", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testMinusMonths_int_fromLeap", "content": "    public void testMinusMonths_int_fromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.minusMonths(1);\n        MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 545, "annotations_start_line": 545, "method_start_line": 545, "end_line": 550}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "minusMonths", "content": "    /**\n     * Returns a copy of this month-day minus the specified number of months.\n     * <p>\n     * This MonthDay instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from January to December.\n     * The day will be adjusted to the last valid value if necessary.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay subtracted = md.minusMonths(6);\n     * MonthDay subtracted = md.minus(Period.months(6));\n     * MonthDay subtracted = md.withFieldAdded(DurationFieldType.months(), -6);\n     * </pre>\n     *\n     * @param months  the amount of months to subtract, may be negative\n     * @return the new month-day minus the increased months, never null\n     */\n    public MonthDay minusMonths(int months) {\n        return withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n    }", "javadoc_start_line": 634, "annotations_start_line": 651, "method_start_line": 651, "end_line": 653}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}]}, {"failing_test": {"className": " org.joda.time.TestMonthDay_Basics", "methodName": "testPlusDays_int_fromLeap", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java", "method_name": "add", "content": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }", "javadoc_start_line": 203, "annotations_start_line": 203, "method_start_line": 203, "end_line": 220}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonthDay_Basics.java", "method_name": "testPlusDays_int_fromLeap", "content": "    public void testPlusDays_int_fromLeap() {\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n        MonthDay result = test.plusDays(1);\n        MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n        assertEquals(expected, result);\n    }", "javadoc_start_line": 507, "annotations_start_line": 507, "method_start_line": 507, "end_line": 512}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "plusDays", "content": "    /**\n     * Returns a copy of this month-day plus the specified number of days.\n     * <p>\n     * This month-day instance is immutable and unaffected by this method call.\n     * The month will wrap at the end of the year from December to January.\n     * <p>\n     * The following three lines are identical in effect:\n     * <pre>\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.plus(Period.days(6));\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * </pre>\n     *\n     * @param days  the amount of days to add, may be negative\n     * @return the new month-day plus the increased days, never null\n     */\n    public MonthDay plusDays(int days) {\n        return withFieldAdded(DurationFieldType.days(), days);\n    }", "javadoc_start_line": 595, "annotations_start_line": 611, "method_start_line": 611, "end_line": 613}, {"file_path": "/src/main/java/org/joda/time/MonthDay.java", "method_name": "withFieldAdded", "content": "    /**\n     * Returns a copy of this month-day with the value of the specified field increased.\n     * <p>\n     * If the addition is zero, then <code>this</code> is returned.\n     * <p>\n     * These three lines are equivalent:\n     * <pre>\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n     * MonthDay added = md.plusDays(6);\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\n     * </pre>\n     * \n     * @param fieldType  the field type to add to, not null\n     * @param amount  the amount to add\n     * @return a copy of this instance with the field updated, never null\n     * @throws IllegalArgumentException if the value is null or invalid\n     * @throws ArithmeticException if the new date-time exceeds the capacity\n     */\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\n        int index = indexOfSupported(fieldType);\n        if (amount == 0) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).add(this, index, newValues, amount);\n        return new MonthDay(this, newValues);\n    }", "javadoc_start_line": 495, "annotations_start_line": 513, "method_start_line": 513, "end_line": 521}, {"file_path": "/src/main/java/org/joda/time/field/BaseDateTimeField.java", "method_name": "add", "content": "    /**\n     * Adds a value (which may be negative) to the partial instant,\n     * throwing an exception if the maximum size of the instant is reached.\n     * <p>\n     * The value will be added to this field, overflowing into larger fields\n     * if necessary. Smaller fields should be unaffected, except where the\n     * result would be an invalid value for a smaller field. In this case the\n     * smaller field is adjusted to be in range.\n     * <p>\n     * Partial instants only contain some fields. This may result in a maximum\n     * possible value, such as TimeOfDay being limited to 23:59:59:999. If this\n     * limit is breached by the add an exception is thrown.\n     * <p>\n     * For example, in the ISO chronology:<br>\n     * 2000-08-20 add six months is 2000-02-20<br>\n     * 2000-08-20 add twenty months is 2000-04-20<br>\n     * 2000-08-20 add minus nine months is 2000-11-20<br>\n     * 2001-01-31 add one month  is 2001-02-28<br>\n     * 2001-01-31 add two months is 2001-03-31<br>\n     * \n     * @param instant  the partial instant\n     * @param fieldIndex  the index of this field in the partial\n     * @param values  the values of the partial instant which should be updated\n     * @param valueToAdd  the value to add, in the units of the field\n     * @return the passed in values\n     * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n     */\n    public int[] add(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) {\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // there are more efficient algorithms than this (especially for time only fields)\n        // trouble is when dealing with days and months, so we use this technique of\n        // adding/removing one from the larger field at a time\n        DateTimeField nextField = null;\n        \n        while (valueToAdd > 0) {\n            int max = getMaximumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed <= max) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                // test only works if this field is UTC (ie. local)\n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (max + 1) - values[fieldIndex];  // reduce the amount to add\n            values = nextField.add(instant, fieldIndex - 1, values, 1);  // add 1 to next bigger field\n            values[fieldIndex] = getMinimumValue(instant, values);  // reset this field to zero\n        }\n        while (valueToAdd < 0) {\n            int min = getMinimumValue(instant, values);\n            long proposed = values[fieldIndex] + valueToAdd;\n            if (proposed >= min) {\n                values[fieldIndex] = (int) proposed;\n                break;\n            }\n            if (nextField == null) {\n                if (fieldIndex == 0) {\n                    throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n                }\n                nextField = instant.getField(fieldIndex - 1);\n                if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                    throw new IllegalArgumentException(\"Fields invalid for add\");\n                }\n            }\n            valueToAdd -= (min - 1) - values[fieldIndex];  // reduce the amount to add\n            values = nextField.add(instant, fieldIndex - 1, values, -1);  // subtract 1 from next bigger field\n            values[fieldIndex] = getMaximumValue(instant, values);  // reset this field to max value\n        }\n        \n        return set(instant, fieldIndex, values, values[fieldIndex]);  // adjusts smaller fields\n    }", "javadoc_start_line": 270, "annotations_start_line": 297, "method_start_line": 297, "end_line": 349}]}], "project": {"name": "Time", "version": 14}}