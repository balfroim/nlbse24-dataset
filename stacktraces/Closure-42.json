{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testForEach", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "processForInLoop", "content": "    Node processForInLoop(ForInLoop loopNode) {\n\n        // Return the bare minimum to put the AST in a valid state.\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }", "javadoc_start_line": 567, "annotations_start_line": 566, "method_start_line": 567, "end_line": 575}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/parsing/ParserRunner.java", "method_name": "parse", "content": "  /**\n   * Parses the JavaScript text given by a reader.\n   *\n   * @param sourceString Source code from the file.\n   * @param errorReporter An error.\n   * @param logger A logger.\n   * @return The AST of the given text.\n   * @throws IOException\n   */\n  public static Node parse(StaticSourceFile sourceFile,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    // Do our own identifier check for ECMASCRIPT 5\n    boolean acceptEs5 =\n        config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3;\n    compilerEnv.setReservedKeywordAsIdentifier(acceptEs5);\n    compilerEnv.setAllowKeywordAsObjectPropertyName(acceptEs5);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }", "javadoc_start_line": 95, "annotations_start_line": 104, "method_start_line": 108, "end_line": 148}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transformTree", "content": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }", "javadoc_start_line": 165, "annotations_start_line": 165, "method_start_line": 169, "end_line": 188}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transform", "content": "    public Node transform(AstNode node) {\n        switch (node.getType()) {\n          case Token.ARRAYCOMP:\n              return transformArrayComp((ArrayComprehension)node);\n          case Token.ARRAYLIT:\n              return transformArrayLiteral((ArrayLiteral)node);\n          case Token.BLOCK:\n              return transformBlock(node);\n          case Token.BREAK:\n              return transformBreak((BreakStatement)node);\n          case Token.CALL:\n              return transformFunctionCall((FunctionCall)node);\n          case Token.CONTINUE:\n              return transformContinue((ContinueStatement)node);\n          case Token.DO:\n              return transformDoLoop((DoLoop)node);\n          case Token.EMPTY:\n              return node;\n          case Token.FOR:\n              if (node instanceof ForInLoop) {\n                  return transformForInLoop((ForInLoop)node);\n              } else {\n                  return transformForLoop((ForLoop)node);\n              }\n          case Token.FUNCTION:\n              return transformFunction((FunctionNode)node);\n          case Token.GETELEM:\n              return transformElementGet((ElementGet)node);\n          case Token.GETPROP:\n              return transformPropertyGet((PropertyGet)node);\n          case Token.HOOK:\n              return transformCondExpr((ConditionalExpression)node);\n          case Token.IF:\n              return transformIf((IfStatement)node);\n\n          case Token.TRUE:\n          case Token.FALSE:\n          case Token.THIS:\n          case Token.NULL:\n          case Token.DEBUGGER:\n              return transformLiteral(node);\n\n          case Token.NAME:\n              return transformName((Name)node);\n          case Token.NUMBER:\n              return transformNumber((NumberLiteral)node);\n          case Token.NEW:\n              return transformNewExpr((NewExpression)node);\n          case Token.OBJECTLIT:\n              return transformObjectLiteral((ObjectLiteral)node);\n          case Token.REGEXP:\n              return transformRegExp((RegExpLiteral)node);\n          case Token.RETURN:\n              return transformReturn((ReturnStatement)node);\n          case Token.SCRIPT:\n              return transformScript((ScriptNode)node);\n          case Token.STRING:\n              return transformString((StringLiteral)node);\n          case Token.SWITCH:\n              return transformSwitch((SwitchStatement)node);\n          case Token.THROW:\n              return transformThrow((ThrowStatement)node);\n          case Token.TRY:\n              return transformTry((TryStatement)node);\n          case Token.WHILE:\n              return transformWhileLoop((WhileLoop)node);\n          case Token.WITH:\n              return transformWith((WithStatement)node);\n          case Token.YIELD:\n              return transformYield((Yield)node);\n          default:\n              if (node instanceof ExpressionStatement) {\n                  return transformExprStmt((ExpressionStatement)node);\n              }\n              if (node instanceof Assignment) {\n                  return transformAssignment((Assignment)node);\n              }\n              if (node instanceof UnaryExpression) {\n                  return transformUnary((UnaryExpression)node);\n              }\n              if (node instanceof XmlMemberGet) {\n                  return transformXmlMemberGet((XmlMemberGet)node);\n              }\n              if (node instanceof InfixExpression) {\n                  return transformInfix((InfixExpression)node);\n              }\n              if (node instanceof VariableDeclaration) {\n                  return transformVariables((VariableDeclaration)node);\n              }\n              if (node instanceof ParenthesizedExpression) {\n                  return transformParenExpr((ParenthesizedExpression)node);\n              }\n              if (node instanceof LabeledStatement) {\n                  return transformLabeledStatement((LabeledStatement)node);\n              }\n              if (node instanceof LetNode) {\n                  return transformLetNode((LetNode)node);\n              }\n              if (node instanceof XmlRef) {\n                  return transformXmlRef((XmlRef)node);\n              }\n              if (node instanceof XmlLiteral) {\n                  return transformXmlLiteral((XmlLiteral)node);\n              }\n              throw new IllegalArgumentException(\"Can't transform: \" + node);\n        }\n    }", "javadoc_start_line": 111, "annotations_start_line": 111, "method_start_line": 111, "end_line": 217}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 263, "annotations_start_line": 263, "method_start_line": 264, "end_line": 356}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transform", "content": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }", "javadoc_start_line": 271, "annotations_start_line": 271, "method_start_line": 271, "end_line": 279}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformArrayLiteral", "content": "    private Node transformArrayLiteral(ArrayLiteral node) {\n        if (node.isDestructuring()) {\n            return node;\n        }\n        decompiler.addToken(Token.LB);\n        List<AstNode> elems = node.getElements();\n        Node array = new Node(Token.ARRAYLIT);\n        List<Integer> skipIndexes = null;\n        for (int i = 0; i < elems.size(); ++i) {\n            AstNode elem = elems.get(i);\n            if (elem.getType() != Token.EMPTY) {\n                array.addChildToBack(transform(elem));\n            } else {\n                if (skipIndexes == null) {\n                    skipIndexes = new ArrayList<Integer>();\n                }\n                skipIndexes.add(i);\n            }\n            if (i < elems.size() - 1)\n                decompiler.addToken(Token.COMMA);\n        }\n        decompiler.addToken(Token.RB);\n        array.putIntProp(Node.DESTRUCTURING_ARRAY_LENGTH,\n                         node.getDestructuringLength());\n        if (skipIndexes != null) {\n            int[] skips = new int[skipIndexes.size()];\n            for (int i = 0; i < skipIndexes.size(); i++)\n                skips[i] = skipIndexes.get(i);\n            array.putProp(Node.SKIP_INDEXES_PROP, skips);\n        }\n        return array;\n    }", "javadoc_start_line": 358, "annotations_start_line": 358, "method_start_line": 358, "end_line": 389}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "justTransform", "content": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }", "javadoc_start_line": 375, "annotations_start_line": 375, "method_start_line": 375, "end_line": 377}, {"file_path": "/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java", "method_name": "process", "content": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }", "javadoc_start_line": 118, "annotations_start_line": 118, "method_start_line": 118, "end_line": 281}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<obinit>", "content": "class IRFactory {", "javadoc_start_line": 80, "annotations_start_line": 80, "method_start_line": 80, "end_line": 80}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<clinit>", "content": "class IRFactory {", "javadoc_start_line": 80, "annotations_start_line": 80, "method_start_line": 80, "end_line": 80}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 263, "annotations_start_line": 263, "method_start_line": 264, "end_line": 356}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transform", "content": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }", "javadoc_start_line": 271, "annotations_start_line": 271, "method_start_line": 271, "end_line": 279}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformArrayLiteral", "content": "    private Node transformArrayLiteral(ArrayLiteral node) {\n        if (node.isDestructuring()) {\n            return node;\n        }\n        decompiler.addToken(Token.LB);\n        List<AstNode> elems = node.getElements();\n        Node array = new Node(Token.ARRAYLIT);\n        List<Integer> skipIndexes = null;\n        for (int i = 0; i < elems.size(); ++i) {\n            AstNode elem = elems.get(i);\n            if (elem.getType() != Token.EMPTY) {\n                array.addChildToBack(transform(elem));\n            } else {\n                if (skipIndexes == null) {\n                    skipIndexes = new ArrayList<Integer>();\n                }\n                skipIndexes.add(i);\n            }\n            if (i < elems.size() - 1)\n                decompiler.addToken(Token.COMMA);\n        }\n        decompiler.addToken(Token.RB);\n        array.putIntProp(Node.DESTRUCTURING_ARRAY_LENGTH,\n                         node.getDestructuringLength());\n        if (skipIndexes != null) {\n            int[] skips = new int[skipIndexes.size()];\n            for (int i = 0; i < skipIndexes.size(); i++)\n                skips[i] = skipIndexes.get(i);\n            array.putProp(Node.SKIP_INDEXES_PROP, skips);\n        }\n        return array;\n    }", "javadoc_start_line": 358, "annotations_start_line": 358, "method_start_line": 358, "end_line": 389}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "justTransform", "content": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }", "javadoc_start_line": 375, "annotations_start_line": 375, "method_start_line": 375, "end_line": 377}, {"file_path": "/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java", "method_name": "process", "content": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }", "javadoc_start_line": 118, "annotations_start_line": 118, "method_start_line": 118, "end_line": 281}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<obinit>", "content": "class IRFactory {", "javadoc_start_line": 80, "annotations_start_line": 80, "method_start_line": 80, "end_line": 80}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<clinit>", "content": "class IRFactory {", "javadoc_start_line": 80, "annotations_start_line": 80, "method_start_line": 80, "end_line": 80}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 263, "annotations_start_line": 263, "method_start_line": 264, "end_line": 356}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transform", "content": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }", "javadoc_start_line": 271, "annotations_start_line": 271, "method_start_line": 271, "end_line": 279}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformArrayLiteral", "content": "    private Node transformArrayLiteral(ArrayLiteral node) {\n        if (node.isDestructuring()) {\n            return node;\n        }\n        decompiler.addToken(Token.LB);\n        List<AstNode> elems = node.getElements();\n        Node array = new Node(Token.ARRAYLIT);\n        List<Integer> skipIndexes = null;\n        for (int i = 0; i < elems.size(); ++i) {\n            AstNode elem = elems.get(i);\n            if (elem.getType() != Token.EMPTY) {\n                array.addChildToBack(transform(elem));\n            } else {\n                if (skipIndexes == null) {\n                    skipIndexes = new ArrayList<Integer>();\n                }\n                skipIndexes.add(i);\n            }\n            if (i < elems.size() - 1)\n                decompiler.addToken(Token.COMMA);\n        }\n        decompiler.addToken(Token.RB);\n        array.putIntProp(Node.DESTRUCTURING_ARRAY_LENGTH,\n                         node.getDestructuringLength());\n        if (skipIndexes != null) {\n            int[] skips = new int[skipIndexes.size()];\n            for (int i = 0; i < skipIndexes.size(); i++)\n                skips[i] = skipIndexes.get(i);\n            array.putProp(Node.SKIP_INDEXES_PROP, skips);\n        }\n        return array;\n    }", "javadoc_start_line": 358, "annotations_start_line": 358, "method_start_line": 358, "end_line": 389}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "justTransform", "content": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }", "javadoc_start_line": 375, "annotations_start_line": 375, "method_start_line": 375, "end_line": 377}, {"file_path": "/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java", "method_name": "process", "content": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }", "javadoc_start_line": 118, "annotations_start_line": 118, "method_start_line": 118, "end_line": 281}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<obinit>", "content": "class IRFactory {", "javadoc_start_line": 80, "annotations_start_line": 80, "method_start_line": 80, "end_line": 80}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<clinit>", "content": "class IRFactory {", "javadoc_start_line": 80, "annotations_start_line": 80, "method_start_line": 80, "end_line": 80}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "arrayCompTransformHelper", "content": "    private Node arrayCompTransformHelper(ArrayComprehension node,\n                                          String arrayName) {\n        decompiler.addToken(Token.LB);\n        int lineno = node.getLineno();\n        Node expr = transform(node.getResult());\n\n        List<ArrayComprehensionLoop> loops = node.getLoops();\n        int numLoops = loops.size();\n\n        // Walk through loops, collecting and defining their iterator symbols.\n        Node[] iterators = new Node[numLoops];\n        Node[] iteratedObjs = new Node[numLoops];\n\n        for (int i = 0; i < numLoops; i++) {\n            ArrayComprehensionLoop acl = loops.get(i);\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.FOR);\n            if (acl.isForEach()) {\n                decompiler.addName(\"each \");\n            }\n            decompiler.addToken(Token.LP);\n\n            AstNode iter = acl.getIterator();\n            String name = null;\n            if (iter.getType() == Token.NAME) {\n                name = iter.getString();\n                decompiler.addName(name);\n            } else {\n                // destructuring assignment\n                decompile(iter);\n                name = currentScriptOrFn.getNextTempName();\n                defineSymbol(Token.LP, name, false);\n                expr = createBinary(Token.COMMA,\n                                    createAssignment(Token.ASSIGN,\n                                                     iter,\n                                                     createName(name)),\n                                    expr);\n            }\n            Node init = createName(name);\n            // Define as a let since we want the scope of the variable to\n            // be restricted to the array comprehension\n            defineSymbol(Token.LET, name, false);\n            iterators[i] = init;\n\n            decompiler.addToken(Token.IN);\n            iteratedObjs[i] = transform(acl.getIteratedObject());\n            decompiler.addToken(Token.RP);\n        }\n\n        // generate code for tmpArray.push(body)\n        Node call = createCallOrNew(Token.CALL,\n                                    createPropertyGet(createName(arrayName),\n                                                      null,\n                                                      \"push\", 0));\n\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\n\n        if (node.getFilter() != null) {\n            decompiler.addName(\" \");\n            decompiler.addToken(Token.IF);\n            decompiler.addToken(Token.LP);\n            body = createIf(transform(node.getFilter()), body, null, lineno);\n            decompiler.addToken(Token.RP);\n        }\n\n        // Now walk loops in reverse to build up the body statement.\n        int pushed = 0;\n        try {\n            for (int i = numLoops-1; i >= 0; i--) {\n                ArrayComprehensionLoop acl = loops.get(i);\n                Scope loop = createLoopNode(null,  // no label\n                                            acl.getLineno());\n                pushScope(loop);\n                pushed++;\n                body = createForIn(Token.LET,\n                                   loop,\n                                   iterators[i],\n                                   iteratedObjs[i],\n                                   body,\n                                   acl.isForEach());\n            }\n        } finally {\n            for (int i = 0; i < pushed; i++) {\n                popScope();\n            }\n        }\n\n        decompiler.addToken(Token.RB);\n\n        // Now that we've accumulated any destructuring forms,\n        // add expr to the call node; it's pushed on each iteration.\n        call.addChildToBack(expr);\n        return body;\n    }", "javadoc_start_line": 263, "annotations_start_line": 263, "method_start_line": 264, "end_line": 356}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transform", "content": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }", "javadoc_start_line": 271, "annotations_start_line": 271, "method_start_line": 271, "end_line": 279}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformArrayLiteral", "content": "    private Node transformArrayLiteral(ArrayLiteral node) {\n        if (node.isDestructuring()) {\n            return node;\n        }\n        decompiler.addToken(Token.LB);\n        List<AstNode> elems = node.getElements();\n        Node array = new Node(Token.ARRAYLIT);\n        List<Integer> skipIndexes = null;\n        for (int i = 0; i < elems.size(); ++i) {\n            AstNode elem = elems.get(i);\n            if (elem.getType() != Token.EMPTY) {\n                array.addChildToBack(transform(elem));\n            } else {\n                if (skipIndexes == null) {\n                    skipIndexes = new ArrayList<Integer>();\n                }\n                skipIndexes.add(i);\n            }\n            if (i < elems.size() - 1)\n                decompiler.addToken(Token.COMMA);\n        }\n        decompiler.addToken(Token.RB);\n        array.putIntProp(Node.DESTRUCTURING_ARRAY_LENGTH,\n                         node.getDestructuringLength());\n        if (skipIndexes != null) {\n            int[] skips = new int[skipIndexes.size()];\n            for (int i = 0; i < skipIndexes.size(); i++)\n                skips[i] = skipIndexes.get(i);\n            array.putProp(Node.SKIP_INDEXES_PROP, skips);\n        }\n        return array;\n    }", "javadoc_start_line": 358, "annotations_start_line": 358, "method_start_line": 358, "end_line": 389}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "justTransform", "content": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }", "javadoc_start_line": 375, "annotations_start_line": 375, "method_start_line": 375, "end_line": 377}, {"file_path": "/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java", "method_name": "process", "content": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }", "javadoc_start_line": 118, "annotations_start_line": 118, "method_start_line": 118, "end_line": 281}]}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testForEach", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/lib/rhino/src/org/mozilla/javascript/IRFactory.java", "method_name": "transformFunction", "content": "    private Node transformFunction(FunctionNode fn) {\n        int functionType = fn.getFunctionType();\n        int start = decompiler.markFunctionStart(functionType);\n        Node mexpr = decompileFunctionHeader(fn);\n        int index = currentScriptOrFn.addFunction(fn);\n\n        PerFunctionVariables savedVars = new PerFunctionVariables(fn);\n        try {\n            // If we start needing to record much more codegen metadata during\n            // function parsing, we should lump it all into a helper class.\n            Node destructuring = (Node)fn.getProp(Node.DESTRUCTURING_PARAMS);\n            fn.removeProp(Node.DESTRUCTURING_PARAMS);\n\n            int lineno = fn.getBody().getLineno();\n            ++nestingOfFunction;  // only for body, not params\n            Node body = transform(fn.getBody());\n\n            if (!fn.isExpressionClosure()) {\n                decompiler.addToken(Token.RC);\n            }\n            fn.setEncodedSourceBounds(start, decompiler.markFunctionEnd(start));\n\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION && !fn.isExpressionClosure()) {\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n\n            if (destructuring != null) {\n                body.addChildToFront(new Node(Token.EXPR_VOID,\n                                              destructuring, lineno));\n            }\n\n            int syntheticType = fn.getFunctionType();\n            Node pn = initFunction(fn, index, body, syntheticType);\n            if (mexpr != null) {\n                pn = createAssignment(Token.ASSIGN, mexpr, pn);\n                if (syntheticType != FunctionNode.FUNCTION_EXPRESSION) {\n                    pn = createExprStatementNoReturn(pn, fn.getLineno());\n                }\n            }\n            return pn;\n\n        } finally {\n            --nestingOfFunction;\n            savedVars.restore();\n        }\n    }", "javadoc_start_line": 542, "annotations_start_line": 542, "method_start_line": 542, "end_line": 589}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "Command failed: defects4j test -w ./projects/Closure/42\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/42 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/42 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/42/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/List.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/ArrayList.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalArgumentException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Collection.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Collection.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Iterable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Iterable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Integer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Integer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Number.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Number.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/AbstractList.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/AbstractList.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/AbstractCollection.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/AbstractCollection.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Byte.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Byte.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Character.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Character.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Short.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Short.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/42/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/42/lib/rhino/src/org/mozilla/javascript/IRFactory.java:543: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testForEach\", \"transformFunction\", \"./results/stacktrace-testForEach-transformFunction.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/42/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 59 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/42/build.xml:95: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/42/lib/rhino/build.xml:75: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/42/lib/rhino/src/build.xml:68: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"}}], "project": {"name": "Closure", "version": 42}}