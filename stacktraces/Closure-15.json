{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testSimpleForIn", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "apply", "content": "      public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n          return false;\n        }\n\n        // TODO(user): We only care about calls to functions that\n        // passes one of the dependent variable to a non-side-effect free\n        // function.\n        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n          return true;\n        }\n\n        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n          return true;\n        }\n\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n            return true;\n          }\n        }\n        return false;\n      }", "javadoc_start_line": 84, "annotations_start_line": 83, "method_start_line": 84, "end_line": 109}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 545}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 561, "annotations_start_line": 562, "method_start_line": 562, "end_line": 569}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n      }\n    }\n  }", "javadoc_start_line": 117, "annotations_start_line": 116, "method_start_line": 117, "end_line": 151}, {"file_path": "/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java", "method_name": "somePathsSatisfyPredicate", "content": "  /**\n   * @return true iff some paths contain at least one node that satisfy the\n   *     predicate\n   */\n  public boolean somePathsSatisfyPredicate() {\n    setUp();\n    boolean result = checkSomePathsWithoutBackEdges(start, end);\n    tearDown();\n    return result;\n  }", "javadoc_start_line": 117, "annotations_start_line": 121, "method_start_line": 121, "end_line": 126}, {"file_path": "/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java", "method_name": "checkSomePathsWithoutBackEdges", "content": "  /**\n   * Verify that some non-looping paths from {@code a} to {@code b} pass\n   * through at least one node where {@code nodePredicate} is true.\n   */\n  private boolean checkSomePathsWithoutBackEdges(DiGraphNode<N, E> a,\n      DiGraphNode<N, E> b) {\n    if (nodePredicate.apply(a.getValue()) &&\n        (inclusive || (a != start && a != end))) {\n      return true;\n    }\n    if (a == b) {\n      return false;\n    }\n    for (DiGraphEdge<N, E> e : a.getOutEdges()) {\n      // Once we visited that edge once, we no longer need to\n      // re-visit it again.\n      if (e.getAnnotation() == VISITED_EDGE) {\n        continue;\n      }\n      e.setAnnotation(VISITED_EDGE);\n\n      if (ignoreEdge(e)) {\n        continue;\n      }\n      if (e.getAnnotation() == BACK_EDGE) {\n        continue;\n      }\n\n      DiGraphNode<N, E> next = e.getDestination();\n      if (checkSomePathsWithoutBackEdges(next, b)) {\n        return true;\n      }\n    }\n    return false;\n  }", "javadoc_start_line": 195, "annotations_start_line": 199, "method_start_line": 200, "end_line": 229}, {"file_path": "/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java", "method_name": "checkSomePathsWithoutBackEdges", "content": "  /**\n   * Verify that some non-looping paths from {@code a} to {@code b} pass\n   * through at least one node where {@code nodePredicate} is true.\n   */\n  private boolean checkSomePathsWithoutBackEdges(DiGraphNode<N, E> a,\n      DiGraphNode<N, E> b) {\n    if (nodePredicate.apply(a.getValue()) &&\n        (inclusive || (a != start && a != end))) {\n      return true;\n    }\n    if (a == b) {\n      return false;\n    }\n    for (DiGraphEdge<N, E> e : a.getOutEdges()) {\n      // Once we visited that edge once, we no longer need to\n      // re-visit it again.\n      if (e.getAnnotation() == VISITED_EDGE) {\n        continue;\n      }\n      e.setAnnotation(VISITED_EDGE);\n\n      if (ignoreEdge(e)) {\n        continue;\n      }\n      if (e.getAnnotation() == BACK_EDGE) {\n        continue;\n      }\n\n      DiGraphNode<N, E> next = e.getDestination();\n      if (checkSomePathsWithoutBackEdges(next, b)) {\n        return true;\n      }\n    }\n    return false;\n  }", "javadoc_start_line": 195, "annotations_start_line": 199, "method_start_line": 200, "end_line": 229}, {"file_path": "/src/com/google/javascript/jscomp/CheckPathsBetweenNodes.java", "method_name": "checkSomePathsWithoutBackEdges", "content": "  /**\n   * Verify that some non-looping paths from {@code a} to {@code b} pass\n   * through at least one node where {@code nodePredicate} is true.\n   */\n  private boolean checkSomePathsWithoutBackEdges(DiGraphNode<N, E> a,\n      DiGraphNode<N, E> b) {\n    if (nodePredicate.apply(a.getValue()) &&\n        (inclusive || (a != start && a != end))) {\n      return true;\n    }\n    if (a == b) {\n      return false;\n    }\n    for (DiGraphEdge<N, E> e : a.getOutEdges()) {\n      // Once we visited that edge once, we no longer need to\n      // re-visit it again.\n      if (e.getAnnotation() == VISITED_EDGE) {\n        continue;\n      }\n      e.setAnnotation(VISITED_EDGE);\n\n      if (ignoreEdge(e)) {\n        continue;\n      }\n      if (e.getAnnotation() == BACK_EDGE) {\n        continue;\n      }\n\n      DiGraphNode<N, E> next = e.getDestination();\n      if (checkSomePathsWithoutBackEdges(next, b)) {\n        return true;\n      }\n    }\n    return false;\n  }", "javadoc_start_line": 195, "annotations_start_line": 199, "method_start_line": 200, "end_line": 229}]}], "project": {"name": "Closure", "version": 15}}