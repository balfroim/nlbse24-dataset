{"tours": [{"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testObjectCycle", "content": "    public void testObjectCycle() {\n        ObjectCycle a = new ObjectCycle();\n        ObjectCycle b = new ObjectCycle();\n        a.obj = b;\n        b.obj = a;\n\n        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n        assertEquals(expected, a.toString());\n        validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 829, "annotations_start_line": 829, "method_start_line": 829, "end_line": 838}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(Object obj) {\n        style.append(buffer, null, obj, null);\n        return this;\n    }", "javadoc_start_line": 466, "annotations_start_line": 473, "method_start_line": 473, "end_line": 476}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(Object obj) {\n        style.append(buffer, null, obj, null);\n        return this;\n    }", "javadoc_start_line": 466, "annotations_start_line": 473, "method_start_line": 473, "end_line": 476}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testObjectCycle", "content": "    public void testObjectCycle() {\n        ObjectCycle a = new ObjectCycle();\n        ObjectCycle b = new ObjectCycle();\n        a.obj = b;\n        b.obj = a;\n\n        String expected = toBaseString(a) + \"[\" + toBaseString(b) + \"[\" + toBaseString(a) + \"]]\";\n        assertEquals(expected, a.toString());\n        validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 829, "annotations_start_line": 829, "method_start_line": 829, "end_line": 838}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionHierarchy", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionHierarchy", "content": "    public void testReflectionHierarchy() {\n        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n        String baseStr = this.toBaseString(baseA);\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false));\n        assertEquals(baseStr + \"[a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseA, null, true));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n\n        ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n        baseStr = this.toBaseString(baseB);\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false));\n        assertEquals(baseStr + \"[b=b,transientB=t,a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseB, null, true));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, null));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n        assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 313, "annotations_start_line": 313, "method_start_line": 313, "end_line": 336}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @param style  the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients  whether to include transient fields\n     * @param reflectUpToClass  the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object,ToStringStyle,boolean,boolean,Class)\n     * @since 2.0\n     */\n    public static <T> String reflectionToString(\n        T object,\n        ToStringStyle style,\n        boolean outputTransients,\n        Class<? super T> reflectUpToClass) {\n        return ReflectionToStringBuilder.toString(object, style, outputTransients, false, reflectUpToClass);\n    }", "javadoc_start_line": 185, "annotations_start_line": 197, "method_start_line": 201, "end_line": 203}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param fieldName  the field name\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(String fieldName, Object obj) {\n        style.append(buffer, fieldName, obj, null);\n        return this;\n    }", "javadoc_start_line": 841, "annotations_start_line": 849, "method_start_line": 849, "end_line": 852}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionHierarchy", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionHierarchy", "content": "    public void testReflectionHierarchy() {\n        ReflectionTestFixtureA baseA = new ReflectionTestFixtureA();\n        String baseStr = this.toBaseString(baseA);\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false));\n        assertEquals(baseStr + \"[a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseA, null, true));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, null));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, Object.class));\n        assertEquals(baseStr + \"[a=a]\", ToStringBuilder.reflectionToString(baseA, null, false, ReflectionTestFixtureA.class));\n\n        ReflectionTestFixtureB baseB = new ReflectionTestFixtureB();\n        baseStr = this.toBaseString(baseB);\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false));\n        assertEquals(baseStr + \"[b=b,transientB=t,a=a,transientA=t]\", ToStringBuilder.reflectionToString(baseB, null, true));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, null));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, Object.class));\n        assertEquals(baseStr + \"[b=b,a=a]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureA.class));\n        assertEquals(baseStr + \"[b=b]\", ToStringBuilder.reflectionToString(baseB, null, false, ReflectionTestFixtureB.class));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 313, "annotations_start_line": 313, "method_start_line": 313, "end_line": 336}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testSelfInstanceTwoVarsReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testSelfInstanceTwoVarsReflectionObjectCycle", "content": "    /**\n     * Test a class that defines an ivar pointing to itself.  This test was\n     * created to show that handling cyclical object resulted in a missing endFieldSeparator call.\n     *\n     * @throws Exception\n     */\n    public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n        SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 524, "annotations_start_line": 530, "method_start_line": 530, "end_line": 534}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param fieldName  the field name\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(String fieldName, Object obj) {\n        style.append(buffer, fieldName, obj, null);\n        return this;\n    }", "javadoc_start_line": 841, "annotations_start_line": 849, "method_start_line": 849, "end_line": 852}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testSelfInstanceTwoVarsReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testSelfInstanceTwoVarsReflectionObjectCycle", "content": "    /**\n     * Test a class that defines an ivar pointing to itself.  This test was\n     * created to show that handling cyclical object resulted in a missing endFieldSeparator call.\n     *\n     * @throws Exception\n     */\n    public void testSelfInstanceTwoVarsReflectionObjectCycle() throws Exception {\n        SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture();\n        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \",otherType=\" + test.getOtherType().toString() + \"]\", test.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 524, "annotations_start_line": 530, "method_start_line": 530, "end_line": 534}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayCycle", "content": "    /**\n     * Test an array element pointing to its container.\n     */\n    public void testReflectionArrayCycle() throws Exception {\n        Object[] objects = new Object[1];\n        objects[0] = objects;\n        assertEquals(\n            this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n            ToStringBuilder.reflectionToString(objects));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 373, "annotations_start_line": 376, "method_start_line": 376, "end_line": 383}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayCycle", "content": "    /**\n     * Test an array element pointing to its container.\n     */\n    public void testReflectionArrayCycle() throws Exception {\n        Object[] objects = new Object[1];\n        objects[0] = objects;\n        assertEquals(\n            this.toBaseString(objects) + \"[{\" + this.toBaseString(objects) + \"}]\",\n            ToStringBuilder.reflectionToString(objects));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 373, "annotations_start_line": 376, "method_start_line": 376, "end_line": 383}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionLongArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionLongArrayArray", "content": "    public void testReflectionLongArrayArray() {\n        long[][] array = new long[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 237, "annotations_start_line": 237, "method_start_line": 237, "end_line": 244}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionLongArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionLongArrayArray", "content": "    public void testReflectionLongArrayArray() {\n        long[][] array = new long[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 237, "annotations_start_line": 237, "method_start_line": 237, "end_line": 244}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayArrayCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayArrayCycle", "content": "    public void testReflectionArrayArrayCycle() throws Exception {\n        Object[][] objects = new Object[2][2];\n        objects[0][0] = objects;\n        objects[0][1] = objects;\n        objects[1][0] = objects;\n        objects[1][1] = objects;\n        String basicToString = this.toBaseString(objects);\n        assertEquals(\n            basicToString\n                + \"[{{\"\n                + basicToString\n                + \",\"\n                + basicToString\n                + \"},{\"\n                + basicToString\n                + \",\"\n                + basicToString\n                + \"}}]\",\n            ToStringBuilder.reflectionToString(objects));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 402, "annotations_start_line": 402, "method_start_line": 402, "end_line": 422}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an\n     * <code>Object</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            Object item = array[i];\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 887, "annotations_start_line": 896, "method_start_line": 896, "end_line": 911}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayArrayCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayArrayCycle", "content": "    public void testReflectionArrayArrayCycle() throws Exception {\n        Object[][] objects = new Object[2][2];\n        objects[0][0] = objects;\n        objects[0][1] = objects;\n        objects[1][0] = objects;\n        objects[1][1] = objects;\n        String basicToString = this.toBaseString(objects);\n        assertEquals(\n            basicToString\n                + \"[{{\"\n                + basicToString\n                + \",\"\n                + basicToString\n                + \"},{\"\n                + basicToString\n                + \",\"\n                + basicToString\n                + \"}}]\",\n            ToStringBuilder.reflectionToString(objects));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 402, "annotations_start_line": 402, "method_start_line": 402, "end_line": 422}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionFloatArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionFloatArray", "content": "    public void testReflectionFloatArray() {\n        float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 207, "annotations_start_line": 207, "method_start_line": 207, "end_line": 214}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionFloatArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionFloatArray", "content": "    public void testReflectionFloatArray() {\n        float[] array = new float[] { 1.0f, 2.9876f, -3.00001f, 4.3f };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 207, "annotations_start_line": 207, "method_start_line": 207, "end_line": 214}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionDoubleArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionDoubleArrayArray", "content": "    public void testReflectionDoubleArrayArray() {\n        double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 282, "annotations_start_line": 282, "method_start_line": 282, "end_line": 289}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionDoubleArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionDoubleArrayArray", "content": "    public void testReflectionDoubleArrayArray() {\n        double[][] array = new double[][] { { 1.0, 2.29686 }, null, { Double.NaN } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 282, "annotations_start_line": 282, "method_start_line": 282, "end_line": 289}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionBooleanArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionBooleanArray", "content": "    public void testReflectionBooleanArray() {\n        boolean[] array = new boolean[] { true, false, false };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 216, "annotations_start_line": 216, "method_start_line": 216, "end_line": 223}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionBooleanArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionBooleanArray", "content": "    public void testReflectionBooleanArray() {\n        boolean[] array = new boolean[] { true, false, false };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{true,false,false}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 216, "annotations_start_line": 216, "method_start_line": 216, "end_line": 223}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionyteArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionyteArray", "content": "    public void testReflectionyteArray() {\n        byte[] array = new byte[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 180, "annotations_start_line": 180, "method_start_line": 180, "end_line": 187}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionyteArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionyteArray", "content": "    public void testReflectionyteArray() {\n        byte[] array = new byte[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 180, "annotations_start_line": 180, "method_start_line": 180, "end_line": 187}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionDoubleArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionDoubleArray", "content": "    public void testReflectionDoubleArray() {\n        double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 198, "annotations_start_line": 198, "method_start_line": 198, "end_line": 205}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionDoubleArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionDoubleArray", "content": "    public void testReflectionDoubleArray() {\n        double[] array = new double[] { 1.0, 2.9876, -3.00001, 4.3 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1.0,2.9876,-3.00001,4.3}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 198, "annotations_start_line": 198, "method_start_line": 198, "end_line": 205}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionIntArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionIntArrayArray", "content": "    public void testReflectionIntArrayArray() {\n        int[][] array = new int[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 246, "annotations_start_line": 246, "method_start_line": 246, "end_line": 253}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionIntArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionIntArrayArray", "content": "    public void testReflectionIntArrayArray() {\n        int[][] array = new int[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 246, "annotations_start_line": 246, "method_start_line": 246, "end_line": 253}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionLongArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionLongArray", "content": "    public void testReflectionLongArray() {\n        long[] array = new long[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 153, "annotations_start_line": 153, "method_start_line": 153, "end_line": 160}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionLongArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionLongArray", "content": "    public void testReflectionLongArray() {\n        long[] array = new long[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 153, "annotations_start_line": 153, "method_start_line": 153, "end_line": 160}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionhortArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionhortArrayArray", "content": "    public void testReflectionhortArrayArray() {\n        short[][] array = new short[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 255, "annotations_start_line": 255, "method_start_line": 255, "end_line": 262}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionhortArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionhortArrayArray", "content": "    public void testReflectionhortArrayArray() {\n        short[][] array = new short[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 255, "annotations_start_line": 255, "method_start_line": 255, "end_line": 262}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionObjectArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionObjectArray", "content": "    public void testReflectionObjectArray() {\n        Object[] array = new Object[] { null, base, new int[] { 3, 6 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 144, "annotations_start_line": 144, "method_start_line": 144, "end_line": 151}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionObjectArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionObjectArray", "content": "    public void testReflectionObjectArray() {\n        Object[] array = new Object[] { null, base, new int[] { 3, 6 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 144, "annotations_start_line": 144, "method_start_line": 144, "end_line": 151}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionObjectCycle", "content": "    /**\n     * Test Objects pointing to each other.\n     *\n     * @throws Exception\n     */\n    public void testReflectionObjectCycle() throws Exception {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        assertEquals(\n            this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n            a.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 537, "annotations_start_line": 542, "method_start_line": 542, "end_line": 551}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param fieldName  the field name\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(String fieldName, Object obj) {\n        style.append(buffer, fieldName, obj, null);\n        return this;\n    }", "javadoc_start_line": 841, "annotations_start_line": 849, "method_start_line": 849, "end_line": 852}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param fieldName  the field name\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(String fieldName, Object obj) {\n        style.append(buffer, fieldName, obj, null);\n        return this;\n    }", "javadoc_start_line": 841, "annotations_start_line": 849, "method_start_line": 849, "end_line": 852}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionObjectCycle", "content": "    /**\n     * Test Objects pointing to each other.\n     *\n     * @throws Exception\n     */\n    public void testReflectionObjectCycle() throws Exception {\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\n        a.b = b;\n        b.a = a;\n        assertEquals(\n            this.toBaseString(a) + \"[b=\" + this.toBaseString(b) + \"[a=\" + this.toBaseString(a) + \"]]\",\n            a.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 537, "annotations_start_line": 542, "method_start_line": 542, "end_line": 551}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionBooleanArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionBooleanArrayArray", "content": "    public void testReflectionBooleanArrayArray() {\n        boolean[][] array = new boolean[][] { { true, false }, null, { false } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 291, "annotations_start_line": 291, "method_start_line": 291, "end_line": 299}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionBooleanArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionBooleanArrayArray", "content": "    public void testReflectionBooleanArrayArray() {\n        boolean[][] array = new boolean[][] { { true, false }, null, { false } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n        assertEquals(baseStr + \"[{{true,false},<null>,{false}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 291, "annotations_start_line": 291, "method_start_line": 291, "end_line": 299}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testSimpleReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testSimpleReflectionObjectCycle", "content": "    /**\n     * Test an Object pointing to itself, the simplest test.\n     *\n     * @throws Exception\n     */\n    public void testSimpleReflectionObjectCycle() throws Exception {\n        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n        simple.o = simple;\n        assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 501, "annotations_start_line": 506, "method_start_line": 506, "end_line": 511}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param fieldName  the field name\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(String fieldName, Object obj) {\n        style.append(buffer, fieldName, obj, null);\n        return this;\n    }", "javadoc_start_line": 841, "annotations_start_line": 849, "method_start_line": 849, "end_line": 852}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testSimpleReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testSimpleReflectionObjectCycle", "content": "    /**\n     * Test an Object pointing to itself, the simplest test.\n     *\n     * @throws Exception\n     */\n    public void testSimpleReflectionObjectCycle() throws Exception {\n        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture();\n        simple.o = simple;\n        assertEquals(this.toBaseString(simple) + \"[o=\" + this.toBaseString(simple) + \"]\", simple.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 501, "annotations_start_line": 506, "method_start_line": 506, "end_line": 511}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionByteArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionByteArrayArray", "content": "    public void testReflectionByteArrayArray() {\n        byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 264, "annotations_start_line": 264, "method_start_line": 264, "end_line": 271}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionByteArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionByteArrayArray", "content": "    public void testReflectionByteArrayArray() {\n        byte[][] array = new byte[][] { { 1, 2 }, null, { 5 } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1,2},<null>,{5}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 264, "annotations_start_line": 264, "method_start_line": 264, "end_line": 271}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayCycleLevel2", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayCycleLevel2", "content": "    /**\n     * Test an array element pointing to its container.\n     */\n    public void testReflectionArrayCycleLevel2() throws Exception {\n        Object[] objects = new Object[1];\n        Object[] objectsLevel2 = new Object[1];\n        objects[0] = objectsLevel2;\n        objectsLevel2[0] = objects;\n        assertEquals(\n            this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\",\n            ToStringBuilder.reflectionToString(objects));\n        assertEquals(\n            this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n            ToStringBuilder.reflectionToString(objectsLevel2));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 385, "annotations_start_line": 388, "method_start_line": 388, "end_line": 400}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an\n     * <code>Object</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            Object item = array[i];\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 887, "annotations_start_line": 896, "method_start_line": 896, "end_line": 911}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayCycleLevel2", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayCycleLevel2", "content": "    /**\n     * Test an array element pointing to its container.\n     */\n    public void testReflectionArrayCycleLevel2() throws Exception {\n        Object[] objects = new Object[1];\n        Object[] objectsLevel2 = new Object[1];\n        objects[0] = objectsLevel2;\n        objectsLevel2[0] = objects;\n        assertEquals(\n            this.toBaseString(objects) + \"[{{\" + this.toBaseString(objects) + \"}}]\",\n            ToStringBuilder.reflectionToString(objects));\n        assertEquals(\n            this.toBaseString(objectsLevel2) + \"[{{\" + this.toBaseString(objectsLevel2) + \"}}]\",\n            ToStringBuilder.reflectionToString(objectsLevel2));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 385, "annotations_start_line": 388, "method_start_line": 388, "end_line": 400}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayAndObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayAndObjectCycle", "content": "    /**\n     * Test a nasty combination of arrays and Objects pointing to each other.\n     * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]\n     *\n     * @throws Exception\n     */\n    public void testReflectionArrayAndObjectCycle() throws Exception {\n        Object[] objects = new Object[1];\n        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n        objects[0] = simple;\n        assertEquals(\n            this.toBaseString(objects)\n                + \"[{\"\n                + this.toBaseString(simple)\n                + \"[o=\"\n                + this.toBaseString(objects)\n                + \"]\"\n                + \"}]\",\n            ToStringBuilder.reflectionToString(objects));\n        assertEquals(\n            this.toBaseString(simple)\n                + \"[o={\"\n                + this.toBaseString(simple)\n                + \"}]\",\n            ToStringBuilder.reflectionToString(simple));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 553, "annotations_start_line": 559, "method_start_line": 559, "end_line": 579}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param fieldName  the field name\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(String fieldName, Object obj) {\n        style.append(buffer, fieldName, obj, null);\n        return this;\n    }", "javadoc_start_line": 841, "annotations_start_line": 849, "method_start_line": 849, "end_line": 852}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an\n     * <code>Object</code> array.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     */\n    protected void appendDetail(StringBuffer buffer, String fieldName, Object[] array) {\n        buffer.append(arrayStart);\n        for (int i = 0; i < array.length; i++) {\n            Object item = array[i];\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 887, "annotations_start_line": 896, "method_start_line": 896, "end_line": 911}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionArrayAndObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionArrayAndObjectCycle", "content": "    /**\n     * Test a nasty combination of arrays and Objects pointing to each other.\n     * objects[0] -> SimpleReflectionTestFixture[ o -> objects ]\n     *\n     * @throws Exception\n     */\n    public void testReflectionArrayAndObjectCycle() throws Exception {\n        Object[] objects = new Object[1];\n        SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture(objects);\n        objects[0] = simple;\n        assertEquals(\n            this.toBaseString(objects)\n                + \"[{\"\n                + this.toBaseString(simple)\n                + \"[o=\"\n                + this.toBaseString(objects)\n                + \"]\"\n                + \"}]\",\n            ToStringBuilder.reflectionToString(objects));\n        assertEquals(\n            this.toBaseString(simple)\n                + \"[o={\"\n                + this.toBaseString(simple)\n                + \"}]\",\n            ToStringBuilder.reflectionToString(simple));\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 553, "annotations_start_line": 559, "method_start_line": 559, "end_line": 579}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionCharArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionCharArrayArray", "content": "    public void testReflectionCharArrayArray() {\n        char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 273, "annotations_start_line": 273, "method_start_line": 273, "end_line": 280}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionCharArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionCharArrayArray", "content": "    public void testReflectionCharArrayArray() {\n        char[][] array = new char[][] { { 'A', 'B' }, null, { 'p' } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{A,B},<null>,{p}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 273, "annotations_start_line": 273, "method_start_line": 273, "end_line": 280}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionShortArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionShortArray", "content": "    public void testReflectionShortArray() {\n        short[] array = new short[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 171, "annotations_start_line": 171, "method_start_line": 171, "end_line": 178}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionShortArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionShortArray", "content": "    public void testReflectionShortArray() {\n        short[] array = new short[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 171, "annotations_start_line": 171, "method_start_line": 171, "end_line": 178}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testSelfInstanceVarReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testSelfInstanceVarReflectionObjectCycle", "content": "    /**\n     * Test a class that defines an ivar pointing to itself.\n     *\n     * @throws Exception\n     */\n    public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n        SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 513, "annotations_start_line": 518, "method_start_line": 518, "end_line": 522}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value.</p>\n     *\n     * @param fieldName  the field name\n     * @param obj  the value to add to the <code>toString</code>\n     * @return this\n     */\n    public ToStringBuilder append(String fieldName, Object obj) {\n        style.append(buffer, fieldName, obj, null);\n        return this;\n    }", "javadoc_start_line": 841, "annotations_start_line": 849, "method_start_line": 849, "end_line": 852}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "append", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>\n     * value, printing the full <code>toString</code> of the\n     * <code>Object</code> passed in.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name\n     * @param value  the value to add to the <code>toString</code>\n     * @param fullDetail  <code>true</code> for detail, <code>false</code>\n     *  for summary info, <code>null</code> for style decides\n     */\n    public void append(StringBuffer buffer, String fieldName, Object value, Boolean fullDetail) {\n        appendFieldStart(buffer, fieldName);\n\n        if (value == null) {\n            appendNullText(buffer, fieldName);\n\n        } else {\n            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));\n        }\n\n        appendFieldEnd(buffer, fieldName);\n    }", "javadoc_start_line": 425, "annotations_start_line": 436, "method_start_line": 436, "end_line": 447}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testSelfInstanceVarReflectionObjectCycle", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testSelfInstanceVarReflectionObjectCycle", "content": "    /**\n     * Test a class that defines an ivar pointing to itself.\n     *\n     * @throws Exception\n     */\n    public void testSelfInstanceVarReflectionObjectCycle() throws Exception {\n        SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture();\n        assertEquals(this.toBaseString(test) + \"[typeIsSelf=\" + this.toBaseString(test) + \"]\", test.toString());\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 513, "annotations_start_line": 518, "method_start_line": 518, "end_line": 522}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionIntArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionIntArray", "content": "    public void testReflectionIntArray() {\n        int[] array = new int[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 162, "annotations_start_line": 162, "method_start_line": 162, "end_line": 169}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionIntArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionIntArray", "content": "    public void testReflectionIntArray() {\n        int[] array = new int[] { 1, 2, -3, 4 };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{1,2,-3,4}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 162, "annotations_start_line": 162, "method_start_line": 162, "end_line": 169}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionCharArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionCharArray", "content": "    public void testReflectionCharArray() {\n        char[] array = new char[] { 'A', '2', '_', 'D' };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 189, "annotations_start_line": 189, "method_start_line": 189, "end_line": 196}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionCharArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionCharArray", "content": "    public void testReflectionCharArray() {\n        char[] array = new char[] { 'A', '2', '_', 'D' };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{A,2,_,D}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 189, "annotations_start_line": 189, "method_start_line": 189, "end_line": 196}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionFloatArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionFloatArrayArray", "content": "    public void testReflectionFloatArrayArray() {\n        float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 227, "end_line": 234}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringBuilder.java", "method_name": "reflectionToString", "content": "    /**\n     * <p>Uses <code>ReflectionToStringBuilder</code> to generate a\n     * <code>toString</code> for the specified object.</p>\n     * \n     * @param object  the Object to be output\n     * @return the String result\n     * @see ReflectionToStringBuilder#toString(Object)\n     */\n    public static String reflectionToString(Object object) {\n        return ReflectionToStringBuilder.toString(object);\n    }", "javadoc_start_line": 146, "annotations_start_line": 154, "method_start_line": 154, "end_line": 156}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value using the default <code>ToStringStyle</code> through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * Transient members will be not be included, as they are likely derived. Static fields will not be included.\n     * Superclass fields will be appended.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     */\n    public static String toString(Object object) {\n        return toString(object, null, false, false, null);\n    }", "javadoc_start_line": 100, "annotations_start_line": 122, "method_start_line": 122, "end_line": 124}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Builds a <code>toString</code> value through reflection.\n     * </p>\n     * \n     * <p>\n     * It uses <code>AccessibleObject.setAccessible</code> to gain access to private fields. This means that it will\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\n     * also not as efficient as testing explicitly.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputTransients</code> is <code>true</code>, transient fields will be output, otherwise they\n     * are ignored, as they are likely derived fields, and not part of the value of the Object.\n     * </p>\n     * \n     * <p>\n     * If the <code>outputStatics</code> is <code>true</code>, static fields will be output, otherwise they are\n     * ignored.\n     * </p>\n     * \n     * <p>\n     * Superclass fields will be appended up to and including the specified superclass. A null superclass is treated as\n     * <code>java.lang.Object</code>.\n     * </p>\n     * \n     * <p>\n     * If the style is <code>null</code>, the default <code>ToStringStyle</code> is used.\n     * </p>\n     * \n     * @param object\n     *            the Object to be output\n     * @param style\n     *            the style of the <code>toString</code> to create, may be <code>null</code>\n     * @param outputTransients\n     *            whether to include transient fields\n     * @param outputStatics\n     *            whether to include static fields\n     * @param reflectUpToClass\n     *            the superclass to reflect up to (inclusive), may be <code>null</code>\n     * @return the String result\n     * @throws IllegalArgumentException\n     *             if the Object is <code>null</code>\n     * @since 2.1\n     */\n    public static <T> String toString(\n            T object, ToStringStyle style, boolean outputTransients,\n            boolean outputStatics, Class<? super T> reflectUpToClass) {\n        return new ReflectionToStringBuilder(object, style, null, reflectUpToClass, outputTransients, outputStatics)\n                .toString();\n    }", "javadoc_start_line": 242, "annotations_start_line": 287, "method_start_line": 289, "end_line": 292}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "toString", "content": "    /**\n     * <p>\n     * Gets the String built by this builder.\n     * </p>\n     * \n     * @return the built string\n     */\n    @Override\n    public String toString() {\n        if (this.getObject() == null) {\n            return this.getStyle().getNullText();\n        }\n        Class<?> clazz = this.getObject().getClass();\n        this.appendFieldsIn(clazz);\n        while (clazz.getSuperclass() != null && clazz != this.getUpToClass()) {\n            clazz = clazz.getSuperclass();\n            this.appendFieldsIn(clazz);\n        }\n        return super.toString();\n    }", "javadoc_start_line": 686, "annotations_start_line": 693, "method_start_line": 694, "end_line": 705}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "appendFieldsIn", "content": "    /**\n     * <p>\n     * Appends the fields and values defined by the given object of the given Class.\n     * </p>\n     * \n     * <p>\n     * If a cycle is detected as an object is &quot;toString()'ed&quot;, such an object is rendered as if\n     * <code>Object.toString()</code> had been called and not implemented by the object.\n     * </p>\n     * \n     * @param clazz\n     *            The class of object parameter\n     */\n    protected void appendFieldsIn(Class<?> clazz) {\n        if (clazz.isArray()) {\n            this.reflectionAppendArray(this.getObject());\n            return;\n        }\n        Field[] fields = clazz.getDeclaredFields();\n        AccessibleObject.setAccessible(fields, true);\n        for (Field field : fields) {\n            String fieldName = field.getName();\n            if (this.accept(field)) {\n                try {\n                    // Warning: Field.get(Object) creates wrappers objects\n                    // for primitive types.\n                    Object fieldValue = this.getValue(field);\n                    this.append(fieldName, fieldValue);\n                } catch (IllegalAccessException ex) {\n                    //this can't happen. Would get a Security exception\n                    // instead\n                    //throw a runtime exception in case the impossible\n                    // happens.\n                    throw new InternalError(\"Unexpected IllegalAccessException: \" + ex.getMessage());\n                }\n            }\n        }\n    }", "javadoc_start_line": 512, "annotations_start_line": 525, "method_start_line": 525, "end_line": 549}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ReflectionToStringBuilder.java", "method_name": "reflectionAppendArray", "content": "    /**\n     * <p>\n     * Append to the <code>toString</code> an <code>Object</code> array.\n     * </p>\n     * \n     * @param array\n     *            the array to add to the <code>toString</code>\n     * @return this\n     */\n    public ReflectionToStringBuilder reflectionAppendArray(Object array) {\n        this.getStyle().reflectionAppendArrayDetail(this.getStringBuffer(), null, array);\n        return this;\n    }", "javadoc_start_line": 612, "annotations_start_line": 621, "method_start_line": 621, "end_line": 624}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "reflectionAppendArrayDetail", "content": "    /**\n     * <p>Append to the <code>toString</code> the detail of an array type.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param array  the array to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @since 2.0\n     */\n    protected void reflectionAppendArrayDetail(StringBuffer buffer, String fieldName, Object array) {\n        buffer.append(arrayStart);\n        int length = Array.getLength(array);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(array, i);\n            if (i > 0) {\n                buffer.append(arraySeparator);\n            }\n            if (item == null) {\n                appendNullText(buffer, fieldName);\n\n            } else {\n                appendInternal(buffer, fieldName, item, arrayContentDetail);\n            }\n        }\n        buffer.append(arrayEnd);\n    }", "javadoc_start_line": 913, "annotations_start_line": 922, "method_start_line": 922, "end_line": 938}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "appendInternal", "content": "    /**\n     * <p>Append to the <code>toString</code> an <code>Object</code>,\n     * correctly interpreting its type.</p>\n     *\n     * <p>This method performs the main lookup by Class type to correctly\n     * route arrays, <code>Collections</code>, <code>Maps</code> and\n     * <code>Objects</code> to the appropriate method.</p>\n     *\n     * <p>Either detail or summary views can be specified.</p>\n     *\n     * <p>If a cycle is detected, an object will be appended with the\n     * <code>Object.toString()</code> format.</p>\n     *\n     * @param buffer  the <code>StringBuffer</code> to populate\n     * @param fieldName  the field name, typically not used as already appended\n     * @param value  the value to add to the <code>toString</code>,\n     *  not <code>null</code>\n     * @param detail  output detail or not\n     */\n    protected void appendInternal(StringBuffer buffer, String fieldName, Object value, boolean detail) {\n        if (isRegistered(value)\n            && !(value instanceof Number || value instanceof Boolean || value instanceof Character)) {\n           appendCyclicObject(buffer, fieldName, value);\n           return;\n        }\n\n        register(value);\n\n        try {\n            if (value instanceof Collection<?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Collection<?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Collection<?>) value).size());\n                }\n\n            } else if (value instanceof Map<?, ?>) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Map<?, ?>) value);\n                } else {\n                    appendSummarySize(buffer, fieldName, ((Map<?, ?>) value).size());\n                }\n\n            } else if (value instanceof long[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (long[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (long[]) value);\n                }\n\n            } else if (value instanceof int[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (int[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (int[]) value);\n                }\n\n            } else if (value instanceof short[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (short[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (short[]) value);\n                }\n\n            } else if (value instanceof byte[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (byte[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (byte[]) value);\n                }\n\n            } else if (value instanceof char[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (char[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (char[]) value);\n                }\n\n            } else if (value instanceof double[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (double[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (double[]) value);\n                }\n\n            } else if (value instanceof float[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (float[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (float[]) value);\n                }\n\n            } else if (value instanceof boolean[]) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (boolean[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (boolean[]) value);\n                }\n\n            } else if (value.getClass().isArray()) {\n                if (detail) {\n                    appendDetail(buffer, fieldName, (Object[]) value);\n                } else {\n                    appendSummary(buffer, fieldName, (Object[]) value);\n                }\n\n            } else {\n                    if (detail) {\n                        appendDetail(buffer, fieldName, value);\n                    } else {\n                        appendSummary(buffer, fieldName, value);\n                    }\n            }\n        } finally {\n            unregister(value);\n        }\n    }", "javadoc_start_line": 449, "annotations_start_line": 468, "method_start_line": 468, "end_line": 565}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "isRegistered", "content": "    /**\n     * <p>\n     * Returns <code>true</code> if the registry contains the given object.\n     * Used by the reflection methods to avoid infinite loops.\n     * </p>\n     *\n     * @param value\n     *                  The object to lookup in the registry.\n     * @return boolean <code>true</code> if the registry contains the given\n     *             object.\n     */\n    static boolean isRegistered(Object value) {\n        Map<Object, Object> m = getRegistry();\n        return m.containsKey(value);\n    }", "javadoc_start_line": 151, "annotations_start_line": 162, "method_start_line": 162, "end_line": 165}]}, {"failing_test": {"className": " org.apache.commons.lang3.builder.ToStringBuilderTest", "methodName": "testReflectionFloatArrayArray", "error": "junit.framework.AssertionFailedError", "message": "Expected: <null> but was: {}"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "testReflectionFloatArrayArray", "content": "    public void testReflectionFloatArrayArray() {\n        float[][] array = new float[][] { { 1.0f, 2.29686f }, null, { Float.NaN } };\n        String baseStr = this.toBaseString(array);\n        assertEquals(baseStr + \"[{{1.0,2.29686},<null>,{NaN}}]\", ToStringBuilder.reflectionToString(array));\n        array = null;\n        assertReflectionArray(\"<null>\", array);\n        this.validateNullToStringStyleRegistry();\n    }", "javadoc_start_line": 227, "annotations_start_line": 227, "method_start_line": 227, "end_line": 234}, {"file_path": "/src/test/java/org/apache/commons/lang3/builder/ToStringBuilderTest.java", "method_name": "validateNullToStringStyleRegistry", "content": "    void validateNullToStringStyleRegistry() {\n       if (ToStringStyle.getRegistry() != null) {\n           System.out.println(ToStringStyle.getRegistry());\n       }\n\n        assertNull(ToStringStyle.getRegistry());\n    }", "javadoc_start_line": 581, "annotations_start_line": 581, "method_start_line": 581, "end_line": 587}, {"file_path": "/src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java", "method_name": "getRegistry", "content": "    /**\n     * <p>\n     * Returns the registry of objects being traversed by the <code>reflectionToString</code>\n     * methods in the current thread.\n     * </p>\n     *\n     * @return Set the registry of objects being traversed\n     */\n    static Map<Object, Object> getRegistry() {\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\n    }", "javadoc_start_line": 139, "annotations_start_line": 147, "method_start_line": 147, "end_line": 149}]}], "project": {"name": "Lang", "version": 34}}