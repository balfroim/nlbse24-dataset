{"tours": [{"failing_test": {"className": " org.apache.commons.lang3.time.FastDateFormat_ParserTest", "methodName": "testLANG_832", "error": "junit.framework.AssertionFailedError", "message": "Parsed dates should be equal expected:<null> but was:<Fri Jan 02 21:00:00 PST 1970>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "init", "content": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }", "javadoc_start_line": 111, "annotations_start_line": 115, "method_start_line": 115, "end_line": 150}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testLANG_832", "content": "    public void testLANG_832() throws Exception {\n        testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n        testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n    }", "javadoc_start_line": 346, "annotations_start_line": 345, "method_start_line": 346, "end_line": 349}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testSdfAndFdp", "content": "    private void testSdfAndFdp(String format, String date, boolean shouldFail)\n            throws Exception {\n        Date dfdp = null;\n        Date dsdf = null;\n        Throwable f = null;\n        Throwable s = null;\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);\n            sdf.setTimeZone(NEW_YORK);\n            dsdf = sdf.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected SDF failure, but got \" + dsdf + \" for [\"+format+\",\"+date+\"]\");\n            }\n        } catch (Exception e) {\n            s = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"sdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n\n        try {\n            DateParser fdp = getInstance(format, NEW_YORK, Locale.US);\n            dfdp = fdp.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected FDF failure, but got \" + dfdp + \" for [\"+format+\",\"+date+\"] using \"+((FastDateParser)fdp).getParsePattern());\n            }\n        } catch (Exception e) {\n            f = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"fdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n        // SDF and FDF should produce equivalent results\n        assertTrue(\"Should both or neither throw Exceptions\", (f==null)==(s==null));\n        assertEquals(\"Parsed dates should be equal\", dsdf, dfdp);\n    }", "javadoc_start_line": 356, "annotations_start_line": 356, "method_start_line": 357, "end_line": 394}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "getInstance", "content": "    /**\n     * Override this method in derived tests to change the construction of instances\n     */\n    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n        return new FastDateParser(format, timeZone, locale);\n    }", "javadoc_start_line": 77, "annotations_start_line": 80, "method_start_line": 80, "end_line": 82}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "FastDateParser", "content": "    /**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */\n    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }", "javadoc_start_line": 96, "annotations_start_line": 104, "method_start_line": 104, "end_line": 109}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "init", "content": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }", "javadoc_start_line": 111, "annotations_start_line": 115, "method_start_line": 115, "end_line": 150}]}, {"failing_test": {"className": " org.apache.commons.lang3.time.FastDateParserTest", "methodName": "testLANG_832", "error": "junit.framework.AssertionFailedError", "message": "Expected FDF failure, but got Fri Jan 02 21:00:00 PST 1970 for ['d'd',d3] using d(\\p{IsNd}++)"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "init", "content": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }", "javadoc_start_line": 111, "annotations_start_line": 115, "method_start_line": 115, "end_line": 150}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testLANG_832", "content": "    public void testLANG_832() throws Exception {\n        testSdfAndFdp(\"'d'd\" ,\"d3\", false); // OK\n        testSdfAndFdp(\"'d'd'\",\"d3\", true); // should fail (unterminated quote)\n    }", "javadoc_start_line": 346, "annotations_start_line": 345, "method_start_line": 346, "end_line": 349}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "testSdfAndFdp", "content": "    private void testSdfAndFdp(String format, String date, boolean shouldFail)\n            throws Exception {\n        Date dfdp = null;\n        Date dsdf = null;\n        Throwable f = null;\n        Throwable s = null;\n\n        try {\n            SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);\n            sdf.setTimeZone(NEW_YORK);\n            dsdf = sdf.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected SDF failure, but got \" + dsdf + \" for [\"+format+\",\"+date+\"]\");\n            }\n        } catch (Exception e) {\n            s = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"sdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n\n        try {\n            DateParser fdp = getInstance(format, NEW_YORK, Locale.US);\n            dfdp = fdp.parse(date);\n            if (shouldFail) {\n                Assert.fail(\"Expected FDF failure, but got \" + dfdp + \" for [\"+format+\",\"+date+\"] using \"+((FastDateParser)fdp).getParsePattern());\n            }\n        } catch (Exception e) {\n            f = e;\n            if (!shouldFail) {\n                throw e;\n            }\n//            System.out.println(\"fdf:\"+format+\"/\"+date+\"=>\"+e);\n        }\n        // SDF and FDF should produce equivalent results\n        assertTrue(\"Should both or neither throw Exceptions\", (f==null)==(s==null));\n        assertEquals(\"Parsed dates should be equal\", dsdf, dfdp);\n    }", "javadoc_start_line": 356, "annotations_start_line": 356, "method_start_line": 357, "end_line": 394}, {"file_path": "/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java", "method_name": "getInstance", "content": "    /**\n     * Override this method in derived tests to change the construction of instances\n     */\n    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\n        return new FastDateParser(format, timeZone, locale);\n    }", "javadoc_start_line": 77, "annotations_start_line": 80, "method_start_line": 80, "end_line": 82}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "FastDateParser", "content": "    /**\n     * <p>Constructs a new FastDateParser.</p>\n     *\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\n     *  pattern\n     * @param timeZone non-null time zone to use\n     * @param locale non-null locale\n     */\n    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }", "javadoc_start_line": 96, "annotations_start_line": 104, "method_start_line": 104, "end_line": 109}, {"file_path": "/src/main/java/org/apache/commons/lang3/time/FastDateParser.java", "method_name": "init", "content": "    /**\n     * Initialize derived fields from defining fields.\n     * This is called from constructor and from readObject (de-serialization)\n     */\n    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }", "javadoc_start_line": 111, "annotations_start_line": 115, "method_start_line": 115, "end_line": 150}]}], "project": {"name": "Lang", "version": 9}}