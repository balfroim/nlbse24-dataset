{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.PeepholeFoldConstantsTest", "methodName": "testFoldGetElem", "error": "junit.framework.AssertionFailedError", "message": "Unexpected error(s): JSC_INDEX_OUT_OF_BOUNDS_ERROR. Array index out of bounds: NUMBER 0.0 1 [source_file: testcode] at testcode line 1 : 10 expected:<0> but was:<1>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/PeepholeFoldConstants.java", "method_name": "tryFoldArrayAccess", "content": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n\n    if (!right.isNumber()) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node current = left.getFirstChild();\n    Node elem = null;\n    for (int i = 0; current != null && i < intIndex; i++) {\n        elem = current;\n\n      current = current.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.isEmpty()) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }", "javadoc_start_line": 1422, "annotations_start_line": 1422, "method_start_line": 1422, "end_line": 1472}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }", "javadoc_start_line": 104, "annotations_start_line": 103, "method_start_line": 104, "end_line": 111}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "visit", "content": "  public void visit(Node n) {\n    Node currentVersionOfNode = n;\n    boolean somethingChanged = false;\n\n    do {\n      somethingChanged = false;\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n        Node newVersionOfNode =\n            optimization.optimizeSubtree(currentVersionOfNode);\n\n        if (newVersionOfNode != currentVersionOfNode) {\n          somethingChanged = true;\n\n          currentVersionOfNode = newVersionOfNode;\n        }\n\n        if (currentVersionOfNode == null) {\n          return;\n        }\n      }\n    } while(somethingChanged);\n  }", "javadoc_start_line": 170, "annotations_start_line": 170, "method_start_line": 170, "end_line": 191}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeFoldConstants.java", "method_name": "optimizeSubtree", "content": "  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.NEW:\n        return tryFoldCtorCall(subtree);\n\n      case Token.TYPEOF:\n        return tryFoldTypeof(subtree);\n\n      case Token.NOT:\n      case Token.POS:\n      case Token.NEG:\n      case Token.BITNOT:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldUnaryOperator(subtree);\n\n      case Token.VOID:\n        return tryReduceVoid(subtree);\n\n      default:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldBinaryOperator(subtree);\n    }\n  }", "javadoc_start_line": 75, "annotations_start_line": 74, "method_start_line": 75, "end_line": 97}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeFoldConstants.java", "method_name": "tryFoldBinaryOperator", "content": "  private Node tryFoldBinaryOperator(Node subtree) {\n    Node left = subtree.getFirstChild();\n\n    if (left == null) {\n      return subtree;\n    }\n\n    Node right = left.getNext();\n\n    if (right == null) {\n      return subtree;\n    }\n\n    // If we've reached here, node is truly a binary operator.\n    switch(subtree.getType()) {\n      case Token.GETPROP:\n        return tryFoldGetProp(subtree, left, right);\n\n      case Token.GETELEM:\n        return tryFoldGetElem(subtree, left, right);\n\n      case Token.INSTANCEOF:\n        return tryFoldInstanceof(subtree, left, right);\n\n      case Token.AND:\n      case Token.OR:\n        return tryFoldAndOr(subtree, left, right);\n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        return tryFoldShift(subtree, left, right);\n\n      case Token.ASSIGN:\n        return tryFoldAssign(subtree, left, right);\n\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return tryUnfoldAssignOp(subtree, left, right);\n\n      case Token.ADD:\n        return tryFoldAdd(subtree, left, right);\n\n      case Token.SUB:\n      case Token.DIV:\n      case Token.MOD:\n        return tryFoldArithmeticOp(subtree, left, right);\n\n      case Token.MUL:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n        Node result = tryFoldArithmeticOp(subtree, left, right);\n        if (result != subtree) {\n          return result;\n        }\n        return tryFoldLeftChildOp(subtree, left, right);\n\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return tryFoldComparison(subtree, left, right);\n\n      default:\n        return subtree;\n    }\n  }", "javadoc_start_line": 99, "annotations_start_line": 99, "method_start_line": 99, "end_line": 179}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeFoldConstants.java", "method_name": "tryFoldGetElem", "content": "  /**\n   * Try to fold array-element. e.g [1, 2, 3][10];\n   */\n  private Node tryFoldGetElem(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.isGetElem());\n\n    if (left.isObjectLit()) {\n      return tryFoldObjectPropAccess(n, left, right);\n    }\n\n    if (left.isArrayLit()) {\n      return tryFoldArrayAccess(n, left, right);\n    }\n    return n;\n  }", "javadoc_start_line": 1353, "annotations_start_line": 1356, "method_start_line": 1356, "end_line": 1367}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeFoldConstants.java", "method_name": "tryFoldArrayAccess", "content": "  private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n    Node parent = n.getParent();\n    // If GETPROP/GETELEM is used as assignment target the array literal is\n    // acting as a temporary we can't fold it here:\n    //    \"[][0] += 1\"\n    if (isAssignmentTarget(n)) {\n      return n;\n    }\n\n    if (!right.isNumber()) {\n      // Sometimes people like to use complex expressions to index into\n      // arrays, or strings to index into array methods.\n      return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index) {\n      error(INVALID_GETELEM_INDEX_ERROR, right);\n      return n;\n    }\n\n    if (intIndex < 0) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    Node current = left.getFirstChild();\n    Node elem = null;\n    for (int i = 0; current != null && i < intIndex; i++) {\n        elem = current;\n\n      current = current.getNext();\n    }\n\n    if (elem == null) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n      return n;\n    }\n\n    if (elem.isEmpty()) {\n      elem = NodeUtil.newUndefinedNode(elem);\n    } else {\n      left.removeChild(elem);\n    }\n\n    // Replace the entire GETELEM with the value\n    n.getParent().replaceChild(n, elem);\n    reportCodeChange();\n    return elem;\n  }", "javadoc_start_line": 1422, "annotations_start_line": 1422, "method_start_line": 1422, "end_line": 1472}]}], "project": {"name": "Closure", "version": 23}}