{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.InlineVariablesTest", "methodName": "testExternalIssue1053", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "isAssignedOnceInLifetime", "content": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n      for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }\n\n      return true;\n    }", "javadoc_start_line": 417, "annotations_start_line": 421, "method_start_line": 421, "end_line": 438}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n    callback.process(externs, root);\n  }", "javadoc_start_line": 83, "annotations_start_line": 82, "method_start_line": 83, "end_line": 87}, {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "process", "content": "  /**\n   * Convenience method for running this pass over a tree with this\n   * class as a callback.\n   */\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n  }", "javadoc_start_line": 104, "annotations_start_line": 108, "method_start_line": 109, "end_line": 112}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  /**\n   * Traverses a list of node trees.\n   */\n  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }", "javadoc_start_line": 497, "annotations_start_line": 500, "method_start_line": 501, "end_line": 504}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 298, "annotations_start_line": 298, "method_start_line": 298, "end_line": 321}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "popScope", "content": "  /** Pops back to the previous scope (e.g. when leaving a function). */\n  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n    if (hasScope()) {\n      compiler.setScope(getScopeRoot());\n    }\n  }", "javadoc_start_line": 615, "annotations_start_line": 616, "method_start_line": 616, "end_line": 629}, {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "exitScope", "content": "  /**\n   * Updates block stack and invokes any additional behavior.\n   */\n  @Override\n  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    if (t.getScope().isGlobal()) {\n      // Update global scope reference lists when we are done with it.\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n    } else {\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n    }\n  }", "javadoc_start_line": 176, "annotations_start_line": 179, "method_start_line": 180, "end_line": 189}]}], "project": {"name": "Closure", "version": 120}}