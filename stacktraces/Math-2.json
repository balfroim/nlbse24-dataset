{"tours": [{"failing_test": {"className": " org.apache.commons.math3.distribution.HypergeometricDistributionTest", "methodName": "testMath1021", "error": "junit.framework.AssertionFailedError", "message": "sample=-50"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java", "method_name": "getNumericalMean", "content": "    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }", "javadoc_start_line": 261, "annotations_start_line": 267, "method_start_line": 267, "end_line": 269}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/distribution/HypergeometricDistributionTest.java", "method_name": "testMath1021", "content": "    public void testMath1021() {\n        final int N = 43130568;\n        final int m = 42976365;\n        final int n = 50;\n        final HypergeometricDistribution dist = new HypergeometricDistribution(N, m, n);\n\n        for (int i = 0; i < 100; i++) {\n            final int sample = dist.sample();\n            Assert.assertTrue(\"sample=\" + sample, 0 <= sample);\n            Assert.assertTrue(\"sample=\" + sample, sample <= n);\n        }\n    }", "javadoc_start_line": 289, "annotations_start_line": 288, "method_start_line": 289, "end_line": 300}, {"file_path": "/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java", "method_name": "sample", "content": "    /**\n     * {@inheritDoc}\n     *\n     * The default implementation uses the\n     * <a href=\"http://en.wikipedia.org/wiki/Inverse_transform_sampling\">\n     * inversion method</a>.\n     */\n    public int sample() {\n        return inverseCumulativeProbability(random.nextDouble());\n    }", "javadoc_start_line": 185, "annotations_start_line": 192, "method_start_line": 192, "end_line": 194}, {"file_path": "/src/main/java/org/apache/commons/math3/distribution/AbstractIntegerDistribution.java", "method_name": "inverseCumulativeProbability", "content": "    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns\n     * <ul>\n     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>\n     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>\n     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for\n     *     {@code 0 < p < 1}.</li>\n     * </ul>\n     */\n    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {\n        if (p < 0.0 || p > 1.0) {\n            throw new OutOfRangeException(p, 0, 1);\n        }\n\n        int lower = getSupportLowerBound();\n        if (p == 0.0) {\n            return lower;\n        }\n        if (lower == Integer.MIN_VALUE) {\n            if (checkedCumulativeProbability(lower) >= p) {\n                return lower;\n            }\n        } else {\n            lower -= 1; // this ensures cumulativeProbability(lower) < p, which\n                        // is important for the solving step\n        }\n\n        int upper = getSupportUpperBound();\n        if (p == 1.0) {\n            return upper;\n        }\n\n        // use the one-sided Chebyshev inequality to narrow the bracket\n        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)\n        final double mu = getNumericalMean();\n        final double sigma = FastMath.sqrt(getNumericalVariance());\n        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\n                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);\n        if (chebyshevApplies) {\n            double k = FastMath.sqrt((1.0 - p) / p);\n            double tmp = mu - k * sigma;\n            if (tmp > lower) {\n                lower = ((int) Math.ceil(tmp)) - 1;\n            }\n            k = 1.0 / k;\n            tmp = mu + k * sigma;\n            if (tmp < upper) {\n                upper = ((int) Math.ceil(tmp)) - 1;\n            }\n        }\n\n        return solveInverseCumulativeProbability(p, lower, upper);\n    }", "javadoc_start_line": 89, "annotations_start_line": 100, "method_start_line": 100, "end_line": 143}, {"file_path": "/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java", "method_name": "getNumericalMean", "content": "    /**\n     * {@inheritDoc}\n     *\n     * For population size {@code N}, number of successes {@code m}, and sample\n     * size {@code n}, the mean is {@code n * m / N}.\n     */\n    public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }", "javadoc_start_line": 261, "annotations_start_line": 267, "method_start_line": 267, "end_line": 269}]}], "project": {"name": "Math", "version": 2}}