{"tours": [{"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testQuinticMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0.2719561270319131> but was:<-0.2719561299044896>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testQuinticMin", "content": "    public void testQuinticMin() throws MathException {\n        // The function has local minima at -0.27195613 and 0.82221643.\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n\n        // search in a large interval\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n    }", "javadoc_start_line": 72, "annotations_start_line": 71, "method_start_line": 72, "end_line": 83}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testQuinticMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0.2719561270319131> but was:<-0.2719561299044896>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testQuinticMin", "content": "    public void testQuinticMin() throws MathException {\n        // The function has local minima at -0.27195613 and 0.82221643.\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n\n        // search in a large interval\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n    }", "javadoc_start_line": 72, "annotations_start_line": 71, "method_start_line": 72, "end_line": 83}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testQuinticMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0.2719561270319131> but was:<-0.2719561299044896>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "doOptimize", "content": "    /**\n     * Perform the optimization.\n     *\n     * @return the optimum.\n     */\n    protected double doOptimize()\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }", "javadoc_start_line": 50, "annotations_start_line": 55, "method_start_line": 56, "end_line": 58}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testQuinticMin-doOptimize.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testQuinticMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0.2719561270319131> but was:<-0.2719561299044896>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "BrentOptimizer", "content": "    /**\n     * Construct a solver.\n     */\n    public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n        setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n    }", "javadoc_start_line": 40, "annotations_start_line": 43, "method_start_line": 43, "end_line": 48}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testQuinticMin-BrentOptimizer.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testQuinticMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0.2719561270319131> but was:<-0.2719561299044896>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testQuinticMin", "content": "    public void testQuinticMin() throws MathException {\n        // The function has local minima at -0.27195613 and 0.82221643.\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n\n        // search in a large interval\n        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n        assertTrue(minimizer.getIterationCount() <= 50);\n    }", "javadoc_start_line": 72, "annotations_start_line": 71, "method_start_line": 72, "end_line": 83}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testSinMin", "content": "    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setMaxEvaluations(200);\n        assertEquals(200, minimizer.getMaxEvaluations());\n        try {\n            minimizer.getResult();\n            fail(\"an exception should have been thrown\");\n        } catch (NoDataException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertTrue(minimizer.getEvaluations()    <= 100);\n        assertTrue(minimizer.getEvaluations()    >=  15);\n        minimizer.setMaxEvaluations(10);\n        try {\n            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n            fail(\"an exception should have been thrown\");\n        } catch (FunctionEvaluationException fee) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n    }", "javadoc_start_line": 41, "annotations_start_line": 40, "method_start_line": 41, "end_line": 69}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testSinMin", "content": "    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setMaxEvaluations(200);\n        assertEquals(200, minimizer.getMaxEvaluations());\n        try {\n            minimizer.getResult();\n            fail(\"an exception should have been thrown\");\n        } catch (NoDataException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertTrue(minimizer.getEvaluations()    <= 100);\n        assertTrue(minimizer.getEvaluations()    >=  15);\n        minimizer.setMaxEvaluations(10);\n        try {\n            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n            fail(\"an exception should have been thrown\");\n        } catch (FunctionEvaluationException fee) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n    }", "javadoc_start_line": 41, "annotations_start_line": 40, "method_start_line": 41, "end_line": 69}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "doOptimize", "content": "    /**\n     * Perform the optimization.\n     *\n     * @return the optimum.\n     */\n    protected double doOptimize()\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }", "javadoc_start_line": 50, "annotations_start_line": 55, "method_start_line": 56, "end_line": 58}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testSinMin-doOptimize.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "BrentOptimizer", "content": "    /**\n     * Construct a solver.\n     */\n    public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n        setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n    }", "javadoc_start_line": 40, "annotations_start_line": 43, "method_start_line": 43, "end_line": 48}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testSinMin-BrentOptimizer.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testSinMin", "content": "    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setMaxEvaluations(200);\n        assertEquals(200, minimizer.getMaxEvaluations());\n        try {\n            minimizer.getResult();\n            fail(\"an exception should have been thrown\");\n        } catch (NoDataException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertTrue(minimizer.getEvaluations()    <= 100);\n        assertTrue(minimizer.getEvaluations()    >=  15);\n        minimizer.setMaxEvaluations(10);\n        try {\n            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n            fail(\"an exception should have been thrown\");\n        } catch (FunctionEvaluationException fee) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n    }", "javadoc_start_line": 41, "annotations_start_line": 40, "method_start_line": 41, "end_line": 69}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testQuinticMinStatistics", "error": "junit.framework.AssertionFailedError", "message": "expected:<1880.5> but was:<18.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testQuinticMinStatistics-optimize.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testQuinticMinStatistics", "error": "junit.framework.AssertionFailedError", "message": "expected:<1880.5> but was:<18.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testQuinticMinStatistics", "content": "    public void testQuinticMinStatistics() throws MathException {\n        // The function has local minima at -0.27195613 and 0.82221643.\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setRelativeAccuracy(1e-10);\n        minimizer.setAbsoluteAccuracy(1e-11);\n\n        final DescriptiveStatistics[] stat = new DescriptiveStatistics[3];\n        for (int i = 0; i < stat.length; i++) {\n            stat[i] = new DescriptiveStatistics();\n        }\n\n        final double min = -0.75;\n        final double max = 0.25;\n        final int nSamples = 200;\n        final double delta = (max - min) / nSamples;\n        for (int i = 0; i < nSamples; i++) {\n            final double start = min + i * delta;\n            stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start));\n            stat[1].addValue(minimizer.getIterationCount());\n            stat[2].addValue(minimizer.getEvaluations());\n        }\n\n        final double meanOptValue = stat[0].getMean();\n        final double medianIter = stat[1].getPercentile(50);\n        final double medianEval = stat[2].getPercentile(50);\n        assertTrue(meanOptValue > -0.27195612812 && meanOptValue < -0.27195612811);\n        assertEquals(medianIter, 17, Math.ulp(1d));\n        assertEquals(medianEval, 18, Math.ulp(1d));\n    }", "javadoc_start_line": 86, "annotations_start_line": 85, "method_start_line": 86, "end_line": 115}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testQuinticMinStatistics", "error": "junit.framework.AssertionFailedError", "message": "expected:<1880.5> but was:<18.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "doOptimize", "content": "    /**\n     * Perform the optimization.\n     *\n     * @return the optimum.\n     */\n    protected double doOptimize()\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }", "javadoc_start_line": 50, "annotations_start_line": 55, "method_start_line": 56, "end_line": 58}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testQuinticMinStatistics-doOptimize.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testQuinticMinStatistics", "error": "junit.framework.AssertionFailedError", "message": "expected:<1880.5> but was:<18.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "BrentOptimizer", "content": "    /**\n     * Construct a solver.\n     */\n    public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n        setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n    }", "javadoc_start_line": 40, "annotations_start_line": 43, "method_start_line": 43, "end_line": 48}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testQuinticMinStatistics-BrentOptimizer.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testQuinticMinStatistics", "error": "junit.framework.AssertionFailedError", "message": "expected:<1880.5> but was:<18.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testQuinticMinStatistics", "content": "    public void testQuinticMinStatistics() throws MathException {\n        // The function has local minima at -0.27195613 and 0.82221643.\n        UnivariateRealFunction f = new QuinticFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setRelativeAccuracy(1e-10);\n        minimizer.setAbsoluteAccuracy(1e-11);\n\n        final DescriptiveStatistics[] stat = new DescriptiveStatistics[3];\n        for (int i = 0; i < stat.length; i++) {\n            stat[i] = new DescriptiveStatistics();\n        }\n\n        final double min = -0.75;\n        final double max = 0.25;\n        final int nSamples = 200;\n        final double delta = (max - min) / nSamples;\n        for (int i = 0; i < nSamples; i++) {\n            final double start = min + i * delta;\n            stat[0].addValue(minimizer.optimize(f, GoalType.MINIMIZE, min, max, start));\n            stat[1].addValue(minimizer.getIterationCount());\n            stat[2].addValue(minimizer.getEvaluations());\n        }\n\n        final double meanOptValue = stat[0].getMean();\n        final double medianIter = stat[1].getPercentile(50);\n        final double medianEval = stat[2].getPercentile(50);\n        assertTrue(meanOptValue > -0.27195612812 && meanOptValue < -0.27195612811);\n        assertEquals(medianIter, 17, Math.ulp(1d));\n        assertEquals(medianEval, 18, Math.ulp(1d));\n    }", "javadoc_start_line": 86, "annotations_start_line": 85, "method_start_line": 86, "end_line": 115}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<4.71238898038469> but was:<4.71238897901431>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testSinMin", "content": "    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setMaxEvaluations(200);\n        assertEquals(200, minimizer.getMaxEvaluations());\n        try {\n            minimizer.getResult();\n            fail(\"an exception should have been thrown\");\n        } catch (NoDataException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertTrue(minimizer.getEvaluations()    <= 100);\n        assertTrue(minimizer.getEvaluations()    >=  15);\n        minimizer.setMaxEvaluations(10);\n        try {\n            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n            fail(\"an exception should have been thrown\");\n        } catch (FunctionEvaluationException fee) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n    }", "javadoc_start_line": 41, "annotations_start_line": 40, "method_start_line": 41, "end_line": 69}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<4.71238898038469> but was:<4.71238897901431>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testSinMin", "content": "    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setMaxEvaluations(200);\n        assertEquals(200, minimizer.getMaxEvaluations());\n        try {\n            minimizer.getResult();\n            fail(\"an exception should have been thrown\");\n        } catch (NoDataException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertTrue(minimizer.getEvaluations()    <= 100);\n        assertTrue(minimizer.getEvaluations()    >=  15);\n        minimizer.setMaxEvaluations(10);\n        try {\n            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n            fail(\"an exception should have been thrown\");\n        } catch (FunctionEvaluationException fee) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n    }", "javadoc_start_line": 41, "annotations_start_line": 40, "method_start_line": 41, "end_line": 69}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}]}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<4.71238898038469> but was:<4.71238897901431>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "doOptimize", "content": "    /**\n     * Perform the optimization.\n     *\n     * @return the optimum.\n     */\n    protected double doOptimize()\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        throw new UnsupportedOperationException();\n    }", "javadoc_start_line": 50, "annotations_start_line": 55, "method_start_line": 56, "end_line": 58}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testSinMin-doOptimize.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<4.71238898038469> but was:<4.71238897901431>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "BrentOptimizer", "content": "    /**\n     * Construct a solver.\n     */\n    public BrentOptimizer() {\n        setMaxEvaluations(Integer.MAX_VALUE);\n        setMaximalIterationCount(100);\n        setAbsoluteAccuracy(1E-10);\n        setRelativeAccuracy(1.0e-14);\n    }", "javadoc_start_line": 40, "annotations_start_line": 43, "method_start_line": 43, "end_line": 48}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/66/results/stacktrace-testSinMin-BrentOptimizer.csv'"}}, {"failing_test": {"className": " org.apache.commons.math.optimization.univariate.BrentOptimizerTest", "methodName": "testSinMin", "error": "junit.framework.AssertionFailedError", "message": "expected:<4.71238898038469> but was:<4.71238897901431>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/optimization/univariate/BrentOptimizerTest.java", "method_name": "testSinMin", "content": "    public void testSinMin() throws MathException {\n        UnivariateRealFunction f = new SinFunction();\n        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n        minimizer.setMaxEvaluations(200);\n        assertEquals(200, minimizer.getMaxEvaluations());\n        try {\n            minimizer.getResult();\n            fail(\"an exception should have been thrown\");\n        } catch (NoDataException ise) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 10 * minimizer.getRelativeAccuracy());\n        assertTrue(minimizer.getIterationCount() <= 50);\n        assertTrue(minimizer.getEvaluations()    <= 100);\n        assertTrue(minimizer.getEvaluations()    >=  15);\n        minimizer.setMaxEvaluations(10);\n        try {\n            minimizer.optimize(f, GoalType.MINIMIZE, 4, 5);\n            fail(\"an exception should have been thrown\");\n        } catch (FunctionEvaluationException fee) {\n            // expected\n        } catch (Exception e) {\n            fail(\"wrong exception caught\");\n        }\n    }", "javadoc_start_line": 41, "annotations_start_line": 40, "method_start_line": 41, "end_line": 69}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max) throws MaxIterationsExceededException, FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + GOLDEN_SECTION * (max - min));\n    }", "javadoc_start_line": 65, "annotations_start_line": 65, "method_start_line": 65, "end_line": 67}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "optimize", "content": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType, final double min, final double max, final double startValue) throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(getGoalType() == GoalType.MINIMIZE,\n                        f, goalType, min, startValue, max,\n                        getRelativeAccuracy(), getAbsoluteAccuracy());\n    }", "javadoc_start_line": 59, "annotations_start_line": 59, "method_start_line": 59, "end_line": 64}, {"file_path": "/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java", "method_name": "localMin", "content": "    /**\n     * Find the minimum of the function within the interval {@code (lo, hi)}.\n     *\n     * If the function is defined on the interval {@code (lo, hi)}, then\n     * this method finds an approximation {@code x} to the point at which\n     * the function attains its minimum.<br/>\n     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t}\n     * and the function is never evaluated at two points closer together than\n     * {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and\n     * preferable not much less than <em>sqrt(macheps)</em>, where\n     * <em>macheps</em> is the relative machine precision. {@code t} should be\n     * positive.\n     * @param isMinim {@code true} when minimizing the function.\n     * @param lo Lower bound of the interval.\n     * @param mid Point inside the interval {@code [lo, hi]}.\n     * @param hi Higher bound of the interval.\n     * @param eps Relative accuracy.\n     * @param t Absolute accuracy.\n     * @return the optimum point.\n     * @throws MaxIterationsExceededException if the maximum iteration count\n     * is exceeded.\n     * @throws FunctionEvaluationException if an error occurs evaluating\n     * the function.\n     */\n    private double localMin(boolean isMinim,\n                            UnivariateRealFunction f,\n                            GoalType goalType,\n                            double lo, double mid, double hi,\n                            double eps, double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (eps <= 0) {\n            throw new NotStrictlyPositiveException(eps);\n        }\n        if (t <= 0) {\n            throw new NotStrictlyPositiveException(t);\n        }\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            final double tol1 = eps * Math.abs(x) + t;\n            final double tol2 = 2 * tol1;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x)\n                        && p < q * (b - x)\n                        && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2\n                            || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (Math.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw\n                        || w == x) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv\n                               || v == x\n                               || v == w) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n            ++count;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }", "javadoc_start_line": 69, "annotations_start_line": 93, "method_start_line": 98, "end_line": 244}]}], "project": {"name": "Math", "version": 66}}