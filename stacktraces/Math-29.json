{"tours": [{"failing_test": {"className": " org.apache.commons.math3.linear.SparseRealVectorTest", "methodName": "testEbeDivideMixedTypes", "error": "junit.framework.AssertionFailedError", "message": "entry #0, left = 0.0, right = 0.0 expected:<NaN> but was:<0.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "ebeMultiply", "content": "    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        return res;\n    }", "javadoc_start_line": 357, "annotations_start_line": 358, "method_start_line": 359, "end_line": 375}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/29/results/stacktrace-testEbeDivideMixedTypes-ebeMultiply.csv'"}}, {"failing_test": {"className": " org.apache.commons.math3.linear.SparseRealVectorTest", "methodName": "testEbeDivideMixedTypes", "error": "junit.framework.AssertionFailedError", "message": "entry #0, left = 0.0, right = 0.0 expected:<NaN> but was:<0.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "ebeDivide", "content": "    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }", "javadoc_start_line": 339, "annotations_start_line": 340, "method_start_line": 341, "end_line": 355}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java", "method_name": "testEbeDivideMixedTypes", "content": "    public void testEbeDivideMixedTypes() {\n        doTestEbeBinaryOperation(BinaryOperation.DIV, true);\n    }", "javadoc_start_line": 594, "annotations_start_line": 593, "method_start_line": 594, "end_line": 596}, {"file_path": "/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java", "method_name": "doTestEbeBinaryOperation", "content": "    private void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed) {\n        /*\n         * Make sure that x, y, z are three different values. Also, x is the\n         * preferred value (e.g. the value which is not stored in sparse\n         * implementations).\n         */\n        final double x = getPreferredEntryValue();\n        final double y = x + 1d;\n        final double z = y + 1d;\n\n        /*\n         * This is an attempt at covering most particular cases of combining\n         * two values.\n         *\n         * 1. Addition\n         *    --------\n         * The following cases should be covered\n         * (2 * x) + (-x)\n         * (-x) + 2 * x\n         * x + y\n         * y + x\n         * y + z\n         * y + (x - y)\n         * (y - x) + x\n         *\n         * The values to be considered are: x, y, z, 2 * x, -x, x - y, y - x.\n         *\n         * 2. Subtraction\n         *    -----------\n         * The following cases should be covered\n         * (2 * x) - x\n         * x - y\n         * y - x\n         * y - z\n         * y - (y - x)\n         * (y + x) - y\n         *\n         * The values to be considered are: x, y, z, x + y, y - x.\n         *\n         * 3. Multiplication\n         *    --------------\n         * (x * x) * (1 / x)\n         * (1 / x) * (x * x)\n         * x * y\n         * y * x\n         * y * z\n         *\n         * The values to be considered are: x, y, z, 1 / x, x * x.\n         *\n         * 4. Division\n         *    --------\n         * (x * x) / x\n         * x / y\n         * y / x\n         * y / z\n         *\n         * The values to be considered are: x, y, z, x * x.\n         *\n         * Also to be considered NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY.\n         */\n        final double[] values = {x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x};\n        final double[] data1 = new double[values.length * values.length];\n        final double[] data2 = new double[values.length * values.length];\n        int k = 0;\n        for (int i = 0; i < values.length; i++) {\n            for (int j = 0; j < values.length; j++) {\n                data1[k] = values[i];\n                data2[k] = values[j];\n                ++k;\n            }\n        }\n        final RealVector v1 = create(data1);\n        final RealVector v2 = mixed ? createAlien(data2) : create(data2);\n        final RealVector actual;\n        switch (op) {\n            case ADD:\n                actual = v1.add(v2);\n                break;\n            case SUB:\n                actual = v1.subtract(v2);\n                break;\n            case MUL:\n                actual = v1.ebeMultiply(v2);\n                break;\n            case DIV:\n                actual = v1.ebeDivide(v2);\n                break;\n            default:\n                throw new AssertionError(\"unexpected value\");\n        }\n        final double[] expected = new double[data1.length];\n        for (int i = 0; i < expected.length; i++) {\n            switch (op) {\n                case ADD:\n                    expected[i] = data1[i] + data2[i];\n                    break;\n                case SUB:\n                    expected[i] = data1[i] - data2[i];\n                    break;\n                case MUL:\n                    expected[i] = data1[i] * data2[i];\n                    break;\n                case DIV:\n                    expected[i] = data1[i] / data2[i];\n                    break;\n                default:\n                    throw new AssertionError(\"unexpected value\");\n            }\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final String msg = \"entry #\"+i+\", left = \"+data1[i]+\", right = \" + data2[i];\n            Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);\n        }\n    }", "javadoc_start_line": 408, "annotations_start_line": 408, "method_start_line": 408, "end_line": 521}, {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "<clinit>", "content": "public class OpenMapRealVector extends SparseRealVector", "javadoc_start_line": 34, "annotations_start_line": 34, "method_start_line": 34, "end_line": 34}]}, {"failing_test": {"className": " org.apache.commons.math3.linear.SparseRealVectorTest", "methodName": "testEbeMultiplyMixedTypes", "error": "junit.framework.AssertionFailedError", "message": "entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "ebeMultiply", "content": "    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        return res;\n    }", "javadoc_start_line": 357, "annotations_start_line": 358, "method_start_line": 359, "end_line": 375}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java", "method_name": "testEbeMultiplyMixedTypes", "content": "    public void testEbeMultiplyMixedTypes() {\n        doTestEbeBinaryOperation(BinaryOperation.MUL, true);\n    }", "javadoc_start_line": 579, "annotations_start_line": 578, "method_start_line": 579, "end_line": 581}, {"file_path": "/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java", "method_name": "doTestEbeBinaryOperation", "content": "    private void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed) {\n        /*\n         * Make sure that x, y, z are three different values. Also, x is the\n         * preferred value (e.g. the value which is not stored in sparse\n         * implementations).\n         */\n        final double x = getPreferredEntryValue();\n        final double y = x + 1d;\n        final double z = y + 1d;\n\n        /*\n         * This is an attempt at covering most particular cases of combining\n         * two values.\n         *\n         * 1. Addition\n         *    --------\n         * The following cases should be covered\n         * (2 * x) + (-x)\n         * (-x) + 2 * x\n         * x + y\n         * y + x\n         * y + z\n         * y + (x - y)\n         * (y - x) + x\n         *\n         * The values to be considered are: x, y, z, 2 * x, -x, x - y, y - x.\n         *\n         * 2. Subtraction\n         *    -----------\n         * The following cases should be covered\n         * (2 * x) - x\n         * x - y\n         * y - x\n         * y - z\n         * y - (y - x)\n         * (y + x) - y\n         *\n         * The values to be considered are: x, y, z, x + y, y - x.\n         *\n         * 3. Multiplication\n         *    --------------\n         * (x * x) * (1 / x)\n         * (1 / x) * (x * x)\n         * x * y\n         * y * x\n         * y * z\n         *\n         * The values to be considered are: x, y, z, 1 / x, x * x.\n         *\n         * 4. Division\n         *    --------\n         * (x * x) / x\n         * x / y\n         * y / x\n         * y / z\n         *\n         * The values to be considered are: x, y, z, x * x.\n         *\n         * Also to be considered NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY.\n         */\n        final double[] values = {x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x};\n        final double[] data1 = new double[values.length * values.length];\n        final double[] data2 = new double[values.length * values.length];\n        int k = 0;\n        for (int i = 0; i < values.length; i++) {\n            for (int j = 0; j < values.length; j++) {\n                data1[k] = values[i];\n                data2[k] = values[j];\n                ++k;\n            }\n        }\n        final RealVector v1 = create(data1);\n        final RealVector v2 = mixed ? createAlien(data2) : create(data2);\n        final RealVector actual;\n        switch (op) {\n            case ADD:\n                actual = v1.add(v2);\n                break;\n            case SUB:\n                actual = v1.subtract(v2);\n                break;\n            case MUL:\n                actual = v1.ebeMultiply(v2);\n                break;\n            case DIV:\n                actual = v1.ebeDivide(v2);\n                break;\n            default:\n                throw new AssertionError(\"unexpected value\");\n        }\n        final double[] expected = new double[data1.length];\n        for (int i = 0; i < expected.length; i++) {\n            switch (op) {\n                case ADD:\n                    expected[i] = data1[i] + data2[i];\n                    break;\n                case SUB:\n                    expected[i] = data1[i] - data2[i];\n                    break;\n                case MUL:\n                    expected[i] = data1[i] * data2[i];\n                    break;\n                case DIV:\n                    expected[i] = data1[i] / data2[i];\n                    break;\n                default:\n                    throw new AssertionError(\"unexpected value\");\n            }\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final String msg = \"entry #\"+i+\", left = \"+data1[i]+\", right = \" + data2[i];\n            Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);\n        }\n    }", "javadoc_start_line": 408, "annotations_start_line": 408, "method_start_line": 408, "end_line": 521}, {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "<clinit>", "content": "public class OpenMapRealVector extends SparseRealVector", "javadoc_start_line": 34, "annotations_start_line": 34, "method_start_line": 34, "end_line": 34}]}, {"failing_test": {"className": " org.apache.commons.math3.linear.SparseRealVectorTest", "methodName": "testEbeMultiplyMixedTypes", "error": "junit.framework.AssertionFailedError", "message": "entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "ebeDivide", "content": "    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }", "javadoc_start_line": 339, "annotations_start_line": 340, "method_start_line": 341, "end_line": 355}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/29/results/stacktrace-testEbeMultiplyMixedTypes-ebeDivide.csv'"}}, {"failing_test": {"className": " org.apache.commons.math3.linear.SparseRealVectorTest", "methodName": "testEbeMultiplySameType", "error": "junit.framework.AssertionFailedError", "message": "entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "ebeMultiply", "content": "    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        return res;\n    }", "javadoc_start_line": 357, "annotations_start_line": 358, "method_start_line": 359, "end_line": 375}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java", "method_name": "testEbeMultiplySameType", "content": "    public void testEbeMultiplySameType() {\n        doTestEbeBinaryOperation(BinaryOperation.MUL, false);\n    }", "javadoc_start_line": 574, "annotations_start_line": 573, "method_start_line": 574, "end_line": 576}, {"file_path": "/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java", "method_name": "doTestEbeBinaryOperation", "content": "    private void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed) {\n        /*\n         * Make sure that x, y, z are three different values. Also, x is the\n         * preferred value (e.g. the value which is not stored in sparse\n         * implementations).\n         */\n        final double x = getPreferredEntryValue();\n        final double y = x + 1d;\n        final double z = y + 1d;\n\n        /*\n         * This is an attempt at covering most particular cases of combining\n         * two values.\n         *\n         * 1. Addition\n         *    --------\n         * The following cases should be covered\n         * (2 * x) + (-x)\n         * (-x) + 2 * x\n         * x + y\n         * y + x\n         * y + z\n         * y + (x - y)\n         * (y - x) + x\n         *\n         * The values to be considered are: x, y, z, 2 * x, -x, x - y, y - x.\n         *\n         * 2. Subtraction\n         *    -----------\n         * The following cases should be covered\n         * (2 * x) - x\n         * x - y\n         * y - x\n         * y - z\n         * y - (y - x)\n         * (y + x) - y\n         *\n         * The values to be considered are: x, y, z, x + y, y - x.\n         *\n         * 3. Multiplication\n         *    --------------\n         * (x * x) * (1 / x)\n         * (1 / x) * (x * x)\n         * x * y\n         * y * x\n         * y * z\n         *\n         * The values to be considered are: x, y, z, 1 / x, x * x.\n         *\n         * 4. Division\n         *    --------\n         * (x * x) / x\n         * x / y\n         * y / x\n         * y / z\n         *\n         * The values to be considered are: x, y, z, x * x.\n         *\n         * Also to be considered NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY.\n         */\n        final double[] values = {x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x};\n        final double[] data1 = new double[values.length * values.length];\n        final double[] data2 = new double[values.length * values.length];\n        int k = 0;\n        for (int i = 0; i < values.length; i++) {\n            for (int j = 0; j < values.length; j++) {\n                data1[k] = values[i];\n                data2[k] = values[j];\n                ++k;\n            }\n        }\n        final RealVector v1 = create(data1);\n        final RealVector v2 = mixed ? createAlien(data2) : create(data2);\n        final RealVector actual;\n        switch (op) {\n            case ADD:\n                actual = v1.add(v2);\n                break;\n            case SUB:\n                actual = v1.subtract(v2);\n                break;\n            case MUL:\n                actual = v1.ebeMultiply(v2);\n                break;\n            case DIV:\n                actual = v1.ebeDivide(v2);\n                break;\n            default:\n                throw new AssertionError(\"unexpected value\");\n        }\n        final double[] expected = new double[data1.length];\n        for (int i = 0; i < expected.length; i++) {\n            switch (op) {\n                case ADD:\n                    expected[i] = data1[i] + data2[i];\n                    break;\n                case SUB:\n                    expected[i] = data1[i] - data2[i];\n                    break;\n                case MUL:\n                    expected[i] = data1[i] * data2[i];\n                    break;\n                case DIV:\n                    expected[i] = data1[i] / data2[i];\n                    break;\n                default:\n                    throw new AssertionError(\"unexpected value\");\n            }\n        }\n        for (int i = 0; i < expected.length; i++) {\n            final String msg = \"entry #\"+i+\", left = \"+data1[i]+\", right = \" + data2[i];\n            Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);\n        }\n    }", "javadoc_start_line": 408, "annotations_start_line": 408, "method_start_line": 408, "end_line": 521}, {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "<clinit>", "content": "public class OpenMapRealVector extends SparseRealVector", "javadoc_start_line": 34, "annotations_start_line": 34, "method_start_line": 34, "end_line": 34}]}, {"failing_test": {"className": " org.apache.commons.math3.linear.SparseRealVectorTest", "methodName": "testEbeMultiplySameType", "error": "junit.framework.AssertionFailedError", "message": "entry #5, left = 0.0, right = Infinity expected:<NaN> but was:<0.0>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java", "method_name": "ebeDivide", "content": "    /** {@inheritDoc} */\n    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }", "javadoc_start_line": 339, "annotations_start_line": 340, "method_start_line": 341, "end_line": 355}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/29/results/stacktrace-testEbeMultiplySameType-ebeDivide.csv'"}}], "project": {"name": "Math", "version": 29}}