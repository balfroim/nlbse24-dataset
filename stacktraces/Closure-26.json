{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.CommandLineRunnerTest", "methodName": "testTransformAMDAndProcessCJS", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "visitModuleExports", "content": "    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n    }", "javadoc_start_line": 217, "annotations_start_line": 220, "method_start_line": 220, "end_line": 228}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testTransformAMDAndProcessCJS-visitModuleExports.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.CommandLineRunnerTest", "methodName": "testTransformAMDAndProcessCJS", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "emitOptionalModuleExportsOverride", "content": "    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }", "javadoc_start_line": 200, "annotations_start_line": 205, "method_start_line": 206, "end_line": 215}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testTransformAMDAndProcessCJS-emitOptionalModuleExportsOverride.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.CommandLineRunnerTest", "methodName": "testProcessCJS", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "visitModuleExports", "content": "    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n    }", "javadoc_start_line": 217, "annotations_start_line": 220, "method_start_line": 220, "end_line": 228}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testProcessCJS-visitModuleExports.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.CommandLineRunnerTest", "methodName": "testProcessCJS", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "emitOptionalModuleExportsOverride", "content": "    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }", "javadoc_start_line": 200, "annotations_start_line": 205, "method_start_line": 206, "end_line": 215}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testProcessCJS-emitOptionalModuleExportsOverride.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testExports", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "visitModuleExports", "content": "    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n    }", "javadoc_start_line": 217, "annotations_start_line": 220, "method_start_line": 220, "end_line": 228}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testExports-visitModuleExports.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testExports", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "emitOptionalModuleExportsOverride", "content": "    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }", "javadoc_start_line": 200, "annotations_start_line": 205, "method_start_line": 206, "end_line": 215}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }", "javadoc_start_line": 64, "annotations_start_line": 63, "method_start_line": 64, "end_line": 67}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 456}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 268, "annotations_start_line": 271, "method_start_line": 271, "end_line": 282}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testModuleName", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "visitModuleExports", "content": "    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n    }", "javadoc_start_line": 217, "annotations_start_line": 220, "method_start_line": 220, "end_line": 228}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testModuleName-visitModuleExports.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testModuleName", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "emitOptionalModuleExportsOverride", "content": "    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }", "javadoc_start_line": 200, "annotations_start_line": 205, "method_start_line": 206, "end_line": 215}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }", "javadoc_start_line": 64, "annotations_start_line": 63, "method_start_line": 64, "end_line": 67}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 456}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 268, "annotations_start_line": 271, "method_start_line": 271, "end_line": 282}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testDash", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "visitModuleExports", "content": "    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n    }", "javadoc_start_line": 217, "annotations_start_line": 220, "method_start_line": 220, "end_line": 228}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testDash-visitModuleExports.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testDash", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "emitOptionalModuleExportsOverride", "content": "    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }", "javadoc_start_line": 200, "annotations_start_line": 205, "method_start_line": 206, "end_line": 215}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }", "javadoc_start_line": 64, "annotations_start_line": 63, "method_start_line": 64, "end_line": 67}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 456}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 268, "annotations_start_line": 271, "method_start_line": 271, "end_line": 282}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testVarRenaming", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "visitModuleExports", "content": "    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n    }", "javadoc_start_line": 217, "annotations_start_line": 220, "method_start_line": 220, "end_line": 228}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testVarRenaming-visitModuleExports.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testVarRenaming", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "emitOptionalModuleExportsOverride", "content": "    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }", "javadoc_start_line": 200, "annotations_start_line": 205, "method_start_line": 206, "end_line": 215}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }", "javadoc_start_line": 64, "annotations_start_line": 63, "method_start_line": 64, "end_line": 67}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 456}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 268, "annotations_start_line": 271, "method_start_line": 271, "end_line": 282}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testWithoutExports", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "visitModuleExports", "content": "    /**\n     * Rewrite module.exports to moduleName.module$exports.\n     */\n    private void visitModuleExports(Node prop) {\n      String moduleName = guessCJSModuleName(prop.getSourceFileName());\n      Node module = prop.getChildAtIndex(0);\n      module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n      module.setString(moduleName);\n      Node exports = prop.getChildAtIndex(1);\n      exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n      exports.setString(\"module$exports\");\n    }", "javadoc_start_line": 217, "annotations_start_line": 220, "method_start_line": 220, "end_line": 228}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/26/results/stacktrace-testWithoutExports-visitModuleExports.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ProcessCommonJSModulesTest", "methodName": "testWithoutExports", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "emitOptionalModuleExportsOverride", "content": "    /**\n     * Emit <code>if (moduleName.module$exports) {\n     *    moduleName = moduleName.module$export;\n     * }</code> at end of file.\n     */\n    private void emitOptionalModuleExportsOverride(Node script,\n        String moduleName) {\n\n      Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n          IR.string(\"module$exports\"));\n      script.addChildToBack(IR.ifNode(\n          moduleExportsProp,\n          IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n              moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n          script));\n    }", "javadoc_start_line": 200, "annotations_start_line": 205, "method_start_line": 206, "end_line": 215}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ProcessCommonJSModules.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    NodeTraversal\n        .traverse(compiler, root, new ProcessCommonJsModulesCallback());\n  }", "javadoc_start_line": 64, "annotations_start_line": 63, "method_start_line": 64, "end_line": 67}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 456}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 268, "annotations_start_line": 271, "method_start_line": 271, "end_line": 282}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 473, "annotations_start_line": 476, "method_start_line": 477, "end_line": 505}]}], "project": {"name": "Closure", "version": 26}}