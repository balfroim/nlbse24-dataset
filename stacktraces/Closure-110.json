{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testHoistedFunctionDeclaration", "error": "junit.framework.AssertionFailedError", "message": "Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>"}, "patched_method": {"file_path": "/src/com/google/javascript/rhino/Node.java", "method_name": "getChildBefore", "content": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }", "javadoc_start_line": 549, "annotations_start_line": 549, "method_start_line": 549, "end_line": 562}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/110/results/stacktrace-testHoistedFunctionDeclaration-getChildBefore.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testHoistedFunctionDeclaration", "error": "junit.framework.AssertionFailedError", "message": "Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>"}, "patched_method": {"file_path": "/lib/rhino/src/org/mozilla/javascript/Node.java", "method_name": "setScope", "content": "    /** Can only be called when node has String context. */\n    public void setScope(Scope s) {\n        if (s == null) Kit.codeBug();\n        if (!(this instanceof Name)) {\n            throw Kit.codeBug();\n        }\n        ((Name)this).setScope(s);\n    }", "javadoc_start_line": 548, "annotations_start_line": 549, "method_start_line": 549, "end_line": 555}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "Command failed: defects4j test -w ./projects/Closure/110\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/110 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/110 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Iterator.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/NoSuchElementException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Iterable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Iterator.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/NoSuchElementException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Iterable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Override.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Annotation.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Override.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Annotation.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalStateException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalStateException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/org/mozilla/javascript/Node.java:550: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testHoistedFunctionDeclaration\", \"setScope\", \"./results/stacktrace-testHoistedFunctionDeclaration-setScope.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 47 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/110/build.xml:102: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/build.xml:45: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/build.xml:38: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testHoistedFunctionDeclaration", "error": "junit.framework.AssertionFailedError", "message": "Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 39 expected:<0> but was:<1>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "findAliases", "content": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n              grandparent.addChildBefore(newDecl, varNode);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }", "javadoc_start_line": 352, "annotations_start_line": 352, "method_start_line": 352, "end_line": 422}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }", "javadoc_start_line": 127, "annotations_start_line": 126, "method_start_line": 127, "end_line": 129}, {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "hotSwapScript", "content": "  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      List<AliasUsage> aliasWorkQueue =\n          Lists.newArrayList(traversal.getAliasUsages());\n      while (!aliasWorkQueue.isEmpty()) {\n        List<AliasUsage> newQueue = Lists.newArrayList();\n        for (AliasUsage aliasUsage : aliasWorkQueue) {\n          if (aliasUsage.referencesOtherAlias()) {\n            newQueue.add(aliasUsage);\n          } else {\n            aliasUsage.applyAlias();\n          }\n        }\n\n        // Prevent an infinite loop.\n        if (newQueue.size() == aliasWorkQueue.size()) {\n          Var cycleVar = newQueue.get(0).aliasVar;\n          compiler.report(JSError.make(\n              cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));\n          break;\n        } else {\n          aliasWorkQueue = newQueue;\n        }\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }", "javadoc_start_line": 132, "annotations_start_line": 131, "method_start_line": 132, "end_line": 189}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /** Traverses a function. */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 543, "annotations_start_line": 544, "method_start_line": 544, "end_line": 577}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    compiler.setScope(node);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 593, "annotations_start_line": 594, "method_start_line": 594, "end_line": 602}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testFunctionDeclaration", "error": "junit.framework.AssertionFailedError", "message": "Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>"}, "patched_method": {"file_path": "/src/com/google/javascript/rhino/Node.java", "method_name": "getChildBefore", "content": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }", "javadoc_start_line": 549, "annotations_start_line": 549, "method_start_line": 549, "end_line": 562}, "steps": [{"file_path": "/src/com/google/javascript/rhino/Node.java", "method_name": "removeChild", "content": "  /**\n   * Detach a child from its parent and siblings.\n   */\n  public void removeChild(Node child) {\n    Node prev = getChildBefore(child);\n    if (prev == null) {\n      first = first.next;\n    } else {\n      prev.next = child.next;\n    }\n    if (child == last) {\n      last = prev;\n    }\n    child.next = null;\n    child.parent = null;\n  }", "javadoc_start_line": 694, "annotations_start_line": 697, "method_start_line": 697, "end_line": 709}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/Node.java", "method_name": "endCheckSwitch", "content": "    /**\n     * Consistency of return statements is checked between the case statements.\n     * If there is no default, then the switch can fall through. If there is a\n     * default,we check to see if all code paths in the default return or if\n     * there is a code path that can fall through.\n     * @return logical OR of END_* flags\n     */\n    private int endCheckSwitch()\n    {\n        int rv = END_UNREACHED;\n\n        // examine the cases\n//         for (n = first.next; n != null; n = n.next)\n//         {\n//             if (n.type == Token.CASE) {\n//                 rv |= ((Jump)n).target.endCheck();\n//             } else\n//                 break;\n//         }\n\n//         // we don't care how the cases drop into each other\n//         rv &= ~END_DROPS_OFF;\n\n//         // examine the default\n//         n = ((Jump)this).getDefault();\n//         if (n != null)\n//             rv |= n.endCheck();\n//         else\n//             rv |= END_DROPS_OFF;\n\n//         // remove the switch block\n//         rv |= getIntProp(CONTROL_BLOCK_PROP, END_UNREACHED);\n\n        return rv;\n    }", "javadoc_start_line": 669, "annotations_start_line": 676, "method_start_line": 677, "end_line": 703}, {"file_path": "/src/com/google/javascript/rhino/Node.java", "method_name": "getChildBefore", "content": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }", "javadoc_start_line": 549, "annotations_start_line": 549, "method_start_line": 549, "end_line": 562}, {"file_path": "/lib/rhino/src/org/mozilla/javascript/Node.java", "method_name": "setScope", "content": "    /** Can only be called when node has String context. */\n    public void setScope(Scope s) {\n        if (s == null) Kit.codeBug();\n        if (!(this instanceof Name)) {\n            throw Kit.codeBug();\n        }\n        ((Name)this).setScope(s);\n    }", "javadoc_start_line": 548, "annotations_start_line": 549, "method_start_line": 549, "end_line": 555}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testFunctionDeclaration", "error": "junit.framework.AssertionFailedError", "message": "Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>"}, "patched_method": {"file_path": "/lib/rhino/src/org/mozilla/javascript/Node.java", "method_name": "setScope", "content": "    /** Can only be called when node has String context. */\n    public void setScope(Scope s) {\n        if (s == null) Kit.codeBug();\n        if (!(this instanceof Name)) {\n            throw Kit.codeBug();\n        }\n        ((Name)this).setScope(s);\n    }", "javadoc_start_line": 548, "annotations_start_line": 549, "method_start_line": 549, "end_line": 555}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "Command failed: defects4j test -w ./projects/Closure/110\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/110 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/110 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Iterator.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/NoSuchElementException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Iterable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Iterator.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/NoSuchElementException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Iterable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Override.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Annotation.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Override.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Annotation.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalStateException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/IllegalStateException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/org/mozilla/javascript/Node.java:550: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testFunctionDeclaration\", \"setScope\", \"./results/stacktrace-testFunctionDeclaration-setScope.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 47 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/110/build.xml:102: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/build.xml:45: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/110/lib/rhino/src/build.xml:38: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"}}, {"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testFunctionDeclaration", "error": "junit.framework.AssertionFailedError", "message": "Unexpected error(s): JSC_GOOG_SCOPE_NON_ALIAS_LOCAL. The local variable f is in a goog.scope and is not an alias. at testcode line 1 : 41 expected:<0> but was:<1>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "findAliases", "content": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar) {\n          Node grandparent = parent.getParent();\n          Node value = n.hasChildren() ?\n              v.getInitialValue().detachFromParent() :\n              null;\n          Node varNode = parent;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n              grandparent.addChildBefore(newDecl, varNode);\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }", "javadoc_start_line": 352, "annotations_start_line": 352, "method_start_line": 352, "end_line": 422}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }", "javadoc_start_line": 127, "annotations_start_line": 126, "method_start_line": 127, "end_line": 129}, {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "hotSwapScript", "content": "  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      List<AliasUsage> aliasWorkQueue =\n          Lists.newArrayList(traversal.getAliasUsages());\n      while (!aliasWorkQueue.isEmpty()) {\n        List<AliasUsage> newQueue = Lists.newArrayList();\n        for (AliasUsage aliasUsage : aliasWorkQueue) {\n          if (aliasUsage.referencesOtherAlias()) {\n            newQueue.add(aliasUsage);\n          } else {\n            aliasUsage.applyAlias();\n          }\n        }\n\n        // Prevent an infinite loop.\n        if (newQueue.size() == aliasWorkQueue.size()) {\n          Var cycleVar = newQueue.get(0).aliasVar;\n          compiler.report(JSError.make(\n              cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));\n          break;\n        } else {\n          aliasWorkQueue = newQueue;\n        }\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }", "javadoc_start_line": 132, "annotations_start_line": 131, "method_start_line": 132, "end_line": 189}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /** Traverses a function. */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 543, "annotations_start_line": 544, "method_start_line": 544, "end_line": 577}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    compiler.setScope(node);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 593, "annotations_start_line": 594, "method_start_line": 594, "end_line": 602}]}], "project": {"name": "Closure", "version": 110}}