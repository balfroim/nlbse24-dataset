{"tours": [{"failing_test": {"className": " org.apache.commons.math3.util.FastMathTest", "methodName": "testMath905LargePositive", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<Infinity>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/util/FastMath.java", "method_name": "sinh", "content": "    /** Compute the hyperbolic sine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic sine of x\n     */\n    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              // Avoid overflow (MATH-905).\n              return -0.5 * exp(-x);\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }", "javadoc_start_line": 439, "annotations_start_line": 443, "method_start_line": 443, "end_line": 553}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/16/results/stacktrace-testMath905LargePositive-sinh.csv'"}}, {"failing_test": {"className": " org.apache.commons.math3.util.FastMathTest", "methodName": "testMath905LargePositive", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<Infinity>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/util/FastMath.java", "method_name": "cosh", "content": "    /** Compute the hyperbolic cosine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      // cosh[z] = (exp(z) + exp(-z))/2\n\n      // for numbers with magnitude 20 or so,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(-x);\n      }\n\n      final double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * HEX_40000000;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      // recip = 1/y\n      double recip = 1.0/ya;\n      temp = recip * HEX_40000000;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      // Correct for rounding in division\n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      // Account for yb\n      recipb += -yb * recip * recip;\n\n      // y = y + 1/y\n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }", "javadoc_start_line": 379, "annotations_start_line": 383, "method_start_line": 383, "end_line": 437}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/util/FastMathTest.java", "method_name": "testMath905LargePositive", "content": "    public void testMath905LargePositive() {\n        final double start = StrictMath.log(Double.MAX_VALUE);\n        final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);\n        final double end = 2 * StrictMath.log(endT);\n\n        double maxErr = 0;\n        for (double x = start; x < end; x += 1e-3) {\n            final double tst = FastMath.cosh(x);\n            final double ref = Math.cosh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n\n        for (double x = start; x < end; x += 1e-3) {\n            final double tst = FastMath.sinh(x);\n            final double ref = Math.sinh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n    }", "javadoc_start_line": 161, "annotations_start_line": 160, "method_start_line": 161, "end_line": 180}, {"file_path": "/src/main/java/org/apache/commons/math3/util/FastMath.java", "method_name": "cosh", "content": "    /** Compute the hyperbolic cosine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      // cosh[z] = (exp(z) + exp(-z))/2\n\n      // for numbers with magnitude 20 or so,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(-x);\n      }\n\n      final double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * HEX_40000000;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      // recip = 1/y\n      double recip = 1.0/ya;\n      temp = recip * HEX_40000000;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      // Correct for rounding in division\n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      // Account for yb\n      recipb += -yb * recip * recip;\n\n      // y = y + 1/y\n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }", "javadoc_start_line": 379, "annotations_start_line": 383, "method_start_line": 383, "end_line": 437}]}, {"failing_test": {"className": " org.apache.commons.math3.util.FastMathTest", "methodName": "testMath905LargeNegative", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<Infinity>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/util/FastMath.java", "method_name": "sinh", "content": "    /** Compute the hyperbolic sine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic sine of x\n     */\n    public static double sinh(double x) {\n      boolean negate = false;\n      if (x != x) {\n          return x;\n      }\n\n      // sinh[z] = (exp(z) - exp(-z) / 2\n\n      // for values of z larger than about 20,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              // Avoid overflow (MATH-905).\n              return -0.5 * exp(-x);\n      }\n\n      if (x == 0) {\n          return x;\n      }\n\n      if (x < 0.0) {\n          x = -x;\n          negate = true;\n      }\n\n      double result;\n\n      if (x > 0.25) {\n          double hiPrec[] = new double[2];\n          exp(x, 0.0, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          double temp = ya * HEX_40000000;\n          double yaa = ya + temp - temp;\n          double yab = ya - yaa;\n\n          // recip = 1/y\n          double recip = 1.0/ya;\n          temp = recip * HEX_40000000;\n          double recipa = recip + temp - temp;\n          double recipb = recip - recipa;\n\n          // Correct for rounding in division\n          recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n          // Account for yb\n          recipb += -yb * recip * recip;\n\n          recipa = -recipa;\n          recipb = -recipb;\n\n          // y = y + 1/y\n          temp = ya + recipa;\n          yb += -(temp - ya - recipa);\n          ya = temp;\n          temp = ya + recipb;\n          yb += -(temp - ya - recipb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n      else {\n          double hiPrec[] = new double[2];\n          expm1(x, hiPrec);\n\n          double ya = hiPrec[0] + hiPrec[1];\n          double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n          /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n          double denom = 1.0 + ya;\n          double denomr = 1.0 / denom;\n          double denomb = -(denom - 1.0 - ya) + yb;\n          double ratio = ya * denomr;\n          double temp = ratio * HEX_40000000;\n          double ra = ratio + temp - temp;\n          double rb = ratio - ra;\n\n          temp = denom * HEX_40000000;\n          double za = denom + temp - temp;\n          double zb = denom - za;\n\n          rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n          // Adjust for yb\n          rb += yb*denomr;                        // numerator\n          rb += -ya * denomb * denomr * denomr;   // denominator\n\n          // y = y - 1/y\n          temp = ya + ra;\n          yb += -(temp - ya - ra);\n          ya = temp;\n          temp = ya + rb;\n          yb += -(temp - ya - rb);\n          ya = temp;\n\n          result = ya + yb;\n          result *= 0.5;\n      }\n\n      if (negate) {\n          result = -result;\n      }\n\n      return result;\n    }", "javadoc_start_line": 439, "annotations_start_line": 443, "method_start_line": 443, "end_line": 553}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/16/results/stacktrace-testMath905LargeNegative-sinh.csv'"}}, {"failing_test": {"className": " org.apache.commons.math3.util.FastMathTest", "methodName": "testMath905LargeNegative", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<Infinity>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/util/FastMath.java", "method_name": "cosh", "content": "    /** Compute the hyperbolic cosine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      // cosh[z] = (exp(z) + exp(-z))/2\n\n      // for numbers with magnitude 20 or so,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(-x);\n      }\n\n      final double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * HEX_40000000;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      // recip = 1/y\n      double recip = 1.0/ya;\n      temp = recip * HEX_40000000;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      // Correct for rounding in division\n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      // Account for yb\n      recipb += -yb * recip * recip;\n\n      // y = y + 1/y\n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }", "javadoc_start_line": 379, "annotations_start_line": 383, "method_start_line": 383, "end_line": 437}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/util/FastMathTest.java", "method_name": "testMath905LargeNegative", "content": "    public void testMath905LargeNegative() {\n        final double start = -StrictMath.log(Double.MAX_VALUE);\n        final double endT = StrictMath.sqrt(2) * StrictMath.sqrt(Double.MAX_VALUE);\n        final double end = -2 * StrictMath.log(endT);\n\n        double maxErr = 0;\n        for (double x = start; x > end; x -= 1e-3) {\n            final double tst = FastMath.cosh(x);\n            final double ref = Math.cosh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n\n        for (double x = start; x > end; x -= 1e-3) {\n            final double tst = FastMath.sinh(x);\n            final double ref = Math.sinh(x);\n            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));            \n        }\n        Assert.assertEquals(0, maxErr, 3);\n    }", "javadoc_start_line": 183, "annotations_start_line": 182, "method_start_line": 183, "end_line": 202}, {"file_path": "/src/main/java/org/apache/commons/math3/util/FastMath.java", "method_name": "cosh", "content": "    /** Compute the hyperbolic cosine of a number.\n     * @param x number on which evaluation is done\n     * @return hyperbolic cosine of x\n     */\n    public static double cosh(double x) {\n      if (x != x) {\n          return x;\n      }\n\n      // cosh[z] = (exp(z) + exp(-z))/2\n\n      // for numbers with magnitude 20 or so,\n      // exp(-z) can be ignored in comparison with exp(z)\n\n      if (x > 20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(x);\n          }\n      if (x < -20) {\n              // Avoid overflow (MATH-905).\n              return 0.5 * exp(-x);\n      }\n\n      final double hiPrec[] = new double[2];\n      if (x < 0.0) {\n          x = -x;\n      }\n      exp(x, 0.0, hiPrec);\n\n      double ya = hiPrec[0] + hiPrec[1];\n      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n      double temp = ya * HEX_40000000;\n      double yaa = ya + temp - temp;\n      double yab = ya - yaa;\n\n      // recip = 1/y\n      double recip = 1.0/ya;\n      temp = recip * HEX_40000000;\n      double recipa = recip + temp - temp;\n      double recipb = recip - recipa;\n\n      // Correct for rounding in division\n      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n      // Account for yb\n      recipb += -yb * recip * recip;\n\n      // y = y + 1/y\n      temp = ya + recipa;\n      yb += -(temp - ya - recipa);\n      ya = temp;\n      temp = ya + recipb;\n      yb += -(temp - ya - recipb);\n      ya = temp;\n\n      double result = ya + yb;\n      result *= 0.5;\n      return result;\n    }", "javadoc_start_line": 379, "annotations_start_line": 383, "method_start_line": 383, "end_line": 437}]}], "project": {"name": "Math", "version": 16}}