{"tours": [{"failing_test": {"className": " org.joda.time.TestDateTimeZoneCutover", "methodName": "testBug3476684_adjustOffset", "error": "junit.framework.AssertionFailedError", "message": "expected:<2012-02-25T23:15:00.000-03:00> but was:<2012-02-25T23:15:00.000-02:00>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "adjustOffset", "content": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n        \n        // calculate result\n          // currently in later offset\n          // currently in earlier offset\n    }", "javadoc_start_line": 1156, "annotations_start_line": 1163, "method_start_line": 1163, "end_line": 1180}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "testBug3476684_adjustOffset", "content": "    public void testBug3476684_adjustOffset() {\n        final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n        DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n        DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n        \n        assertSame(base, base.withEarlierOffsetAtOverlap());\n        assertSame(base, base.withLaterOffsetAtOverlap());\n        \n        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n        \n        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n    }", "javadoc_start_line": 1249, "annotations_start_line": 1249, "method_start_line": 1249, "end_line": 1263}, {"file_path": "/src/main/java/org/joda/time/DateTime.java", "method_name": "withLaterOffsetAtOverlap", "content": "    /**\n     * Returns a copy of this ZonedDateTime changing the zone offset to the later\n     * of the two valid offsets at a local time-line overlap.\n     * <p>\n     * This method only has any effect when the local time-line overlaps, such as at\n     * an autumn daylight savings cutover. In this scenario, there are two valid offsets\n     * for the local date-time. Calling this method will return a date-time with the\n     * later of the two selected.\n     * <p>\n     * If this method is called when it is not an overlap, this is returned.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @return a copy of this datetime with the latest valid offset for the local datetime\n     */\n    public DateTime withLaterOffsetAtOverlap() {\n        long newMillis = getZone().adjustOffset(getMillis(), true);\n        return withMillis(newMillis);\n    }", "javadoc_start_line": 669, "annotations_start_line": 684, "method_start_line": 684, "end_line": 687}, {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "adjustOffset", "content": "    /**\n     * Adjusts the offset to be the earlier or later one during an overlap.\n     * \n     * @param instant  the instant to adjust\n     * @param earlierOrLater  false for earlier, true for later\n     * @return the adjusted instant millis\n     */\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n        \n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n        \n        // calculate result\n          // currently in later offset\n          // currently in earlier offset\n    }", "javadoc_start_line": 1156, "annotations_start_line": 1163, "method_start_line": 1163, "end_line": 1180}]}], "project": {"name": "Time", "version": 17}}