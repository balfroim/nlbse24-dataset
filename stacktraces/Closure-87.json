{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest", "methodName": "testIssue291", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java", "method_name": "isFoldableExpressBlock", "content": "  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n\n          return NodeUtil.isExpressionNode(maybeExpr);\n      }\n    }\n\n    return false;\n  }", "javadoc_start_line": 515, "annotations_start_line": 519, "method_start_line": 519, "end_line": 538}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    NodeTraversal t = new NodeTraversal(compiler, this);\n\n    beginTraversal(t);\n    t.traverse(root);\n    endTraversal(t);\n  }", "javadoc_start_line": 55, "annotations_start_line": 54, "method_start_line": 55, "end_line": 61}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 241, "annotations_start_line": 244, "method_start_line": 244, "end_line": 254}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 434, "annotations_start_line": 437, "method_start_line": 438, "end_line": 465}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "visit", "content": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    Node currentVersionOfNode = n;\n    boolean somethingChanged = false;\n\n    do {\n      somethingChanged = false;\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n        Node newVersionOfNode =\n            optimization.optimizeSubtree(currentVersionOfNode);\n\n        if (newVersionOfNode != currentVersionOfNode) {\n          somethingChanged = true;\n\n          currentVersionOfNode = newVersionOfNode;\n        }\n\n        if (currentVersionOfNode == null) {\n          return;\n        }\n      }\n    } while(somethingChanged);\n  }", "javadoc_start_line": 64, "annotations_start_line": 63, "method_start_line": 64, "end_line": 85}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java", "method_name": "optimizeSubtree", "content": "  /**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n      case Token.RETURN:\n        return tryReduceReturn(node);\n\n      case Token.NOT:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeNot(node);\n\n      case Token.IF:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeIf(node);\n\n      case Token.EXPR_RESULT:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.HOOK:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.WHILE:\n      case Token.DO:\n        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        return node;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(node)) {\n          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        }\n        return node;\n\n      case Token.NEW:\n        node = tryFoldStandardConstructors(node);\n        if (node.getType() != Token.CALL) {\n          return node;\n        }\n        // Fall through on purpose because tryFoldStandardConstructors() may\n        // convert a NEW node into a CALL node\n      case Token.CALL:\n        return tryFoldLiteralConstructor(node);\n\n      default:\n        return node; //Nothing changed\n    }\n  }", "javadoc_start_line": 53, "annotations_start_line": 56, "method_start_line": 58, "end_line": 103}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java", "method_name": "tryMinimizeIf", "content": "  /**\n   * Try turning IF nodes into smaller HOOKs\n   *\n   * Returns the replacement for n or the original if no replacement was\n   * necessary.\n   */\n  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          return n;\n        }\n\n        if (cond.getType() == Token.NOT) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = new Node(Token.OR, cond.removeFirstChild(),\n          expr.removeFirstChild()).copyInformationFrom(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses isn't worth it.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = new Node(Token.AND, cond, expr.removeFirstChild())\n                       .copyInformationFrom(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                          .copyInformationFrom(n);\n      Node returnNode = new Node(Token.RETURN, hookNode);\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              !mayEffectMutableState(lhs)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild();\n            elseOp.removeChild(elseExpr);\n\n            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                                .copyInformationFrom(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                              .copyInformationFrom(thenOp);\n            Node expr = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }\n        } else if (NodeUtil.isCall(thenOp)) {\n          // if(x)foo();else bar(); -> x?foo():bar()\n          n.removeChild(cond);\n          thenOp.detachFromParent();\n          elseOp.detachFromParent();\n          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)\n                              .copyInformationFrom(n);\n          Node expr = NodeUtil.newExpr(hookNode);\n          parent.replaceChild(n, expr);\n          reportCodeChange();\n\n          return expr;\n        }\n      }\n      return n;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    // if(x)var y=1;else y=2  ->  var y=x?1:2\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n        NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {\n\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n\n      if (name1.hasChildren()\n          && maybeName2.getType() == Token.NAME\n          && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        cond.detachFromParent();\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                            .copyInformationFrom(n);\n        var.detachFromParent();\n        name1.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n        return var;\n      }\n\n    // if(x)y=1;else var y=2  ->  var y=x?1:2\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n        NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {\n\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n\n      if (name2.hasChildren()\n          && maybeName1.getType() == Token.NAME\n          && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        cond.detachFromParent();\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                            .copyInformationFrom(n);\n        var.detachFromParent();\n        name2.addChildrenToBack(hookNode);\n        parent.replaceChild(n, var);\n        reportCodeChange();\n\n        return var;\n      }\n    }\n\n    return n;\n  }", "javadoc_start_line": 252, "annotations_start_line": 258, "method_start_line": 258, "end_line": 462}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java", "method_name": "isFoldableExpressBlock", "content": "  /**\n   * @return Whether the node is a block with a single statement that is\n   *     an expression.\n   */\n  private boolean isFoldableExpressBlock(Node n) {\n    if (n.getType() == Token.BLOCK) {\n      if (n.hasOneChild()) {\n        Node maybeExpr = n.getFirstChild();\n          // IE has a bug where event handlers behave differently when\n          // their return value is used vs. when their return value is in\n          // an EXPR_RESULT. It's pretty freaking weird. See:\n          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n          // We try to detect this case, and not fold EXPR_RESULTs\n          // into other expressions.\n\n            // We only have to worry about methods with an implicit 'this'\n            // param, or this doesn't happen.\n\n          return NodeUtil.isExpressionNode(maybeExpr);\n      }\n    }\n\n    return false;\n  }", "javadoc_start_line": 515, "annotations_start_line": 519, "method_start_line": 519, "end_line": 538}]}], "project": {"name": "Closure", "version": 87}}