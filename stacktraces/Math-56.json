{"tours": [{"failing_test": {"className": " org.apache.commons.math.util.MultidimensionalCounterTest", "methodName": "testIterationConsistency", "error": "junit.framework.AssertionFailedError", "message": "Wrong multidimensional index for [3][2] expected:<3> but was:<2>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java", "method_name": "getCounts", "content": "    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        int idx = 1;\n        while (count < index) {\n            count += idx;\n            ++idx;\n        }\n        --idx;\n        indices[last] = idx;\n\n        return indices;\n    }", "javadoc_start_line": 208, "annotations_start_line": 216, "method_start_line": 216, "end_line": 246}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/util/MultidimensionalCounterTest.java", "method_name": "testIterationConsistency", "content": "    public void testIterationConsistency() {\n        final MultidimensionalCounter c = new MultidimensionalCounter(2, 3, 4);\n        final int[][] expected = new int[][] {\n            { 0, 0, 0 },\n            { 0, 0, 1 },\n            { 0, 0, 2 },\n            { 0, 0, 3 },\n            { 0, 1, 0 },\n            { 0, 1, 1 },\n            { 0, 1, 2 },\n            { 0, 1, 3 },\n            { 0, 2, 0 },\n            { 0, 2, 1 },\n            { 0, 2, 2 },\n            { 0, 2, 3 },\n            { 1, 0, 0 },\n            { 1, 0, 1 },\n            { 1, 0, 2 },\n            { 1, 0, 3 },\n            { 1, 1, 0 },\n            { 1, 1, 1 },\n            { 1, 1, 2 },\n            { 1, 1, 3 },\n            { 1, 2, 0 },\n            { 1, 2, 1 },\n            { 1, 2, 2 },\n            { 1, 2, 3 }\n        };\n\n        final int totalSize = c.getSize();\n        final int nDim = c.getDimension();\n        final MultidimensionalCounter.Iterator iter = c.iterator();\n        for (int i = 0; i < totalSize; i++) {\n            if (!iter.hasNext()) {\n                Assert.fail(\"Too short\");\n            }\n            final int uniDimIndex = iter.next();\n            Assert.assertEquals(\"Wrong iteration at \" + i, i, uniDimIndex);\n\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n                                    expected[i][dimIndex], iter.getCount(dimIndex));\n            }\n\n            Assert.assertEquals(\"Wrong unidimensional index for [\" + i + \"]\",\n                                c.getCount(expected[i]), uniDimIndex);\n\n            final int[] indices = c.getCounts(uniDimIndex);\n            for (int dimIndex = 0; dimIndex < nDim; dimIndex++) {\n                Assert.assertEquals(\"Wrong multidimensional index for [\" + i + \"][\" + dimIndex + \"]\",\n                                    expected[i][dimIndex], indices[dimIndex]);\n            }\n        }\n\n        if (iter.hasNext()) {\n            Assert.fail(\"Too long\");\n        }\n    }", "javadoc_start_line": 123, "annotations_start_line": 122, "method_start_line": 123, "end_line": 180}, {"file_path": "/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java", "method_name": "getCounts", "content": "    /**\n     * Convert to multidimensional counter.\n     *\n     * @param index Index in unidimensional counter.\n     * @return the multidimensional counts.\n     * @throws OutOfRangeException if {@code index} is not between\n     * {@code 0} and the value returned by {@link #getSize()} (excluded).\n     */\n    public int[] getCounts(int index) {\n        if (index < 0 ||\n            index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        final int[] indices = new int[dimension];\n\n        int count = 0;\n        for (int i = 0; i < last; i++) {\n            int idx = 0;\n            final int offset = uniCounterOffset[i];\n            while (count <= index) {\n                count += offset;\n                ++idx;\n            }\n            --idx;\n            count -= offset;\n            indices[i] = idx;\n        }\n\n        int idx = 1;\n        while (count < index) {\n            count += idx;\n            ++idx;\n        }\n        --idx;\n        indices[last] = idx;\n\n        return indices;\n    }", "javadoc_start_line": 208, "annotations_start_line": 216, "method_start_line": 216, "end_line": 246}]}], "project": {"name": "Math", "version": 56}}