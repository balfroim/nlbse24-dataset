{"tours": [{"failing_test": {"className": " org.joda.time.TestDays", "methodName": "testFactory_daysBetween_RPartial_MonthDay", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java", "method_name": "between", "content": "    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n        return values[0];\n    }", "javadoc_start_line": 76, "annotations_start_line": 88, "method_start_line": 88, "end_line": 106}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestDays.java", "method_name": "testFactory_daysBetween_RPartial_MonthDay", "content": "    public void testFactory_daysBetween_RPartial_MonthDay() {\n        MonthDay start1 = new MonthDay(2, 1);\n        MonthDay start2 = new MonthDay(2, 28);\n        MonthDay end1 = new MonthDay(2, 28);\n        MonthDay end2 = new MonthDay(2, 29);\n        \n        assertEquals(27, Days.daysBetween(start1, end1).getDays());\n        assertEquals(28, Days.daysBetween(start1, end2).getDays());\n        assertEquals(0, Days.daysBetween(start2, end1).getDays());\n        assertEquals(1, Days.daysBetween(start2, end2).getDays());\n        \n        assertEquals(-27, Days.daysBetween(end1, start1).getDays());\n        assertEquals(-28, Days.daysBetween(end2, start1).getDays());\n        assertEquals(0, Days.daysBetween(end1, start2).getDays());\n        assertEquals(-1, Days.daysBetween(end2, start2).getDays());\n    }", "javadoc_start_line": 123, "annotations_start_line": 123, "method_start_line": 123, "end_line": 138}, {"file_path": "/src/main/java/org/joda/time/Days.java", "method_name": "daysBetween", "content": "    /**\n     * Creates a <code>Days</code> representing the number of whole days\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in days\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    public static Days daysBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int days = chrono.days().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return Days.days(days);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Days.days(amount);\n    }", "javadoc_start_line": 122, "annotations_start_line": 134, "method_start_line": 134, "end_line": 143}, {"file_path": "/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java", "method_name": "between", "content": "    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n        return values[0];\n    }", "javadoc_start_line": 76, "annotations_start_line": 88, "method_start_line": 88, "end_line": 106}]}, {"failing_test": {"className": " org.joda.time.TestMonths", "methodName": "testFactory_monthsBetween_RPartial_MonthDay", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 29 for dayOfMonth must be in the range [1,28]"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java", "method_name": "between", "content": "    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n        return values[0];\n    }", "javadoc_start_line": 76, "annotations_start_line": 88, "method_start_line": 88, "end_line": 106}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestMonths.java", "method_name": "testFactory_monthsBetween_RPartial_MonthDay", "content": "    public void testFactory_monthsBetween_RPartial_MonthDay() {\n        MonthDay start = new MonthDay(2, 1);\n        MonthDay end1 = new MonthDay(2, 28);\n        MonthDay end2 = new MonthDay(2, 29);\n        MonthDay end3 = new MonthDay(3, 1);\n        \n        assertEquals(0, Months.monthsBetween(start, end1).getMonths());\n        assertEquals(0, Months.monthsBetween(start, end2).getMonths());\n        assertEquals(1, Months.monthsBetween(start, end3).getMonths());\n        \n        assertEquals(0, Months.monthsBetween(end1, start).getMonths());\n        assertEquals(0, Months.monthsBetween(end2, start).getMonths());\n        assertEquals(-1, Months.monthsBetween(end3, start).getMonths());\n    }", "javadoc_start_line": 130, "annotations_start_line": 130, "method_start_line": 130, "end_line": 143}, {"file_path": "/src/main/java/org/joda/time/Months.java", "method_name": "monthsBetween", "content": "    /**\n     * Creates a <code>Months</code> representing the number of whole months\n     * between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, must not be null\n     * @param end  the end partial date, must not be null\n     * @return the period in months\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int months = chrono.months().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return Months.months(months);\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n        return Months.months(amount);\n    }", "javadoc_start_line": 142, "annotations_start_line": 154, "method_start_line": 154, "end_line": 163}, {"file_path": "/src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java", "method_name": "between", "content": "    /**\n     * Calculates the number of whole units between the two specified partial datetimes.\n     * <p>\n     * The two partials must contain the same fields, for example you can specify\n     * two <code>LocalDate</code> objects.\n     *\n     * @param start  the start partial date, validated to not be null\n     * @param end  the end partial date, validated to not be null\n     * @param zeroInstance  the zero instance constant, must not be null\n     * @return the period\n     * @throws IllegalArgumentException if the partials are null or invalid\n     */\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n        }\n        if (DateTimeUtils.isContiguous(start) == false) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n        return values[0];\n    }", "javadoc_start_line": 76, "annotations_start_line": 88, "method_start_line": 88, "end_line": 106}]}], "project": {"name": "Time", "version": 10}}