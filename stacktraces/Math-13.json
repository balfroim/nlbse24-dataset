{"tours": [{"failing_test": {"className": " org.apache.commons.math3.optimization.fitting.PolynomialFitterTest", "methodName": "testLargeSample", "error": "java.lang.OutOfMemoryError", "message": "Java heap space"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java", "method_name": "squareRoot", "content": "    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }", "javadoc_start_line": 555, "annotations_start_line": 561, "method_start_line": 561, "end_line": 564}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java", "method_name": "testLargeSample", "content": "    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }", "javadoc_start_line": 224, "annotations_start_line": 223, "method_start_line": 224, "end_line": 248}, {"file_path": "/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java", "method_name": "testLargeSample", "content": "    public void testLargeSample() {\n        Random randomizer = new Random(0x5551480dca5b369bl);\n        double maxError = 0;\n        for (int degree = 0; degree < 10; ++degree) {\n            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);\n\n            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());\n            for (int i = 0; i < 40000; ++i) {\n                double x = -1.0 + i / 20000.0;\n                fitter.addObservedPoint(1.0, x,\n                                        p.value(x) + 0.1 * randomizer.nextGaussian());\n            }\n\n            final double[] init = new double[degree + 1];\n            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));\n\n            for (double x = -1.0; x < 1.0; x += 0.01) {\n                double error = FastMath.abs(p.value(x) - fitted.value(x)) /\n                              (1.0 + FastMath.abs(p.value(x)));\n                maxError = FastMath.max(maxError, error);\n                Assert.assertTrue(FastMath.abs(error) < 0.01);\n            }\n        }\n        Assert.assertTrue(maxError > 0.001);\n    }", "javadoc_start_line": 227, "annotations_start_line": 226, "method_start_line": 227, "end_line": 251}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java", "method_name": "fit", "content": "    /**\n     * Get the coefficients of the polynomial fitting the weighted data points.\n     * The degree of the fitting polynomial is {@code guess.length - 1}.\n     *\n     * @param guess First guess for the coefficients. They must be sorted in\n     * increasing order of the polynomial's degree.\n     * @return the coefficients of the polynomial that best fits the observed points.\n     * @throws org.apache.commons.math3.exception.ConvergenceException\n     * if the algorithm failed to converge.\n     * @since 3.1\n     */\n    public double[] fit(double[] guess) {\n        return fit(new PolynomialFunction.Parametric(), guess);\n    }", "javadoc_start_line": 98, "annotations_start_line": 109, "method_start_line": 109, "end_line": 111}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/fitting/CurveFitter.java", "method_name": "fit", "content": "    /**\n     * Fit a curve.\n     * This method compute the coefficients of the curve that best\n     * fit the sample of observed points previously given through calls\n     * to the {@link #addObservedPoint(WeightedObservedPoint)\n     * addObservedPoint} method.\n     *\n     * @param f parametric function to fit.\n     * @param initialGuess first guess of the function parameters.\n     * @return the fitted parameters.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     */\n    public double[] fit(T f, final double[] initialGuess) {\n        return fit(Integer.MAX_VALUE, f, initialGuess);\n    }", "javadoc_start_line": 139, "annotations_start_line": 152, "method_start_line": 152, "end_line": 154}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/fitting/CurveFitter.java", "method_name": "fit", "content": "    /**\n     * Fit a curve.\n     * This method compute the coefficients of the curve that best\n     * fit the sample of observed points previously given through calls\n     * to the {@link #addObservedPoint(WeightedObservedPoint)\n     * addObservedPoint} method.\n     *\n     * @param f parametric function to fit.\n     * @param initialGuess first guess of the function parameters.\n     * @param maxEval Maximum number of function evaluations.\n     * @return the fitted parameters.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException\n     * if the number of allowed evaluations is exceeded.\n     * @throws org.apache.commons.math3.exception.DimensionMismatchException\n     * if the start point dimension is wrong.\n     * @since 3.0\n     */\n    public double[] fit(int maxEval, T f,\n                        final double[] initialGuess) {\n        // prepare least squares problem\n        double[] target  = new double[observations.size()];\n        double[] weights = new double[observations.size()];\n        int i = 0;\n        for (WeightedObservedPoint point : observations) {\n            target[i]  = point.getY();\n            weights[i] = point.getWeight();\n            ++i;\n        }\n\n        // perform the fit\n        final PointVectorValuePair optimum;\n        if (optimizer == null) {\n            // to be removed in 4.0\n            optimum = oldOptimizer.optimize(maxEval, new OldTheoreticalValuesFunction(f),\n                                            target, weights, initialGuess);\n        } else {\n            optimum = optimizer.optimize(maxEval, new TheoreticalValuesFunction(f),\n                                         target, weights, initialGuess);\n        }\n\n        // extract the coefficients\n        return optimum.getPointRef();\n    }", "javadoc_start_line": 156, "annotations_start_line": 173, "method_start_line": 174, "end_line": 198}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java", "method_name": "optimize", "content": "    /** {@inheritDoc}\n     * @deprecated As of 3.1. Please use\n     * {@link BaseAbstractMultivariateVectorOptimizer#optimize(int,MultivariateVectorFunction,OptimizationData[])\n     * optimize(int,MultivariateDifferentiableVectorFunction,OptimizationData...)}\n     * instead.\n     */\n    @Override\n    @Deprecated\n    public PointVectorValuePair optimize(int maxEval,\n                                         final DifferentiableMultivariateVectorFunction f,\n                                         final double[] target, final double[] weights,\n                                         final double[] startPoint) {\n        return optimizeInternal(maxEval,\n                                FunctionUtils.toMultivariateDifferentiableVectorFunction(f),\n                                new Target(target),\n                                new Weight(weights),\n                                new InitialGuess(startPoint));\n    }", "javadoc_start_line": 411, "annotations_start_line": 417, "method_start_line": 422, "end_line": 428}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java", "method_name": "optimizeInternal", "content": "    /**\n     * Optimize an objective function.\n     * Optimization is considered to be a weighted least-squares minimization.\n     * The cost function to be minimized is\n     * <code>&sum;weight<sub>i</sub>(objective<sub>i</sub> - target<sub>i</sub>)<sup>2</sup></code>\n     *\n     * @param maxEval Allowed number of evaluations of the objective function.\n     * @param f Objective function.\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Target}</li>\n     *  <li>{@link Weight}</li>\n     *  <li>{@link InitialGuess}</li>\n     * </ul>\n     * @return the point/value pair giving the optimal value of the objective\n     * function.\n     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if\n     * the maximal number of evaluations is exceeded.\n     * @throws DimensionMismatchException if the target, and weight arguments\n     * have inconsistent dimensions.\n     * @see BaseAbstractMultivariateVectorOptimizer#optimizeInternal(int,MultivariateVectorFunction,OptimizationData[])\n     * @since 3.1\n     * @deprecated As of 3.1. Override is necessary only until this class's generic\n     * argument is changed to {@code MultivariateDifferentiableVectorFunction}.\n     */\n    @Deprecated\n    protected PointVectorValuePair optimizeInternal(final int maxEval,\n                                                    final MultivariateDifferentiableVectorFunction f,\n                                                    OptimizationData... optData) {\n        // XXX Conversion will be removed when the generic argument of the\n        // base class becomes \"MultivariateDifferentiableVectorFunction\".\n        return super.optimizeInternal(maxEval, FunctionUtils.toDifferentiableMultivariateVectorFunction(f), optData);\n    }", "javadoc_start_line": 465, "annotations_start_line": 490, "method_start_line": 493, "end_line": 497}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/direct/BaseAbstractMultivariateVectorOptimizer.java", "method_name": "optimizeInternal", "content": "    /**\n     * Optimize an objective function.\n     *\n     * @param maxEval Allowed number of evaluations of the objective function.\n     * @param f Objective function.\n     * @param optData Optimization data. The following data will be looked for:\n     * <ul>\n     *  <li>{@link Target}</li>\n     *  <li>{@link Weight}</li>\n     *  <li>{@link InitialGuess}</li>\n     * </ul>\n     * @return the point/value pair giving the optimal value of the objective\n     * function.\n     * @throws TooManyEvaluationsException if the maximal number of\n     * evaluations is exceeded.\n     * @throws DimensionMismatchException if the initial guess, target, and weight\n     * arguments have inconsistent dimensions.\n     *\n     * @since 3.1\n     */\n    protected PointVectorValuePair optimizeInternal(int maxEval,\n                                                    FUNC f,\n                                                    OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {\n        // Set internal state.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n        function = f;\n        // Retrieve other settings.\n        parseOptimizationData(optData);\n        // Check input consistency.\n        checkParameters();\n        // Allow subclasses to reset their own internal state.\n        setUp();\n        // Perform computation.\n        return doOptimize();\n    }", "javadoc_start_line": 205, "annotations_start_line": 225, "method_start_line": 229, "end_line": 242}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java", "method_name": "setUp", "content": "    /** {@inheritDoc} */\n    @Override\n    protected void setUp() {\n        super.setUp();\n\n        // Reset counter.\n        jacobianEvaluations = 0;\n\n        // Square-root of the weight matrix.\n        weightMatrixSqrt = squareRoot(getWeight());\n\n        // Store least squares problem characteristics.\n        // XXX The conversion won't be necessary when the generic argument of\n        // the base class becomes \"MultivariateDifferentiableVectorFunction\".\n        // XXX \"jF\" is not strictly necessary anymore but is currently more\n        // efficient than converting the value returned from \"getObjectiveFunction()\"\n        // every time it is used.\n        jF = FunctionUtils.toMultivariateDifferentiableVectorFunction((DifferentiableMultivariateVectorFunction) getObjectiveFunction());\n\n        // Arrays shared with \"private\" and \"protected\" methods.\n        point = getStartPoint();\n        rows = getTarget().length;\n        cols = point.length;\n    }", "javadoc_start_line": 499, "annotations_start_line": 500, "method_start_line": 501, "end_line": 522}, {"file_path": "/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java", "method_name": "squareRoot", "content": "    /**\n     * Computes the square-root of the weight matrix.\n     *\n     * @param m Symmetric, positive-definite (weight) matrix.\n     * @return the square-root of the weight matrix.\n     */\n    private RealMatrix squareRoot(RealMatrix m) {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n    }", "javadoc_start_line": 555, "annotations_start_line": 561, "method_start_line": 561, "end_line": 564}]}], "project": {"name": "Math", "version": 13}}