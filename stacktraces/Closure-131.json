{
    "tours": [
        {
            "failing_test": {
                "className": " com.google.javascript.jscomp.ConvertToDottedPropertiesTest",
                "methodName": "testQuotedProps",
                "error": "junit.framework.AssertionFailedError",
                "message": ""
            },
            "patched_method": {
                "file_path": "/src/com/google/javascript/rhino/TokenStream.java",
                "method_name": "isJSIdentifier",
                "content": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
                "javadoc_start_line": 190,
                "annotations_start_line": 190,
                "method_start_line": 190,
                "end_line": 206
            },
            "steps": [
                {
                    "file_path": "/src/com/google/javascript/jscomp/Compiler.java",
                    "method_name": "toSource",
                    "content": "  /**\n   * Generates JavaScript source code for an AST, doesn't generate source\n   * map info.\n   */\n  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null, true);\n  }",
                    "javadoc_start_line": 1801,
                    "annotations_start_line": 1805,
                    "method_start_line": 1806,
                    "end_line": 1809
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/Compiler.java",
                    "method_name": "toSource",
                    "content": "  /**\n   * Generates JavaScript source code for an AST.\n   */\n  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setCompilerOptions(options);\n    builder.setSourceMap(sourceMap);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    return builder.build();\n  }",
                    "javadoc_start_line": 1811,
                    "annotations_start_line": 1814,
                    "method_start_line": 1814,
                    "end_line": 1821
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodePrinter.java",
                    "method_name": "CodePrinter",
                    "content": "class CodePrinter {",
                    "javadoc_start_line": 36,
                    "annotations_start_line": 36,
                    "method_start_line": 36,
                    "end_line": 36
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodePrinter.java",
                    "method_name": "<clinit>",
                    "content": "class CodePrinter {",
                    "javadoc_start_line": 36,
                    "annotations_start_line": 36,
                    "method_start_line": 36,
                    "end_line": 36
                },
                {
                    "file_path": "/lib/rhino/toolsrc/org/mozilla/javascript/tools/idswitch/CodePrinter.java",
                    "method_name": "ensure_area",
                    "content": "    private int ensure_area(int area_size) {\n        int begin = offset;\n        int end = begin + area_size;\n        if (end > buffer.length) {\n            int new_capacity = buffer.length * 2;\n            if (end > new_capacity) { new_capacity = end; }\n            char[] tmp = new char[new_capacity];\n            System.arraycopy(buffer, 0, tmp, 0, begin);\n            buffer = tmp;\n        }\n        return begin;\n    }",
                    "javadoc_start_line": 34,
                    "annotations_start_line": 34,
                    "method_start_line": 34,
                    "end_line": 45
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodePrinter.java",
                    "method_name": "toSource",
                    "content": "  /**\n   * Converts a tree to JS code\n   */\n  private static String toSource(Node root, Format outputFormat,\n      CompilerOptions options, JSTypeRegistry registry,\n      SourceMap sourceMap,  boolean tagAsStrict) {\n    Preconditions.checkState(options.sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            options.lineBreak,\n            options.preferLineBreakAtEndOfFile,\n            options.lineLengthThreshold,\n            createSourceMap,\n            options.sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            options.lineLengthThreshold,\n            createSourceMap,\n            options.sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, options, registry)\n        : new CodeGenerator(mcp, options);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }",
                    "javadoc_start_line": 651,
                    "annotations_start_line": 654,
                    "method_start_line": 656,
                    "end_line": 691
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodeGenerator.java",
                    "method_name": "add",
                    "content": "  void add(Node n) {\n    add(n, Context.OTHER);\n  }",
                    "javadoc_start_line": 99,
                    "annotations_start_line": 99,
                    "method_start_line": 99,
                    "end_line": 101
                },
                {
                    "file_path": "/lib/rhino/src/org/mozilla/javascript/CodeGenerator.java",
                    "method_name": "generateFunctionICode",
                    "content": "    private void generateFunctionICode()\n    {\n        itsInFunctionFlag = true;\n\n        FunctionNode theFunction = (FunctionNode)scriptOrFn;\n\n        itsData.itsFunctionType = theFunction.getFunctionType();\n        itsData.itsNeedsActivation = theFunction.requiresActivation();\n        if (theFunction.getFunctionName() != null) {\n            itsData.itsName = theFunction.getName();\n        }\n        if (theFunction.isGenerator()) {\n          addIcode(Icode_GENERATOR);\n          addUint16(theFunction.getBaseLineno() & 0xFFFF);\n        }\n\n        generateICodeFromTree(theFunction.getLastChild());\n    }",
                    "javadoc_start_line": 88,
                    "annotations_start_line": 88,
                    "method_start_line": 89,
                    "end_line": 105
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodeGenerator.java",
                    "method_name": "add",
                    "content": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
                    "javadoc_start_line": 103,
                    "annotations_start_line": 103,
                    "method_start_line": 103,
                    "end_line": 756
                },
                {
                    "file_path": "/lib/rhino/src/org/mozilla/javascript/CodeGenerator.java",
                    "method_name": "visitStatement",
                    "content": "    private void visitStatement(Node node, int initialStackDepth)\n    {\n        int type = node.getType();\n        Node child = node.getFirstChild();\n        switch (type) {\n\n          case Token.FUNCTION:\n            {\n                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n                int fnType = scriptOrFn.getFunctionNode(fnIndex).\n                                 getFunctionType();\n                // Only function expressions or function expression\n                // statements need closure code creating new function\n                // object on stack as function statements are initialized\n                // at script/function start.\n                // In addition, function expressions can not be present here\n                // at statement level, they must only be present as expressions.\n                if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {\n                    addIndexOp(Icode_CLOSURE_STMT, fnIndex);\n                } else {\n                    if (fnType != FunctionNode.FUNCTION_STATEMENT) {\n                        throw Kit.codeBug();\n                    }\n                }\n                // For function statements or function expression statements\n                // in scripts, we need to ensure that the result of the script\n                // is the function if it is the last statement in the script.\n                // For example, eval(\"function () {}\") should return a\n                // function, not undefined.\n                if (!itsInFunctionFlag) {\n                    addIndexOp(Icode_CLOSURE_EXPR, fnIndex);\n                    stackChange(1);\n                    addIcode(Icode_POP_RESULT);\n                    stackChange(-1);\n                }\n            }\n            break;\n\n          case Token.LABEL:\n          case Token.LOOP:\n          case Token.BLOCK:\n          case Token.EMPTY:\n          case Token.WITH:\n            updateLineNumber(node);\n          case Token.SCRIPT:\n            // fall through\n            while (child != null) {\n                visitStatement(child, initialStackDepth);\n                child = child.getNext();\n            }\n            break;\n\n          case Token.ENTERWITH:\n            visitExpression(child, 0);\n            addToken(Token.ENTERWITH);\n            stackChange(-1);\n            break;\n\n          case Token.LEAVEWITH:\n            addToken(Token.LEAVEWITH);\n            break;\n\n          case Token.LOCAL_BLOCK:\n            {\n                int local = allocLocal();\n                node.putIntProp(Node.LOCAL_PROP, local);\n                updateLineNumber(node);\n                while (child != null) {\n                    visitStatement(child, initialStackDepth);\n                    child = child.getNext();\n                }\n                addIndexOp(Icode_LOCAL_CLEAR, local);\n                releaseLocal(local);\n            }\n            break;\n\n          case Token.DEBUGGER:\n            addIcode(Icode_DEBUGGER);\n            break;\n\n          case Token.SWITCH:\n            updateLineNumber(node);\n            // See comments in IRFactory.createSwitch() for description\n            // of SWITCH node\n            {\n                visitExpression(child, 0);\n                for (Jump caseNode = (Jump)child.getNext();\n                     caseNode != null;\n                     caseNode = (Jump)caseNode.getNext())\n                {\n                    if (caseNode.getType() != Token.CASE)\n                        throw badTree(caseNode);\n                    Node test = caseNode.getFirstChild();\n                    addIcode(Icode_DUP);\n                    stackChange(1);\n                    visitExpression(test, 0);\n                    addToken(Token.SHEQ);\n                    stackChange(-1);\n                    // If true, Icode_IFEQ_POP will jump and remove case\n                    // value from stack\n                    addGoto(caseNode.target, Icode_IFEQ_POP);\n                    stackChange(-1);\n                }\n                addIcode(Icode_POP);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.TARGET:\n            markTargetLabel(node);\n            break;\n\n          case Token.IFEQ :\n          case Token.IFNE :\n            {\n                Node target = ((Jump)node).target;\n                visitExpression(child, 0);\n                addGoto(target, type);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.GOTO:\n            {\n                Node target = ((Jump)node).target;\n                addGoto(target, type);\n            }\n            break;\n\n          case Token.JSR:\n            {\n                Node target = ((Jump)node).target;\n                addGoto(target, Icode_GOSUB);\n            }\n            break;\n\n          case Token.FINALLY:\n            {\n                // Account for incomming GOTOSUB address\n                stackChange(1);\n                int finallyRegister = getLocalBlockRef(node);\n                addIndexOp(Icode_STARTSUB, finallyRegister);\n                stackChange(-1);\n                while (child != null) {\n                    visitStatement(child, initialStackDepth);\n                    child = child.getNext();\n                }\n                addIndexOp(Icode_RETSUB, finallyRegister);\n            }\n            break;\n\n          case Token.EXPR_VOID:\n          case Token.EXPR_RESULT:\n            updateLineNumber(node);\n            visitExpression(child, 0);\n            addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);\n            stackChange(-1);\n            break;\n\n          case Token.TRY:\n            {\n                Jump tryNode = (Jump)node;\n                int exceptionObjectLocal = getLocalBlockRef(tryNode);\n                int scopeLocal = allocLocal();\n\n                addIndexOp(Icode_SCOPE_SAVE, scopeLocal);\n\n                int tryStart = iCodeTop;\n                boolean savedFlag = itsInTryFlag;\n                itsInTryFlag = true;\n                while (child != null) {\n                    visitStatement(child, initialStackDepth);\n                    child = child.getNext();\n                }\n                itsInTryFlag = savedFlag;\n\n                Node catchTarget = tryNode.target;\n                if (catchTarget != null) {\n                    int catchStartPC\n                        = labelTable[getTargetLabel(catchTarget)];\n                    addExceptionHandler(\n                        tryStart, catchStartPC, catchStartPC,\n                        false, exceptionObjectLocal, scopeLocal);\n                }\n                Node finallyTarget = tryNode.getFinally();\n                if (finallyTarget != null) {\n                    int finallyStartPC\n                        = labelTable[getTargetLabel(finallyTarget)];\n                    addExceptionHandler(\n                        tryStart, finallyStartPC, finallyStartPC,\n                        true, exceptionObjectLocal, scopeLocal);\n                }\n\n                addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);\n                releaseLocal(scopeLocal);\n            }\n            break;\n\n          case Token.CATCH_SCOPE:\n            {\n                int localIndex = getLocalBlockRef(node);\n                int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);\n                String name = child.getString();\n                child = child.getNext();\n                visitExpression(child, 0); // load expression object\n                addStringPrefix(name);\n                addIndexPrefix(localIndex);\n                addToken(Token.CATCH_SCOPE);\n                addUint8(scopeIndex != 0 ? 1 : 0);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.THROW:\n            updateLineNumber(node);\n            visitExpression(child, 0);\n            addToken(Token.THROW);\n            addUint16(lineNumber & 0xFFFF);\n            stackChange(-1);\n            break;\n\n          case Token.RETHROW:\n            updateLineNumber(node);\n            addIndexOp(Token.RETHROW, getLocalBlockRef(node));\n            break;\n\n          case Token.RETURN:\n            updateLineNumber(node);\n            if (node.getIntProp(Node.GENERATOR_END_PROP, 0) != 0) {\n                // We're in a generator, so change RETURN to GENERATOR_END\n                addIcode(Icode_GENERATOR_END);\n                addUint16(lineNumber & 0xFFFF);\n            } else if (child != null) {\n                visitExpression(child, ECF_TAIL);\n                addToken(Token.RETURN);\n                stackChange(-1);\n            } else {\n                addIcode(Icode_RETUNDEF);\n            }\n            break;\n\n          case Token.RETURN_RESULT:\n            updateLineNumber(node);\n            addToken(Token.RETURN_RESULT);\n            break;\n\n          case Token.ENUM_INIT_KEYS:\n          case Token.ENUM_INIT_VALUES:\n          case Token.ENUM_INIT_ARRAY:\n            visitExpression(child, 0);\n            addIndexOp(type, getLocalBlockRef(node));\n            stackChange(-1);\n            break;\n\n          case Icode_GENERATOR:\n            break;\n\n          default:\n            throw badTree(node);\n        }\n\n        if (stackDepth != initialStackDepth) {\n            throw Kit.codeBug();\n        }\n    }",
                    "javadoc_start_line": 229,
                    "annotations_start_line": 229,
                    "method_start_line": 230,
                    "end_line": 493
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodeGenerator.java",
                    "method_name": "add",
                    "content": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
                    "javadoc_start_line": 103,
                    "annotations_start_line": 103,
                    "method_start_line": 103,
                    "end_line": 756
                },
                {
                    "file_path": "/lib/rhino/src/org/mozilla/javascript/CodeGenerator.java",
                    "method_name": "visitStatement",
                    "content": "    private void visitStatement(Node node, int initialStackDepth)\n    {\n        int type = node.getType();\n        Node child = node.getFirstChild();\n        switch (type) {\n\n          case Token.FUNCTION:\n            {\n                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n                int fnType = scriptOrFn.getFunctionNode(fnIndex).\n                                 getFunctionType();\n                // Only function expressions or function expression\n                // statements need closure code creating new function\n                // object on stack as function statements are initialized\n                // at script/function start.\n                // In addition, function expressions can not be present here\n                // at statement level, they must only be present as expressions.\n                if (fnType == FunctionNode.FUNCTION_EXPRESSION_STATEMENT) {\n                    addIndexOp(Icode_CLOSURE_STMT, fnIndex);\n                } else {\n                    if (fnType != FunctionNode.FUNCTION_STATEMENT) {\n                        throw Kit.codeBug();\n                    }\n                }\n                // For function statements or function expression statements\n                // in scripts, we need to ensure that the result of the script\n                // is the function if it is the last statement in the script.\n                // For example, eval(\"function () {}\") should return a\n                // function, not undefined.\n                if (!itsInFunctionFlag) {\n                    addIndexOp(Icode_CLOSURE_EXPR, fnIndex);\n                    stackChange(1);\n                    addIcode(Icode_POP_RESULT);\n                    stackChange(-1);\n                }\n            }\n            break;\n\n          case Token.LABEL:\n          case Token.LOOP:\n          case Token.BLOCK:\n          case Token.EMPTY:\n          case Token.WITH:\n            updateLineNumber(node);\n          case Token.SCRIPT:\n            // fall through\n            while (child != null) {\n                visitStatement(child, initialStackDepth);\n                child = child.getNext();\n            }\n            break;\n\n          case Token.ENTERWITH:\n            visitExpression(child, 0);\n            addToken(Token.ENTERWITH);\n            stackChange(-1);\n            break;\n\n          case Token.LEAVEWITH:\n            addToken(Token.LEAVEWITH);\n            break;\n\n          case Token.LOCAL_BLOCK:\n            {\n                int local = allocLocal();\n                node.putIntProp(Node.LOCAL_PROP, local);\n                updateLineNumber(node);\n                while (child != null) {\n                    visitStatement(child, initialStackDepth);\n                    child = child.getNext();\n                }\n                addIndexOp(Icode_LOCAL_CLEAR, local);\n                releaseLocal(local);\n            }\n            break;\n\n          case Token.DEBUGGER:\n            addIcode(Icode_DEBUGGER);\n            break;\n\n          case Token.SWITCH:\n            updateLineNumber(node);\n            // See comments in IRFactory.createSwitch() for description\n            // of SWITCH node\n            {\n                visitExpression(child, 0);\n                for (Jump caseNode = (Jump)child.getNext();\n                     caseNode != null;\n                     caseNode = (Jump)caseNode.getNext())\n                {\n                    if (caseNode.getType() != Token.CASE)\n                        throw badTree(caseNode);\n                    Node test = caseNode.getFirstChild();\n                    addIcode(Icode_DUP);\n                    stackChange(1);\n                    visitExpression(test, 0);\n                    addToken(Token.SHEQ);\n                    stackChange(-1);\n                    // If true, Icode_IFEQ_POP will jump and remove case\n                    // value from stack\n                    addGoto(caseNode.target, Icode_IFEQ_POP);\n                    stackChange(-1);\n                }\n                addIcode(Icode_POP);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.TARGET:\n            markTargetLabel(node);\n            break;\n\n          case Token.IFEQ :\n          case Token.IFNE :\n            {\n                Node target = ((Jump)node).target;\n                visitExpression(child, 0);\n                addGoto(target, type);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.GOTO:\n            {\n                Node target = ((Jump)node).target;\n                addGoto(target, type);\n            }\n            break;\n\n          case Token.JSR:\n            {\n                Node target = ((Jump)node).target;\n                addGoto(target, Icode_GOSUB);\n            }\n            break;\n\n          case Token.FINALLY:\n            {\n                // Account for incomming GOTOSUB address\n                stackChange(1);\n                int finallyRegister = getLocalBlockRef(node);\n                addIndexOp(Icode_STARTSUB, finallyRegister);\n                stackChange(-1);\n                while (child != null) {\n                    visitStatement(child, initialStackDepth);\n                    child = child.getNext();\n                }\n                addIndexOp(Icode_RETSUB, finallyRegister);\n            }\n            break;\n\n          case Token.EXPR_VOID:\n          case Token.EXPR_RESULT:\n            updateLineNumber(node);\n            visitExpression(child, 0);\n            addIcode((type == Token.EXPR_VOID) ? Icode_POP : Icode_POP_RESULT);\n            stackChange(-1);\n            break;\n\n          case Token.TRY:\n            {\n                Jump tryNode = (Jump)node;\n                int exceptionObjectLocal = getLocalBlockRef(tryNode);\n                int scopeLocal = allocLocal();\n\n                addIndexOp(Icode_SCOPE_SAVE, scopeLocal);\n\n                int tryStart = iCodeTop;\n                boolean savedFlag = itsInTryFlag;\n                itsInTryFlag = true;\n                while (child != null) {\n                    visitStatement(child, initialStackDepth);\n                    child = child.getNext();\n                }\n                itsInTryFlag = savedFlag;\n\n                Node catchTarget = tryNode.target;\n                if (catchTarget != null) {\n                    int catchStartPC\n                        = labelTable[getTargetLabel(catchTarget)];\n                    addExceptionHandler(\n                        tryStart, catchStartPC, catchStartPC,\n                        false, exceptionObjectLocal, scopeLocal);\n                }\n                Node finallyTarget = tryNode.getFinally();\n                if (finallyTarget != null) {\n                    int finallyStartPC\n                        = labelTable[getTargetLabel(finallyTarget)];\n                    addExceptionHandler(\n                        tryStart, finallyStartPC, finallyStartPC,\n                        true, exceptionObjectLocal, scopeLocal);\n                }\n\n                addIndexOp(Icode_LOCAL_CLEAR, scopeLocal);\n                releaseLocal(scopeLocal);\n            }\n            break;\n\n          case Token.CATCH_SCOPE:\n            {\n                int localIndex = getLocalBlockRef(node);\n                int scopeIndex = node.getExistingIntProp(Node.CATCH_SCOPE_PROP);\n                String name = child.getString();\n                child = child.getNext();\n                visitExpression(child, 0); // load expression object\n                addStringPrefix(name);\n                addIndexPrefix(localIndex);\n                addToken(Token.CATCH_SCOPE);\n                addUint8(scopeIndex != 0 ? 1 : 0);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.THROW:\n            updateLineNumber(node);\n            visitExpression(child, 0);\n            addToken(Token.THROW);\n            addUint16(lineNumber & 0xFFFF);\n            stackChange(-1);\n            break;\n\n          case Token.RETHROW:\n            updateLineNumber(node);\n            addIndexOp(Token.RETHROW, getLocalBlockRef(node));\n            break;\n\n          case Token.RETURN:\n            updateLineNumber(node);\n            if (node.getIntProp(Node.GENERATOR_END_PROP, 0) != 0) {\n                // We're in a generator, so change RETURN to GENERATOR_END\n                addIcode(Icode_GENERATOR_END);\n                addUint16(lineNumber & 0xFFFF);\n            } else if (child != null) {\n                visitExpression(child, ECF_TAIL);\n                addToken(Token.RETURN);\n                stackChange(-1);\n            } else {\n                addIcode(Icode_RETUNDEF);\n            }\n            break;\n\n          case Token.RETURN_RESULT:\n            updateLineNumber(node);\n            addToken(Token.RETURN_RESULT);\n            break;\n\n          case Token.ENUM_INIT_KEYS:\n          case Token.ENUM_INIT_VALUES:\n          case Token.ENUM_INIT_ARRAY:\n            visitExpression(child, 0);\n            addIndexOp(type, getLocalBlockRef(node));\n            stackChange(-1);\n            break;\n\n          case Icode_GENERATOR:\n            break;\n\n          default:\n            throw badTree(node);\n        }\n\n        if (stackDepth != initialStackDepth) {\n            throw Kit.codeBug();\n        }\n    }",
                    "javadoc_start_line": 229,
                    "annotations_start_line": 229,
                    "method_start_line": 230,
                    "end_line": 493
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodeGenerator.java",
                    "method_name": "add",
                    "content": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
                    "javadoc_start_line": 103,
                    "annotations_start_line": 103,
                    "method_start_line": 103,
                    "end_line": 756
                },
                {
                    "file_path": "/lib/rhino/src/org/mozilla/javascript/CodeGenerator.java",
                    "method_name": "visitExpression",
                    "content": "    private void visitExpression(Node node, int contextFlags)\n    {\n        int type = node.getType();\n        Node child = node.getFirstChild();\n        int savedStackDepth = stackDepth;\n        switch (type) {\n\n          case Token.FUNCTION:\n            {\n                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n                FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);\n                // See comments in visitStatement for Token.FUNCTION case\n                if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {\n                    throw Kit.codeBug();\n                }\n                addIndexOp(Icode_CLOSURE_EXPR, fnIndex);\n                stackChange(1);\n            }\n            break;\n\n          case Token.LOCAL_LOAD:\n            {\n                int localIndex = getLocalBlockRef(node);\n                addIndexOp(Token.LOCAL_LOAD, localIndex);\n                stackChange(1);\n            }\n            break;\n\n          case Token.COMMA:\n            {\n                Node lastChild = node.getLastChild();\n                while (child != lastChild) {\n                    visitExpression(child, 0);\n                    addIcode(Icode_POP);\n                    stackChange(-1);\n                    child = child.getNext();\n                }\n                // Preserve tail context flag if any\n                visitExpression(child, contextFlags & ECF_TAIL);\n            }\n            break;\n\n          case Token.USE_STACK:\n            // Indicates that stack was modified externally,\n            // like placed catch object\n            stackChange(1);\n            break;\n\n          case Token.REF_CALL:\n          case Token.CALL:\n          case Token.NEW:\n            {\n                if (type == Token.NEW) {\n                    visitExpression(child, 0);\n                } else {\n                    generateCallFunAndThis(child);\n                }\n                int argCount = 0;\n                while ((child = child.getNext()) != null) {\n                    visitExpression(child, 0);\n                    ++argCount;\n                }\n                int callType = node.getIntProp(Node.SPECIALCALL_PROP,\n                                               Node.NON_SPECIALCALL);\n                if (type != Token.REF_CALL && callType != Node.NON_SPECIALCALL) {\n                    // embed line number and source filename\n                    addIndexOp(Icode_CALLSPECIAL, argCount);\n                    addUint8(callType);\n                    addUint8(type == Token.NEW ? 1 : 0);\n                    addUint16(lineNumber & 0xFFFF);\n                } else {\n                    // Only use the tail call optimization if we're not in a try\n                    // or we're not generating debug info (since the\n                    // optimization will confuse the debugger)\n                    if (type == Token.CALL && (contextFlags & ECF_TAIL) != 0 &&\n                        !compilerEnv.isGenerateDebugInfo() && !itsInTryFlag)\n                    {\n                        type = Icode_TAIL_CALL;\n                    }\n                    addIndexOp(type, argCount);\n                }\n                // adjust stack\n                if (type == Token.NEW) {\n                    // new: f, args -> result\n                    stackChange(-argCount);\n                } else {\n                    // call: f, thisObj, args -> result\n                    // ref_call: f, thisObj, args -> ref\n                    stackChange(-1 - argCount);\n                }\n                if (argCount > itsData.itsMaxCalleeArgs) {\n                    itsData.itsMaxCalleeArgs = argCount;\n                }\n            }\n            break;\n\n          case Token.AND:\n          case Token.OR:\n            {\n                visitExpression(child, 0);\n                addIcode(Icode_DUP);\n                stackChange(1);\n                int afterSecondJumpStart = iCodeTop;\n                int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;\n                addGotoOp(jump);\n                stackChange(-1);\n                addIcode(Icode_POP);\n                stackChange(-1);\n                child = child.getNext();\n                // Preserve tail context flag if any\n                visitExpression(child, contextFlags & ECF_TAIL);\n                resolveForwardGoto(afterSecondJumpStart);\n            }\n            break;\n\n          case Token.HOOK:\n            {\n                Node ifThen = child.getNext();\n                Node ifElse = ifThen.getNext();\n                visitExpression(child, 0);\n                int elseJumpStart = iCodeTop;\n                addGotoOp(Token.IFNE);\n                stackChange(-1);\n                // Preserve tail context flag if any\n                visitExpression(ifThen, contextFlags & ECF_TAIL);\n                int afterElseJumpStart = iCodeTop;\n                addGotoOp(Token.GOTO);\n                resolveForwardGoto(elseJumpStart);\n                stackDepth = savedStackDepth;\n                // Preserve tail context flag if any\n                visitExpression(ifElse, contextFlags & ECF_TAIL);\n                resolveForwardGoto(afterElseJumpStart);\n            }\n            break;\n\n          case Token.GETPROP:\n          case Token.GETPROPNOWARN:\n            visitExpression(child, 0);\n            child = child.getNext();\n            addStringOp(type, child.getString());\n            break;\n\n          case Token.DELPROP:\n            boolean isName = child.getType() == Token.BINDNAME;\n            visitExpression(child, 0);\n            child = child.getNext();\n            visitExpression(child, 0);\n            if (isName) {\n                // special handling for delete name\n                addIcode(Icode_DELNAME);\n            } else {\n                addToken(Token.DELPROP);\n            }\n            stackChange(-1);\n            break;\n\n          case Token.GETELEM:\n          case Token.BITAND:\n          case Token.BITOR:\n          case Token.BITXOR:\n          case Token.LSH:\n          case Token.RSH:\n          case Token.URSH:\n          case Token.ADD:\n          case Token.SUB:\n          case Token.MOD:\n          case Token.DIV:\n          case Token.MUL:\n          case Token.EQ:\n          case Token.NE:\n          case Token.SHEQ:\n          case Token.SHNE:\n          case Token.IN:\n          case Token.INSTANCEOF:\n          case Token.LE:\n          case Token.LT:\n          case Token.GE:\n          case Token.GT:\n            visitExpression(child, 0);\n            child = child.getNext();\n            visitExpression(child, 0);\n            addToken(type);\n            stackChange(-1);\n            break;\n\n          case Token.POS:\n          case Token.NEG:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.TYPEOF:\n          case Token.VOID:\n            visitExpression(child, 0);\n            if (type == Token.VOID) {\n                addIcode(Icode_POP);\n                addIcode(Icode_UNDEF);\n            } else {\n                addToken(type);\n            }\n            break;\n\n          case Token.GET_REF:\n          case Token.DEL_REF:\n            visitExpression(child, 0);\n            addToken(type);\n            break;\n\n          case Token.SETPROP:\n          case Token.SETPROP_OP:\n            {\n                visitExpression(child, 0);\n                child = child.getNext();\n                String property = child.getString();\n                child = child.getNext();\n                if (type == Token.SETPROP_OP) {\n                    addIcode(Icode_DUP);\n                    stackChange(1);\n                    addStringOp(Token.GETPROP, property);\n                    // Compensate for the following USE_STACK\n                    stackChange(-1);\n                }\n                visitExpression(child, 0);\n                addStringOp(Token.SETPROP, property);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.SETELEM:\n          case Token.SETELEM_OP:\n            visitExpression(child, 0);\n            child = child.getNext();\n            visitExpression(child, 0);\n            child = child.getNext();\n            if (type == Token.SETELEM_OP) {\n                addIcode(Icode_DUP2);\n                stackChange(2);\n                addToken(Token.GETELEM);\n                stackChange(-1);\n                // Compensate for the following USE_STACK\n                stackChange(-1);\n            }\n            visitExpression(child, 0);\n            addToken(Token.SETELEM);\n            stackChange(-2);\n            break;\n\n          case Token.SET_REF:\n          case Token.SET_REF_OP:\n            visitExpression(child, 0);\n            child = child.getNext();\n            if (type == Token.SET_REF_OP) {\n                addIcode(Icode_DUP);\n                stackChange(1);\n                addToken(Token.GET_REF);\n                // Compensate for the following USE_STACK\n                stackChange(-1);\n            }\n            visitExpression(child, 0);\n            addToken(Token.SET_REF);\n            stackChange(-1);\n            break;\n\n          case Token.STRICT_SETNAME:\n          case Token.SETNAME:\n            {\n                String name = child.getString();\n                visitExpression(child, 0);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addStringOp(type, name);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.SETCONST:\n            {\n                String name = child.getString();\n                visitExpression(child, 0);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addStringOp(Icode_SETCONST, name);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.TYPEOFNAME:\n            {\n                int index = -1;\n                // use typeofname if an activation frame exists\n                // since the vars all exist there instead of in jregs\n                if (itsInFunctionFlag && !itsData.itsNeedsActivation)\n                    index = scriptOrFn.getIndexForNameNode(node);\n                if (index == -1) {\n                    addStringOp(Icode_TYPEOFNAME, node.getString());\n                    stackChange(1);\n                } else {\n                    addVarOp(Token.GETVAR, index);\n                    stackChange(1);\n                    addToken(Token.TYPEOF);\n                }\n            }\n            break;\n\n          case Token.BINDNAME:\n          case Token.NAME:\n          case Token.STRING:\n            addStringOp(type, node.getString());\n            stackChange(1);\n            break;\n\n          case Token.INC:\n          case Token.DEC:\n            visitIncDec(node, child);\n            break;\n\n          case Token.NUMBER:\n            {\n                double num = node.getDouble();\n                int inum = (int)num;\n                if (inum == num) {\n                    if (inum == 0) {\n                        addIcode(Icode_ZERO);\n                        // Check for negative zero\n                        if (1.0 / num < 0.0) {\n                            addToken(Token.NEG);\n                        }\n                    } else if (inum == 1) {\n                        addIcode(Icode_ONE);\n                    } else if ((short)inum == inum) {\n                        addIcode(Icode_SHORTNUMBER);\n                        // write short as uin16 bit pattern\n                        addUint16(inum & 0xFFFF);\n                    } else {\n                        addIcode(Icode_INTNUMBER);\n                        addInt(inum);\n                    }\n                } else {\n                    int index = getDoubleIndex(num);\n                    addIndexOp(Token.NUMBER, index);\n                }\n                stackChange(1);\n            }\n            break;\n\n          case Token.GETVAR:\n            {\n                if (itsData.itsNeedsActivation) Kit.codeBug();\n                int index = scriptOrFn.getIndexForNameNode(node);\n                addVarOp(Token.GETVAR, index);\n                stackChange(1);\n            }\n            break;\n\n          case Token.SETVAR:\n            {\n                if (itsData.itsNeedsActivation) Kit.codeBug();\n                int index = scriptOrFn.getIndexForNameNode(child);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addVarOp(Token.SETVAR, index);\n            }\n            break;\n\n          case Token.SETCONSTVAR:\n            {\n                if (itsData.itsNeedsActivation) Kit.codeBug();\n                int index = scriptOrFn.getIndexForNameNode(child);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addVarOp(Token.SETCONSTVAR, index);\n            }\n            break;\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.THISFN:\n          case Token.FALSE:\n          case Token.TRUE:\n            addToken(type);\n            stackChange(1);\n            break;\n\n          case Token.ENUM_NEXT:\n          case Token.ENUM_ID:\n            addIndexOp(type, getLocalBlockRef(node));\n            stackChange(1);\n            break;\n\n          case Token.REGEXP:\n            {\n                int index = node.getExistingIntProp(Node.REGEXP_PROP);\n                addIndexOp(Token.REGEXP, index);\n                stackChange(1);\n            }\n            break;\n\n          case Token.ARRAYLIT:\n          case Token.OBJECTLIT:\n            visitLiteral(node, child);\n            break;\n\n          case Token.ARRAYCOMP:\n            visitArrayComprehension(node, child, child.getNext());\n            break;\n\n          case Token.REF_SPECIAL:\n            visitExpression(child, 0);\n            addStringOp(type, (String)node.getProp(Node.NAME_PROP));\n            break;\n\n          case Token.REF_MEMBER:\n          case Token.REF_NS_MEMBER:\n          case Token.REF_NAME:\n          case Token.REF_NS_NAME:\n            {\n                int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);\n                // generate possible target, possible namespace and member\n                int childCount = 0;\n                do {\n                    visitExpression(child, 0);\n                    ++childCount;\n                    child = child.getNext();\n                } while (child != null);\n                addIndexOp(type, memberTypeFlags);\n                stackChange(1 - childCount);\n            }\n            break;\n\n          case Token.DOTQUERY:\n            {\n                int queryPC;\n                updateLineNumber(node);\n                visitExpression(child, 0);\n                addIcode(Icode_ENTERDQ);\n                stackChange(-1);\n                queryPC = iCodeTop;\n                visitExpression(child.getNext(), 0);\n                addBackwardGoto(Icode_LEAVEDQ, queryPC);\n            }\n            break;\n\n          case Token.DEFAULTNAMESPACE :\n          case Token.ESCXMLATTR :\n          case Token.ESCXMLTEXT :\n            visitExpression(child, 0);\n            addToken(type);\n            break;\n\n          case Token.YIELD:\n            if (child != null) {\n                visitExpression(child, 0);\n            } else {\n                addIcode(Icode_UNDEF);\n                stackChange(1);\n            }\n            addToken(Token.YIELD);\n            addUint16(node.getLineno() & 0xFFFF);\n            break;\n\n          case Token.WITHEXPR: {\n            Node enterWith = node.getFirstChild();\n            Node with = enterWith.getNext();\n            visitExpression(enterWith.getFirstChild(), 0);\n            addToken(Token.ENTERWITH);\n            stackChange(-1);\n            visitExpression(with.getFirstChild(), 0);\n            addToken(Token.LEAVEWITH);\n            break;\n          }\n\n          default:\n            throw badTree(node);\n        }\n        if (savedStackDepth + 1 != stackDepth) {\n            Kit.codeBug();\n        }\n    }",
                    "javadoc_start_line": 495,
                    "annotations_start_line": 495,
                    "method_start_line": 496,
                    "end_line": 970
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/CodeGenerator.java",
                    "method_name": "add",
                    "content": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // Unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top-level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were Unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      case Token.CAST:\n        add(\"(\");\n        add(first);\n        add(\")\");\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
                    "javadoc_start_line": 103,
                    "annotations_start_line": 103,
                    "method_start_line": 103,
                    "end_line": 756
                },
                {
                    "file_path": "/lib/rhino/src/org/mozilla/javascript/CodeGenerator.java",
                    "method_name": "visitExpression",
                    "content": "    private void visitExpression(Node node, int contextFlags)\n    {\n        int type = node.getType();\n        Node child = node.getFirstChild();\n        int savedStackDepth = stackDepth;\n        switch (type) {\n\n          case Token.FUNCTION:\n            {\n                int fnIndex = node.getExistingIntProp(Node.FUNCTION_PROP);\n                FunctionNode fn = scriptOrFn.getFunctionNode(fnIndex);\n                // See comments in visitStatement for Token.FUNCTION case\n                if (fn.getFunctionType() != FunctionNode.FUNCTION_EXPRESSION) {\n                    throw Kit.codeBug();\n                }\n                addIndexOp(Icode_CLOSURE_EXPR, fnIndex);\n                stackChange(1);\n            }\n            break;\n\n          case Token.LOCAL_LOAD:\n            {\n                int localIndex = getLocalBlockRef(node);\n                addIndexOp(Token.LOCAL_LOAD, localIndex);\n                stackChange(1);\n            }\n            break;\n\n          case Token.COMMA:\n            {\n                Node lastChild = node.getLastChild();\n                while (child != lastChild) {\n                    visitExpression(child, 0);\n                    addIcode(Icode_POP);\n                    stackChange(-1);\n                    child = child.getNext();\n                }\n                // Preserve tail context flag if any\n                visitExpression(child, contextFlags & ECF_TAIL);\n            }\n            break;\n\n          case Token.USE_STACK:\n            // Indicates that stack was modified externally,\n            // like placed catch object\n            stackChange(1);\n            break;\n\n          case Token.REF_CALL:\n          case Token.CALL:\n          case Token.NEW:\n            {\n                if (type == Token.NEW) {\n                    visitExpression(child, 0);\n                } else {\n                    generateCallFunAndThis(child);\n                }\n                int argCount = 0;\n                while ((child = child.getNext()) != null) {\n                    visitExpression(child, 0);\n                    ++argCount;\n                }\n                int callType = node.getIntProp(Node.SPECIALCALL_PROP,\n                                               Node.NON_SPECIALCALL);\n                if (type != Token.REF_CALL && callType != Node.NON_SPECIALCALL) {\n                    // embed line number and source filename\n                    addIndexOp(Icode_CALLSPECIAL, argCount);\n                    addUint8(callType);\n                    addUint8(type == Token.NEW ? 1 : 0);\n                    addUint16(lineNumber & 0xFFFF);\n                } else {\n                    // Only use the tail call optimization if we're not in a try\n                    // or we're not generating debug info (since the\n                    // optimization will confuse the debugger)\n                    if (type == Token.CALL && (contextFlags & ECF_TAIL) != 0 &&\n                        !compilerEnv.isGenerateDebugInfo() && !itsInTryFlag)\n                    {\n                        type = Icode_TAIL_CALL;\n                    }\n                    addIndexOp(type, argCount);\n                }\n                // adjust stack\n                if (type == Token.NEW) {\n                    // new: f, args -> result\n                    stackChange(-argCount);\n                } else {\n                    // call: f, thisObj, args -> result\n                    // ref_call: f, thisObj, args -> ref\n                    stackChange(-1 - argCount);\n                }\n                if (argCount > itsData.itsMaxCalleeArgs) {\n                    itsData.itsMaxCalleeArgs = argCount;\n                }\n            }\n            break;\n\n          case Token.AND:\n          case Token.OR:\n            {\n                visitExpression(child, 0);\n                addIcode(Icode_DUP);\n                stackChange(1);\n                int afterSecondJumpStart = iCodeTop;\n                int jump = (type == Token.AND) ? Token.IFNE : Token.IFEQ;\n                addGotoOp(jump);\n                stackChange(-1);\n                addIcode(Icode_POP);\n                stackChange(-1);\n                child = child.getNext();\n                // Preserve tail context flag if any\n                visitExpression(child, contextFlags & ECF_TAIL);\n                resolveForwardGoto(afterSecondJumpStart);\n            }\n            break;\n\n          case Token.HOOK:\n            {\n                Node ifThen = child.getNext();\n                Node ifElse = ifThen.getNext();\n                visitExpression(child, 0);\n                int elseJumpStart = iCodeTop;\n                addGotoOp(Token.IFNE);\n                stackChange(-1);\n                // Preserve tail context flag if any\n                visitExpression(ifThen, contextFlags & ECF_TAIL);\n                int afterElseJumpStart = iCodeTop;\n                addGotoOp(Token.GOTO);\n                resolveForwardGoto(elseJumpStart);\n                stackDepth = savedStackDepth;\n                // Preserve tail context flag if any\n                visitExpression(ifElse, contextFlags & ECF_TAIL);\n                resolveForwardGoto(afterElseJumpStart);\n            }\n            break;\n\n          case Token.GETPROP:\n          case Token.GETPROPNOWARN:\n            visitExpression(child, 0);\n            child = child.getNext();\n            addStringOp(type, child.getString());\n            break;\n\n          case Token.DELPROP:\n            boolean isName = child.getType() == Token.BINDNAME;\n            visitExpression(child, 0);\n            child = child.getNext();\n            visitExpression(child, 0);\n            if (isName) {\n                // special handling for delete name\n                addIcode(Icode_DELNAME);\n            } else {\n                addToken(Token.DELPROP);\n            }\n            stackChange(-1);\n            break;\n\n          case Token.GETELEM:\n          case Token.BITAND:\n          case Token.BITOR:\n          case Token.BITXOR:\n          case Token.LSH:\n          case Token.RSH:\n          case Token.URSH:\n          case Token.ADD:\n          case Token.SUB:\n          case Token.MOD:\n          case Token.DIV:\n          case Token.MUL:\n          case Token.EQ:\n          case Token.NE:\n          case Token.SHEQ:\n          case Token.SHNE:\n          case Token.IN:\n          case Token.INSTANCEOF:\n          case Token.LE:\n          case Token.LT:\n          case Token.GE:\n          case Token.GT:\n            visitExpression(child, 0);\n            child = child.getNext();\n            visitExpression(child, 0);\n            addToken(type);\n            stackChange(-1);\n            break;\n\n          case Token.POS:\n          case Token.NEG:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.TYPEOF:\n          case Token.VOID:\n            visitExpression(child, 0);\n            if (type == Token.VOID) {\n                addIcode(Icode_POP);\n                addIcode(Icode_UNDEF);\n            } else {\n                addToken(type);\n            }\n            break;\n\n          case Token.GET_REF:\n          case Token.DEL_REF:\n            visitExpression(child, 0);\n            addToken(type);\n            break;\n\n          case Token.SETPROP:\n          case Token.SETPROP_OP:\n            {\n                visitExpression(child, 0);\n                child = child.getNext();\n                String property = child.getString();\n                child = child.getNext();\n                if (type == Token.SETPROP_OP) {\n                    addIcode(Icode_DUP);\n                    stackChange(1);\n                    addStringOp(Token.GETPROP, property);\n                    // Compensate for the following USE_STACK\n                    stackChange(-1);\n                }\n                visitExpression(child, 0);\n                addStringOp(Token.SETPROP, property);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.SETELEM:\n          case Token.SETELEM_OP:\n            visitExpression(child, 0);\n            child = child.getNext();\n            visitExpression(child, 0);\n            child = child.getNext();\n            if (type == Token.SETELEM_OP) {\n                addIcode(Icode_DUP2);\n                stackChange(2);\n                addToken(Token.GETELEM);\n                stackChange(-1);\n                // Compensate for the following USE_STACK\n                stackChange(-1);\n            }\n            visitExpression(child, 0);\n            addToken(Token.SETELEM);\n            stackChange(-2);\n            break;\n\n          case Token.SET_REF:\n          case Token.SET_REF_OP:\n            visitExpression(child, 0);\n            child = child.getNext();\n            if (type == Token.SET_REF_OP) {\n                addIcode(Icode_DUP);\n                stackChange(1);\n                addToken(Token.GET_REF);\n                // Compensate for the following USE_STACK\n                stackChange(-1);\n            }\n            visitExpression(child, 0);\n            addToken(Token.SET_REF);\n            stackChange(-1);\n            break;\n\n          case Token.STRICT_SETNAME:\n          case Token.SETNAME:\n            {\n                String name = child.getString();\n                visitExpression(child, 0);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addStringOp(type, name);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.SETCONST:\n            {\n                String name = child.getString();\n                visitExpression(child, 0);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addStringOp(Icode_SETCONST, name);\n                stackChange(-1);\n            }\n            break;\n\n          case Token.TYPEOFNAME:\n            {\n                int index = -1;\n                // use typeofname if an activation frame exists\n                // since the vars all exist there instead of in jregs\n                if (itsInFunctionFlag && !itsData.itsNeedsActivation)\n                    index = scriptOrFn.getIndexForNameNode(node);\n                if (index == -1) {\n                    addStringOp(Icode_TYPEOFNAME, node.getString());\n                    stackChange(1);\n                } else {\n                    addVarOp(Token.GETVAR, index);\n                    stackChange(1);\n                    addToken(Token.TYPEOF);\n                }\n            }\n            break;\n\n          case Token.BINDNAME:\n          case Token.NAME:\n          case Token.STRING:\n            addStringOp(type, node.getString());\n            stackChange(1);\n            break;\n\n          case Token.INC:\n          case Token.DEC:\n            visitIncDec(node, child);\n            break;\n\n          case Token.NUMBER:\n            {\n                double num = node.getDouble();\n                int inum = (int)num;\n                if (inum == num) {\n                    if (inum == 0) {\n                        addIcode(Icode_ZERO);\n                        // Check for negative zero\n                        if (1.0 / num < 0.0) {\n                            addToken(Token.NEG);\n                        }\n                    } else if (inum == 1) {\n                        addIcode(Icode_ONE);\n                    } else if ((short)inum == inum) {\n                        addIcode(Icode_SHORTNUMBER);\n                        // write short as uin16 bit pattern\n                        addUint16(inum & 0xFFFF);\n                    } else {\n                        addIcode(Icode_INTNUMBER);\n                        addInt(inum);\n                    }\n                } else {\n                    int index = getDoubleIndex(num);\n                    addIndexOp(Token.NUMBER, index);\n                }\n                stackChange(1);\n            }\n            break;\n\n          case Token.GETVAR:\n            {\n                if (itsData.itsNeedsActivation) Kit.codeBug();\n                int index = scriptOrFn.getIndexForNameNode(node);\n                addVarOp(Token.GETVAR, index);\n                stackChange(1);\n            }\n            break;\n\n          case Token.SETVAR:\n            {\n                if (itsData.itsNeedsActivation) Kit.codeBug();\n                int index = scriptOrFn.getIndexForNameNode(child);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addVarOp(Token.SETVAR, index);\n            }\n            break;\n\n          case Token.SETCONSTVAR:\n            {\n                if (itsData.itsNeedsActivation) Kit.codeBug();\n                int index = scriptOrFn.getIndexForNameNode(child);\n                child = child.getNext();\n                visitExpression(child, 0);\n                addVarOp(Token.SETCONSTVAR, index);\n            }\n            break;\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.THISFN:\n          case Token.FALSE:\n          case Token.TRUE:\n            addToken(type);\n            stackChange(1);\n            break;\n\n          case Token.ENUM_NEXT:\n          case Token.ENUM_ID:\n            addIndexOp(type, getLocalBlockRef(node));\n            stackChange(1);\n            break;\n\n          case Token.REGEXP:\n            {\n                int index = node.getExistingIntProp(Node.REGEXP_PROP);\n                addIndexOp(Token.REGEXP, index);\n                stackChange(1);\n            }\n            break;\n\n          case Token.ARRAYLIT:\n          case Token.OBJECTLIT:\n            visitLiteral(node, child);\n            break;\n\n          case Token.ARRAYCOMP:\n            visitArrayComprehension(node, child, child.getNext());\n            break;\n\n          case Token.REF_SPECIAL:\n            visitExpression(child, 0);\n            addStringOp(type, (String)node.getProp(Node.NAME_PROP));\n            break;\n\n          case Token.REF_MEMBER:\n          case Token.REF_NS_MEMBER:\n          case Token.REF_NAME:\n          case Token.REF_NS_NAME:\n            {\n                int memberTypeFlags = node.getIntProp(Node.MEMBER_TYPE_PROP, 0);\n                // generate possible target, possible namespace and member\n                int childCount = 0;\n                do {\n                    visitExpression(child, 0);\n                    ++childCount;\n                    child = child.getNext();\n                } while (child != null);\n                addIndexOp(type, memberTypeFlags);\n                stackChange(1 - childCount);\n            }\n            break;\n\n          case Token.DOTQUERY:\n            {\n                int queryPC;\n                updateLineNumber(node);\n                visitExpression(child, 0);\n                addIcode(Icode_ENTERDQ);\n                stackChange(-1);\n                queryPC = iCodeTop;\n                visitExpression(child.getNext(), 0);\n                addBackwardGoto(Icode_LEAVEDQ, queryPC);\n            }\n            break;\n\n          case Token.DEFAULTNAMESPACE :\n          case Token.ESCXMLATTR :\n          case Token.ESCXMLTEXT :\n            visitExpression(child, 0);\n            addToken(type);\n            break;\n\n          case Token.YIELD:\n            if (child != null) {\n                visitExpression(child, 0);\n            } else {\n                addIcode(Icode_UNDEF);\n                stackChange(1);\n            }\n            addToken(Token.YIELD);\n            addUint16(node.getLineno() & 0xFFFF);\n            break;\n\n          case Token.WITHEXPR: {\n            Node enterWith = node.getFirstChild();\n            Node with = enterWith.getNext();\n            visitExpression(enterWith.getFirstChild(), 0);\n            addToken(Token.ENTERWITH);\n            stackChange(-1);\n            visitExpression(with.getFirstChild(), 0);\n            addToken(Token.LEAVEWITH);\n            break;\n          }\n\n          default:\n            throw badTree(node);\n        }\n        if (savedStackDepth + 1 != stackDepth) {\n            Kit.codeBug();\n        }\n    }",
                    "javadoc_start_line": 495,
                    "annotations_start_line": 495,
                    "method_start_line": 496,
                    "end_line": 970
                },
                {
                    "file_path": "/src/com/google/javascript/rhino/TokenStream.java",
                    "method_name": "isJSIdentifier",
                    "content": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
                    "javadoc_start_line": 190,
                    "annotations_start_line": 190,
                    "method_start_line": 190,
                    "end_line": 206
                },
                {
                    "file_path": "/lib/rhino/src/org/mozilla/javascript/TokenStream.java",
                    "method_name": "stringToKeyword",
                    "content": "    private static int stringToKeyword(String name)\n    {\n// #string_id_map#\n// The following assumes that Token.EOF == 0\n        final int\n            Id_break         = Token.BREAK,\n            Id_case          = Token.CASE,\n            Id_continue      = Token.CONTINUE,\n            Id_default       = Token.DEFAULT,\n            Id_delete        = Token.DELPROP,\n            Id_do            = Token.DO,\n            Id_else          = Token.ELSE,\n            Id_export        = Token.RESERVED,\n            Id_false         = Token.FALSE,\n            Id_for           = Token.FOR,\n            Id_function      = Token.FUNCTION,\n            Id_if            = Token.IF,\n            Id_in            = Token.IN,\n            Id_let           = Token.LET,  // reserved ES5 strict\n            Id_new           = Token.NEW,\n            Id_null          = Token.NULL,\n            Id_return        = Token.RETURN,\n            Id_switch        = Token.SWITCH,\n            Id_this          = Token.THIS,\n            Id_true          = Token.TRUE,\n            Id_typeof        = Token.TYPEOF,\n            Id_var           = Token.VAR,\n            Id_void          = Token.VOID,\n            Id_while         = Token.WHILE,\n            Id_with          = Token.WITH,\n            Id_yield         = Token.YIELD,  // reserved ES5 strict\n\n            // the following are #ifdef RESERVE_JAVA_KEYWORDS in jsscan.c\n            Id_abstract      = Token.RESERVED,  // ES3 only\n            Id_boolean       = Token.RESERVED,  // ES3 only\n            Id_byte          = Token.RESERVED,  // ES3 only\n            Id_catch         = Token.CATCH,\n            Id_char          = Token.RESERVED,  // ES3 only\n            Id_class         = Token.RESERVED,\n            Id_const         = Token.CONST,     // reserved\n            Id_debugger      = Token.DEBUGGER,\n            Id_double        = Token.RESERVED,  // ES3 only\n            Id_enum          = Token.RESERVED,\n            Id_extends       = Token.RESERVED,\n            Id_final         = Token.RESERVED,  // ES3 only\n            Id_finally       = Token.FINALLY,\n            Id_float         = Token.RESERVED,  // ES3 only\n            Id_goto          = Token.RESERVED,  // ES3 only\n            Id_implements    = Token.RESERVED,  // ES3, ES5 strict\n            Id_import        = Token.RESERVED,\n            Id_instanceof    = Token.INSTANCEOF,\n            Id_int           = Token.RESERVED,  // ES3\n            Id_interface     = Token.RESERVED,  // ES3, ES5 strict\n            Id_long          = Token.RESERVED,  // ES3 only\n            Id_native        = Token.RESERVED,  // ES3 only\n            Id_package       = Token.RESERVED,  // ES3, ES5 strict\n            Id_private       = Token.RESERVED,  // ES3, ES5 strict\n            Id_protected     = Token.RESERVED,  // ES3, ES5 strict\n            Id_public        = Token.RESERVED,  // ES3, ES5 strict\n            Id_short         = Token.RESERVED,  // ES3 only\n            Id_static        = Token.RESERVED,  // ES3, ES5 strict\n            Id_super         = Token.RESERVED,\n            Id_synchronized  = Token.RESERVED,  // ES3 only\n            Id_throw         = Token.THROW,\n            Id_throws        = Token.RESERVED,  // ES3 only\n            Id_transient     = Token.RESERVED,  // ES3 only\n            Id_try           = Token.TRY,\n            Id_volatile      = Token.RESERVED;  // ES3 only\n\n        int id;\n        String s = name;\n// #generated# Last update: 2007-04-18 13:53:30 PDT\n        L0: { id = 0; String X = null; int c;\n            L: switch (s.length()) {\n            case 2: c=s.charAt(1);\n                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }\n                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }\n                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n                break L;\n            case 3: switch (s.charAt(0)) {\n                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n                case 'l': if (s.charAt(2)=='t' && s.charAt(1)=='e') {id=Id_let; break L0;} break L;\n                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n                } break L;\n            case 4: switch (s.charAt(0)) {\n                case 'b': X=\"byte\";id=Id_byte; break L;\n                case 'c': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {id=Id_case; break L0;} }\n                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {id=Id_char; break L0;} }\n                    break L;\n                case 'e': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {id=Id_else; break L0;} }\n                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {id=Id_enum; break L0;} }\n                    break L;\n                case 'g': X=\"goto\";id=Id_goto; break L;\n                case 'l': X=\"long\";id=Id_long; break L;\n                case 'n': X=\"null\";id=Id_null; break L;\n                case 't': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {id=Id_true; break L0;} }\n                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {id=Id_this; break L0;} }\n                    break L;\n                case 'v': X=\"void\";id=Id_void; break L;\n                case 'w': X=\"with\";id=Id_with; break L;\n                } break L;\n            case 5: switch (s.charAt(2)) {\n                case 'a': X=\"class\";id=Id_class; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='b') { X=\"break\";id=Id_break; }\n                    else if (c=='y') { X=\"yield\";id=Id_yield; }\n                    break L;\n                case 'i': X=\"while\";id=Id_while; break L;\n                case 'l': X=\"false\";id=Id_false; break L;\n                case 'n': c=s.charAt(0);\n                    if (c=='c') { X=\"const\";id=Id_const; }\n                    else if (c=='f') { X=\"final\";id=Id_final; }\n                    break L;\n                case 'o': c=s.charAt(0);\n                    if (c=='f') { X=\"float\";id=Id_float; }\n                    else if (c=='s') { X=\"short\";id=Id_short; }\n                    break L;\n                case 'p': X=\"super\";id=Id_super; break L;\n                case 'r': X=\"throw\";id=Id_throw; break L;\n                case 't': X=\"catch\";id=Id_catch; break L;\n                } break L;\n            case 6: switch (s.charAt(1)) {\n                case 'a': X=\"native\";id=Id_native; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='d') { X=\"delete\";id=Id_delete; }\n                    else if (c=='r') { X=\"return\";id=Id_return; }\n                    break L;\n                case 'h': X=\"throws\";id=Id_throws; break L;\n                case 'm': X=\"import\";id=Id_import; break L;\n                case 'o': X=\"double\";id=Id_double; break L;\n                case 't': X=\"static\";id=Id_static; break L;\n                case 'u': X=\"public\";id=Id_public; break L;\n                case 'w': X=\"switch\";id=Id_switch; break L;\n                case 'x': X=\"export\";id=Id_export; break L;\n                case 'y': X=\"typeof\";id=Id_typeof; break L;\n                } break L;\n            case 7: switch (s.charAt(1)) {\n                case 'a': X=\"package\";id=Id_package; break L;\n                case 'e': X=\"default\";id=Id_default; break L;\n                case 'i': X=\"finally\";id=Id_finally; break L;\n                case 'o': X=\"boolean\";id=Id_boolean; break L;\n                case 'r': X=\"private\";id=Id_private; break L;\n                case 'x': X=\"extends\";id=Id_extends; break L;\n                } break L;\n            case 8: switch (s.charAt(0)) {\n                case 'a': X=\"abstract\";id=Id_abstract; break L;\n                case 'c': X=\"continue\";id=Id_continue; break L;\n                case 'd': X=\"debugger\";id=Id_debugger; break L;\n                case 'f': X=\"function\";id=Id_function; break L;\n                case 'v': X=\"volatile\";id=Id_volatile; break L;\n                } break L;\n            case 9: c=s.charAt(0);\n                if (c=='i') { X=\"interface\";id=Id_interface; }\n                else if (c=='p') { X=\"protected\";id=Id_protected; }\n                else if (c=='t') { X=\"transient\";id=Id_transient; }\n                break L;\n            case 10: c=s.charAt(1);\n                if (c=='m') { X=\"implements\";id=Id_implements; }\n                else if (c=='n') { X=\"instanceof\";id=Id_instanceof; }\n                break L;\n            case 12: X=\"synchronized\";id=Id_synchronized; break L;\n            }\n            if (X!=null && X!=s && !X.equals(s)) id = 0;\n        }\n// #/generated#\n// #/string_id_map#\n        if (id == 0) { return Token.EOF; }\n        return id & 0xff;\n    }",
                    "javadoc_start_line": 80,
                    "annotations_start_line": 80,
                    "method_start_line": 81,
                    "end_line": 254
                }
            ]
        },
        {
            "failing_test": {
                "className": " com.google.javascript.jscomp.ConvertToDottedPropertiesTest",
                "methodName": "testQuotedProps",
                "error": "junit.framework.AssertionFailedError",
                "message": ""
            },
            "patched_method": {
                "file_path": "/lib/rhino/src/org/mozilla/javascript/TokenStream.java",
                "method_name": "stringToKeyword",
                "content": "    private static int stringToKeyword(String name)\n    {\n// #string_id_map#\n// The following assumes that Token.EOF == 0\n        final int\n            Id_break         = Token.BREAK,\n            Id_case          = Token.CASE,\n            Id_continue      = Token.CONTINUE,\n            Id_default       = Token.DEFAULT,\n            Id_delete        = Token.DELPROP,\n            Id_do            = Token.DO,\n            Id_else          = Token.ELSE,\n            Id_export        = Token.RESERVED,\n            Id_false         = Token.FALSE,\n            Id_for           = Token.FOR,\n            Id_function      = Token.FUNCTION,\n            Id_if            = Token.IF,\n            Id_in            = Token.IN,\n            Id_let           = Token.LET,  // reserved ES5 strict\n            Id_new           = Token.NEW,\n            Id_null          = Token.NULL,\n            Id_return        = Token.RETURN,\n            Id_switch        = Token.SWITCH,\n            Id_this          = Token.THIS,\n            Id_true          = Token.TRUE,\n            Id_typeof        = Token.TYPEOF,\n            Id_var           = Token.VAR,\n            Id_void          = Token.VOID,\n            Id_while         = Token.WHILE,\n            Id_with          = Token.WITH,\n            Id_yield         = Token.YIELD,  // reserved ES5 strict\n\n            // the following are #ifdef RESERVE_JAVA_KEYWORDS in jsscan.c\n            Id_abstract      = Token.RESERVED,  // ES3 only\n            Id_boolean       = Token.RESERVED,  // ES3 only\n            Id_byte          = Token.RESERVED,  // ES3 only\n            Id_catch         = Token.CATCH,\n            Id_char          = Token.RESERVED,  // ES3 only\n            Id_class         = Token.RESERVED,\n            Id_const         = Token.CONST,     // reserved\n            Id_debugger      = Token.DEBUGGER,\n            Id_double        = Token.RESERVED,  // ES3 only\n            Id_enum          = Token.RESERVED,\n            Id_extends       = Token.RESERVED,\n            Id_final         = Token.RESERVED,  // ES3 only\n            Id_finally       = Token.FINALLY,\n            Id_float         = Token.RESERVED,  // ES3 only\n            Id_goto          = Token.RESERVED,  // ES3 only\n            Id_implements    = Token.RESERVED,  // ES3, ES5 strict\n            Id_import        = Token.RESERVED,\n            Id_instanceof    = Token.INSTANCEOF,\n            Id_int           = Token.RESERVED,  // ES3\n            Id_interface     = Token.RESERVED,  // ES3, ES5 strict\n            Id_long          = Token.RESERVED,  // ES3 only\n            Id_native        = Token.RESERVED,  // ES3 only\n            Id_package       = Token.RESERVED,  // ES3, ES5 strict\n            Id_private       = Token.RESERVED,  // ES3, ES5 strict\n            Id_protected     = Token.RESERVED,  // ES3, ES5 strict\n            Id_public        = Token.RESERVED,  // ES3, ES5 strict\n            Id_short         = Token.RESERVED,  // ES3 only\n            Id_static        = Token.RESERVED,  // ES3, ES5 strict\n            Id_super         = Token.RESERVED,\n            Id_synchronized  = Token.RESERVED,  // ES3 only\n            Id_throw         = Token.THROW,\n            Id_throws        = Token.RESERVED,  // ES3 only\n            Id_transient     = Token.RESERVED,  // ES3 only\n            Id_try           = Token.TRY,\n            Id_volatile      = Token.RESERVED;  // ES3 only\n\n        int id;\n        String s = name;\n// #generated# Last update: 2007-04-18 13:53:30 PDT\n        L0: { id = 0; String X = null; int c;\n            L: switch (s.length()) {\n            case 2: c=s.charAt(1);\n                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }\n                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }\n                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n                break L;\n            case 3: switch (s.charAt(0)) {\n                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n                case 'l': if (s.charAt(2)=='t' && s.charAt(1)=='e') {id=Id_let; break L0;} break L;\n                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n                } break L;\n            case 4: switch (s.charAt(0)) {\n                case 'b': X=\"byte\";id=Id_byte; break L;\n                case 'c': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {id=Id_case; break L0;} }\n                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {id=Id_char; break L0;} }\n                    break L;\n                case 'e': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {id=Id_else; break L0;} }\n                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {id=Id_enum; break L0;} }\n                    break L;\n                case 'g': X=\"goto\";id=Id_goto; break L;\n                case 'l': X=\"long\";id=Id_long; break L;\n                case 'n': X=\"null\";id=Id_null; break L;\n                case 't': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {id=Id_true; break L0;} }\n                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {id=Id_this; break L0;} }\n                    break L;\n                case 'v': X=\"void\";id=Id_void; break L;\n                case 'w': X=\"with\";id=Id_with; break L;\n                } break L;\n            case 5: switch (s.charAt(2)) {\n                case 'a': X=\"class\";id=Id_class; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='b') { X=\"break\";id=Id_break; }\n                    else if (c=='y') { X=\"yield\";id=Id_yield; }\n                    break L;\n                case 'i': X=\"while\";id=Id_while; break L;\n                case 'l': X=\"false\";id=Id_false; break L;\n                case 'n': c=s.charAt(0);\n                    if (c=='c') { X=\"const\";id=Id_const; }\n                    else if (c=='f') { X=\"final\";id=Id_final; }\n                    break L;\n                case 'o': c=s.charAt(0);\n                    if (c=='f') { X=\"float\";id=Id_float; }\n                    else if (c=='s') { X=\"short\";id=Id_short; }\n                    break L;\n                case 'p': X=\"super\";id=Id_super; break L;\n                case 'r': X=\"throw\";id=Id_throw; break L;\n                case 't': X=\"catch\";id=Id_catch; break L;\n                } break L;\n            case 6: switch (s.charAt(1)) {\n                case 'a': X=\"native\";id=Id_native; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='d') { X=\"delete\";id=Id_delete; }\n                    else if (c=='r') { X=\"return\";id=Id_return; }\n                    break L;\n                case 'h': X=\"throws\";id=Id_throws; break L;\n                case 'm': X=\"import\";id=Id_import; break L;\n                case 'o': X=\"double\";id=Id_double; break L;\n                case 't': X=\"static\";id=Id_static; break L;\n                case 'u': X=\"public\";id=Id_public; break L;\n                case 'w': X=\"switch\";id=Id_switch; break L;\n                case 'x': X=\"export\";id=Id_export; break L;\n                case 'y': X=\"typeof\";id=Id_typeof; break L;\n                } break L;\n            case 7: switch (s.charAt(1)) {\n                case 'a': X=\"package\";id=Id_package; break L;\n                case 'e': X=\"default\";id=Id_default; break L;\n                case 'i': X=\"finally\";id=Id_finally; break L;\n                case 'o': X=\"boolean\";id=Id_boolean; break L;\n                case 'r': X=\"private\";id=Id_private; break L;\n                case 'x': X=\"extends\";id=Id_extends; break L;\n                } break L;\n            case 8: switch (s.charAt(0)) {\n                case 'a': X=\"abstract\";id=Id_abstract; break L;\n                case 'c': X=\"continue\";id=Id_continue; break L;\n                case 'd': X=\"debugger\";id=Id_debugger; break L;\n                case 'f': X=\"function\";id=Id_function; break L;\n                case 'v': X=\"volatile\";id=Id_volatile; break L;\n                } break L;\n            case 9: c=s.charAt(0);\n                if (c=='i') { X=\"interface\";id=Id_interface; }\n                else if (c=='p') { X=\"protected\";id=Id_protected; }\n                else if (c=='t') { X=\"transient\";id=Id_transient; }\n                break L;\n            case 10: c=s.charAt(1);\n                if (c=='m') { X=\"implements\";id=Id_implements; }\n                else if (c=='n') { X=\"instanceof\";id=Id_instanceof; }\n                break L;\n            case 12: X=\"synchronized\";id=Id_synchronized; break L;\n            }\n            if (X!=null && X!=s && !X.equals(s)) id = 0;\n        }\n// #/generated#\n// #/string_id_map#\n        if (id == 0) { return Token.EOF; }\n        return id & 0xff;\n    }",
                "javadoc_start_line": 80,
                "annotations_start_line": 80,
                "method_start_line": 81,
                "end_line": 254
            },
            "steps": [],
            "generation_failure": {
                "error": "Failed to generate stacktrace",
                "error_message": "Command failed: defects4j test -w ./projects/Closure/131\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/131 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/131 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Reader.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Reader.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Thread.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Thread.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/sun/misc/Contended.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/sun/misc/Contended.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/File.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/File.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/nio/charset/Charset.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/nio/charset/Charset.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Writer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Writer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/CharSequence.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/CharSequence.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Locale.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Locale.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Integer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Integer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Number.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Number.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Error.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Error.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FileNotFoundException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FileNotFoundException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/UnsupportedEncodingException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/UnsupportedEncodingException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Byte.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Byte.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Character.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Character.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Short.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Short.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Long.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Long.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Float.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Float.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Double.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Double.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Boolean.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Boolean.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Void.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Void.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuilder.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuilder.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AbstractStringBuilder.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AbstractStringBuilder.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/org/mozilla/javascript/TokenStream.java:82: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testQuotedProps\", \"stringToKeyword\", \"./results/stacktrace-testQuotedProps-stringToKeyword.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 93 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/131/build.xml:98: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/build.xml:45: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/build.xml:38: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"
            }
        },
        {
            "failing_test": {
                "className": " com.google.javascript.jscomp.ConvertToDottedPropertiesTest",
                "methodName": "testDoNotConvert",
                "error": "junit.framework.AssertionFailedError",
                "message": ""
            },
            "patched_method": {
                "file_path": "/src/com/google/javascript/rhino/TokenStream.java",
                "method_name": "isJSIdentifier",
                "content": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
                "javadoc_start_line": 190,
                "annotations_start_line": 190,
                "method_start_line": 190,
                "end_line": 206
            },
            "steps": [
                {
                    "file_path": "/src/com/google/javascript/jscomp/ConvertToDottedProperties.java",
                    "method_name": "process",
                    "content": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
                    "javadoc_start_line": 40,
                    "annotations_start_line": 39,
                    "method_start_line": 40,
                    "end_line": 42
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java",
                    "method_name": "traverse",
                    "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
                    "javadoc_start_line": 450,
                    "annotations_start_line": 453,
                    "method_start_line": 454,
                    "end_line": 457
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java",
                    "method_name": "traverse",
                    "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
                    "javadoc_start_line": 268,
                    "annotations_start_line": 271,
                    "method_start_line": 271,
                    "end_line": 282
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java",
                    "method_name": "traverseBranch",
                    "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
                    "javadoc_start_line": 474,
                    "annotations_start_line": 477,
                    "method_start_line": 478,
                    "end_line": 506
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java",
                    "method_name": "traverseBranch",
                    "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
                    "javadoc_start_line": 474,
                    "annotations_start_line": 477,
                    "method_start_line": 478,
                    "end_line": 506
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java",
                    "method_name": "traverseBranch",
                    "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
                    "javadoc_start_line": 474,
                    "annotations_start_line": 477,
                    "method_start_line": 478,
                    "end_line": 506
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java",
                    "method_name": "traverseBranch",
                    "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
                    "javadoc_start_line": 474,
                    "annotations_start_line": 477,
                    "method_start_line": 478,
                    "end_line": 506
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/ConvertToDottedProperties.java",
                    "method_name": "visit",
                    "content": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n      case Token.STRING_KEY:\n        if (NodeUtil.isValidPropertyName(n.getString())) {\n          n.putBooleanProp(Node.QUOTED_PROP, false);\n          compiler.reportCodeChange();\n        }\n        break;\n\n      case Token.GETELEM:\n        Node left = n.getFirstChild();\n        Node right = left.getNext();\n        if (right.isString() &&\n            NodeUtil.isValidPropertyName(right.getString())) {\n          n.removeChild(left);\n          n.removeChild(right);\n          parent.replaceChild(n, IR.getprop(left, right));\n          compiler.reportCodeChange();\n        }\n        break;\n    }\n  }",
                    "javadoc_start_line": 45,
                    "annotations_start_line": 44,
                    "method_start_line": 45,
                    "end_line": 68
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeUtil.java",
                    "method_name": "isValidPropertyName",
                    "content": "  /**\n   * Determines whether the given name can appear on the right side of\n   * the dot operator. Many properties (like reserved words) cannot.\n   */\n  static boolean isValidPropertyName(String name) {\n    return isValidSimpleName(name);\n  }",
                    "javadoc_start_line": 2473,
                    "annotations_start_line": 2477,
                    "method_start_line": 2477,
                    "end_line": 2479
                },
                {
                    "file_path": "/src/com/google/javascript/jscomp/NodeUtil.java",
                    "method_name": "isValidSimpleName",
                    "content": "  /**\n   * Determines whether the given name is a valid variable name.\n   */\n  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
                    "javadoc_start_line": 2440,
                    "annotations_start_line": 2443,
                    "method_start_line": 2443,
                    "end_line": 2453
                },
                {
                    "file_path": "/src/com/google/javascript/rhino/TokenStream.java",
                    "method_name": "isJSIdentifier",
                    "content": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }",
                    "javadoc_start_line": 190,
                    "annotations_start_line": 190,
                    "method_start_line": 190,
                    "end_line": 206
                },
                {
                    "file_path": "/lib/rhino/src/org/mozilla/javascript/TokenStream.java",
                    "method_name": "stringToKeyword",
                    "content": "    private static int stringToKeyword(String name)\n    {\n// #string_id_map#\n// The following assumes that Token.EOF == 0\n        final int\n            Id_break         = Token.BREAK,\n            Id_case          = Token.CASE,\n            Id_continue      = Token.CONTINUE,\n            Id_default       = Token.DEFAULT,\n            Id_delete        = Token.DELPROP,\n            Id_do            = Token.DO,\n            Id_else          = Token.ELSE,\n            Id_export        = Token.RESERVED,\n            Id_false         = Token.FALSE,\n            Id_for           = Token.FOR,\n            Id_function      = Token.FUNCTION,\n            Id_if            = Token.IF,\n            Id_in            = Token.IN,\n            Id_let           = Token.LET,  // reserved ES5 strict\n            Id_new           = Token.NEW,\n            Id_null          = Token.NULL,\n            Id_return        = Token.RETURN,\n            Id_switch        = Token.SWITCH,\n            Id_this          = Token.THIS,\n            Id_true          = Token.TRUE,\n            Id_typeof        = Token.TYPEOF,\n            Id_var           = Token.VAR,\n            Id_void          = Token.VOID,\n            Id_while         = Token.WHILE,\n            Id_with          = Token.WITH,\n            Id_yield         = Token.YIELD,  // reserved ES5 strict\n\n            // the following are #ifdef RESERVE_JAVA_KEYWORDS in jsscan.c\n            Id_abstract      = Token.RESERVED,  // ES3 only\n            Id_boolean       = Token.RESERVED,  // ES3 only\n            Id_byte          = Token.RESERVED,  // ES3 only\n            Id_catch         = Token.CATCH,\n            Id_char          = Token.RESERVED,  // ES3 only\n            Id_class         = Token.RESERVED,\n            Id_const         = Token.CONST,     // reserved\n            Id_debugger      = Token.DEBUGGER,\n            Id_double        = Token.RESERVED,  // ES3 only\n            Id_enum          = Token.RESERVED,\n            Id_extends       = Token.RESERVED,\n            Id_final         = Token.RESERVED,  // ES3 only\n            Id_finally       = Token.FINALLY,\n            Id_float         = Token.RESERVED,  // ES3 only\n            Id_goto          = Token.RESERVED,  // ES3 only\n            Id_implements    = Token.RESERVED,  // ES3, ES5 strict\n            Id_import        = Token.RESERVED,\n            Id_instanceof    = Token.INSTANCEOF,\n            Id_int           = Token.RESERVED,  // ES3\n            Id_interface     = Token.RESERVED,  // ES3, ES5 strict\n            Id_long          = Token.RESERVED,  // ES3 only\n            Id_native        = Token.RESERVED,  // ES3 only\n            Id_package       = Token.RESERVED,  // ES3, ES5 strict\n            Id_private       = Token.RESERVED,  // ES3, ES5 strict\n            Id_protected     = Token.RESERVED,  // ES3, ES5 strict\n            Id_public        = Token.RESERVED,  // ES3, ES5 strict\n            Id_short         = Token.RESERVED,  // ES3 only\n            Id_static        = Token.RESERVED,  // ES3, ES5 strict\n            Id_super         = Token.RESERVED,\n            Id_synchronized  = Token.RESERVED,  // ES3 only\n            Id_throw         = Token.THROW,\n            Id_throws        = Token.RESERVED,  // ES3 only\n            Id_transient     = Token.RESERVED,  // ES3 only\n            Id_try           = Token.TRY,\n            Id_volatile      = Token.RESERVED;  // ES3 only\n\n        int id;\n        String s = name;\n// #generated# Last update: 2007-04-18 13:53:30 PDT\n        L0: { id = 0; String X = null; int c;\n            L: switch (s.length()) {\n            case 2: c=s.charAt(1);\n                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }\n                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }\n                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n                break L;\n            case 3: switch (s.charAt(0)) {\n                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n                case 'l': if (s.charAt(2)=='t' && s.charAt(1)=='e') {id=Id_let; break L0;} break L;\n                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n                } break L;\n            case 4: switch (s.charAt(0)) {\n                case 'b': X=\"byte\";id=Id_byte; break L;\n                case 'c': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {id=Id_case; break L0;} }\n                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {id=Id_char; break L0;} }\n                    break L;\n                case 'e': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {id=Id_else; break L0;} }\n                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {id=Id_enum; break L0;} }\n                    break L;\n                case 'g': X=\"goto\";id=Id_goto; break L;\n                case 'l': X=\"long\";id=Id_long; break L;\n                case 'n': X=\"null\";id=Id_null; break L;\n                case 't': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {id=Id_true; break L0;} }\n                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {id=Id_this; break L0;} }\n                    break L;\n                case 'v': X=\"void\";id=Id_void; break L;\n                case 'w': X=\"with\";id=Id_with; break L;\n                } break L;\n            case 5: switch (s.charAt(2)) {\n                case 'a': X=\"class\";id=Id_class; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='b') { X=\"break\";id=Id_break; }\n                    else if (c=='y') { X=\"yield\";id=Id_yield; }\n                    break L;\n                case 'i': X=\"while\";id=Id_while; break L;\n                case 'l': X=\"false\";id=Id_false; break L;\n                case 'n': c=s.charAt(0);\n                    if (c=='c') { X=\"const\";id=Id_const; }\n                    else if (c=='f') { X=\"final\";id=Id_final; }\n                    break L;\n                case 'o': c=s.charAt(0);\n                    if (c=='f') { X=\"float\";id=Id_float; }\n                    else if (c=='s') { X=\"short\";id=Id_short; }\n                    break L;\n                case 'p': X=\"super\";id=Id_super; break L;\n                case 'r': X=\"throw\";id=Id_throw; break L;\n                case 't': X=\"catch\";id=Id_catch; break L;\n                } break L;\n            case 6: switch (s.charAt(1)) {\n                case 'a': X=\"native\";id=Id_native; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='d') { X=\"delete\";id=Id_delete; }\n                    else if (c=='r') { X=\"return\";id=Id_return; }\n                    break L;\n                case 'h': X=\"throws\";id=Id_throws; break L;\n                case 'm': X=\"import\";id=Id_import; break L;\n                case 'o': X=\"double\";id=Id_double; break L;\n                case 't': X=\"static\";id=Id_static; break L;\n                case 'u': X=\"public\";id=Id_public; break L;\n                case 'w': X=\"switch\";id=Id_switch; break L;\n                case 'x': X=\"export\";id=Id_export; break L;\n                case 'y': X=\"typeof\";id=Id_typeof; break L;\n                } break L;\n            case 7: switch (s.charAt(1)) {\n                case 'a': X=\"package\";id=Id_package; break L;\n                case 'e': X=\"default\";id=Id_default; break L;\n                case 'i': X=\"finally\";id=Id_finally; break L;\n                case 'o': X=\"boolean\";id=Id_boolean; break L;\n                case 'r': X=\"private\";id=Id_private; break L;\n                case 'x': X=\"extends\";id=Id_extends; break L;\n                } break L;\n            case 8: switch (s.charAt(0)) {\n                case 'a': X=\"abstract\";id=Id_abstract; break L;\n                case 'c': X=\"continue\";id=Id_continue; break L;\n                case 'd': X=\"debugger\";id=Id_debugger; break L;\n                case 'f': X=\"function\";id=Id_function; break L;\n                case 'v': X=\"volatile\";id=Id_volatile; break L;\n                } break L;\n            case 9: c=s.charAt(0);\n                if (c=='i') { X=\"interface\";id=Id_interface; }\n                else if (c=='p') { X=\"protected\";id=Id_protected; }\n                else if (c=='t') { X=\"transient\";id=Id_transient; }\n                break L;\n            case 10: c=s.charAt(1);\n                if (c=='m') { X=\"implements\";id=Id_implements; }\n                else if (c=='n') { X=\"instanceof\";id=Id_instanceof; }\n                break L;\n            case 12: X=\"synchronized\";id=Id_synchronized; break L;\n            }\n            if (X!=null && X!=s && !X.equals(s)) id = 0;\n        }\n// #/generated#\n// #/string_id_map#\n        if (id == 0) { return Token.EOF; }\n        return id & 0xff;\n    }",
                    "javadoc_start_line": 80,
                    "annotations_start_line": 80,
                    "method_start_line": 81,
                    "end_line": 254
                }
            ]
        },
        {
            "failing_test": {
                "className": " com.google.javascript.jscomp.ConvertToDottedPropertiesTest",
                "methodName": "testDoNotConvert",
                "error": "junit.framework.AssertionFailedError",
                "message": ""
            },
            "patched_method": {
                "file_path": "/lib/rhino/src/org/mozilla/javascript/TokenStream.java",
                "method_name": "stringToKeyword",
                "content": "    private static int stringToKeyword(String name)\n    {\n// #string_id_map#\n// The following assumes that Token.EOF == 0\n        final int\n            Id_break         = Token.BREAK,\n            Id_case          = Token.CASE,\n            Id_continue      = Token.CONTINUE,\n            Id_default       = Token.DEFAULT,\n            Id_delete        = Token.DELPROP,\n            Id_do            = Token.DO,\n            Id_else          = Token.ELSE,\n            Id_export        = Token.RESERVED,\n            Id_false         = Token.FALSE,\n            Id_for           = Token.FOR,\n            Id_function      = Token.FUNCTION,\n            Id_if            = Token.IF,\n            Id_in            = Token.IN,\n            Id_let           = Token.LET,  // reserved ES5 strict\n            Id_new           = Token.NEW,\n            Id_null          = Token.NULL,\n            Id_return        = Token.RETURN,\n            Id_switch        = Token.SWITCH,\n            Id_this          = Token.THIS,\n            Id_true          = Token.TRUE,\n            Id_typeof        = Token.TYPEOF,\n            Id_var           = Token.VAR,\n            Id_void          = Token.VOID,\n            Id_while         = Token.WHILE,\n            Id_with          = Token.WITH,\n            Id_yield         = Token.YIELD,  // reserved ES5 strict\n\n            // the following are #ifdef RESERVE_JAVA_KEYWORDS in jsscan.c\n            Id_abstract      = Token.RESERVED,  // ES3 only\n            Id_boolean       = Token.RESERVED,  // ES3 only\n            Id_byte          = Token.RESERVED,  // ES3 only\n            Id_catch         = Token.CATCH,\n            Id_char          = Token.RESERVED,  // ES3 only\n            Id_class         = Token.RESERVED,\n            Id_const         = Token.CONST,     // reserved\n            Id_debugger      = Token.DEBUGGER,\n            Id_double        = Token.RESERVED,  // ES3 only\n            Id_enum          = Token.RESERVED,\n            Id_extends       = Token.RESERVED,\n            Id_final         = Token.RESERVED,  // ES3 only\n            Id_finally       = Token.FINALLY,\n            Id_float         = Token.RESERVED,  // ES3 only\n            Id_goto          = Token.RESERVED,  // ES3 only\n            Id_implements    = Token.RESERVED,  // ES3, ES5 strict\n            Id_import        = Token.RESERVED,\n            Id_instanceof    = Token.INSTANCEOF,\n            Id_int           = Token.RESERVED,  // ES3\n            Id_interface     = Token.RESERVED,  // ES3, ES5 strict\n            Id_long          = Token.RESERVED,  // ES3 only\n            Id_native        = Token.RESERVED,  // ES3 only\n            Id_package       = Token.RESERVED,  // ES3, ES5 strict\n            Id_private       = Token.RESERVED,  // ES3, ES5 strict\n            Id_protected     = Token.RESERVED,  // ES3, ES5 strict\n            Id_public        = Token.RESERVED,  // ES3, ES5 strict\n            Id_short         = Token.RESERVED,  // ES3 only\n            Id_static        = Token.RESERVED,  // ES3, ES5 strict\n            Id_super         = Token.RESERVED,\n            Id_synchronized  = Token.RESERVED,  // ES3 only\n            Id_throw         = Token.THROW,\n            Id_throws        = Token.RESERVED,  // ES3 only\n            Id_transient     = Token.RESERVED,  // ES3 only\n            Id_try           = Token.TRY,\n            Id_volatile      = Token.RESERVED;  // ES3 only\n\n        int id;\n        String s = name;\n// #generated# Last update: 2007-04-18 13:53:30 PDT\n        L0: { id = 0; String X = null; int c;\n            L: switch (s.length()) {\n            case 2: c=s.charAt(1);\n                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }\n                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }\n                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n                break L;\n            case 3: switch (s.charAt(0)) {\n                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n                case 'l': if (s.charAt(2)=='t' && s.charAt(1)=='e') {id=Id_let; break L0;} break L;\n                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n                } break L;\n            case 4: switch (s.charAt(0)) {\n                case 'b': X=\"byte\";id=Id_byte; break L;\n                case 'c': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {id=Id_case; break L0;} }\n                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {id=Id_char; break L0;} }\n                    break L;\n                case 'e': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {id=Id_else; break L0;} }\n                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {id=Id_enum; break L0;} }\n                    break L;\n                case 'g': X=\"goto\";id=Id_goto; break L;\n                case 'l': X=\"long\";id=Id_long; break L;\n                case 'n': X=\"null\";id=Id_null; break L;\n                case 't': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {id=Id_true; break L0;} }\n                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {id=Id_this; break L0;} }\n                    break L;\n                case 'v': X=\"void\";id=Id_void; break L;\n                case 'w': X=\"with\";id=Id_with; break L;\n                } break L;\n            case 5: switch (s.charAt(2)) {\n                case 'a': X=\"class\";id=Id_class; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='b') { X=\"break\";id=Id_break; }\n                    else if (c=='y') { X=\"yield\";id=Id_yield; }\n                    break L;\n                case 'i': X=\"while\";id=Id_while; break L;\n                case 'l': X=\"false\";id=Id_false; break L;\n                case 'n': c=s.charAt(0);\n                    if (c=='c') { X=\"const\";id=Id_const; }\n                    else if (c=='f') { X=\"final\";id=Id_final; }\n                    break L;\n                case 'o': c=s.charAt(0);\n                    if (c=='f') { X=\"float\";id=Id_float; }\n                    else if (c=='s') { X=\"short\";id=Id_short; }\n                    break L;\n                case 'p': X=\"super\";id=Id_super; break L;\n                case 'r': X=\"throw\";id=Id_throw; break L;\n                case 't': X=\"catch\";id=Id_catch; break L;\n                } break L;\n            case 6: switch (s.charAt(1)) {\n                case 'a': X=\"native\";id=Id_native; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='d') { X=\"delete\";id=Id_delete; }\n                    else if (c=='r') { X=\"return\";id=Id_return; }\n                    break L;\n                case 'h': X=\"throws\";id=Id_throws; break L;\n                case 'm': X=\"import\";id=Id_import; break L;\n                case 'o': X=\"double\";id=Id_double; break L;\n                case 't': X=\"static\";id=Id_static; break L;\n                case 'u': X=\"public\";id=Id_public; break L;\n                case 'w': X=\"switch\";id=Id_switch; break L;\n                case 'x': X=\"export\";id=Id_export; break L;\n                case 'y': X=\"typeof\";id=Id_typeof; break L;\n                } break L;\n            case 7: switch (s.charAt(1)) {\n                case 'a': X=\"package\";id=Id_package; break L;\n                case 'e': X=\"default\";id=Id_default; break L;\n                case 'i': X=\"finally\";id=Id_finally; break L;\n                case 'o': X=\"boolean\";id=Id_boolean; break L;\n                case 'r': X=\"private\";id=Id_private; break L;\n                case 'x': X=\"extends\";id=Id_extends; break L;\n                } break L;\n            case 8: switch (s.charAt(0)) {\n                case 'a': X=\"abstract\";id=Id_abstract; break L;\n                case 'c': X=\"continue\";id=Id_continue; break L;\n                case 'd': X=\"debugger\";id=Id_debugger; break L;\n                case 'f': X=\"function\";id=Id_function; break L;\n                case 'v': X=\"volatile\";id=Id_volatile; break L;\n                } break L;\n            case 9: c=s.charAt(0);\n                if (c=='i') { X=\"interface\";id=Id_interface; }\n                else if (c=='p') { X=\"protected\";id=Id_protected; }\n                else if (c=='t') { X=\"transient\";id=Id_transient; }\n                break L;\n            case 10: c=s.charAt(1);\n                if (c=='m') { X=\"implements\";id=Id_implements; }\n                else if (c=='n') { X=\"instanceof\";id=Id_instanceof; }\n                break L;\n            case 12: X=\"synchronized\";id=Id_synchronized; break L;\n            }\n            if (X!=null && X!=s && !X.equals(s)) id = 0;\n        }\n// #/generated#\n// #/string_id_map#\n        if (id == 0) { return Token.EOF; }\n        return id & 0xff;\n    }",
                "javadoc_start_line": 80,
                "annotations_start_line": 80,
                "method_start_line": 81,
                "end_line": 254
            },
            "steps": [],
            "generation_failure": {
                "error": "Failed to generate stacktrace",
                "error_message": "Command failed: defects4j test -w ./projects/Closure/131\nRunning ant (compile.tests)................................................ FAIL\nExecuted command:  cd /home/balfroim/Documents/Shomidacode/script/projects/Closure/131 && /home/balfroim/Documents/Defect4J/defects4j/major/bin/ant -f /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml -Dd4j.home=/home/balfroim/Documents/Defect4J/defects4j -Dd4j.dir.projects=/home/balfroim/Documents/Defect4J/defects4j/framework/projects -Dbasedir=/home/balfroim/Documents/Shomidacode/script/projects/Closure/131 -Dbuild.compiler=javac1.7  compile.tests 2>&1\nOpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=1G; support was removed in 8.0\nBuildfile: /home/balfroim/Documents/Defect4J/defects4j/framework/projects/defects4j.build.xml\n\nrhino:\n\nproperties:\n\ninit:\n\ncompile:\n\ncompile-most:\n    [javac] Compiling 2 source files to /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/build/lib/classes\n    [javac] warning: [options] bootstrap class path not set in conjunction with -source 1.5\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Reader.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/BufferedWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation': class file for jdk.Profile+Annotation not found\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/IOException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintWriter.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Matcher.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/regex/Pattern.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Object.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/String.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StackTraceElement.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Reader.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AutoCloseable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Thread.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Thread.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/sun/misc/Contended.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/sun/misc/Contended.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Retention.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/RetentionPolicy.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/Target.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/annotation/ElementType.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/File.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/File.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/nio/charset/Charset.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/nio/charset/Charset.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/OutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Writer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Writer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/CharSequence.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/CharSequence.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/Serializable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Comparable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Locale.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/util/Locale.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Integer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Integer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Number.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Number.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Exception.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Throwable.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/System.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/PrintStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FilterOutputStream.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Error.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Error.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FileNotFoundException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/FileNotFoundException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/RuntimeException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/UnsupportedEncodingException.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/io/UnsupportedEncodingException.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Byte.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Byte.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Character.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Character.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Short.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Short.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Long.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Long.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Float.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Float.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Double.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Double.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Boolean.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Boolean.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Void.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/Void.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuilder.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuilder.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AbstractStringBuilder.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/AbstractStringBuilder.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] warning: /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): major version 52 is newer than 51, the highest major version supported by this compiler.\n    [javac]   It is recommended that the compiler be upgraded.\n    [javac] /home/balfroim/.sdkman/candidates/java/8.0.362-amzn/lib/ct.sym(META-INF/sym/rt.jar/java/lang/StringBuffer.class): warning: Cannot find annotation method 'value()' in type 'Profile+Annotation'\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java:15: error: duplicate class: lib.rhino.org.mozilla.javascript.StackTraceRecorder\n    [javac] public class StackTraceRecorder {\n    [javac]        ^\n    [javac] /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/org/mozilla/javascript/TokenStream.java:82: error: cannot access StackTraceRecorder\n    [javac] StackTraceRecorder recorder = new StackTraceRecorder(\"testDoNotConvert\", \"stringToKeyword\", \"./results/stacktrace-testDoNotConvert-stringToKeyword.csv\");\n    [javac] ^\n    [javac]   bad source file: /home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/org/mozilla/javascript/StackTraceRecorder.java\n    [javac]     file does not contain class org.mozilla.javascript.StackTraceRecorder\n    [javac]     Please remove or make sure it appears in the correct subdirectory of the sourcepath.\n    [javac] 2 errors\n    [javac] 93 warnings\n\nBUILD FAILED\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/131/build.xml:98: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/build.xml:45: The following error occurred while executing this line:\n/home/balfroim/Documents/Shomidacode/script/projects/Closure/131/lib/rhino/src/build.xml:38: Compile failed; see the compiler error output for details.\n\nTotal time: 0 seconds\nCannot compile test suite! at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/d4j/d4j-test line 134.\nCompilation failed in require at /home/balfroim/Documents/Defect4J/defects4j/framework/bin/defects4j line 195.\n\n"
            }
        }
    ],
    "project": {
        "name": "Closure",
        "version": 131
    }
}