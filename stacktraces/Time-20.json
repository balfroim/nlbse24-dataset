{"tours": [{"failing_test": {"className": " org.joda.time.format.TestDateTimeFormatterBuilder", "methodName": "test_printParseZoneDawsonCreek", "error": "java.lang.IllegalArgumentException", "message": "Invalid format: \"2007-03-04 12:30 America/Dawson_Creek\" is malformed at \"_Creek\""}, "patched_method": {"file_path": "/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java", "method_name": "parseInto", "content": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }", "javadoc_start_line": 2540, "annotations_start_line": 2540, "method_start_line": 2540, "end_line": 2549}, "steps": [{"file_path": "/src/test/java/org/joda/time/format/TestDateTimeFormatterBuilder.java", "method_name": "test_printParseZoneDawsonCreek", "content": "    public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n            .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n        DateTimeFormatter f = bld.toFormatter();\n        \n        DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\n        assertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\n        assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n    }", "javadoc_start_line": 255, "annotations_start_line": 255, "method_start_line": 255, "end_line": 263}, {"file_path": "/src/main/java/org/joda/time/format/DateTimeFormatter.java", "method_name": "parseDateTime", "content": "    /**\n     * Parses a date-time from the given text, returning a new DateTime.\n     * <p>\n     * The parse will use the zone and chronology specified on this formatter.\n     * <p>\n     * If the text contains a time zone string then that will be taken into\n     * account in adjusting the time of day as follows.\n     * If the {@link #withOffsetParsed()} has been called, then the resulting\n     * DateTime will have a fixed offset based on the parsed time zone.\n     * Otherwise the resulting DateTime will have the zone of this formatter,\n     * but the parsed zone may have caused the time to be adjusted.\n     *\n     * @param text  the text to parse, not null\n     * @return the parsed date-time, never null\n     * @throws UnsupportedOperationException if parsing is not supported\n     * @throws IllegalArgumentException if the text to parse is invalid\n     */\n    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }", "javadoc_start_line": 824, "annotations_start_line": 841, "method_start_line": 841, "end_line": 867}]}], "project": {"name": "Time", "version": 20}}