{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest", "methodName": "testIssue794b", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java", "method_name": "hasExceptionHandler", "content": "  private boolean hasExceptionHandler(Node cfgNode) {\n    return false;\n  }", "javadoc_start_line": 159, "annotations_start_line": 159, "method_start_line": 159, "end_line": 161}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverseRoots(externs, root);\n  }", "javadoc_start_line": 176, "annotations_start_line": 175, "method_start_line": 176, "end_line": 178}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }", "javadoc_start_line": 284, "annotations_start_line": 284, "method_start_line": 284, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 288, "end_line": 311}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 474, "annotations_start_line": 477, "method_start_line": 478, "end_line": 506}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 508, "annotations_start_line": 511, "method_start_line": 511, "end_line": 546}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 562, "annotations_start_line": 563, "method_start_line": 563, "end_line": 570}, {"file_path": "/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java", "method_name": "enterScope", "content": "  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n        t.getScope().getVarCount()) {\n      return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n\n        // If definition c has dependencies, then inlining it may have\n        // introduced new dependencies for our other inlining candidates.\n        //\n        // MustBeReachingVariableDef uses this dependency graph in its\n        // analysis, so some of these candidates may no longer be valid.\n        // We keep track of when the variable dependency graph changed\n        // so that we can back off appropriately.\n        if (!c.defMetadata.depends.isEmpty()) {\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n        }\n      }\n    }\n  }", "javadoc_start_line": 125, "annotations_start_line": 124, "method_start_line": 125, "end_line": 170}, {"file_path": "/src/com/google/javascript/jscomp/DataFlowAnalysis.java", "method_name": "analyze", "content": "  /**\n   * Finds a fixed-point solution using at most {@link #MAX_STEPS}\n   * iterations.\n   *\n   * @see #analyze(int)\n   */\n  final void analyze() {\n    analyze(MAX_STEPS);\n  }", "javadoc_start_line": 173, "annotations_start_line": 179, "method_start_line": 179, "end_line": 181}, {"file_path": "/src/com/google/javascript/jscomp/DataFlowAnalysis.java", "method_name": "analyze", "content": "  /**\n   * Finds a fixed-point solution. The function has the side effect of replacing\n   * the existing node annotations with the computed solutions using {@link\n   * com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.\n   *\n   * <p>Initially, each node's input and output flow state contains the value\n   * given by {@link #createInitialEstimateLattice()} (with the exception of the\n   * entry node of the graph which takes on the {@link #createEntryLattice()}\n   * value. Each node will use the output state of its predecessor and compute a\n   * output state according to the instruction. At that time, any nodes that\n   * depends on the node's newly modified output value will need to recompute\n   * their output state again. Each step will perform a computation at one node\n   * until no extra computation will modify any existing output state anymore.\n   *\n   * @param maxSteps Max number of iterations before the method stops and throw\n   *        a {@link MaxIterationsExceededException}. This will prevent the\n   *        analysis from going into a infinite loop.\n   */\n  final void analyze(int maxSteps) {\n    initialize();\n    int step = 0;\n    while (!orderedWorkSet.isEmpty()) {\n      if (step > maxSteps) {\n        throw new MaxIterationsExceededException(\n          \"Analysis did not terminate after \" + maxSteps + \" iterations\");\n      }\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\n      orderedWorkSet.remove(curNode);\n      joinInputs(curNode);\n      if (flow(curNode)) {\n        // If there is a change in the current node, we want to grab the list\n        // of nodes that this node affects.\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\n            cfg.getDirectedSuccNodes(curNode) :\n            cfg.getDirectedPredNodes(curNode);\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\n          if (nextNode != cfg.getImplicitReturn()) {\n            orderedWorkSet.add(nextNode);\n          }\n        }\n      }\n      step++;\n    }\n    if (isForward()) {\n      joinInputs(getCfg().getImplicitReturn());\n    }\n  }", "javadoc_start_line": 183, "annotations_start_line": 201, "method_start_line": 201, "end_line": 229}, {"file_path": "/src/com/google/javascript/jscomp/DataFlowAnalysis.java", "method_name": "flow", "content": "  /**\n   * Performs a single flow through a node.\n   *\n   * @return {@code true} if the flow state differs from the previous state.\n   */\n  protected boolean flow(DiGraphNode<N, Branch> node) {\n    FlowState<L> state = node.getAnnotation();\n    if (isForward()) {\n      L outBefore = state.out;\n      state.out = flowThrough(node.getValue(), state.in);\n      return !outBefore.equals(state.out);\n    } else {\n      L inBefore = state.in;\n      state.in = flowThrough(node.getValue(), state.out);\n      return !inBefore.equals(state.in);\n    }\n  }", "javadoc_start_line": 262, "annotations_start_line": 267, "method_start_line": 267, "end_line": 278}, {"file_path": "/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java", "method_name": "flowThrough", "content": "  ReachingUses flowThrough(Node n, ReachingUses input) {\n    ReachingUses output = new ReachingUses(input);\n\n    // If there's an ON_EX edge, this cfgNode may or may not get executed.\n    // We can express this concisely by just pretending this happens in\n    // a conditional.\n    boolean conditional = hasExceptionHandler(n);\n    computeMayUse(n, n, output, conditional);\n\n    return output;\n  }", "javadoc_start_line": 147, "annotations_start_line": 146, "method_start_line": 147, "end_line": 157}, {"file_path": "/src/com/google/javascript/jscomp/MaybeReachingVariableUse.java", "method_name": "hasExceptionHandler", "content": "  private boolean hasExceptionHandler(Node cfgNode) {\n    return false;\n  }", "javadoc_start_line": 159, "annotations_start_line": 159, "method_start_line": 159, "end_line": 161}]}], "project": {"name": "Closure", "version": 12}}