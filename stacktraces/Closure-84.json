{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testDestructuringAssignForbidden4", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "processUnaryExpression", "content": "    Node processUnaryExpression(UnaryExpression exprNode) {\n      int type = transformTokenType(exprNode.getType());\n      Node operand = transform(exprNode.getOperand());\n      if (type == Token.NEG && operand.getType() == Token.NUMBER) {\n        operand.setDouble(-operand.getDouble());\n        return operand;\n      } else {\n\n        Node node = newNode(type, operand);\n        if (exprNode.isPostfix()) {\n          node.putBooleanProp(Node.INCRDECR_PROP, true);\n        }\n        return node;\n      }\n    }", "javadoc_start_line": 790, "annotations_start_line": 789, "method_start_line": 790, "end_line": 804}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/84/results/stacktrace-testDestructuringAssignForbidden4-processUnaryExpression.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.ParserTest", "methodName": "testDestructuringAssignForbidden4", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "processAssignment", "content": "    Node processAssignment(Assignment assignmentNode) {\n      Node assign = processInfixExpression(assignmentNode);\n      return assign;\n    }", "javadoc_start_line": 339, "annotations_start_line": 338, "method_start_line": 339, "end_line": 342}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/parsing/ParserRunner.java", "method_name": "parse", "content": "  /**\n   * Parses the JavaScript text given by a reader.\n   *\n   * @param sourceName The filename.\n   * @param sourceString Source code from the file.\n   * @param errorReporter An error.\n   * @param logger A logger.\n   * @return The AST of the given text.\n   * @throws IOException\n   */\n  public static Node parse(String sourceName,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    compilerEnv.setWarnTrailingComma(true);\n    if (config.isIdeMode) {\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceName, 1);\n    } catch (EvaluatorException e) {\n      logger.info(\"Error parsing \" + sourceName + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }", "javadoc_start_line": 75, "annotations_start_line": 85, "method_start_line": 89, "end_line": 119}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transformTree", "content": "  public static Node transformTree(AstRoot node,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == JSDOC && !comment.isParsed()) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }", "javadoc_start_line": 123, "annotations_start_line": 123, "method_start_line": 126, "end_line": 142}, {"file_path": "/src/com/google/javascript/rhino/IRFactory.java", "method_name": "createExprStatement", "content": "    Node createExprStatement(Node expr, int lineno, int charno)\n    {\n        int type;\n        if (parser.insideFunction()) {\n            type = Token.EXPR_VOID;\n        } else {\n            type = Token.EXPR_RESULT;\n        }\n        return new Node(type, expr, lineno, charno);\n    }", "javadoc_start_line": 124, "annotations_start_line": 124, "method_start_line": 125, "end_line": 133}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transform", "content": "  private Node transform(AstNode node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = justTransform(node);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    return irNode;\n  }", "javadoc_start_line": 204, "annotations_start_line": 204, "method_start_line": 204, "end_line": 228}, {"file_path": "/src/com/google/javascript/rhino/IRFactory.java", "method_name": "createContinue", "content": "    /**\n     * Continue (possibly labeled)\n     */\n    Node createContinue(String label, int lineno, int charno)\n    {\n        Node result = new Node(Token.CONTINUE, lineno, charno);\n        if (label == null) {\n            return result;\n        } else {\n            Node name = Node.newString(Token.NAME, label, lineno, charno);\n            result.addChildToBack(name);\n            return result;\n        }\n    }", "javadoc_start_line": 262, "annotations_start_line": 265, "method_start_line": 266, "end_line": 275}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "justTransform", "content": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }", "javadoc_start_line": 272, "annotations_start_line": 272, "method_start_line": 272, "end_line": 274}, {"file_path": "/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java", "method_name": "process", "content": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }", "javadoc_start_line": 118, "annotations_start_line": 118, "method_start_line": 118, "end_line": 281}, {"file_path": "/src/com/google/javascript/rhino/IRFactory.java", "method_name": "createLeaf", "content": "    /**\n     * Leaf\n     */\n    Node createLeaf(int nodeType)\n    {\n        return new Node(nodeType);\n    }", "javadoc_start_line": 71, "annotations_start_line": 74, "method_start_line": 75, "end_line": 77}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<obinit>", "content": "public class IRFactory {", "javadoc_start_line": 76, "annotations_start_line": 76, "method_start_line": 76, "end_line": 76}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transform", "content": "  private Node transform(AstNode node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = justTransform(node);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    return irNode;\n  }", "javadoc_start_line": 204, "annotations_start_line": 204, "method_start_line": 204, "end_line": 228}, {"file_path": "/src/com/google/javascript/rhino/IRFactory.java", "method_name": "createContinue", "content": "    /**\n     * Continue (possibly labeled)\n     */\n    Node createContinue(String label, int lineno, int charno)\n    {\n        Node result = new Node(Token.CONTINUE, lineno, charno);\n        if (label == null) {\n            return result;\n        } else {\n            Node name = Node.newString(Token.NAME, label, lineno, charno);\n            result.addChildToBack(name);\n            return result;\n        }\n    }", "javadoc_start_line": 262, "annotations_start_line": 265, "method_start_line": 266, "end_line": 275}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "justTransform", "content": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }", "javadoc_start_line": 272, "annotations_start_line": 272, "method_start_line": 272, "end_line": 274}, {"file_path": "/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java", "method_name": "process", "content": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }", "javadoc_start_line": 118, "annotations_start_line": 118, "method_start_line": 118, "end_line": 281}, {"file_path": "/src/com/google/javascript/rhino/IRFactory.java", "method_name": "createLeaf", "content": "    /**\n     * Leaf\n     */\n    Node createLeaf(int nodeType)\n    {\n        return new Node(nodeType);\n    }", "javadoc_start_line": 71, "annotations_start_line": 74, "method_start_line": 75, "end_line": 77}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "<obinit>", "content": "public class IRFactory {", "javadoc_start_line": 76, "annotations_start_line": 76, "method_start_line": 76, "end_line": 76}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "transform", "content": "  private Node transform(AstNode node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = justTransform(node);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    return irNode;\n  }", "javadoc_start_line": 204, "annotations_start_line": 204, "method_start_line": 204, "end_line": 228}, {"file_path": "/src/com/google/javascript/rhino/IRFactory.java", "method_name": "createContinue", "content": "    /**\n     * Continue (possibly labeled)\n     */\n    Node createContinue(String label, int lineno, int charno)\n    {\n        Node result = new Node(Token.CONTINUE, lineno, charno);\n        if (label == null) {\n            return result;\n        } else {\n            Node name = Node.newString(Token.NAME, label, lineno, charno);\n            result.addChildToBack(name);\n            return result;\n        }\n    }", "javadoc_start_line": 262, "annotations_start_line": 265, "method_start_line": 266, "end_line": 275}, {"file_path": "/src/com/google/javascript/jscomp/parsing/IRFactory.java", "method_name": "justTransform", "content": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }", "javadoc_start_line": 272, "annotations_start_line": 272, "method_start_line": 272, "end_line": 274}, {"file_path": "/src/com/google/javascript/jscomp/parsing/TypeSafeDispatcher.java", "method_name": "process", "content": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }", "javadoc_start_line": 118, "annotations_start_line": 118, "method_start_line": 118, "end_line": 281}]}], "project": {"name": "Closure", "version": 84}}