{"tours": [{"failing_test": {"className": " org.apache.commons.math.distribution.FDistributionTest", "methodName": "testSmallDegreesOfFreedom", "error": "java.lang.IllegalArgumentException", "message": "Invalid endpoint parameters:  lowerBound=0.0 initial=-1.0 upperBound=1.7976931348623157E308"}, "patched_method": {"file_path": "/src/java/org/apache/commons/math/distribution/FDistributionImpl.java", "method_name": "getInitialDomain", "content": "    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }", "javadoc_start_line": 135, "annotations_start_line": 143, "method_start_line": 143, "end_line": 149}, "steps": [{"file_path": "/src/test/org/apache/commons/math/distribution/FDistributionTest.java", "method_name": "testSmallDegreesOfFreedom", "content": "    public void testSmallDegreesOfFreedom() throws Exception {\n        org.apache.commons.math.distribution.FDistributionImpl fd =\n            new org.apache.commons.math.distribution.FDistributionImpl(\n                1.0, 1.0);\n        double p = fd.cumulativeProbability(0.975);\n        double x = fd.inverseCumulativeProbability(p);\n        assertEquals(0.975, x, 1.0e-5);\n\n        fd.setDenominatorDegreesOfFreedom(2.0);\n        p = fd.cumulativeProbability(0.975);\n        x = fd.inverseCumulativeProbability(p);\n        assertEquals(0.975, x, 1.0e-5);\n    }", "javadoc_start_line": 109, "annotations_start_line": 109, "method_start_line": 109, "end_line": 121}, {"file_path": "/src/java/org/apache/commons/math/distribution/FDistributionImpl.java", "method_name": "inverseCumulativeProbability", "content": "    /**\n     * For this distribution, X, this method returns the critical point x, such\n     * that P(X &lt; x) = <code>p</code>.\n     * <p>\n     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n     *\n     * @param p the desired probability\n     * @return x, such that P(X &lt; x) = <code>p</code>\n     * @throws MathException if the inverse cumulative probability can not be\n     *         computed due to convergence or other numerical errors.\n     * @throws IllegalArgumentException if <code>p</code> is not a valid\n     *         probability.\n     */\n    public double inverseCumulativeProbability(final double p) \n        throws MathException {\n        if (p == 0) {\n            return 0d;\n        }\n        if (p == 1) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return super.inverseCumulativeProbability(p);\n    }", "javadoc_start_line": 85, "annotations_start_line": 98, "method_start_line": 99, "end_line": 107}, {"file_path": "/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java", "method_name": "inverseCumulativeProbability", "content": "    /**\n     * For this distribution, X, this method returns the critical point x, such\n     * that P(X &lt; x) = <code>p</code>.\n     *\n     * @param p the desired probability\n     * @return x, such that P(X &lt; x) = <code>p</code>\n     * @throws MathException if the inverse cumulative probability can not be\n     *         computed due to convergence or other numerical errors.\n     * @throws IllegalArgumentException if <code>p</code> is not a valid\n     *         probability.\n     */\n    public double inverseCumulativeProbability(final double p)\n        throws MathException {\n        if (p < 0.0 || p > 1.0) {\n            throw new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n        }\n\n        // by default, do simple root finding using bracketing and default solver.\n        // subclasses can overide if there is a better method.\n        UnivariateRealFunction rootFindingFunction =\n            new UnivariateRealFunction() {\n\n            public double value(double x) throws FunctionEvaluationException {\n                try {\n                    return cumulativeProbability(x) - p;\n                } catch (MathException ex) {\n                    throw new FunctionEvaluationException(x, ex.getPattern(), ex.getArguments(), ex);\n                }\n            }\n        };\n              \n        // Try to bracket root, test domain endoints if this fails     \n        double lowerBound = getDomainLowerBound(p);\n        double upperBound = getDomainUpperBound(p);\n        double[] bracket = null;\n        try {\n            bracket = UnivariateRealSolverUtils.bracket(\n                    rootFindingFunction, getInitialDomain(p),\n                    lowerBound, upperBound);\n        }  catch (ConvergenceException ex) {\n            /* \n             * Check domain endpoints to see if one gives value that is within\n             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n             * case if density has bounded support and p is 0 or 1).\n             * \n             * TODO: expose the default solver, defaultAbsoluteAccuracy as\n             * a constant.\n             */ \n            if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                return lowerBound;\n            }\n            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n                return upperBound;\n            }     \n            // Failed bracket convergence was not because of corner solution\n            throw new MathException(ex);\n        }\n\n        // find root\n        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n                bracket[0],bracket[1]);\n        return root;\n    }", "javadoc_start_line": 48, "annotations_start_line": 59, "method_start_line": 60, "end_line": 110}, {"file_path": "/src/java/org/apache/commons/math/distribution/FDistributionImpl.java", "method_name": "getInitialDomain", "content": "    /**\n     * Access the initial domain value, based on <code>p</code>, used to\n     * bracket a CDF root.  This method is used by\n     * {@link #inverseCumulativeProbability(double)} to find critical values.\n     * \n     * @param p the desired probability for the critical value\n     * @return initial domain value\n     */\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }", "javadoc_start_line": 135, "annotations_start_line": 143, "method_start_line": 143, "end_line": 149}]}], "project": {"name": "Math", "version": 95}}