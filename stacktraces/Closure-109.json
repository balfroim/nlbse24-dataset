{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.parsing.JsDocInfoParserTest", "methodName": "testStructuralConstructor2", "error": "junit.framework.AssertionFailedError", "message": "extra warning: Bad type annotation. type not recognized due to syntax error"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseContextTypeExpression", "content": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }", "javadoc_start_line": 1903, "annotations_start_line": 1907, "method_start_line": 1907, "end_line": 1909}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parse", "content": "  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse() {\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());\n  }", "javadoc_start_line": 208, "annotations_start_line": 216, "method_start_line": 216, "end_line": 239}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseHelperLoop", "content": "  private boolean parseHelperLoop(JsDocToken token,\n                                  List<ExtendedTypeInfo> extendedTypes) {\n    while (true) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            token = parseAnnotation(token, extendedTypes);\n          } else {\n            token = next();\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          break;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n          }\n          break;\n      }\n    }\n  }", "javadoc_start_line": 241, "annotations_start_line": 241, "method_start_line": 242, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseAnnotation", "content": "  private JsDocToken parseAnnotation(JsDocToken token,\n      List<ExtendedTypeInfo> extendedTypes) {\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n\n    String annotationName = stream.getString();\n    Annotation annotation = annotationNames.get(annotationName);\n    if (annotation == null) {\n      parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n          stream.getLineno(), stream.getCharno());\n    } else {\n      // Mark the beginning of the annotation.\n      jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n      switch (annotation) {\n        case NG_INJECT:\n          if (jsdocBuilder.isNgInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordNgInject(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_INJECT:\n          if (jsdocBuilder.isJaggerInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerInject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerInject(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_MODULE:\n          if (jsdocBuilder.isJaggerModuleRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerModule.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerModule(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_PROVIDE:\n          if (jsdocBuilder.isJaggerProvideRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerProvide.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerProvide(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case AUTHOR:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo authorInfo = extractSingleLineBlock();\n            String author = authorInfo.string;\n\n            if (author.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addAuthor(author);\n            }\n            token = authorInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case CONSISTENTIDGENERATOR:\n          if (!jsdocBuilder.recordConsistentIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case STRUCT:\n          if (!jsdocBuilder.recordStruct()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DICT:\n          if (!jsdocBuilder.recordDict()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case CONSTRUCTOR:\n          if (!jsdocBuilder.recordConstructor()) {\n            if (jsdocBuilder.isInterfaceRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DEPRECATED:\n          if (!jsdocBuilder.recordDeprecated()) {\n            parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          // Find the reason/description, if any.\n          ExtractionInfo reasonInfo =\n              extractMultilineTextualBlock(token);\n\n          String reason = reasonInfo.string;\n\n          if (reason.length() > 0) {\n            jsdocBuilder.recordDeprecationReason(reason);\n          }\n\n          token = reasonInfo.token;\n          return token;\n\n        case INTERFACE:\n          if (!jsdocBuilder.recordInterface()) {\n            if (jsdocBuilder.isConstructorRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DESC:\n          if (jsdocBuilder.isDescriptionRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                stream.getLineno(), stream.getCharno());\n            return eatUntilEOLIfNotAnnotation();\n          } else {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            jsdocBuilder.recordDescription(description);\n            token = descriptionInfo.token;\n            return token;\n          }\n\n        case FILE_OVERVIEW:\n          String fileOverview = \"\";\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo fileOverviewInfo =\n                extractMultilineTextualBlock(token,\n                    WhitespaceOption.TRIM);\n\n            fileOverview = fileOverviewInfo.string;\n\n            token = fileOverviewInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n\n          if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n            parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case LICENSE:\n        case PRESERVE:\n          ExtractionInfo preserveInfo =\n              extractMultilineTextualBlock(token,\n                                           WhitespaceOption.PRESERVE);\n\n          String preserve = preserveInfo.string;\n\n          if (preserve.length() > 0) {\n            if (fileLevelJsDocBuilder != null) {\n              fileLevelJsDocBuilder.append(preserve);\n            }\n          }\n\n          token = preserveInfo.token;\n          return token;\n\n        case ENUM:\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          type = null;\n          if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n          }\n\n          if (type == null) {\n            type = createJSTypeExpression(newStringNode(\"number\"));\n          }\n          if (!jsdocBuilder.recordEnumParameterType(type)) {\n            parser.addTypeWarning(\n                \"msg.jsdoc.incompat.type\", lineno, charno);\n          }\n          token = eatUntilEOLIfNotAnnotation(token);\n          return token;\n\n        case EXPORT:\n          if (!jsdocBuilder.recordExport()) {\n            parser.addParserWarning(\"msg.jsdoc.export\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXPOSE:\n          if (!jsdocBuilder.recordExpose()) {\n            parser.addParserWarning(\"msg.jsdoc.expose\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXTERNS:\n          if (!jsdocBuilder.recordExterns()) {\n            parser.addParserWarning(\"msg.jsdoc.externs\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAVA_DISPATCH:\n          if (!jsdocBuilder.recordJavaDispatch()) {\n            parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXTENDS:\n        case IMPLEMENTS:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          boolean matchingRc = false;\n\n          if (token == JsDocToken.LC) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (token == JsDocToken.STRING) {\n            Node typeNode = parseAndRecordTypeNameNode(\n                token, lineno, charno, matchingRc);\n\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            typeNode = wrapNode(Token.BANG, typeNode);\n            type = createJSTypeExpression(typeNode);\n\n            if (annotation == Annotation.EXTENDS) {\n              // record the extended type, check later\n              extendedTypes.add(new ExtendedTypeInfo(\n                  type, stream.getLineno(), stream.getCharno()));\n            } else {\n              Preconditions.checkState(\n                  annotation == Annotation.IMPLEMENTS);\n              if (!jsdocBuilder.recordImplementedInterface(type)) {\n                parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                    lineno, charno);\n              }\n            }\n            token = next();\n            if (matchingRc) {\n              if (token != JsDocToken.RC) {\n                parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                    stream.getLineno(), stream.getCharno());\n              } else {\n                token = next();\n              }\n            } else if (token != JsDocToken.EOL &&\n                token != JsDocToken.EOF && token != JsDocToken.EOC) {\n              parser.addTypeWarning(\"msg.end.annotation.expected\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n          }\n          token = eatUntilEOLIfNotAnnotation(token);\n          return token;\n\n        case HIDDEN:\n          if (!jsdocBuilder.recordHiddenness()) {\n            parser.addParserWarning(\"msg.jsdoc.hidden\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case LENDS:\n          skipEOLs();\n\n          matchingRc = false;\n          if (match(JsDocToken.LC)) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (match(JsDocToken.STRING)) {\n            token = next();\n            if (!jsdocBuilder.recordLends(stream.getString())) {\n              parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          if (matchingRc && !match(JsDocToken.RC)) {\n            parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case MEANING:\n          ExtractionInfo meaningInfo =\n              extractMultilineTextualBlock(token);\n          String meaning = meaningInfo.string;\n          token = meaningInfo.token;\n          if (!jsdocBuilder.recordMeaning(meaning)) {\n            parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case NO_ALIAS:\n          if (!jsdocBuilder.recordNoAlias()) {\n            parser.addParserWarning(\"msg.jsdoc.noalias\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_COMPILE:\n          if (!jsdocBuilder.recordNoCompile()) {\n            parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_TYPE_CHECK:\n          if (!jsdocBuilder.recordNoTypeCheck()) {\n            parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NOT_IMPLEMENTED:\n          return eatUntilEOLIfNotAnnotation();\n\n        case INHERIT_DOC:\n        case OVERRIDE:\n          if (!jsdocBuilder.recordOverride()) {\n            parser.addTypeWarning(\"msg.jsdoc.override\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case THROWS: {\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatUntilEOLIfNotAnnotation();\n            }\n          }\n\n          // *Update* the token to that after the type annotation.\n          token = current();\n\n          // Save the throw type.\n          jsdocBuilder.recordThrowType(type);\n\n          boolean isAnnotationNext = lookAheadForAnnotation();\n\n          // Find the throw's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            if (description.length() > 0) {\n              jsdocBuilder.recordThrowDescription(type, description);\n            }\n\n            token = descriptionInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n        }\n\n        case PARAM:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordParamTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatUntilEOLIfNotAnnotation();\n            }\n            skipEOLs();\n            token = next();\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n          }\n\n          String name = null;\n          boolean isBracketedParam = JsDocToken.LB == token;\n          if (isBracketedParam) {\n            token = next();\n          }\n\n          if (JsDocToken.STRING != token) {\n            parser.addTypeWarning(\"msg.missing.variable.name\",\n                lineno, charno);\n          } else {\n            name = stream.getString();\n\n            if (isBracketedParam) {\n              token = next();\n\n              // Throw out JsDocToolkit's \"default\" parameter\n              // annotation.  It makes no sense under our type\n              // system.\n              if (JsDocToken.EQUALS == token) {\n                token = next();\n                if (JsDocToken.STRING == token) {\n                  token = next();\n                }\n              }\n\n              if (JsDocToken.RB != token) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n              } else if (type != null) {\n                // Make the type expression optional, if it isn't\n                // already.\n                type = JSTypeExpression.makeOptionalArg(type);\n              }\n            }\n\n            // If the param name has a DOT in it, just throw it out\n            // quietly. We do not handle the JsDocToolkit method\n            // for handling properties of params.\n            if (name.indexOf('.') > -1) {\n              name = null;\n            } else if (!jsdocBuilder.recordParameter(name, type)) {\n              if (jsdocBuilder.hasParameter(name)) {\n                parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                    lineno, charno);\n              } else {\n                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                    lineno, charno);\n              }\n            }\n          }\n\n          if (name == null) {\n            token = eatUntilEOLIfNotAnnotation(token);\n            return token;\n          }\n\n          jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n          // Find the parameter's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation()\n              && token != JsDocToken.ANNOTATION) {\n            ExtractionInfo paramDescriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String paramDescription = paramDescriptionInfo.string;\n\n            if (paramDescription.length() > 0) {\n              jsdocBuilder.recordParameterDescription(name,\n                  paramDescription);\n            }\n\n            token = paramDescriptionInfo.token;\n          } else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case PRESERVE_TRY:\n          if (!jsdocBuilder.recordPreserveTry()) {\n            parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_SHADOW:\n          if (!jsdocBuilder.recordNoShadow()) {\n            parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_SIDE_EFFECTS:\n          if (!jsdocBuilder.recordNoSideEffects()) {\n            parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case MODIFIES:\n          token = parseModifiesTag(next());\n          return token;\n\n        case IMPLICIT_CAST:\n          if (!jsdocBuilder.recordImplicitCast()) {\n            parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case SEE:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo referenceInfo = extractSingleLineBlock();\n            String reference = referenceInfo.string;\n\n            if (reference.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addReference(reference);\n            }\n\n            token = referenceInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case STABLEIDGENERATOR:\n          if (!jsdocBuilder.recordStableIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case SUPPRESS:\n          token = parseSuppressTag(next());\n          return token;\n\n        case TEMPLATE: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case IDGENERATOR:\n          token = parseIdGeneratorTag(next());\n          return token;\n\n        case WIZACTION:\n          if (!jsdocBuilder.recordWizaction()) {\n            parser.addParserWarning(\"msg.jsdoc.wizaction\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DISPOSES: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.missing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordDisposesParameter(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.error\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case VERSION:\n          ExtractionInfo versionInfo = extractSingleLineBlock();\n          String version = versionInfo.string;\n\n          if (version.length() == 0) {\n            parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else {\n            if (!jsdocBuilder.recordVersion(version)) {\n               parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n\n          token = versionInfo.token;\n          return token;\n\n        case CONSTANT:\n        case DEFINE:\n        case RETURN:\n        case PRIVATE:\n        case PROTECTED:\n        case PUBLIC:\n        case THIS:\n        case TYPE:\n        case TYPEDEF:\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          Node typeNode = null;\n          boolean hasType = lookAheadForType();\n          boolean isAlternateTypeAnnotation =\n              (annotation == Annotation.PRIVATE ||\n               annotation == Annotation.PROTECTED ||\n               annotation == Annotation.PUBLIC ||\n               annotation == Annotation.CONSTANT);\n          boolean canSkipTypeAnnotation =\n              (isAlternateTypeAnnotation ||\n               annotation == Annotation.RETURN);\n          type = null;\n          if (hasType || !canSkipTypeAnnotation) {\n            skipEOLs();\n            token = next();\n            typeNode = parseAndRecordTypeNode(token);\n\n            if (annotation == Annotation.THIS) {\n              typeNode = wrapNode(Token.BANG, typeNode);\n            }\n            type = createJSTypeExpression(typeNode);\n          }\n\n          // The error was reported during recursive descent\n          // recovering parsing\n          boolean hasError = type == null && !canSkipTypeAnnotation;\n          if (!hasError) {\n            // Record types for @type.\n            // If the @private, @protected, or @public annotations\n            // have a type attached, pretend that they actually wrote:\n            // @type {type}\\n@private\n            // This will have some weird behavior in some cases\n            // (for example, @private can now be used as a type-cast),\n            // but should be mostly OK.\n            if ((type != null && isAlternateTypeAnnotation)\n                || annotation == Annotation.TYPE) {\n              if (!jsdocBuilder.recordType(type)) {\n                parser.addTypeWarning(\n                    \"msg.jsdoc.incompat.type\", lineno, charno);\n              }\n            }\n\n            switch (annotation) {\n              case CONSTANT:\n                if (!jsdocBuilder.recordConstancy()) {\n                  parser.addParserWarning(\"msg.jsdoc.const\",\n                      stream.getLineno(), stream.getCharno());\n                }\n                break;\n\n              case DEFINE:\n                if (!jsdocBuilder.recordDefineType(type)) {\n                  parser.addParserWarning(\"msg.jsdoc.define\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PRIVATE:\n                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.private\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PROTECTED:\n                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.protected\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PUBLIC:\n                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.public\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case RETURN:\n                if (type == null) {\n                  type = createJSTypeExpression(newNode(Token.QMARK));\n                }\n\n                if (!jsdocBuilder.recordReturnType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                  break;\n                }\n\n                // TODO(johnlenz): The extractMultilineTextualBlock method\n                // and friends look directly at the stream, regardless of\n                // last token read, so we don't want to read the first\n                // \"STRING\" out of the stream.\n\n                boolean isAnnotationNext = lookAheadForAnnotation();\n\n                // Find the return's description (if applicable).\n                if (jsdocBuilder.shouldParseDocumentation()\n                    && !isAnnotationNext) {\n                  ExtractionInfo returnDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String returnDescription =\n                      returnDescriptionInfo.string;\n\n                  if (returnDescription.length() > 0) {\n                    jsdocBuilder.recordReturnDescription(\n                        returnDescription);\n                  }\n\n                  token = returnDescriptionInfo.token;\n                } else {\n                  token = eatUntilEOLIfNotAnnotation();\n                }\n                return token;\n\n              case THIS:\n                if (!jsdocBuilder.recordThisType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n\n              case TYPEDEF:\n                if (!jsdocBuilder.recordTypedef(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n            }\n          }\n\n          return eatUntilEOLIfNotAnnotation();\n      }\n    }\n\n    return next();\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 289, "end_line": 1076}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseAndRecordTypeNode", "content": "  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LC, false);\n  }", "javadoc_start_line": 1262, "annotations_start_line": 1269, "method_start_line": 1269, "end_line": 1272}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseAndRecordTypeNode", "content": "  /**\n   * Looks for a parameter type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param onlyParseSimpleNames If true, only simple type names are parsed\n   *     (via a call to parseTypeNameAnnotation instead of\n   *     parseTypeExpressionAnnotation).\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    recordTypeNode(lineno, startCharno, typeNode, matchingLC);\n    return typeNode;\n  }", "javadoc_start_line": 1312, "annotations_start_line": 1325, "method_start_line": 1328, "end_line": 1339}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseTypeExpressionAnnotation", "content": "  /**\n   * TypeExpressionAnnotation := TypeExpression |\n   *     '{' TopLevelTypeExpression '}'\n   */\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }", "javadoc_start_line": 1710, "annotations_start_line": 1714, "method_start_line": 1714, "end_line": 1731}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseTopLevelTypeExpression", "content": "  /**\n   * TopLevelTypeExpression := TypeExpression\n   *     | TypeUnionList\n   *\n   * We made this rule up, for the sake of backwards compatibility.\n   */\n  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }", "javadoc_start_line": 1801, "annotations_start_line": 1807, "method_start_line": 1807, "end_line": 1823}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseTypeExpression", "content": "  /**\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   */\n  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 8 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // {Array.<?>} - greater than\n      // /** ? */ - EOC (inline types)\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT ||\n          token == JsDocToken.EOC) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }", "javadoc_start_line": 1848, "annotations_start_line": 1856, "method_start_line": 1856, "end_line": 1901}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseBasicTypeExpression", "content": "  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }", "javadoc_start_line": 1911, "annotations_start_line": 1915, "method_start_line": 1915, "end_line": 1941}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseFunctionType", "content": "  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseContextTypeExpression(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }", "javadoc_start_line": 1984, "annotations_start_line": 1989, "method_start_line": 1989, "end_line": 2059}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseContextTypeExpression", "content": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }", "javadoc_start_line": 1903, "annotations_start_line": 1907, "method_start_line": 1907, "end_line": 1909}]}, {"failing_test": {"className": " com.google.javascript.jscomp.parsing.JsDocInfoParserTest", "methodName": "testStructuralConstructor3", "error": "junit.framework.AssertionFailedError", "message": "extra warning: Bad type annotation. type not recognized due to syntax error"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseContextTypeExpression", "content": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }", "javadoc_start_line": 1903, "annotations_start_line": 1907, "method_start_line": 1907, "end_line": 1909}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parse", "content": "  /**\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\n   * {@link JsDocToken#EOC} is returned.\n   *\n   * @return {@code true} if JSDoc information was correctly parsed,\n   *     {@code false} otherwise\n   */\n  boolean parse() {\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());\n  }", "javadoc_start_line": 208, "annotations_start_line": 216, "method_start_line": 216, "end_line": 239}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseHelperLoop", "content": "  private boolean parseHelperLoop(JsDocToken token,\n                                  List<ExtendedTypeInfo> extendedTypes) {\n    while (true) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            token = parseAnnotation(token, extendedTypes);\n          } else {\n            token = next();\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          break;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n          }\n          break;\n      }\n    }\n  }", "javadoc_start_line": 241, "annotations_start_line": 241, "method_start_line": 242, "end_line": 286}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseAnnotation", "content": "  private JsDocToken parseAnnotation(JsDocToken token,\n      List<ExtendedTypeInfo> extendedTypes) {\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n\n    String annotationName = stream.getString();\n    Annotation annotation = annotationNames.get(annotationName);\n    if (annotation == null) {\n      parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n          stream.getLineno(), stream.getCharno());\n    } else {\n      // Mark the beginning of the annotation.\n      jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n      switch (annotation) {\n        case NG_INJECT:\n          if (jsdocBuilder.isNgInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.nginject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordNgInject(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_INJECT:\n          if (jsdocBuilder.isJaggerInjectRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerInject.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerInject(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_MODULE:\n          if (jsdocBuilder.isJaggerModuleRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerModule.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerModule(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAGGER_PROVIDE:\n          if (jsdocBuilder.isJaggerProvideRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.jaggerProvide.extra\",\n              stream.getLineno(), stream.getCharno());\n          } else {\n            jsdocBuilder.recordJaggerProvide(true);\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case AUTHOR:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo authorInfo = extractSingleLineBlock();\n            String author = authorInfo.string;\n\n            if (author.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addAuthor(author);\n            }\n            token = authorInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case CONSISTENTIDGENERATOR:\n          if (!jsdocBuilder.recordConsistentIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.consistidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case STRUCT:\n          if (!jsdocBuilder.recordStruct()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DICT:\n          if (!jsdocBuilder.recordDict()) {\n            parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                                  stream.getLineno(),\n                                  stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case CONSTRUCTOR:\n          if (!jsdocBuilder.recordConstructor()) {\n            if (jsdocBuilder.isInterfaceRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DEPRECATED:\n          if (!jsdocBuilder.recordDeprecated()) {\n            parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          // Find the reason/description, if any.\n          ExtractionInfo reasonInfo =\n              extractMultilineTextualBlock(token);\n\n          String reason = reasonInfo.string;\n\n          if (reason.length() > 0) {\n            jsdocBuilder.recordDeprecationReason(reason);\n          }\n\n          token = reasonInfo.token;\n          return token;\n\n        case INTERFACE:\n          if (!jsdocBuilder.recordInterface()) {\n            if (jsdocBuilder.isConstructorRecorded()) {\n              parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DESC:\n          if (jsdocBuilder.isDescriptionRecorded()) {\n            parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                stream.getLineno(), stream.getCharno());\n            return eatUntilEOLIfNotAnnotation();\n          } else {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            jsdocBuilder.recordDescription(description);\n            token = descriptionInfo.token;\n            return token;\n          }\n\n        case FILE_OVERVIEW:\n          String fileOverview = \"\";\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo fileOverviewInfo =\n                extractMultilineTextualBlock(token,\n                    WhitespaceOption.TRIM);\n\n            fileOverview = fileOverviewInfo.string;\n\n            token = fileOverviewInfo.token;\n          } else {\n            token = eatTokensUntilEOL(token);\n          }\n\n          if (!jsdocBuilder.recordFileOverview(fileOverview)) {\n            parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case LICENSE:\n        case PRESERVE:\n          ExtractionInfo preserveInfo =\n              extractMultilineTextualBlock(token,\n                                           WhitespaceOption.PRESERVE);\n\n          String preserve = preserveInfo.string;\n\n          if (preserve.length() > 0) {\n            if (fileLevelJsDocBuilder != null) {\n              fileLevelJsDocBuilder.append(preserve);\n            }\n          }\n\n          token = preserveInfo.token;\n          return token;\n\n        case ENUM:\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          type = null;\n          if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n          }\n\n          if (type == null) {\n            type = createJSTypeExpression(newStringNode(\"number\"));\n          }\n          if (!jsdocBuilder.recordEnumParameterType(type)) {\n            parser.addTypeWarning(\n                \"msg.jsdoc.incompat.type\", lineno, charno);\n          }\n          token = eatUntilEOLIfNotAnnotation(token);\n          return token;\n\n        case EXPORT:\n          if (!jsdocBuilder.recordExport()) {\n            parser.addParserWarning(\"msg.jsdoc.export\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXPOSE:\n          if (!jsdocBuilder.recordExpose()) {\n            parser.addParserWarning(\"msg.jsdoc.expose\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXTERNS:\n          if (!jsdocBuilder.recordExterns()) {\n            parser.addParserWarning(\"msg.jsdoc.externs\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case JAVA_DISPATCH:\n          if (!jsdocBuilder.recordJavaDispatch()) {\n            parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case EXTENDS:\n        case IMPLEMENTS:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          boolean matchingRc = false;\n\n          if (token == JsDocToken.LC) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (token == JsDocToken.STRING) {\n            Node typeNode = parseAndRecordTypeNameNode(\n                token, lineno, charno, matchingRc);\n\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            typeNode = wrapNode(Token.BANG, typeNode);\n            type = createJSTypeExpression(typeNode);\n\n            if (annotation == Annotation.EXTENDS) {\n              // record the extended type, check later\n              extendedTypes.add(new ExtendedTypeInfo(\n                  type, stream.getLineno(), stream.getCharno()));\n            } else {\n              Preconditions.checkState(\n                  annotation == Annotation.IMPLEMENTS);\n              if (!jsdocBuilder.recordImplementedInterface(type)) {\n                parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                    lineno, charno);\n              }\n            }\n            token = next();\n            if (matchingRc) {\n              if (token != JsDocToken.RC) {\n                parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                    stream.getLineno(), stream.getCharno());\n              } else {\n                token = next();\n              }\n            } else if (token != JsDocToken.EOL &&\n                token != JsDocToken.EOF && token != JsDocToken.EOC) {\n              parser.addTypeWarning(\"msg.end.annotation.expected\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n          }\n          token = eatUntilEOLIfNotAnnotation(token);\n          return token;\n\n        case HIDDEN:\n          if (!jsdocBuilder.recordHiddenness()) {\n            parser.addParserWarning(\"msg.jsdoc.hidden\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case LENDS:\n          skipEOLs();\n\n          matchingRc = false;\n          if (match(JsDocToken.LC)) {\n            token = next();\n            matchingRc = true;\n          }\n\n          if (match(JsDocToken.STRING)) {\n            token = next();\n            if (!jsdocBuilder.recordLends(stream.getString())) {\n              parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          } else {\n            parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          if (matchingRc && !match(JsDocToken.RC)) {\n            parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case MEANING:\n          ExtractionInfo meaningInfo =\n              extractMultilineTextualBlock(token);\n          String meaning = meaningInfo.string;\n          token = meaningInfo.token;\n          if (!jsdocBuilder.recordMeaning(meaning)) {\n            parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return token;\n\n        case NO_ALIAS:\n          if (!jsdocBuilder.recordNoAlias()) {\n            parser.addParserWarning(\"msg.jsdoc.noalias\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_COMPILE:\n          if (!jsdocBuilder.recordNoCompile()) {\n            parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_TYPE_CHECK:\n          if (!jsdocBuilder.recordNoTypeCheck()) {\n            parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NOT_IMPLEMENTED:\n          return eatUntilEOLIfNotAnnotation();\n\n        case INHERIT_DOC:\n        case OVERRIDE:\n          if (!jsdocBuilder.recordOverride()) {\n            parser.addTypeWarning(\"msg.jsdoc.override\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case THROWS: {\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatUntilEOLIfNotAnnotation();\n            }\n          }\n\n          // *Update* the token to that after the type annotation.\n          token = current();\n\n          // Save the throw type.\n          jsdocBuilder.recordThrowType(type);\n\n          boolean isAnnotationNext = lookAheadForAnnotation();\n\n          // Find the throw's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {\n            ExtractionInfo descriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String description = descriptionInfo.string;\n\n            if (description.length() > 0) {\n              jsdocBuilder.recordThrowDescription(type, description);\n            }\n\n            token = descriptionInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n        }\n\n        case PARAM:\n          skipEOLs();\n          token = next();\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n          type = null;\n\n          if (token == JsDocToken.LC) {\n            type = createJSTypeExpression(\n                parseAndRecordParamTypeNode(token));\n\n            if (type == null) {\n              // parsing error reported during recursive descent\n              // recovering parsing\n              return eatUntilEOLIfNotAnnotation();\n            }\n            skipEOLs();\n            token = next();\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n          }\n\n          String name = null;\n          boolean isBracketedParam = JsDocToken.LB == token;\n          if (isBracketedParam) {\n            token = next();\n          }\n\n          if (JsDocToken.STRING != token) {\n            parser.addTypeWarning(\"msg.missing.variable.name\",\n                lineno, charno);\n          } else {\n            name = stream.getString();\n\n            if (isBracketedParam) {\n              token = next();\n\n              // Throw out JsDocToolkit's \"default\" parameter\n              // annotation.  It makes no sense under our type\n              // system.\n              if (JsDocToken.EQUALS == token) {\n                token = next();\n                if (JsDocToken.STRING == token) {\n                  token = next();\n                }\n              }\n\n              if (JsDocToken.RB != token) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n              } else if (type != null) {\n                // Make the type expression optional, if it isn't\n                // already.\n                type = JSTypeExpression.makeOptionalArg(type);\n              }\n            }\n\n            // If the param name has a DOT in it, just throw it out\n            // quietly. We do not handle the JsDocToolkit method\n            // for handling properties of params.\n            if (name.indexOf('.') > -1) {\n              name = null;\n            } else if (!jsdocBuilder.recordParameter(name, type)) {\n              if (jsdocBuilder.hasParameter(name)) {\n                parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                    lineno, charno);\n              } else {\n                parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                    lineno, charno);\n              }\n            }\n          }\n\n          if (name == null) {\n            token = eatUntilEOLIfNotAnnotation(token);\n            return token;\n          }\n\n          jsdocBuilder.markName(name, sourceFile, lineno, charno);\n\n          // Find the parameter's description (if applicable).\n          if (jsdocBuilder.shouldParseDocumentation()\n              && token != JsDocToken.ANNOTATION) {\n            ExtractionInfo paramDescriptionInfo =\n                extractMultilineTextualBlock(token);\n\n            String paramDescription = paramDescriptionInfo.string;\n\n            if (paramDescription.length() > 0) {\n              jsdocBuilder.recordParameterDescription(name,\n                  paramDescription);\n            }\n\n            token = paramDescriptionInfo.token;\n          } else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case PRESERVE_TRY:\n          if (!jsdocBuilder.recordPreserveTry()) {\n            parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_SHADOW:\n          if (!jsdocBuilder.recordNoShadow()) {\n            parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case NO_SIDE_EFFECTS:\n          if (!jsdocBuilder.recordNoSideEffects()) {\n            parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case MODIFIES:\n          token = parseModifiesTag(next());\n          return token;\n\n        case IMPLICIT_CAST:\n          if (!jsdocBuilder.recordImplicitCast()) {\n            parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case SEE:\n          if (jsdocBuilder.shouldParseDocumentation()) {\n            ExtractionInfo referenceInfo = extractSingleLineBlock();\n            String reference = referenceInfo.string;\n\n            if (reference.length() == 0) {\n              parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              jsdocBuilder.addReference(reference);\n            }\n\n            token = referenceInfo.token;\n          } else {\n            token = eatUntilEOLIfNotAnnotation();\n          }\n          return token;\n\n        case STABLEIDGENERATOR:\n          if (!jsdocBuilder.recordStableIdGenerator()) {\n            parser.addParserWarning(\"msg.jsdoc.stableidgen\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case SUPPRESS:\n          token = parseSuppressTag(next());\n          return token;\n\n        case TEMPLATE: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case IDGENERATOR:\n          token = parseIdGeneratorTag(next());\n          return token;\n\n        case WIZACTION:\n          if (!jsdocBuilder.recordWizaction()) {\n            parser.addParserWarning(\"msg.jsdoc.wizaction\",\n              stream.getLineno(), stream.getCharno());\n          }\n          return eatUntilEOLIfNotAnnotation();\n\n        case DISPOSES: {\n          ExtractionInfo templateInfo = extractSingleLineBlock();\n          List<String> names = Lists.newArrayList(\n              Splitter.on(',')\n                  .trimResults()\n                  .split(templateInfo.string));\n\n          if (names.size() == 0 || names.get(0).length() == 0) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.missing\",\n                  stream.getLineno(), stream.getCharno());\n          } else if (!jsdocBuilder.recordDisposesParameter(names)) {\n            parser.addTypeWarning(\"msg.jsdoc.disposeparameter.error\",\n                stream.getLineno(), stream.getCharno());\n          }\n\n          token = templateInfo.token;\n          return token;\n        }\n\n        case VERSION:\n          ExtractionInfo versionInfo = extractSingleLineBlock();\n          String version = versionInfo.string;\n\n          if (version.length() == 0) {\n            parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                  stream.getLineno(), stream.getCharno());\n          } else {\n            if (!jsdocBuilder.recordVersion(version)) {\n               parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                  stream.getLineno(), stream.getCharno());\n            }\n          }\n\n          token = versionInfo.token;\n          return token;\n\n        case CONSTANT:\n        case DEFINE:\n        case RETURN:\n        case PRIVATE:\n        case PROTECTED:\n        case PUBLIC:\n        case THIS:\n        case TYPE:\n        case TYPEDEF:\n          lineno = stream.getLineno();\n          charno = stream.getCharno();\n\n          Node typeNode = null;\n          boolean hasType = lookAheadForType();\n          boolean isAlternateTypeAnnotation =\n              (annotation == Annotation.PRIVATE ||\n               annotation == Annotation.PROTECTED ||\n               annotation == Annotation.PUBLIC ||\n               annotation == Annotation.CONSTANT);\n          boolean canSkipTypeAnnotation =\n              (isAlternateTypeAnnotation ||\n               annotation == Annotation.RETURN);\n          type = null;\n          if (hasType || !canSkipTypeAnnotation) {\n            skipEOLs();\n            token = next();\n            typeNode = parseAndRecordTypeNode(token);\n\n            if (annotation == Annotation.THIS) {\n              typeNode = wrapNode(Token.BANG, typeNode);\n            }\n            type = createJSTypeExpression(typeNode);\n          }\n\n          // The error was reported during recursive descent\n          // recovering parsing\n          boolean hasError = type == null && !canSkipTypeAnnotation;\n          if (!hasError) {\n            // Record types for @type.\n            // If the @private, @protected, or @public annotations\n            // have a type attached, pretend that they actually wrote:\n            // @type {type}\\n@private\n            // This will have some weird behavior in some cases\n            // (for example, @private can now be used as a type-cast),\n            // but should be mostly OK.\n            if ((type != null && isAlternateTypeAnnotation)\n                || annotation == Annotation.TYPE) {\n              if (!jsdocBuilder.recordType(type)) {\n                parser.addTypeWarning(\n                    \"msg.jsdoc.incompat.type\", lineno, charno);\n              }\n            }\n\n            switch (annotation) {\n              case CONSTANT:\n                if (!jsdocBuilder.recordConstancy()) {\n                  parser.addParserWarning(\"msg.jsdoc.const\",\n                      stream.getLineno(), stream.getCharno());\n                }\n                break;\n\n              case DEFINE:\n                if (!jsdocBuilder.recordDefineType(type)) {\n                  parser.addParserWarning(\"msg.jsdoc.define\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PRIVATE:\n                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.private\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PROTECTED:\n                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.protected\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case PUBLIC:\n                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                  parser.addParserWarning(\n                      \"msg.jsdoc.visibility.public\",\n                      lineno, charno);\n                }\n                return recordDescription(token);\n\n              case RETURN:\n                if (type == null) {\n                  type = createJSTypeExpression(newNode(Token.QMARK));\n                }\n\n                if (!jsdocBuilder.recordReturnType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                  break;\n                }\n\n                // TODO(johnlenz): The extractMultilineTextualBlock method\n                // and friends look directly at the stream, regardless of\n                // last token read, so we don't want to read the first\n                // \"STRING\" out of the stream.\n\n                boolean isAnnotationNext = lookAheadForAnnotation();\n\n                // Find the return's description (if applicable).\n                if (jsdocBuilder.shouldParseDocumentation()\n                    && !isAnnotationNext) {\n                  ExtractionInfo returnDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String returnDescription =\n                      returnDescriptionInfo.string;\n\n                  if (returnDescription.length() > 0) {\n                    jsdocBuilder.recordReturnDescription(\n                        returnDescription);\n                  }\n\n                  token = returnDescriptionInfo.token;\n                } else {\n                  token = eatUntilEOLIfNotAnnotation();\n                }\n                return token;\n\n              case THIS:\n                if (!jsdocBuilder.recordThisType(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n\n              case TYPEDEF:\n                if (!jsdocBuilder.recordTypedef(type)) {\n                  parser.addTypeWarning(\n                      \"msg.jsdoc.incompat.type\", lineno, charno);\n                }\n                break;\n            }\n          }\n\n          return eatUntilEOLIfNotAnnotation();\n      }\n    }\n\n    return next();\n  }", "javadoc_start_line": 288, "annotations_start_line": 288, "method_start_line": 289, "end_line": 1076}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseAndRecordTypeNode", "content": "  /**\n   * Looks for a type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @return The type expression found or null if none.\n   */\n  Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        token == JsDocToken.LC, false);\n  }", "javadoc_start_line": 1262, "annotations_start_line": 1269, "method_start_line": 1269, "end_line": 1272}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseAndRecordTypeNode", "content": "  /**\n   * Looks for a parameter type expression at the current token and if found,\n   * returns it. Note that this method consumes input.\n   *\n   * @param token The current token.\n   * @param lineno The line of the type expression.\n   * @param startCharno The starting character position of the type expression.\n   * @param matchingLC Whether the type expression starts with a \"{\".\n   * @param onlyParseSimpleNames If true, only simple type names are parsed\n   *     (via a call to parseTypeNameAnnotation instead of\n   *     parseTypeExpressionAnnotation).\n   * @return The type expression found or null if none.\n   */\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    recordTypeNode(lineno, startCharno, typeNode, matchingLC);\n    return typeNode;\n  }", "javadoc_start_line": 1312, "annotations_start_line": 1325, "method_start_line": 1328, "end_line": 1339}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseTypeExpressionAnnotation", "content": "  /**\n   * TypeExpressionAnnotation := TypeExpression |\n   *     '{' TopLevelTypeExpression '}'\n   */\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }", "javadoc_start_line": 1710, "annotations_start_line": 1714, "method_start_line": 1714, "end_line": 1731}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseTopLevelTypeExpression", "content": "  /**\n   * TopLevelTypeExpression := TypeExpression\n   *     | TypeUnionList\n   *\n   * We made this rule up, for the sake of backwards compatibility.\n   */\n  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }", "javadoc_start_line": 1801, "annotations_start_line": 1807, "method_start_line": 1807, "end_line": 1823}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseTypeExpression", "content": "  /**\n   * TypeExpression := BasicTypeExpression\n   *     | '?' BasicTypeExpression\n   *     | '!' BasicTypeExpression\n   *     | BasicTypeExpression '?'\n   *     | BasicTypeExpression '!'\n   *     | '?'\n   */\n  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 8 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(number, ...[?])} - right bracket\n      // {function(): ?|number} - pipe\n      // {Array.<?>} - greater than\n      // /** ? */ - EOC (inline types)\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RB ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE ||\n          token == JsDocToken.GT ||\n          token == JsDocToken.EOC) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }", "javadoc_start_line": 1848, "annotations_start_line": 1856, "method_start_line": 1856, "end_line": 1901}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseBasicTypeExpression", "content": "  /**\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n   *     | FunctionType | UnionType | RecordType | ArrayType\n   */\n  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }", "javadoc_start_line": 1911, "annotations_start_line": 1915, "method_start_line": 1915, "end_line": 1941}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseFunctionType", "content": "  /**\n   * FunctionType := 'function' FunctionSignatureType\n   * FunctionSignatureType :=\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\n   */\n  private Node parseFunctionType(JsDocToken token) {\n    // NOTE(nicksantos): We're not implementing generics at the moment, so\n    // just throw out TypeParameters.\n    if (token != JsDocToken.LP) {\n      restoreLookAhead(token);\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    Node parameters = null;\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      token = next();\n\n      boolean hasParams = true;\n      if (token == JsDocToken.STRING) {\n        String tokenStr = stream.getString();\n        boolean isThis = \"this\".equals(tokenStr);\n        boolean isNew = \"new\".equals(tokenStr);\n        if (isThis || isNew) {\n          if (match(JsDocToken.COLON)) {\n            next();\n            skipEOLs();\n            Node contextType = wrapNode(\n                isThis ? Token.THIS : Token.NEW,\n                parseContextTypeExpression(next()));\n            if (contextType == null) {\n              return null;\n            }\n\n            functionType.addChildToFront(contextType);\n          } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n          }\n\n          if (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n          } else {\n            hasParams = false;\n          }\n        }\n      }\n\n      if (hasParams) {\n        parameters = parseParametersType(token);\n        if (parameters == null) {\n          return null;\n        }\n      }\n    }\n\n    if (parameters != null) {\n      functionType.addChildToBack(parameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    } else {\n      functionType.addChildToBack(resultType);\n    }\n    return functionType;\n  }", "javadoc_start_line": 1984, "annotations_start_line": 1989, "method_start_line": 1989, "end_line": 2059}, {"file_path": "/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java", "method_name": "parseContextTypeExpression", "content": "  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n          return parseTypeName(token);\n  }", "javadoc_start_line": 1903, "annotations_start_line": 1907, "method_start_line": 1907, "end_line": 1909}]}], "project": {"name": "Closure", "version": 109}}