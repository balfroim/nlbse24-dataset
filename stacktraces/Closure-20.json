{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest", "methodName": "testSimpleFunctionCall", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java", "method_name": "tryFoldSimpleFunctionCall", "content": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }", "javadoc_start_line": 208, "annotations_start_line": 208, "method_start_line": 208, "end_line": 230}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }", "javadoc_start_line": 104, "annotations_start_line": 103, "method_start_line": 104, "end_line": 111}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "traverse", "content": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n        traverse(c);\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "javadoc_start_line": 113, "annotations_start_line": 113, "method_start_line": 113, "end_line": 135}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "visit", "content": "  public void visit(Node n) {\n    Node currentVersionOfNode = n;\n    boolean somethingChanged = false;\n\n    do {\n      somethingChanged = false;\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n        Node newVersionOfNode =\n            optimization.optimizeSubtree(currentVersionOfNode);\n\n        if (newVersionOfNode != currentVersionOfNode) {\n          somethingChanged = true;\n\n          currentVersionOfNode = newVersionOfNode;\n        }\n\n        if (currentVersionOfNode == null) {\n          return;\n        }\n      }\n    } while(somethingChanged);\n  }", "javadoc_start_line": 170, "annotations_start_line": 170, "method_start_line": 170, "end_line": 191}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java", "method_name": "optimizeSubtree", "content": "  /**\n   * Tries apply our various peephole minimizations on the passed in node.\n   */\n  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n      case Token.RETURN: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        result = tryReplaceExitWithBreak(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReduceReturn(node);\n      }\n\n      case Token.THROW: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReplaceExitWithBreak(node);\n      }\n\n      // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\n      // with MinimizeExitPoints.\n\n      case Token.NOT:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeNot(node);\n\n      case Token.IF:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeIf(node);\n\n      case Token.EXPR_RESULT:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.HOOK:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.WHILE:\n      case Token.DO:\n        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        return node;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(node)) {\n          tryJoinForCondition(node);\n          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        }\n        return node;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        return reduceTrueFalse(node);\n\n      case Token.NEW:\n        node = tryFoldStandardConstructors(node);\n        if (!node.isCall()) {\n          return node;\n        }\n        // Fall through on purpose because tryFoldStandardConstructors() may\n        // convert a NEW node into a CALL node\n      case Token.CALL:\n        Node result =  tryFoldLiteralConstructor(node);\n        if (result == node) {\n          result = tryFoldSimpleFunctionCall(node);\n          if (result == node) {\n            result = tryFoldImmediateCallToBoundFunction(node);\n          }\n        }\n        return result;\n\n      case Token.COMMA:\n        return trySplitComma(node);\n\n      case Token.NAME:\n        return tryReplaceUndefined(node);\n\n      case Token.BLOCK:\n        return tryReplaceIf(node);\n\n      case Token.ARRAYLIT:\n        return tryMinimizeArrayLiteral(node);\n\n      default:\n        return node; //Nothing changed\n    }\n  }", "javadoc_start_line": 72, "annotations_start_line": 75, "method_start_line": 77, "end_line": 166}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java", "method_name": "tryFoldSimpleFunctionCall", "content": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n    if (callTarget != null && callTarget.isName() &&\n          callTarget.getString().equals(\"String\")) {\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null) {\n        Node addition = IR.add(\n            IR.string(\"\").srcref(callTarget),\n            value.detachFromParent());\n        n.getParent().replaceChild(n, addition);\n        reportCodeChange();\n        return addition;\n      }\n    }\n    return n;\n  }", "javadoc_start_line": 208, "annotations_start_line": 208, "method_start_line": 208, "end_line": 230}]}], "project": {"name": "Closure", "version": 20}}