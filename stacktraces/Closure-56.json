{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.JSCompilerSourceExcerptProviderTest", "methodName": "testExceptNoNewLine", "error": "junit.framework.ComparisonFailure", "message": "expected:<foo2:third line> but was:<null>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceFile.java", "method_name": "getLine", "content": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "javadoc_start_line": 197, "annotations_start_line": 205, "method_start_line": 205, "end_line": 246}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/Compiler.java", "method_name": "getSourceLine", "content": "  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }", "javadoc_start_line": 1898, "annotations_start_line": 1897, "method_start_line": 1898, "end_line": 1907}, {"file_path": "/src/com/google/javascript/jscomp/SourceFile.java", "method_name": "getLine", "content": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "javadoc_start_line": 197, "annotations_start_line": 205, "method_start_line": 205, "end_line": 246}]}, {"failing_test": {"className": " com.google.javascript.jscomp.JsMessageExtractorTest", "methodName": "testSyntaxError1", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceFile.java", "method_name": "getLine", "content": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "javadoc_start_line": 197, "annotations_start_line": 205, "method_start_line": 205, "end_line": 246}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/JsMessageExtractor.java", "method_name": "extractMessages", "content": "  /**\n   * Extracts js messages from javascript code.\n   */\n  public Collection<JsMessage> extractMessages(JSSourceFile... inputs)\n      throws IOException {\n    return extractMessages(ImmutableList.copyOf(inputs));\n  }", "javadoc_start_line": 95, "annotations_start_line": 98, "method_start_line": 99, "end_line": 101}, {"file_path": "/src/com/google/javascript/jscomp/JsMessageExtractor.java", "method_name": "extractMessages", "content": "  /**\n   * Extracts js messages from javascript code.\n   *\n   * @param inputs  the javascript source code inputs\n   * @return the extracted messages collection\n   * @throws IOException if there is a problem reading the js code\n   * @throws RuntimeException if there are problems parsing the js code or the\n   *     js messages, or if two messages have the same key\n   */\n  public Collection<JsMessage> extractMessages(\n      Iterable<JSSourceFile> inputs) throws IOException {\n\n    Compiler compiler = new Compiler();\n    compiler.init(\n        new JSSourceFile[] {},\n        Iterables.toArray(inputs, JSSourceFile.class),\n        new CompilerOptions());\n\n    ExtractMessagesVisitor extractCompilerPass =\n        new ExtractMessagesVisitor(compiler);\n    for (JSSourceFile input : inputs) {\n      // Parse the js files individually, to prevent out-of-memory\n      // problems.\n      Node root = new JsAst(input).getAstRoot(compiler);\n\n      // Traverse the returned nodes and extract messages.\n      extractCompilerPass.process(null, root);\n    }\n\n    JSError[] errors = compiler.getErrors();\n    // Check for errors.\n    if (errors.length > 0) {\n      StringBuilder msg = new StringBuilder(\"JSCompiler errors\\n\");\n      MessageFormatter formatter = new LightweightMessageFormatter(compiler);\n      for (JSError e : errors) {\n        msg.append(formatter.formatError(e));\n      }\n      throw new RuntimeException(msg.toString());\n    }\n\n    return extractCompilerPass.getMessages();\n  }", "javadoc_start_line": 104, "annotations_start_line": 113, "method_start_line": 114, "end_line": 145}, {"file_path": "/src/com/google/javascript/jscomp/LightweightMessageFormatter.java", "method_name": "formatError", "content": "  public String formatError(JSError error) {\n    return format(error, false);\n  }", "javadoc_start_line": 59, "annotations_start_line": 58, "method_start_line": 59, "end_line": 61}, {"file_path": "/src/com/google/javascript/jscomp/LightweightMessageFormatter.java", "method_name": "format", "content": "  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }", "javadoc_start_line": 68, "annotations_start_line": 68, "method_start_line": 68, "end_line": 113}, {"file_path": "/src/com/google/javascript/jscomp/Compiler.java", "method_name": "getSourceLine", "content": "  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }", "javadoc_start_line": 1898, "annotations_start_line": 1897, "method_start_line": 1898, "end_line": 1907}, {"file_path": "/src/com/google/javascript/jscomp/SourceFile.java", "method_name": "getLine", "content": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "javadoc_start_line": 197, "annotations_start_line": 205, "method_start_line": 205, "end_line": 246}]}, {"failing_test": {"className": " com.google.javascript.jscomp.JsMessageExtractorTest", "methodName": "testSyntaxError2", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceFile.java", "method_name": "getLine", "content": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "javadoc_start_line": 197, "annotations_start_line": 205, "method_start_line": 205, "end_line": 246}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/JsMessageExtractor.java", "method_name": "extractMessages", "content": "  /**\n   * Extracts js messages from javascript code.\n   */\n  public Collection<JsMessage> extractMessages(JSSourceFile... inputs)\n      throws IOException {\n    return extractMessages(ImmutableList.copyOf(inputs));\n  }", "javadoc_start_line": 95, "annotations_start_line": 98, "method_start_line": 99, "end_line": 101}, {"file_path": "/src/com/google/javascript/jscomp/JsMessageExtractor.java", "method_name": "extractMessages", "content": "  /**\n   * Extracts js messages from javascript code.\n   *\n   * @param inputs  the javascript source code inputs\n   * @return the extracted messages collection\n   * @throws IOException if there is a problem reading the js code\n   * @throws RuntimeException if there are problems parsing the js code or the\n   *     js messages, or if two messages have the same key\n   */\n  public Collection<JsMessage> extractMessages(\n      Iterable<JSSourceFile> inputs) throws IOException {\n\n    Compiler compiler = new Compiler();\n    compiler.init(\n        new JSSourceFile[] {},\n        Iterables.toArray(inputs, JSSourceFile.class),\n        new CompilerOptions());\n\n    ExtractMessagesVisitor extractCompilerPass =\n        new ExtractMessagesVisitor(compiler);\n    for (JSSourceFile input : inputs) {\n      // Parse the js files individually, to prevent out-of-memory\n      // problems.\n      Node root = new JsAst(input).getAstRoot(compiler);\n\n      // Traverse the returned nodes and extract messages.\n      extractCompilerPass.process(null, root);\n    }\n\n    JSError[] errors = compiler.getErrors();\n    // Check for errors.\n    if (errors.length > 0) {\n      StringBuilder msg = new StringBuilder(\"JSCompiler errors\\n\");\n      MessageFormatter formatter = new LightweightMessageFormatter(compiler);\n      for (JSError e : errors) {\n        msg.append(formatter.formatError(e));\n      }\n      throw new RuntimeException(msg.toString());\n    }\n\n    return extractCompilerPass.getMessages();\n  }", "javadoc_start_line": 104, "annotations_start_line": 113, "method_start_line": 114, "end_line": 145}, {"file_path": "/src/com/google/javascript/jscomp/LightweightMessageFormatter.java", "method_name": "formatError", "content": "  public String formatError(JSError error) {\n    return format(error, false);\n  }", "javadoc_start_line": 59, "annotations_start_line": 58, "method_start_line": 59, "end_line": 61}, {"file_path": "/src/com/google/javascript/jscomp/LightweightMessageFormatter.java", "method_name": "format", "content": "  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }", "javadoc_start_line": 68, "annotations_start_line": 68, "method_start_line": 68, "end_line": 113}, {"file_path": "/src/com/google/javascript/jscomp/Compiler.java", "method_name": "getSourceLine", "content": "  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }", "javadoc_start_line": 1898, "annotations_start_line": 1897, "method_start_line": 1898, "end_line": 1907}, {"file_path": "/src/com/google/javascript/jscomp/SourceFile.java", "method_name": "getLine", "content": "  /**\n   * Gets the source line for the indicated line number.\n   *\n   * @param lineNumber the line number, 1 being the first line of the file.\n   * @return The line indicated. Does not include the newline at the end\n   *     of the file. Returns {@code null} if it does not exist,\n   *     or if there was an IO exception.\n   */\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        return null;\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }", "javadoc_start_line": 197, "annotations_start_line": 205, "method_start_line": 205, "end_line": 246}]}], "project": {"name": "Closure", "version": 56}}