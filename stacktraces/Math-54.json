{"tours": [{"failing_test": {"className": " org.apache.commons.math.dfp.DfpTest", "methodName": "testIssue567", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<-Infinity>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/dfp/Dfp.java", "method_name": "toDouble", "content": "    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }", "javadoc_start_line": 2299, "annotations_start_line": 2303, "method_start_line": 2303, "end_line": 2384}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/dfp/DfpTest.java", "method_name": "testIssue567", "content": "    public void testIssue567() {\n        DfpField field = new DfpField(100);\n        Assert.assertEquals(0.0, field.getZero().toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(0.0, field.newDfp(0.0).toDouble(), MathUtils.SAFE_MIN);\n        Assert.assertEquals(-1, FastMath.copySign(1, field.newDfp(-0.0).toDouble()), MathUtils.EPSILON);\n        Assert.assertEquals(+1, FastMath.copySign(1, field.newDfp(+0.0).toDouble()), MathUtils.EPSILON);\n    }", "javadoc_start_line": 1510, "annotations_start_line": 1509, "method_start_line": 1510, "end_line": 1516}, {"file_path": "/src/main/java/org/apache/commons/math/dfp/Dfp.java", "method_name": "toDouble", "content": "    /** Convert the instance into a double.\n     * @return a double approximating the instance\n     * @see #toSplitDouble()\n     */\n    public double toDouble() {\n\n        if (isInfinite()) {\n            if (lessThan(getZero())) {\n                return Double.NEGATIVE_INFINITY;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (isNaN()) {\n            return Double.NaN;\n        }\n\n        Dfp y = this;\n        boolean negate = false;\n        if (lessThan(getZero())) {\n            y = negate();\n            negate = true;\n        }\n\n        /* Find the exponent, first estimate by integer log10, then adjust.\n         Should be faster than doing a natural logarithm.  */\n        int exponent = (int)(y.log10() * 3.32);\n        if (exponent < 0) {\n            exponent--;\n        }\n\n        Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n        while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n            tempDfp = tempDfp.multiply(2);\n            exponent++;\n        }\n        exponent--;\n\n        /* We have the exponent, now work on the mantissa */\n\n        y = y.divide(DfpMath.pow(getTwo(), exponent));\n        if (exponent > -1023) {\n            y = y.subtract(getOne());\n        }\n\n        if (exponent < -1074) {\n            return 0;\n        }\n\n        if (exponent > 1023) {\n            return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n        }\n\n\n        y = y.multiply(newInstance(4503599627370496l)).rint();\n        String str = y.toString();\n        str = str.substring(0, str.length()-1);\n        long mantissa = Long.parseLong(str);\n\n        if (mantissa == 4503599627370496L) {\n            // Handle special case where we round up to next power of two\n            mantissa = 0;\n            exponent++;\n        }\n\n        /* Its going to be subnormal, so make adjustments */\n        if (exponent <= -1023) {\n            exponent--;\n        }\n\n        while (exponent < -1023) {\n            exponent++;\n            mantissa >>>= 1;\n        }\n\n        long bits = mantissa | ((exponent + 1023L) << 52);\n        double x = Double.longBitsToDouble(bits);\n\n        if (negate) {\n            x = -x;\n        }\n\n        return x;\n\n    }", "javadoc_start_line": 2299, "annotations_start_line": 2303, "method_start_line": 2303, "end_line": 2384}]}, {"failing_test": {"className": " org.apache.commons.math.dfp.DfpTest", "methodName": "testIssue567", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<-Infinity>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/dfp/Dfp.java", "method_name": "Dfp", "content": "    /** Create an instance from a double value.\n     * @param field field to which this instance belongs\n     * @param x value to convert to an instance\n     */\n    protected Dfp(final DfpField field, double x) {\n\n        // initialize as if 0\n        mant = new int[field.getRadixDigits()];\n        sign = 1;\n        exp = 0;\n        nans = FINITE;\n        this.field = field;\n\n        long bits = Double.doubleToLongBits(x);\n        long mantissa = bits & 0x000fffffffffffffL;\n        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n\n        if (exponent == -1023) {\n            // Zero or sub-normal\n            if (x == 0) {\n                // make sure 0 has the right sign\n                return;\n            }\n\n            exponent++;\n\n            // Normalize the subnormal number\n            while ( (mantissa & 0x0010000000000000L) == 0) {\n                exponent--;\n                mantissa <<= 1;\n            }\n            mantissa &= 0x000fffffffffffffL;\n        }\n\n        if (exponent == 1024) {\n            // infinity or NAN\n            if (x != x) {\n                sign = (byte) 1;\n                nans = QNAN;\n            } else if (x < 0) {\n                sign = (byte) -1;\n                nans = INFINITE;\n            } else {\n                sign = (byte) 1;\n                nans = INFINITE;\n            }\n            return;\n        }\n\n        Dfp xdfp = new Dfp(field, mantissa);\n        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n\n        if ((bits & 0x8000000000000000L) != 0) {\n            xdfp = xdfp.negate();\n        }\n\n        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n        sign = xdfp.sign;\n        exp  = xdfp.exp;\n        nans = xdfp.nans;\n\n    }", "javadoc_start_line": 252, "annotations_start_line": 256, "method_start_line": 256, "end_line": 314}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Math/54/results/stacktrace-testIssue567-Dfp.csv'"}}], "project": {"name": "Math", "version": 54}}