{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.UnreachableCodeEliminationTest", "methodName": "testIssue4177428_return", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "tryRemoveUnconditionalBranching", "content": "    /**\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to\n     * remove the target branch as well. The reason why we want to cascade this\n     * removal is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When\n     * we first look at the first break, we see that it branches to the 2nd\n     * break. However, if we remove the last break, the 2nd break becomes\n     * useless and finally the first break becomes useless as well.\n     *\n     * @returns The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     */\n    @SuppressWarnings(\"fallthrough\")\n    private void tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, this jump is not useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(\n                outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n              removeNode(n);\n            }\n          }\n      }\n    }", "javadoc_start_line": 110, "annotations_start_line": 128, "method_start_line": 129, "end_line": 175}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "process", "content": "  public void process(Node externs, Node toplevel) {\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n        @Override\n        public void visit(AbstractCompiler compiler, Node root) {\n          // Computes the control flow graph.\n          ControlFlowAnalysis cfa =\n              new ControlFlowAnalysis(compiler, false, false);\n          cfa.process(null, root);\n          ControlFlowGraph<Node> cfg = cfa.getCfg();\n          new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n              .compute(cfg.getEntry().getValue());\n          if (root.isFunction()) {\n            root = root.getLastChild();\n          }\n          do {\n            codeChanged = false;\n            NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n          } while (codeChanged);\n        }\n      });\n  }", "javadoc_start_line": 65, "annotations_start_line": 64, "method_start_line": 65, "end_line": 85}, {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "", "content": "    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {", "javadoc_start_line": 66, "annotations_start_line": 66, "method_start_line": 66, "end_line": 66}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseChangedFunctions", "content": "  /**\n   * Traversal for passes that work only on changed functions.\n   * Suppose a loopable pass P1 uses this traversal.\n   * Then, if a function doesn't change between two runs of P1, it won't look at\n   * the function the second time.\n   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n   */\n  public static void traverseChangedFunctions(\n      AbstractCompiler compiler, FunctionCallback callback) {\n    final AbstractCompiler comp = compiler;\n    final FunctionCallback cb = callback;\n    final Node jsRoot = comp.getJsRoot();\n    if (comp.hasScopeChanged(jsRoot)) {\n      cb.visit(comp, jsRoot);\n    }\n    traverse(comp, jsRoot,\n        new AbstractPreOrderCallback() {\n          @Override\n          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n            if (n.isFunction() && comp.hasScopeChanged(n)) {\n              cb.visit(comp, n);\n            }\n            return true;\n          }\n        });\n  }", "javadoc_start_line": 456, "annotations_start_line": 463, "method_start_line": 464, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}]}, {"failing_test": {"className": " com.google.javascript.jscomp.UnreachableCodeEliminationTest", "methodName": "testDontRemoveBreakInTryFinally", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "tryRemoveUnconditionalBranching", "content": "    /**\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to\n     * remove the target branch as well. The reason why we want to cascade this\n     * removal is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When\n     * we first look at the first break, we see that it branches to the 2nd\n     * break. However, if we remove the last break, the 2nd break becomes\n     * useless and finally the first break becomes useless as well.\n     *\n     * @returns The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     */\n    @SuppressWarnings(\"fallthrough\")\n    private void tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, this jump is not useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(\n                outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n              removeNode(n);\n            }\n          }\n      }\n    }", "javadoc_start_line": 110, "annotations_start_line": 128, "method_start_line": 129, "end_line": 175}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "process", "content": "  public void process(Node externs, Node toplevel) {\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n        @Override\n        public void visit(AbstractCompiler compiler, Node root) {\n          // Computes the control flow graph.\n          ControlFlowAnalysis cfa =\n              new ControlFlowAnalysis(compiler, false, false);\n          cfa.process(null, root);\n          ControlFlowGraph<Node> cfg = cfa.getCfg();\n          new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n              .compute(cfg.getEntry().getValue());\n          if (root.isFunction()) {\n            root = root.getLastChild();\n          }\n          do {\n            codeChanged = false;\n            NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n          } while (codeChanged);\n        }\n      });\n  }", "javadoc_start_line": 65, "annotations_start_line": 64, "method_start_line": 65, "end_line": 85}, {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "", "content": "    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {", "javadoc_start_line": 66, "annotations_start_line": 66, "method_start_line": 66, "end_line": 66}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseChangedFunctions", "content": "  /**\n   * Traversal for passes that work only on changed functions.\n   * Suppose a loopable pass P1 uses this traversal.\n   * Then, if a function doesn't change between two runs of P1, it won't look at\n   * the function the second time.\n   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n   */\n  public static void traverseChangedFunctions(\n      AbstractCompiler compiler, FunctionCallback callback) {\n    final AbstractCompiler comp = compiler;\n    final FunctionCallback cb = callback;\n    final Node jsRoot = comp.getJsRoot();\n    if (comp.hasScopeChanged(jsRoot)) {\n      cb.visit(comp, jsRoot);\n    }\n    traverse(comp, jsRoot,\n        new AbstractPreOrderCallback() {\n          @Override\n          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n            if (n.isFunction() && comp.hasScopeChanged(n)) {\n              cb.visit(comp, n);\n            }\n            return true;\n          }\n        });\n  }", "javadoc_start_line": 456, "annotations_start_line": 463, "method_start_line": 464, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}]}, {"failing_test": {"className": " com.google.javascript.jscomp.UnreachableCodeEliminationTest", "methodName": "testIssue4177428_continue", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "tryRemoveUnconditionalBranching", "content": "    /**\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to\n     * remove the target branch as well. The reason why we want to cascade this\n     * removal is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When\n     * we first look at the first break, we see that it branches to the 2nd\n     * break. However, if we remove the last break, the 2nd break becomes\n     * useless and finally the first break becomes useless as well.\n     *\n     * @returns The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     */\n    @SuppressWarnings(\"fallthrough\")\n    private void tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, this jump is not useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(\n                outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n              removeNode(n);\n            }\n          }\n      }\n    }", "javadoc_start_line": 110, "annotations_start_line": 128, "method_start_line": 129, "end_line": 175}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "process", "content": "  public void process(Node externs, Node toplevel) {\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n        @Override\n        public void visit(AbstractCompiler compiler, Node root) {\n          // Computes the control flow graph.\n          ControlFlowAnalysis cfa =\n              new ControlFlowAnalysis(compiler, false, false);\n          cfa.process(null, root);\n          ControlFlowGraph<Node> cfg = cfa.getCfg();\n          new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n              .compute(cfg.getEntry().getValue());\n          if (root.isFunction()) {\n            root = root.getLastChild();\n          }\n          do {\n            codeChanged = false;\n            NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n          } while (codeChanged);\n        }\n      });\n  }", "javadoc_start_line": 65, "annotations_start_line": 64, "method_start_line": 65, "end_line": 85}, {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "", "content": "    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {", "javadoc_start_line": 66, "annotations_start_line": 66, "method_start_line": 66, "end_line": 66}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseChangedFunctions", "content": "  /**\n   * Traversal for passes that work only on changed functions.\n   * Suppose a loopable pass P1 uses this traversal.\n   * Then, if a function doesn't change between two runs of P1, it won't look at\n   * the function the second time.\n   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n   */\n  public static void traverseChangedFunctions(\n      AbstractCompiler compiler, FunctionCallback callback) {\n    final AbstractCompiler comp = compiler;\n    final FunctionCallback cb = callback;\n    final Node jsRoot = comp.getJsRoot();\n    if (comp.hasScopeChanged(jsRoot)) {\n      cb.visit(comp, jsRoot);\n    }\n    traverse(comp, jsRoot,\n        new AbstractPreOrderCallback() {\n          @Override\n          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n            if (n.isFunction() && comp.hasScopeChanged(n)) {\n              cb.visit(comp, n);\n            }\n            return true;\n          }\n        });\n  }", "javadoc_start_line": 456, "annotations_start_line": 463, "method_start_line": 464, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}]}, {"failing_test": {"className": " com.google.javascript.jscomp.UnreachableCodeEliminationTest", "methodName": "testDontRemoveBreakInTryFinallySwitch", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "tryRemoveUnconditionalBranching", "content": "    /**\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to\n     * remove the target branch as well. The reason why we want to cascade this\n     * removal is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When\n     * we first look at the first break, we see that it branches to the 2nd\n     * break. However, if we remove the last break, the 2nd break becomes\n     * useless and finally the first break becomes useless as well.\n     *\n     * @returns The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     */\n    @SuppressWarnings(\"fallthrough\")\n    private void tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, this jump is not useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(\n                outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n              removeNode(n);\n            }\n          }\n      }\n    }", "javadoc_start_line": 110, "annotations_start_line": 128, "method_start_line": 129, "end_line": 175}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "process", "content": "  public void process(Node externs, Node toplevel) {\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n        @Override\n        public void visit(AbstractCompiler compiler, Node root) {\n          // Computes the control flow graph.\n          ControlFlowAnalysis cfa =\n              new ControlFlowAnalysis(compiler, false, false);\n          cfa.process(null, root);\n          ControlFlowGraph<Node> cfg = cfa.getCfg();\n          new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n              .compute(cfg.getEntry().getValue());\n          if (root.isFunction()) {\n            root = root.getLastChild();\n          }\n          do {\n            codeChanged = false;\n            NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n          } while (codeChanged);\n        }\n      });\n  }", "javadoc_start_line": 65, "annotations_start_line": 64, "method_start_line": 65, "end_line": 85}, {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "", "content": "    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {", "javadoc_start_line": 66, "annotations_start_line": 66, "method_start_line": 66, "end_line": 66}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseChangedFunctions", "content": "  /**\n   * Traversal for passes that work only on changed functions.\n   * Suppose a loopable pass P1 uses this traversal.\n   * Then, if a function doesn't change between two runs of P1, it won't look at\n   * the function the second time.\n   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n   */\n  public static void traverseChangedFunctions(\n      AbstractCompiler compiler, FunctionCallback callback) {\n    final AbstractCompiler comp = compiler;\n    final FunctionCallback cb = callback;\n    final Node jsRoot = comp.getJsRoot();\n    if (comp.hasScopeChanged(jsRoot)) {\n      cb.visit(comp, jsRoot);\n    }\n    traverse(comp, jsRoot,\n        new AbstractPreOrderCallback() {\n          @Override\n          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n            if (n.isFunction() && comp.hasScopeChanged(n)) {\n              cb.visit(comp, n);\n            }\n            return true;\n          }\n        });\n  }", "javadoc_start_line": 456, "annotations_start_line": 463, "method_start_line": 464, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}]}, {"failing_test": {"className": " com.google.javascript.jscomp.UnreachableCodeEliminationTest", "methodName": "testIssue4177428a", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "tryRemoveUnconditionalBranching", "content": "    /**\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to\n     * remove the target branch as well. The reason why we want to cascade this\n     * removal is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When\n     * we first look at the first break, we see that it branches to the 2nd\n     * break. However, if we remove the last break, the 2nd break becomes\n     * useless and finally the first break becomes useless as well.\n     *\n     * @returns The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     */\n    @SuppressWarnings(\"fallthrough\")\n    private void tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, this jump is not useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(\n                outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n              removeNode(n);\n            }\n          }\n      }\n    }", "javadoc_start_line": 110, "annotations_start_line": 128, "method_start_line": 129, "end_line": 175}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "process", "content": "  public void process(Node externs, Node toplevel) {\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n        @Override\n        public void visit(AbstractCompiler compiler, Node root) {\n          // Computes the control flow graph.\n          ControlFlowAnalysis cfa =\n              new ControlFlowAnalysis(compiler, false, false);\n          cfa.process(null, root);\n          ControlFlowGraph<Node> cfg = cfa.getCfg();\n          new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n              .compute(cfg.getEntry().getValue());\n          if (root.isFunction()) {\n            root = root.getLastChild();\n          }\n          do {\n            codeChanged = false;\n            NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n          } while (codeChanged);\n        }\n      });\n  }", "javadoc_start_line": 65, "annotations_start_line": 64, "method_start_line": 65, "end_line": 85}, {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "", "content": "    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {", "javadoc_start_line": 66, "annotations_start_line": 66, "method_start_line": 66, "end_line": 66}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseChangedFunctions", "content": "  /**\n   * Traversal for passes that work only on changed functions.\n   * Suppose a loopable pass P1 uses this traversal.\n   * Then, if a function doesn't change between two runs of P1, it won't look at\n   * the function the second time.\n   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n   */\n  public static void traverseChangedFunctions(\n      AbstractCompiler compiler, FunctionCallback callback) {\n    final AbstractCompiler comp = compiler;\n    final FunctionCallback cb = callback;\n    final Node jsRoot = comp.getJsRoot();\n    if (comp.hasScopeChanged(jsRoot)) {\n      cb.visit(comp, jsRoot);\n    }\n    traverse(comp, jsRoot,\n        new AbstractPreOrderCallback() {\n          @Override\n          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n            if (n.isFunction() && comp.hasScopeChanged(n)) {\n              cb.visit(comp, n);\n            }\n            return true;\n          }\n        });\n  }", "javadoc_start_line": 456, "annotations_start_line": 463, "method_start_line": 464, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}]}, {"failing_test": {"className": " com.google.javascript.jscomp.UnreachableCodeEliminationTest", "methodName": "testIssue4177428c", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "tryRemoveUnconditionalBranching", "content": "    /**\n     * Tries to remove n if it is an unconditional branch node (break, continue,\n     * or return) and the target of n is the same as the the follow of n.\n     * That is, if removing n preserves the control flow. Also if n targets\n     * another unconditional branch, this function will recursively try to\n     * remove the target branch as well. The reason why we want to cascade this\n     * removal is because we only run this pass once. If we have code such as\n     *\n     * break -> break -> break\n     *\n     * where all 3 breaks are useless, then the order of removal matters. When\n     * we first look at the first break, we see that it branches to the 2nd\n     * break. However, if we remove the last break, the 2nd break becomes\n     * useless and finally the first break becomes useless as well.\n     *\n     * @returns The target of this jump. If the target is also useless jump,\n     *     the target of that useless jump recursively.\n     */\n    @SuppressWarnings(\"fallthrough\")\n    private void tryRemoveUnconditionalBranching(Node n) {\n      /*\n       * For each unconditional branching control flow node, check to see\n       * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n       * the branching target. If it is, the branch node is safe to be removed.\n       *\n       * This is not as clever as MinimizeExitPoints because it doesn't do any\n       * if-else conversion but it handles more complicated switch statements\n       * much more nicely.\n       */\n\n      // If n is null the target is the end of the function, nothing to do.\n      if (n == null) {\n         return;\n      }\n\n      DiGraphNode<Node, Branch> gNode = cfg.getDirectedGraphNode(n);\n\n      if (gNode == null) {\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.RETURN:\n          if (n.hasChildren()) {\n            break;\n          }\n        case Token.BREAK:\n        case Token.CONTINUE:\n          // We are looking for a control flow changing statement that always\n          // branches to the same node. If after removing it control still\n          // branches to the same node, it is safe to remove.\n          List<DiGraphEdge<Node, Branch>> outEdges = gNode.getOutEdges();\n          if (outEdges.size() == 1 &&\n              // If there is a next node, this jump is not useless.\n              (n.getNext() == null || n.getNext().isFunction())) {\n\n            Preconditions.checkState(\n                outEdges.get(0).getValue() == Branch.UNCOND);\n            Node fallThrough = computeFollowing(n);\n            Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n            if (nextCfgNode == fallThrough) {\n              removeNode(n);\n            }\n          }\n      }\n    }", "javadoc_start_line": 110, "annotations_start_line": 128, "method_start_line": 129, "end_line": 175}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "process", "content": "  public void process(Node externs, Node toplevel) {\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n        @Override\n        public void visit(AbstractCompiler compiler, Node root) {\n          // Computes the control flow graph.\n          ControlFlowAnalysis cfa =\n              new ControlFlowAnalysis(compiler, false, false);\n          cfa.process(null, root);\n          ControlFlowGraph<Node> cfg = cfa.getCfg();\n          new GraphReachability<Node, ControlFlowGraph.Branch>(cfg)\n              .compute(cfg.getEntry().getValue());\n          if (root.isFunction()) {\n            root = root.getLastChild();\n          }\n          do {\n            codeChanged = false;\n            NodeTraversal.traverse(compiler, root, new EliminationPass(cfg));\n          } while (codeChanged);\n        }\n      });\n  }", "javadoc_start_line": 65, "annotations_start_line": 64, "method_start_line": 65, "end_line": 85}, {"file_path": "/src/com/google/javascript/jscomp/UnreachableCodeElimination.java", "method_name": "", "content": "    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {", "javadoc_start_line": 66, "annotations_start_line": 66, "method_start_line": 66, "end_line": 66}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseChangedFunctions", "content": "  /**\n   * Traversal for passes that work only on changed functions.\n   * Suppose a loopable pass P1 uses this traversal.\n   * Then, if a function doesn't change between two runs of P1, it won't look at\n   * the function the second time.\n   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n   */\n  public static void traverseChangedFunctions(\n      AbstractCompiler compiler, FunctionCallback callback) {\n    final AbstractCompiler comp = compiler;\n    final FunctionCallback cb = callback;\n    final Node jsRoot = comp.getJsRoot();\n    if (comp.hasScopeChanged(jsRoot)) {\n      cb.visit(comp, jsRoot);\n    }\n    traverse(comp, jsRoot,\n        new AbstractPreOrderCallback() {\n          @Override\n          public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n            if (n.isFunction() && comp.hasScopeChanged(n)) {\n              cb.visit(comp, n);\n            }\n            return true;\n          }\n        });\n  }", "javadoc_start_line": 456, "annotations_start_line": 463, "method_start_line": 464, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 487, "end_line": 490}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 278, "annotations_start_line": 281, "method_start_line": 281, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 507, "annotations_start_line": 510, "method_start_line": 510, "end_line": 536}]}], "project": {"name": "Closure", "version": 127}}