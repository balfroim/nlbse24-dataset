{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.ExploitAssignsTest", "methodName": "testIssue1017", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ExploitAssigns.java", "method_name": "isSafeReplacement", "content": "  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n      node = node.getFirstChild();\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }", "javadoc_start_line": 201, "annotations_start_line": 206, "method_start_line": 206, "end_line": 220}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\n        @Override\n        public void visit(AbstractCompiler compiler, Node root) {\n          if (root.isFunction()) {\n            root = root.getLastChild();\n          }\n          do {\n            handler.reset();\n            NodeTraversal.traverse(compiler, root, new PeepCallback());\n          } while (retraverseOnChange && handler.hasCodeChanged());\n        }\n      });\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }", "javadoc_start_line": 60, "annotations_start_line": 59, "method_start_line": 60, "end_line": 77}, {"file_path": "/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java", "method_name": "", "content": "    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {", "javadoc_start_line": 63, "annotations_start_line": 63, "method_start_line": 63, "end_line": 63}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseChangedFunctions", "content": "  /**\n   * Traversal for passes that work only on changed functions.\n   * Suppose a loopable pass P1 uses this traversal.\n   * Then, if a function doesn't change between two runs of P1, it won't look at\n   * the function the second time.\n   * (We're assuming that P1 runs to a fixpoint, o/w we may miss optimizations.)\n   *\n   * Most changes are reported with calls to Compiler.reportCodeChange(), which\n   * doesn't know which scope changed. We keep track of the current scope by\n   * calling Compiler.setScope inside pushScope and popScope.\n   * The automatic tracking can be wrong in rare cases when a pass changes scope\n   * w/out causing a call to pushScope or popScope. It's very hard to find the\n   * places where this happens unless a bug is triggered.\n   * Passes that do cross-scope modifications call\n   * Compiler.reportChangeToEnclosingScope(Node n).\n   */\n  public static void traverseChangedFunctions(\n      AbstractCompiler compiler, FunctionCallback callback) {\n    final AbstractCompiler comp = compiler;\n    final FunctionCallback cb = callback;\n    final Node jsRoot = comp.getJsRoot();\n    NodeTraversal t = new NodeTraversal(comp, new AbstractPreOrderCallback() {\n        @Override\n        public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\n          if ((n == jsRoot || n.isFunction()) && comp.hasScopeChanged(n)) {\n            cb.visit(comp, n);\n          }\n          return true;\n        }\n      });\n    t.traverse(jsRoot);\n  }", "javadoc_start_line": 455, "annotations_start_line": 471, "method_start_line": 472, "end_line": 486}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/ExploitAssigns.java", "method_name": "optimizeSubtree", "content": "  Node optimizeSubtree(Node subtree) {\n    for (Node child = subtree.getFirstChild(); child != null;) {\n      Node next = child.getNext();\n      if (NodeUtil.isExprAssign(child)) {\n        collapseAssign(child.getFirstChild(), child, subtree);\n      }\n      child = next;\n    }\n    return subtree;\n  }", "javadoc_start_line": 32, "annotations_start_line": 31, "method_start_line": 32, "end_line": 41}, {"file_path": "/src/com/google/javascript/jscomp/ExploitAssigns.java", "method_name": "collapseAssign", "content": "  /**\n   * Try to collapse the given assign into subsequent expressions.\n   */\n  private void collapseAssign(Node assign, Node expr,\n      Node exprParent) {\n    Node leftValue = assign.getFirstChild();\n    Node rightValue = leftValue.getNext();\n    if (isCollapsibleValue(leftValue, true) &&\n        collapseAssignEqualTo(expr, exprParent, leftValue)) {\n      reportCodeChange();\n    } else if (isCollapsibleValue(rightValue, false) &&\n        collapseAssignEqualTo(expr, exprParent, rightValue)) {\n      reportCodeChange();\n    } else if (rightValue.isAssign()) {\n      // Recursively deal with nested assigns.\n      collapseAssign(rightValue, expr, exprParent);\n    }\n  }", "javadoc_start_line": 43, "annotations_start_line": 46, "method_start_line": 47, "end_line": 60}, {"file_path": "/src/com/google/javascript/jscomp/ExploitAssigns.java", "method_name": "collapseAssignEqualTo", "content": "  /**\n   * Collapse the given assign expression into the expression directly\n   * following it, if possible.\n   *\n   * @param expr The expression that may be moved.\n   * @param exprParent The parent of {@code expr}.\n   * @param value The value of this expression, expressed as a node. Each\n   *     expression may have multiple values, so this function may be called\n   *     multiple times for the same expression. For example,\n   *     <code>\n   *     a = true;\n   *     </code>\n   *     is equal to the name \"a\" and the boolean \"true\".\n   * @return Whether the expression was collapsed successfully.\n   */\n  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.isName() ||\n              leftSide.isGetProp() &&\n              leftSide.getFirstChild().isThis()) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }", "javadoc_start_line": 93, "annotations_start_line": 108, "method_start_line": 109, "end_line": 199}, {"file_path": "/src/com/google/javascript/jscomp/ExploitAssigns.java", "method_name": "isSafeReplacement", "content": "  /**\n   * Checks name referenced in node to determine if it might have\n   * changed.\n   * @return Whether the replacement can be made.\n   */\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n      node = node.getFirstChild();\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }", "javadoc_start_line": 201, "annotations_start_line": 206, "method_start_line": 206, "end_line": 220}]}], "project": {"name": "Closure", "version": 124}}