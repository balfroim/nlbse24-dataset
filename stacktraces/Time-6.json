{"tours": [{"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_cutoverPreZero", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 995, "annotations_start_line": 995, "method_start_line": 995, "end_line": 1015}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_cutoverPreZero-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_cutoverPreZero", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 973, "annotations_start_line": 973, "method_start_line": 973, "end_line": 993}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_cutoverPreZero-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_cutoverPreZero", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "getInstance", "content": "    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }", "javadoc_start_line": 177, "annotations_start_line": 185, "method_start_line": 188, "end_line": 230}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_cutoverPreZero-getInstance.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusWeekyears_positiveToNegative_crossCutover", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-06-30> but was:<-0001-06-28>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 995, "annotations_start_line": 995, "method_start_line": 995, "end_line": 1015}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusWeekyears_positiveToNegative_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusWeekyears_positiveToNegative_crossCutover", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-06-30> but was:<-0001-06-28>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 973, "annotations_start_line": 973, "method_start_line": 973, "end_line": 993}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusWeekyears_positiveToNegative_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusWeekyears_positiveToNegative_crossCutover", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-06-30> but was:<-0001-06-28>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "getInstance", "content": "    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }", "javadoc_start_line": 177, "annotations_start_line": 185, "method_start_line": 188, "end_line": 230}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusWeekyears_positiveToNegative_crossCutover-getInstance.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusYears_positiveToZero_crossCutover", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 0 for year is not supported"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 995, "annotations_start_line": 995, "method_start_line": 995, "end_line": 1015}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusYears_positiveToZero_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusYears_positiveToZero_crossCutover", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 0 for year is not supported"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 973, "annotations_start_line": 973, "method_start_line": 973, "end_line": 993}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusYears_positiveToZero_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusYears_positiveToZero_crossCutover", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 0 for year is not supported"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "getInstance", "content": "    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }", "javadoc_start_line": 177, "annotations_start_line": 185, "method_start_line": 188, "end_line": 230}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusYears_positiveToZero_crossCutover-getInstance.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusYears_positiveToNegative_crossCutover", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-06-30> but was:<-0001-06-30>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 995, "annotations_start_line": 995, "method_start_line": 995, "end_line": 1015}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusYears_positiveToNegative_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusYears_positiveToNegative_crossCutover", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-06-30> but was:<-0001-06-30>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 973, "annotations_start_line": 973, "method_start_line": 973, "end_line": 993}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusYears_positiveToNegative_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusYears_positiveToNegative_crossCutover", "error": "junit.framework.AssertionFailedError", "message": "expected:<-0002-06-30> but was:<-0001-06-30>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "getInstance", "content": "    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }", "javadoc_start_line": 177, "annotations_start_line": 185, "method_start_line": 188, "end_line": 230}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusYears_positiveToNegative_crossCutover-getInstance.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusWeekyears_positiveToZero_crossCutover", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 0 for year is not supported"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, long value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 995, "annotations_start_line": 995, "method_start_line": 995, "end_line": 1015}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusWeekyears_positiveToZero_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusWeekyears_positiveToZero_crossCutover", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 0 for year is not supported"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "add", "content": "        public long add(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.add(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                }\n            } else {\n                instant = iJulianField.add(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        // no special handling for year zero as cutover always after year zero\n                        instant = julianToGregorian(instant);\n                    }\n                }\n            }\n            return instant;\n        }", "javadoc_start_line": 973, "annotations_start_line": 973, "method_start_line": 973, "end_line": 993}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusWeekyears_positiveToZero_crossCutover-add.csv'"}}, {"failing_test": {"className": " org.joda.time.chrono.TestGJDate", "methodName": "test_plusWeekyears_positiveToZero_crossCutover", "error": "org.joda.time.IllegalFieldValueException", "message": "Value 0 for year is not supported"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/chrono/GJChronology.java", "method_name": "getInstance", "content": "    /**\n     * Factory method returns instances of the GJ cutover chronology. Any\n     * cutover date may be specified.\n     *\n     * @param zone  the time zone to use, null is default\n     * @param gregorianCutover  the cutover to use, null means default\n     * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n     */\n    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }", "javadoc_start_line": 177, "annotations_start_line": 185, "method_start_line": 188, "end_line": 230}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Time/6/results/stacktrace-test_plusWeekyears_positiveToZero_crossCutover-getInstance.csv'"}}], "project": {"name": "Time", "version": 6}}