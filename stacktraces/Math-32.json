{"tours": [{"failing_test": {"className": " org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest", "methodName": "testIssue780", "error": "java.lang.ClassCastException", "message": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java", "method_name": "computeGeometricalProperties", "content": "    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }", "javadoc_start_line": 128, "annotations_start_line": 129, "method_start_line": 130, "end_line": 181}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSetTest.java", "method_name": "testIssue780", "content": "    public void testIssue780() {\n        float[] coords = {\n            1.000000f, -1.000000f, -1.000000f, \n            1.000000f, -1.000000f, 1.000000f, \n            -1.000000f, -1.000000f, 1.000000f, \n            -1.000000f, -1.000000f, -1.000000f, \n            1.000000f, 1.000000f, -1f, \n            0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f, \n            -1.000000f, 1.000000f, 1.000000f, \n            -1.000000f, 1.000000f, -1.000000f};\n        int[] indices = {\n            0, 1, 2, 0, 2, 3, \n            4, 7, 6, 4, 6, 5, \n            0, 4, 5, 0, 5, 1, \n            1, 5, 6, 1, 6, 2, \n            2, 6, 7, 2, 7, 3, \n            4, 0, 3, 4, 3, 7};\n        ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\n        for (int idx = 0; idx < indices.length; idx += 3) {\n            int idxA = indices[idx] * 3;\n            int idxB = indices[idx + 1] * 3;\n            int idxC = indices[idx + 2] * 3;\n            Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\n            Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\n            Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\n            Vector3D[] vertices = {v_1, v_2, v_3};\n            Plane polyPlane = new Plane(v_1, v_2, v_3);\n            ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\n\n            Vector2D[] projPts = new Vector2D[vertices.length];\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n                projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n            }\n\n            SubLine lineInPlane = null;\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\n                lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\n                lines.add(lineInPlane);\n            }\n            Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\n            SubPlane polygon = new SubPlane(polyPlane, polyRegion);\n            subHyperplaneList.add(polygon);\n        }\n        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\n        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\n        Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);\n    }", "javadoc_start_line": 237, "annotations_start_line": 236, "method_start_line": 237, "end_line": 283}, {"file_path": "/src/main/java/org/apache/commons/math3/geometry/partitioning/AbstractRegion.java", "method_name": "getSize", "content": "    /** {@inheritDoc} */\n    public double getSize() {\n        if (barycenter == null) {\n            computeGeometricalProperties();\n        }\n        return size;\n    }", "javadoc_start_line": 378, "annotations_start_line": 379, "method_start_line": 379, "end_line": 384}, {"file_path": "/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.java", "method_name": "computeGeometricalProperties", "content": "    /** {@inheritDoc} */\n    @Override\n    protected void computeGeometricalProperties() {\n\n        // compute the contribution of all boundary facets\n        getTree(true).visit(new FacetsContributionVisitor());\n\n        if (getSize() < 0) {\n            // the polyhedrons set as a finite outside\n            // surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector3D.NaN);\n        } else {\n            // the polyhedrons set is finite, apply the remaining scaling factors\n            setSize(getSize() / 3.0);\n            setBarycenter(new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n        }\n\n    }", "javadoc_start_line": 113, "annotations_start_line": 114, "method_start_line": 115, "end_line": 131}]}], "project": {"name": "Math", "version": 32}}