{"tours": [{"failing_test": {"className": " org.joda.time.TestDateTimeZoneCutover", "methodName": "test_DateTime_constructor_Moscow_Autumn", "error": "junit.framework.ComparisonFailure", "message": "expected:<...10-28T02:30:00.000+0[4]:00> but was:<...10-28T02:30:00.000+0[3]:00>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "getOffsetFromLocal", "content": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "javadoc_start_line": 846, "annotations_start_line": 879, "method_start_line": 879, "end_line": 901}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "test_DateTime_constructor_Moscow_Autumn", "content": "    public void test_DateTime_constructor_Moscow_Autumn() {\n        DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);\n        assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());\n    }", "javadoc_start_line": 920, "annotations_start_line": 920, "method_start_line": 920, "end_line": 923}, {"file_path": "/src/main/java/org/joda/time/DateTime.java", "method_name": "DateTime", "content": "    /**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param zone  the time zone, null means default time zone\n     * @since 2.0\n     */\n    public DateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            DateTimeZone zone) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, 0, 0, zone);\n    }", "javadoc_start_line": 264, "annotations_start_line": 278, "method_start_line": 284, "end_line": 287}, {"file_path": "/src/main/java/org/joda/time/base/BaseDateTime.java", "method_name": "BaseDateTime", "content": "    /**\n     * Constructs an instance from datetime field values\n     * using <code>ISOChronology</code> in the specified time zone.\n     * <p>\n     * If the specified time zone is null, the default zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param zone  the time zone, null means default time zone\n     */\n    public BaseDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            DateTimeZone zone) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));\n    }", "javadoc_start_line": 199, "annotations_start_line": 214, "method_start_line": 222, "end_line": 225}, {"file_path": "/src/main/java/org/joda/time/base/BaseDateTime.java", "method_name": "BaseDateTime", "content": "    /**\n     * Constructs an instance from datetime field values\n     * using the specified chronology.\n     * <p>\n     * If the chronology is null, <code>ISOChronology</code>\n     * in the default time zone is used.\n     *\n     * @param year  the year\n     * @param monthOfYear  the month of the year\n     * @param dayOfMonth  the day of the month\n     * @param hourOfDay  the hour of the day\n     * @param minuteOfHour  the minute of the hour\n     * @param secondOfMinute  the second of the minute\n     * @param millisOfSecond  the millisecond of the second\n     * @param chronology  the chronology, null means ISOChronology in default zone\n     */\n    public BaseDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super();\n        iChronology = checkChronology(chronology);\n        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iMillis = checkInstant(instant, iChronology);\n    }", "javadoc_start_line": 227, "annotations_start_line": 243, "method_start_line": 251, "end_line": 257}, {"file_path": "/src/main/java/org/joda/time/chrono/AssembledChronology.java", "method_name": "getDateTimeMillis", "content": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n            // Only call specialized implementation if applicable fields are the same.\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }", "javadoc_start_line": 125, "annotations_start_line": 125, "method_start_line": 129, "end_line": 138}, {"file_path": "/src/main/java/org/joda/time/chrono/ZonedChronology.java", "method_name": "getDateTimeMillis", "content": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, \n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }", "javadoc_start_line": 114, "annotations_start_line": 114, "method_start_line": 118, "end_line": 122}, {"file_path": "/src/main/java/org/joda/time/chrono/ZonedChronology.java", "method_name": "localToUTC", "content": "    /**\n     * @param instant instant from 1970-01-01T00:00:00 local time\n     * @return instant from 1970-01-01T00:00:00Z\n     */\n    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }", "javadoc_start_line": 134, "annotations_start_line": 138, "method_start_line": 138, "end_line": 148}, {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "getOffsetFromLocal", "content": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "javadoc_start_line": 846, "annotations_start_line": 879, "method_start_line": 879, "end_line": 901}]}, {"failing_test": {"className": " org.joda.time.TestDateTimeZoneCutover", "methodName": "test_getOffsetFromLocal_Moscow_Autumn_overlap_mins", "error": "junit.framework.ComparisonFailure", "message": "2007-10-28T02:00:00.000+03:00 expected:<...10-28T02:00:00.000+0[4]:00> but was:<...10-28T02:00:00.000+0[3]:00>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "getOffsetFromLocal", "content": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "javadoc_start_line": 846, "annotations_start_line": 879, "method_start_line": 879, "end_line": 901}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "test_getOffsetFromLocal_Moscow_Autumn_overlap_mins", "content": "    public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {\n        for (int min = 0; min < 60; min++) {\n            if (min < 10) {\n                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:0\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n            } else {\n                doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n            }\n        }\n    }", "javadoc_start_line": 910, "annotations_start_line": 910, "method_start_line": 910, "end_line": 918}, {"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "doTest_getOffsetFromLocal", "content": "    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {\n        doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, zone);\n    }", "javadoc_start_line": 1216, "annotations_start_line": 1216, "method_start_line": 1216, "end_line": 1218}, {"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "doTest_getOffsetFromLocal", "content": "    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {\n        DateTime dt = new DateTime(year, month, day, hour, min, sec, milli, DateTimeZone.UTC);\n        int offset = zone.getOffsetFromLocal(dt.getMillis());\n        DateTime res = new DateTime(dt.getMillis() - offset, zone);\n        assertEquals(res.toString(), expected, res.toString());\n    }", "javadoc_start_line": 1228, "annotations_start_line": 1228, "method_start_line": 1228, "end_line": 1233}, {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "getOffsetFromLocal", "content": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "javadoc_start_line": 846, "annotations_start_line": 879, "method_start_line": 879, "end_line": 901}]}, {"failing_test": {"className": " org.joda.time.TestDateTimeZoneCutover", "methodName": "test_getOffsetFromLocal_Moscow_Autumn", "error": "junit.framework.ComparisonFailure", "message": "2007-10-28T02:00:00.000+03:00 expected:<...10-28T02:00:00.000+0[4]:00> but was:<...10-28T02:00:00.000+0[3]:00>"}, "patched_method": {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "getOffsetFromLocal", "content": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "javadoc_start_line": 846, "annotations_start_line": 879, "method_start_line": 879, "end_line": 901}, "steps": [{"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "test_getOffsetFromLocal_Moscow_Autumn", "content": "    public void test_getOffsetFromLocal_Moscow_Autumn() {\n        doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n        \n        doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,30,59,999, \"2007-10-28T02:30:59.999+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,59,59,998, \"2007-10-28T02:59:59.998+04:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 2,59,59,999, \"2007-10-28T02:59:59.999+04:00\", ZONE_MOSCOW);\n        \n        doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n        doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n    }", "javadoc_start_line": 889, "annotations_start_line": 889, "method_start_line": 889, "end_line": 908}, {"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "doTest_getOffsetFromLocal", "content": "    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {\n        doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, zone);\n    }", "javadoc_start_line": 1216, "annotations_start_line": 1216, "method_start_line": 1216, "end_line": 1218}, {"file_path": "/src/test/java/org/joda/time/TestDateTimeZoneCutover.java", "method_name": "doTest_getOffsetFromLocal", "content": "    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {\n        DateTime dt = new DateTime(year, month, day, hour, min, sec, milli, DateTimeZone.UTC);\n        int offset = zone.getOffsetFromLocal(dt.getMillis());\n        DateTime res = new DateTime(dt.getMillis() - offset, zone);\n        assertEquals(res.toString(), expected, res.toString());\n    }", "javadoc_start_line": 1228, "annotations_start_line": 1228, "method_start_line": 1228, "end_line": 1233}, {"file_path": "/src/main/java/org/joda/time/DateTimeZone.java", "method_name": "getOffsetFromLocal", "content": "    /**\n     * Gets the millisecond offset to subtract from local time to get UTC time.\n     * This offset can be used to undo adding the offset obtained by getOffset.\n     *\n     * <pre>\n     * millisLocal == millisUTC   + getOffset(millisUTC)\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n     * </pre>\n     *\n     * NOTE: After calculating millisLocal, some error may be introduced. At\n     * offset transitions (due to DST or other historical changes), ranges of\n     * local times may map to different UTC times.\n     * <p>\n     * This method will return an offset suitable for calculating an instant\n     * after any DST gap. For example, consider a zone with a cutover\n     * from 01:00 to 01:59:<br />\n     * Input: 00:00  Output: 00:00<br />\n     * Input: 00:30  Output: 00:30<br />\n     * Input: 01:00  Output: 02:00<br />\n     * Input: 01:30  Output: 02:30<br />\n     * Input: 02:00  Output: 02:00<br />\n     * Input: 02:30  Output: 02:30<br />\n     * <p>\n     * During a DST overlap (where the local time is ambiguous) this method will return\n     * the earlier instant. The combination of these two rules is to always favour\n     * daylight (summer) time over standard (winter) time.\n     * <p>\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n     * Prior to v1.5, the DST gap behaviour was also not defined.\n     *\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n     * @return the millisecond offset to subtract from local time to get UTC time\n     */\n    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }", "javadoc_start_line": 846, "annotations_start_line": 879, "method_start_line": 879, "end_line": 901}]}], "project": {"name": "Time", "version": 25}}