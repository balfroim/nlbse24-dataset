{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.InlineObjectLiteralsTest", "methodName": "testBug545", "error": "java.lang.RuntimeException", "message": "INTERNAL COMPILER ERROR."}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/InlineObjectLiterals.java", "method_name": "replaceAssignmentExpression", "content": "    /**\n     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\n     * Note that the resulting expression will always evaluate to\n     * true, as would the x = {...} expression.\n     */\n    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = Lists.newArrayList();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n      for (Node key = val.getFirstChild(); key != null;\n           key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n      }\n\n      // TODO(user): Better source information.\n      for (String var : all) {\n        nodes.add(\n          new Node(Token.ASSIGN,\n                   Node.newString(Token.NAME, varmap.get(var)),\n                   NodeUtil.newUndefinedNode(null)));\n      }\n\n      Node replacement;\n        // All assignments evaluate to true, so make sure that the\n        // expr statement evaluates to true in case it matters.\n        nodes.add(new Node(Token.TRUE));\n\n        // Join these using COMMA.  A COMMA node must have 2 children, so we\n        // create a tree. In the tree the first child be the COMMA to match\n        // the parser, otherwise tree equality tests fail.\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = new Node(Token.COMMA);\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n\n      Node replace = ref.getParent();\n      replacement.copyInformationFromForTree(replace);\n\n      if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n      } else {\n        replace.getParent().replaceChild(replace, replacement);\n      }\n    }", "javadoc_start_line": 298, "annotations_start_line": 303, "method_start_line": 304, "end_line": 360}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineObjectLiterals.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }", "javadoc_start_line": 63, "annotations_start_line": 62, "method_start_line": 63, "end_line": 67}, {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "process", "content": "  /**\n   * Convenience method for running this pass over a tree with this\n   * class as a callback.\n   */\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n  }", "javadoc_start_line": 104, "annotations_start_line": 108, "method_start_line": 109, "end_line": 112}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  /**\n   * Traverses a list of node trees.\n   */\n  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }", "javadoc_start_line": 440, "annotations_start_line": 443, "method_start_line": 444, "end_line": 447}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseRoots", "content": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      inputId = NodeUtil.getInputId(scopeRoot);\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 270, "annotations_start_line": 270, "method_start_line": 270, "end_line": 293}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 449, "annotations_start_line": 452, "method_start_line": 453, "end_line": 481}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /**\n   * Traverses a function.\n   */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 483, "annotations_start_line": 486, "method_start_line": 486, "end_line": 521}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "popScope", "content": "  /** Pops back to the previous scope (e.g. when leaving a function). */\n  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }", "javadoc_start_line": 557, "annotations_start_line": 558, "method_start_line": 558, "end_line": 568}, {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "exitScope", "content": "  /**\n   * Updates block statck and invokes any additional behavior.\n   */\n  @Override\n  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    if (t.getScope().isGlobal()) {\n      // Update global scope reference lists when we are done with it.\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n    } else {\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n    }\n  }", "javadoc_start_line": 176, "annotations_start_line": 179, "method_start_line": 180, "end_line": 189}]}], "project": {"name": "Closure", "version": 53}}