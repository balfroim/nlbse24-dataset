{"tours": [{"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testParseSourceMetaMap", "error": "junit.framework.AssertionFailedError", "message": "expected:<5> but was:<4>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testParseSourceMetaMap-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testParseSourceMetaMap", "error": "junit.framework.AssertionFailedError", "message": "expected:<5> but was:<4>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput0a", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput0a-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput0a", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput0a-getOriginalMappingForEntry.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testMultilineMapping", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testMultilineMapping-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testMultilineMapping", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testMultiFunctionMapping", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testMultiFunctionMapping-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testMultiFunctionMapping", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testLiteralMappingsGoldenOutput", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testLiteralMappingsGoldenOutput-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testLiteralMappingsGoldenOutput", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testLiteralMappingsGoldenOutput-getOriginalMappingForEntry.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testMultilineMapping2", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testMultilineMapping2-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testMultilineMapping2", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testBasicMappingGoldenOutput", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testBasicMappingGoldenOutput-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testBasicMappingGoldenOutput", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testBasicMappingGoldenOutput-getOriginalMappingForEntry.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testSourceMapMerging", "error": "junit.framework.AssertionFailedError", "message": "expected:<5> but was:<4>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testSourceMapMerging-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testSourceMapMerging", "error": "junit.framework.AssertionFailedError", "message": "expected:<5> but was:<4>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testLiteralMappings", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testLiteralMappings-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testLiteralMappings", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testBasicMapping1", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testBasicMapping1-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testBasicMapping1", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testBasicMapping2", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testBasicMapping2-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testBasicMapping2", "error": "junit.framework.AssertionFailedError", "message": "expected:<10> but was:<9>"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [{"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getMappingForLine", "content": "  public OriginalMapping getMappingForLine(int lineNumber, int column) {\n    // Normalize the line and column numbers to 0.\n    lineNumber--;\n    column--;\n\n    if (lineNumber < 0 || lineNumber >= lines.size()) {\n      return null;\n    }\n\n    Preconditions.checkState(lineNumber >= 0);\n    Preconditions.checkState(column >= 0);\n\n\n    // If the line is empty return the previous mapping.\n    if (lines.get(lineNumber) == null) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    ArrayList<Entry> entries = lines.get(lineNumber);\n    // No empty lists.\n    Preconditions.checkState(entries.size() > 0);\n    if (entries.get(0).getGeneratedColumn() > column) {\n      return getPreviousMapping(lineNumber);\n    }\n\n    int index = search(entries, column, 0, entries.size() - 1);\n    Preconditions.checkState(index >= 0, \"unexpected:%s\", index);\n    return getOriginalMappingForEntry(entries.get(index));\n  }", "javadoc_start_line": 206, "annotations_start_line": 205, "method_start_line": 206, "end_line": 234}, {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}]}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput1", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput1-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput1", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput1-getOriginalMappingForEntry.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput2", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput2-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput2", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput2-getOriginalMappingForEntry.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput3", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput3-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput3", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput3-getOriginalMappingForEntry.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput4", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput4-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput4", "error": "junit.framework.ComparisonFailure", "message": "expected:<...t\":1,"}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput4-getOriginalMappingForEntry.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput5", "error": "junit.framework.ComparisonFailure", "message": "expected:<..."}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/SourceMap.java", "method_name": "addMapping", "content": "  public void addMapping(\n      Node node,\n      FilePosition outputStartPosition,\n      FilePosition outputEndPosition) {\n    String sourceFile = node.getSourceFileName();\n\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n      return;\n    }\n\n    sourceFile = fixupSourceLocation(sourceFile);\n\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n\n    // Strangely, Rhino source lines are one based but columns are\n    // zero based.\n    // We don't change this for the v1 or v2 source maps but for\n    // v3 we make them both 0 based.\n\n    generator.addMapping(\n        sourceFile, originalName,\n        new FilePosition(node.getLineno(), node.getCharno()),\n        outputStartPosition, outputEndPosition);\n  }", "javadoc_start_line": 117, "annotations_start_line": 117, "method_start_line": 120, "end_line": 143}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput5-addMapping.csv'"}}, {"failing_test": {"className": " com.google.debugging.sourcemap.SourceMapGeneratorV3Test", "methodName": "testGoldenOutput5", "error": "junit.framework.ComparisonFailure", "message": "expected:<..."}, "patched_method": {"file_path": "/src/com/google/debugging/sourcemap/SourceMapConsumerV3.java", "method_name": "getOriginalMappingForEntry", "content": "  /**\n   * Creates an \"OriginalMapping\" object for the given entry object.\n   */\n  private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n    if (entry.getSourceFileId() == UNMAPPED) {\n      return null;\n    } else {\n      // Adjust the line/column here to be start at 1.\n      Builder x = OriginalMapping.newBuilder()\n        .setOriginalFile(sources[entry.getSourceFileId()])\n        .setLineNumber(entry.getSourceLine())\n        .setColumnPosition(entry.getSourceColumn());\n      if (entry.getNameId() != UNMAPPED) {\n        x.setIdentifier(names[entry.getNameId()]);\n      }\n      return x.build();\n    }\n  }", "javadoc_start_line": 479, "annotations_start_line": 482, "method_start_line": 482, "end_line": 496}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/47/results/stacktrace-testGoldenOutput5-getOriginalMappingForEntry.csv'"}}], "project": {"name": "Closure", "version": 47}}