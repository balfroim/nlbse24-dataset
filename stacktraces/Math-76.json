{"tours": [{"failing_test": {"className": " org.apache.commons.math.linear.SingularValueSolverTest", "methodName": "testMath320A", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<0.09336767546650937>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getV", "content": "    /** {@inheritDoc} */\n    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }", "javadoc_start_line": 232, "annotations_start_line": 233, "method_start_line": 234, "end_line": 277}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java", "method_name": "testMath320A", "content": "    public void testMath320A() {\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n        });\n        double s439  = Math.sqrt(439.0);\n        double[] reference = new double[] {\n            Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\n        };\n        SingularValueDecomposition svd =\n            new SingularValueDecompositionImpl(rm);\n\n        // check we get the expected theoretical singular values\n        double[] singularValues = svd.getSingularValues();\n        Assert.assertEquals(reference.length, singularValues.length);\n        for (int i = 0; i < reference.length; ++i) {\n            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n        }\n\n        // check the decomposition allows to recover the original matrix\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);\n\n        // check we can solve a singular system\n        double[] b = new double[] { 5.0, 6.0, 7.0 };\n        double[] resSVD = svd.getSolver().solve(b);\n        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n\n        // check the solution really minimizes the residuals\n        double svdMinResidual = residual(rm, resSVD, b);\n        double epsilon = 2 * Math.ulp(svdMinResidual);\n        double h = 0.1;\n        int    k = 3;\n        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n                    double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 };\n                    Assert.assertTrue((residual(rm, x, b) - svdMinResidual) > -epsilon);\n                }\n            }\n        }\n\n    }", "javadoc_start_line": 168, "annotations_start_line": 167, "method_start_line": 168, "end_line": 209}, {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getVT", "content": "    /** {@inheritDoc} */\n    public RealMatrix getVT()\n        throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n\n        // return the cached matrix\n        return cachedVt;\n\n    }", "javadoc_start_line": 279, "annotations_start_line": 280, "method_start_line": 281, "end_line": 290}, {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getV", "content": "    /** {@inheritDoc} */\n    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }", "javadoc_start_line": 232, "annotations_start_line": 233, "method_start_line": 234, "end_line": 277}]}, {"failing_test": {"className": " org.apache.commons.math.linear.SingularValueSolverTest", "methodName": "testMath320A", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<0.09336767546650937>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getU", "content": "    /** {@inheritDoc} */\n    public RealMatrix getU()\n        throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedU;\n\n    }", "javadoc_start_line": 152, "annotations_start_line": 153, "method_start_line": 154, "end_line": 198}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java", "method_name": "testMath320A", "content": "    public void testMath320A() {\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\n        });\n        double s439  = Math.sqrt(439.0);\n        double[] reference = new double[] {\n            Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\n        };\n        SingularValueDecomposition svd =\n            new SingularValueDecompositionImpl(rm);\n\n        // check we get the expected theoretical singular values\n        double[] singularValues = svd.getSingularValues();\n        Assert.assertEquals(reference.length, singularValues.length);\n        for (int i = 0; i < reference.length; ++i) {\n            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\n        }\n\n        // check the decomposition allows to recover the original matrix\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);\n\n        // check we can solve a singular system\n        double[] b = new double[] { 5.0, 6.0, 7.0 };\n        double[] resSVD = svd.getSolver().solve(b);\n        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\n\n        // check the solution really minimizes the residuals\n        double svdMinResidual = residual(rm, resSVD, b);\n        double epsilon = 2 * Math.ulp(svdMinResidual);\n        double h = 0.1;\n        int    k = 3;\n        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\n            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\n                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\n                    double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 };\n                    Assert.assertTrue((residual(rm, x, b) - svdMinResidual) > -epsilon);\n                }\n            }\n        }\n\n    }", "javadoc_start_line": 168, "annotations_start_line": 167, "method_start_line": 168, "end_line": 209}, {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getU", "content": "    /** {@inheritDoc} */\n    public RealMatrix getU()\n        throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedU;\n\n    }", "javadoc_start_line": 152, "annotations_start_line": 153, "method_start_line": 154, "end_line": 198}]}, {"failing_test": {"className": " org.apache.commons.math.linear.SingularValueSolverTest", "methodName": "testMath320B", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<3.2>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getV", "content": "    /** {@inheritDoc} */\n    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }", "javadoc_start_line": 232, "annotations_start_line": 233, "method_start_line": 234, "end_line": 277}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java", "method_name": "testMath320B", "content": "    public void testMath320B() {\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n            { 1.0, 2.0 }, { 1.0, 2.0 }\n        });\n        SingularValueDecomposition svd =\n            new SingularValueDecompositionImpl(rm);\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);\n    }", "javadoc_start_line": 212, "annotations_start_line": 211, "method_start_line": 212, "end_line": 220}, {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getVT", "content": "    /** {@inheritDoc} */\n    public RealMatrix getVT()\n        throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n\n        // return the cached matrix\n        return cachedVt;\n\n    }", "javadoc_start_line": 279, "annotations_start_line": 280, "method_start_line": 281, "end_line": 290}, {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getV", "content": "    /** {@inheritDoc} */\n    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }", "javadoc_start_line": 232, "annotations_start_line": 233, "method_start_line": 234, "end_line": 277}]}, {"failing_test": {"className": " org.apache.commons.math.linear.SingularValueSolverTest", "methodName": "testMath320B", "error": "junit.framework.AssertionFailedError", "message": "expected:<0.0> but was:<3.2>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getU", "content": "    /** {@inheritDoc} */\n    public RealMatrix getU()\n        throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedU;\n\n    }", "javadoc_start_line": 152, "annotations_start_line": 153, "method_start_line": 154, "end_line": 198}, "steps": [{"file_path": "/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java", "method_name": "testMath320B", "content": "    public void testMath320B() {\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\n            { 1.0, 2.0 }, { 1.0, 2.0 }\n        });\n        SingularValueDecomposition svd =\n            new SingularValueDecompositionImpl(rm);\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);\n    }", "javadoc_start_line": 212, "annotations_start_line": 211, "method_start_line": 212, "end_line": 220}, {"file_path": "/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java", "method_name": "getU", "content": "    /** {@inheritDoc} */\n    public RealMatrix getU()\n        throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedU;\n\n    }", "javadoc_start_line": 152, "annotations_start_line": 153, "method_start_line": 154, "end_line": 198}]}], "project": {"name": "Math", "version": 76}}