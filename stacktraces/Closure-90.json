{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.TypeCheckTest", "methodName": "testBackwardsTypedefUse8", "error": "junit.framework.AssertionFailedError", "message": "unexpected warnings(s):"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionTypeBuilder.java", "method_name": "apply", "content": "    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }", "javadoc_start_line": 177, "annotations_start_line": 176, "method_start_line": 177, "end_line": 190}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/TypeCheck.java", "method_name": "processForTesting", "content": "  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }", "javadoc_start_line": 345, "annotations_start_line": 346, "method_start_line": 346, "end_line": 363}, {"file_path": "/src/com/google/javascript/jscomp/MemoizedScopeCreator.java", "method_name": "createScope", "content": "  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }", "javadoc_start_line": 50, "annotations_start_line": 49, "method_start_line": 50, "end_line": 59}, {"file_path": "/src/com/google/javascript/jscomp/TypedScopeCreator.java", "method_name": "createScope", "content": "  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }", "javadoc_start_line": 165, "annotations_start_line": 169, "method_start_line": 169, "end_line": 212}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "resolve", "content": "  /**\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   */\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "javadoc_start_line": 871, "annotations_start_line": 884, "method_start_line": 884, "end_line": 897}, {"file_path": "/src/com/google/javascript/rhino/jstype/FunctionType.java", "method_name": "resolveInternal", "content": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }", "javadoc_start_line": 862, "annotations_start_line": 861, "method_start_line": 862, "end_line": 903}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "safeResolve", "content": "  /**\n   * A null-safe resolve.\n   * @see #resolve\n   */\n  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }", "javadoc_start_line": 920, "annotations_start_line": 924, "method_start_line": 925, "end_line": 927}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "resolve", "content": "  /**\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   */\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "javadoc_start_line": 871, "annotations_start_line": 884, "method_start_line": 884, "end_line": 897}, {"file_path": "/src/com/google/javascript/rhino/jstype/NamedType.java", "method_name": "resolveInternal", "content": "  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    super.resolveInternal(t, enclosing);\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }", "javadoc_start_line": 181, "annotations_start_line": 184, "method_start_line": 185, "end_line": 209}, {"file_path": "/src/com/google/javascript/rhino/jstype/NamedType.java", "method_name": "resolveViaRegistry", "content": "  /**\n   * Resolves a named type by looking it up in the registry.\n   * @return True if we resolved successfully.\n   */\n  private boolean resolveViaRegistry(\n      ErrorReporter t, StaticScope<JSType> enclosing) {\n    JSType type = registry.getType(reference);\n    if (type != null) {\n      setReferencedAndResolvedType(type, t, enclosing);\n      return true;\n    }\n    return false;\n  }", "javadoc_start_line": 211, "annotations_start_line": 215, "method_start_line": 216, "end_line": 223}, {"file_path": "/src/com/google/javascript/rhino/jstype/NamedType.java", "method_name": "setReferencedAndResolvedType", "content": "  private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\n      StaticScope<JSType> enclosing) {\n    if (validator != null) {\n      validator.apply(type);\n    }\n    setReferencedType(type);\n    checkEnumElementCycle(t);\n    setResolvedTypeInternal(getReferencedType());\n  }", "javadoc_start_line": 295, "annotations_start_line": 295, "method_start_line": 296, "end_line": 303}]}, {"failing_test": {"className": " com.google.javascript.jscomp.TypeCheckTest", "methodName": "testBackwardsTypedefUse8", "error": "junit.framework.AssertionFailedError", "message": "unexpected warnings(s):"}, "patched_method": {"file_path": "/src/com/google/javascript/rhino/jstype/FunctionType.java", "method_name": "resolveInternal", "content": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }", "javadoc_start_line": 862, "annotations_start_line": 861, "method_start_line": 862, "end_line": 903}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/TypeCheck.java", "method_name": "processForTesting", "content": "  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }", "javadoc_start_line": 345, "annotations_start_line": 346, "method_start_line": 346, "end_line": 363}, {"file_path": "/src/com/google/javascript/jscomp/MemoizedScopeCreator.java", "method_name": "createScope", "content": "  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }", "javadoc_start_line": 50, "annotations_start_line": 49, "method_start_line": 50, "end_line": 59}, {"file_path": "/src/com/google/javascript/jscomp/TypedScopeCreator.java", "method_name": "createScope", "content": "  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }", "javadoc_start_line": 165, "annotations_start_line": 169, "method_start_line": 169, "end_line": 212}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "resolve", "content": "  /**\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   */\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "javadoc_start_line": 871, "annotations_start_line": 884, "method_start_line": 884, "end_line": 897}, {"file_path": "/src/com/google/javascript/rhino/jstype/FunctionType.java", "method_name": "resolveInternal", "content": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }", "javadoc_start_line": 862, "annotations_start_line": 861, "method_start_line": 862, "end_line": 903}]}, {"failing_test": {"className": " com.google.javascript.jscomp.TypeCheckTest", "methodName": "testBackwardsTypedefUse9", "error": "junit.framework.ComparisonFailure", "message": "expected:<[actual parameter 1 of g does not match formal parameter"}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/FunctionTypeBuilder.java", "method_name": "apply", "content": "    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }", "javadoc_start_line": 177, "annotations_start_line": 176, "method_start_line": 177, "end_line": 190}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/TypeCheck.java", "method_name": "processForTesting", "content": "  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }", "javadoc_start_line": 345, "annotations_start_line": 346, "method_start_line": 346, "end_line": 363}, {"file_path": "/src/com/google/javascript/jscomp/MemoizedScopeCreator.java", "method_name": "createScope", "content": "  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }", "javadoc_start_line": 50, "annotations_start_line": 49, "method_start_line": 50, "end_line": 59}, {"file_path": "/src/com/google/javascript/jscomp/TypedScopeCreator.java", "method_name": "createScope", "content": "  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }", "javadoc_start_line": 165, "annotations_start_line": 169, "method_start_line": 169, "end_line": 212}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "resolve", "content": "  /**\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   */\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "javadoc_start_line": 871, "annotations_start_line": 884, "method_start_line": 884, "end_line": 897}, {"file_path": "/src/com/google/javascript/rhino/jstype/FunctionType.java", "method_name": "resolveInternal", "content": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }", "javadoc_start_line": 862, "annotations_start_line": 861, "method_start_line": 862, "end_line": 903}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "safeResolve", "content": "  /**\n   * A null-safe resolve.\n   * @see #resolve\n   */\n  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }", "javadoc_start_line": 920, "annotations_start_line": 924, "method_start_line": 925, "end_line": 927}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "resolve", "content": "  /**\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   */\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "javadoc_start_line": 871, "annotations_start_line": 884, "method_start_line": 884, "end_line": 897}, {"file_path": "/src/com/google/javascript/rhino/jstype/NamedType.java", "method_name": "resolveInternal", "content": "  /**\n   * Resolve the referenced type within the enclosing scope.\n   */\n  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    super.resolveInternal(t, enclosing);\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }", "javadoc_start_line": 181, "annotations_start_line": 184, "method_start_line": 185, "end_line": 209}, {"file_path": "/src/com/google/javascript/rhino/jstype/NamedType.java", "method_name": "resolveViaRegistry", "content": "  /**\n   * Resolves a named type by looking it up in the registry.\n   * @return True if we resolved successfully.\n   */\n  private boolean resolveViaRegistry(\n      ErrorReporter t, StaticScope<JSType> enclosing) {\n    JSType type = registry.getType(reference);\n    if (type != null) {\n      setReferencedAndResolvedType(type, t, enclosing);\n      return true;\n    }\n    return false;\n  }", "javadoc_start_line": 211, "annotations_start_line": 215, "method_start_line": 216, "end_line": 223}, {"file_path": "/src/com/google/javascript/rhino/jstype/NamedType.java", "method_name": "setReferencedAndResolvedType", "content": "  private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\n      StaticScope<JSType> enclosing) {\n    if (validator != null) {\n      validator.apply(type);\n    }\n    setReferencedType(type);\n    checkEnumElementCycle(t);\n    setResolvedTypeInternal(getReferencedType());\n  }", "javadoc_start_line": 295, "annotations_start_line": 295, "method_start_line": 296, "end_line": 303}]}, {"failing_test": {"className": " com.google.javascript.jscomp.TypeCheckTest", "methodName": "testBackwardsTypedefUse9", "error": "junit.framework.ComparisonFailure", "message": "expected:<[actual parameter 1 of g does not match formal parameter"}, "patched_method": {"file_path": "/src/com/google/javascript/rhino/jstype/FunctionType.java", "method_name": "resolveInternal", "content": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }", "javadoc_start_line": 862, "annotations_start_line": 861, "method_start_line": 862, "end_line": 903}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/TypeCheck.java", "method_name": "processForTesting", "content": "  /** Main entry point of this phase for testing code. */\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }", "javadoc_start_line": 345, "annotations_start_line": 346, "method_start_line": 346, "end_line": 363}, {"file_path": "/src/com/google/javascript/jscomp/MemoizedScopeCreator.java", "method_name": "createScope", "content": "  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }", "javadoc_start_line": 50, "annotations_start_line": 49, "method_start_line": 50, "end_line": 59}, {"file_path": "/src/com/google/javascript/jscomp/TypedScopeCreator.java", "method_name": "createScope", "content": "  /**\n   * Creates a scope with all types declared. Declares newly discovered types\n   * and type properties in the type registry.\n   */\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }", "javadoc_start_line": 165, "annotations_start_line": 169, "method_start_line": 169, "end_line": 212}, {"file_path": "/src/com/google/javascript/rhino/jstype/JSType.java", "method_name": "resolve", "content": "  /**\n   * Resolve this type in the given scope.\n   *\n   * The returned value must be equal to {@code this}, as defined by\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\n   * may modify the internal state of {@code this}, as long as it does\n   * so in a way that preserves Object equality.\n   *\n   * For efficiency, we should only resolve a type once per compilation job.\n   * For incremental compilations, one compilation job may need the\n   * artifacts from a previous generation, so we will eventually need\n   * a generational flag instead of a boolean one.\n   */\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }", "javadoc_start_line": 871, "annotations_start_line": 884, "method_start_line": 884, "end_line": 897}, {"file_path": "/src/com/google/javascript/rhino/jstype/FunctionType.java", "method_name": "resolveInternal", "content": "  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }", "javadoc_start_line": 862, "annotations_start_line": 861, "method_start_line": 862, "end_line": 903}]}], "project": {"name": "Closure", "version": 90}}