{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testIssue1144", "error": "java.lang.IllegalStateException", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "visit", "content": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n      }\n\n      if (t.getScopeDepth() < 2) {\n        return;\n      }\n\n      int type = n.getType();\n      Var aliasVar = null;\n      if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n          aliasVar = lexicalVar;\n        }\n      }\n\n      // Validate the top-level of the goog.scope block.\n      if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n          if (aliasVar.getNode() == n) {\n            aliasDefinitionsInOrder.add(n);\n\n            // Return early, to ensure that we don't record a definition\n            // twice.\n            return;\n          } else {\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n          }\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      // Validate all descendent scopes of the goog.scope block.\n      if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n          // Note, to support the transitive case, it's important we don't\n          // clone aliasedNode here.  For example,\n          // var g = goog; var d = g.dom; d.createElement('DIV');\n          // The node in aliasedNode (which is \"g\") will be replaced in the\n          // changes pass above with \"goog\".  If we cloned here, we'd end up\n          // with <code>g.dom.createElement('DIV')</code>.\n          aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }", "javadoc_start_line": 523, "annotations_start_line": 522, "method_start_line": 523, "end_line": 589}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }", "javadoc_start_line": 127, "annotations_start_line": 126, "method_start_line": 127, "end_line": 129}, {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "hotSwapScript", "content": "  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      List<AliasUsage> aliasWorkQueue =\n          Lists.newArrayList(traversal.getAliasUsages());\n      while (!aliasWorkQueue.isEmpty()) {\n        List<AliasUsage> newQueue = Lists.newArrayList();\n        for (AliasUsage aliasUsage : aliasWorkQueue) {\n          if (aliasUsage.referencesOtherAlias()) {\n            newQueue.add(aliasUsage);\n          } else {\n            aliasUsage.applyAlias();\n          }\n        }\n\n        // Prevent an infinite loop.\n        if (newQueue.size() == aliasWorkQueue.size()) {\n          Var cycleVar = newQueue.get(0).aliasVar;\n          compiler.report(JSError.make(\n              cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));\n          break;\n        } else {\n          aliasWorkQueue = newQueue;\n        }\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }", "javadoc_start_line": 132, "annotations_start_line": 131, "method_start_line": 132, "end_line": 189}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testIssue1144", "error": "java.lang.IllegalStateException", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "exitScope", "content": "    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n      }\n\n      if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n      }\n    }", "javadoc_start_line": 309, "annotations_start_line": 308, "method_start_line": 309, "end_line": 321}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }", "javadoc_start_line": 127, "annotations_start_line": 126, "method_start_line": 127, "end_line": 129}, {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "hotSwapScript", "content": "  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      List<AliasUsage> aliasWorkQueue =\n          Lists.newArrayList(traversal.getAliasUsages());\n      while (!aliasWorkQueue.isEmpty()) {\n        List<AliasUsage> newQueue = Lists.newArrayList();\n        for (AliasUsage aliasUsage : aliasWorkQueue) {\n          if (aliasUsage.referencesOtherAlias()) {\n            newQueue.add(aliasUsage);\n          } else {\n            aliasUsage.applyAlias();\n          }\n        }\n\n        // Prevent an infinite loop.\n        if (newQueue.size() == aliasWorkQueue.size()) {\n          Var cycleVar = newQueue.get(0).aliasVar;\n          compiler.report(JSError.make(\n              cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));\n          break;\n        } else {\n          aliasWorkQueue = newQueue;\n        }\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }", "javadoc_start_line": 132, "annotations_start_line": 131, "method_start_line": 132, "end_line": 189}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "popScope", "content": "  /** Pops back to the previous scope (e.g. when leaving a function). */\n  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n    if (hasScope()) {\n      compiler.setScope(getScopeRoot());\n    }\n  }", "javadoc_start_line": 615, "annotations_start_line": 616, "method_start_line": 616, "end_line": 629}]}, {"failing_test": {"className": " com.google.javascript.jscomp.ScopedAliasesTest", "methodName": "testIssue1144", "error": "java.lang.IllegalStateException", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "findAliases", "content": "    private void findAliases(NodeTraversal t) {\n      Scope scope = t.getScope();\n      for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n          recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n          // Bleeding functions already get a BAD_PARAMETERS error, so just\n          // do nothing.\n        } else if (parent.getType() == Token.LP) {\n          // Parameters of the scope function also get a BAD_PARAMETERS\n          // error.\n        } else if (isVar || isFunctionDecl) {\n          boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n          Node grandparent = parent.getParent();\n          Node value = v.getInitialValue() != null ?\n              v.getInitialValue() :\n              null;\n          Node varNode = null;\n\n          String name = n.getString();\n          int nameCount = scopedAliasNames.count(name);\n          scopedAliasNames.add(name);\n          String globalName =\n              \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n\n          compiler.ensureLibraryInjected(\"base\");\n\n          // First, we need to free up the function expression (EXPR)\n          // to be used in another expression.\n          if (isFunctionDecl) {\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            Node existingName = v.getNameNode();\n\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n            value.replaceChild(existingName, newName);\n\n            varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n            grandparent.replaceChild(parent, varNode);\n          } else {\n            if (value != null) {\n              // If this is a VAR, we can just detach the expression and\n              // the tree will still be valid.\n              value.detachFromParent();\n            }\n            varNode = parent;\n          }\n\n          // Add $jscomp.scope.name = EXPR;\n          // Make sure we copy over all the jsdoc and debug info.\n          if (value != null || v.getJSDocInfo() != null) {\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                compiler.getCodingConvention(),\n                globalName,\n                value,\n                v.getJSDocInfo())\n                .useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(\n                newDecl.getFirstChild().getFirstChild(), n, name);\n\n            if (isHoisted) {\n              grandparent.addChildToFront(newDecl);\n            } else {\n              grandparent.addChildBefore(newDecl, varNode);\n            }\n          }\n\n          // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n          v.getNameNode().addChildToFront(\n              NodeUtil.newQualifiedNameNode(\n                  compiler.getCodingConvention(), globalName, n, name));\n\n          recordAlias(v);\n        } else {\n          // Do not other kinds of local symbols, like catch params.\n          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n      }\n    }", "javadoc_start_line": 357, "annotations_start_line": 357, "method_start_line": 357, "end_line": 445}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }", "javadoc_start_line": 127, "annotations_start_line": 126, "method_start_line": 127, "end_line": 129}, {"file_path": "/src/com/google/javascript/jscomp/ScopedAliases.java", "method_name": "hotSwapScript", "content": "  public void hotSwapScript(Node root, Node originalRoot) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      List<AliasUsage> aliasWorkQueue =\n          Lists.newArrayList(traversal.getAliasUsages());\n      while (!aliasWorkQueue.isEmpty()) {\n        List<AliasUsage> newQueue = Lists.newArrayList();\n        for (AliasUsage aliasUsage : aliasWorkQueue) {\n          if (aliasUsage.referencesOtherAlias()) {\n            newQueue.add(aliasUsage);\n          } else {\n            aliasUsage.applyAlias();\n          }\n        }\n\n        // Prevent an infinite loop.\n        if (newQueue.size() == aliasWorkQueue.size()) {\n          Var cycleVar = newQueue.get(0).aliasVar;\n          compiler.report(JSError.make(\n              cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));\n          break;\n        } else {\n          aliasWorkQueue = newQueue;\n        }\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\n        if (aliasDefinition.getParent().isVar() &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }", "javadoc_start_line": 132, "annotations_start_line": 131, "method_start_line": 132, "end_line": 189}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 488, "annotations_start_line": 491, "method_start_line": 492, "end_line": 495}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      // null parent ensures that the shallow callbacks will traverse root\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 277, "annotations_start_line": 280, "method_start_line": 280, "end_line": 292}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseBranch", "content": "  /**\n   * Traverses a branch.\n   */\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) {\n      return;\n    }\n\n    if (type == Token.FUNCTION) {\n      traverseFunction(n, parent);\n    } else {\n      for (Node child = n.getFirstChild(); child != null; ) {\n        // child could be replaced, in which case our child node\n        // would no longer point to the true next\n        Node next = child.getNext();\n        traverseBranch(child, n);\n        child = next;\n      }\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }", "javadoc_start_line": 512, "annotations_start_line": 515, "method_start_line": 515, "end_line": 541}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverseFunction", "content": "  /** Traverses a function. */\n  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock(), body);\n    traverseBranch(body, n);\n\n    popScope();\n  }", "javadoc_start_line": 543, "annotations_start_line": 544, "method_start_line": 544, "end_line": 577}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "pushScope", "content": "  /** Creates a new scope (e.g. when entering a function). */\n  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    compiler.setScope(node);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }", "javadoc_start_line": 593, "annotations_start_line": 594, "method_start_line": 594, "end_line": 602}]}], "project": {"name": "Closure", "version": 108}}