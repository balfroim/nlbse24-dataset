{"tours": [{"failing_test": {"className": " com.google.javascript.jscomp.InlineVariablesTest", "methodName": "testNoInlineAliasesInLoop", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "BasicBlock", "content": "    /**\n     * Whether this block denotes a function scope.\n     */\n\n    /**\n     * Whether this block denotes a loop.\n     */\n\n    /**\n     * Creates a new block.\n     * @param parent The containing block.\n     * @param root The root node of the block.\n     */\n    BasicBlock(BasicBlock parent, Node root) {\n      this.parent = parent;\n\n      // only named functions may be hoisted.\n      this.isHoisted = NodeUtil.isHoistedFunctionDeclaration(root);\n\n\n    }", "javadoc_start_line": 542, "annotations_start_line": 555, "method_start_line": 555, "end_line": 562}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Closure/98/results/stacktrace-testNoInlineAliasesInLoop-BasicBlock.csv'"}}, {"failing_test": {"className": " com.google.javascript.jscomp.InlineVariablesTest", "methodName": "testNoInlineAliasesInLoop", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "isAssignedOnceInLifetime", "content": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      // Make sure this assignment is not in a loop.\n\n      return true;\n    }", "javadoc_start_line": 350, "annotations_start_line": 354, "method_start_line": 354, "end_line": 363}, "steps": [{"file_path": "/src/com/google/javascript/jscomp/InlineVariables.java", "method_name": "process", "content": "  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n    callback.process(externs, root);\n  }", "javadoc_start_line": 84, "annotations_start_line": 83, "method_start_line": 84, "end_line": 88}, {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "process", "content": "  /**\n   * Convenience method for running this pass over a tree with this\n   * class as a callback.\n   */\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }", "javadoc_start_line": 95, "annotations_start_line": 99, "method_start_line": 99, "end_line": 101}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a node recursively.\n   */\n  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }", "javadoc_start_line": 420, "annotations_start_line": 423, "method_start_line": 424, "end_line": 427}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "traverse", "content": "  /**\n   * Traverses a parse tree recursively.\n   */\n  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }", "javadoc_start_line": 245, "annotations_start_line": 248, "method_start_line": 248, "end_line": 258}, {"file_path": "/src/com/google/javascript/jscomp/NodeTraversal.java", "method_name": "popScope", "content": "  /** Pops back to the previous scope (e.g. when leaving a function). */\n  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }", "javadoc_start_line": 554, "annotations_start_line": 555, "method_start_line": 555, "end_line": 565}, {"file_path": "/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java", "method_name": "exitScope", "content": "  /**\n   * Updates block statck and invokes any additional behavior.\n   */\n  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    behavior.afterExitScope(t, referenceMap);\n  }", "javadoc_start_line": 137, "annotations_start_line": 140, "method_start_line": 140, "end_line": 143}]}], "project": {"name": "Closure", "version": 98}}