{"tours": [{"failing_test": {"className": " org.apache.commons.lang3.StringEscapeUtilsTest", "methodName": "testLang720", "error": "junit.framework.ComparisonFailure", "message": "expected:<\ud842\udfb7[A]> but was:<\ud842\udfb7[?]>"}, "patched_method": {"file_path": "/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java", "method_name": "translate", "content": "    /**\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \n     * tightly coupled with the abstract method of this class. \n     *\n     * @param input CharSequence that is being translated\n     * @param out Writer to translate the text to\n     * @throws IOException if and only if the Writer produces an IOException\n     */\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = Character.codePointCount(input, 0, input.length());\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n            }\n            else {\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                    if (pos < len - 2) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n                    } else {\n                        pos++;\n                    }\n                }\n                pos--;\n            }\n            pos++;\n        }\n    }", "javadoc_start_line": 67, "annotations_start_line": 75, "method_start_line": 75, "end_line": 104}, "steps": [{"file_path": "/src/test/java/org/apache/commons/lang3/StringEscapeUtilsTest.java", "method_name": "testLang720", "content": "    public void testLang720() {\n        String input = new StringBuilder(\"\\ud842\\udfb7\").append(\"A\").toString();\n        String escaped = StringEscapeUtils.escapeXml(input);\n        assertEquals(input, escaped);\n    }", "javadoc_start_line": 428, "annotations_start_line": 428, "method_start_line": 428, "end_line": 432}, {"file_path": "/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java", "method_name": "escapeXml", "content": "    /**\n     * <p>Escapes the characters in a {@code String} using XML entities.</p>\n     *\n     * <p>For example: <tt>\"bread\" & \"butter\"</tt> =>\n     * <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;</tt>.\n     * </p>\n     *\n     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\n     * Does not support DTDs or external entities.</p>\n     *\n     * <p>Note that unicode characters greater than 0x7f are as of 3.0, no longer \n     *    escaped. If you still wish this functionality, you can achieve it \n     *    via the following: \n     * {@code StringEscapeUtils.ESCAPE_XML.with( new UnicodeEscaper(Range.between(0x7f, Integer.MAX_VALUE)) );}</p>\n     *\n     * @param input  the {@code String} to escape, may be null\n     * @return a new escaped {@code String}, {@code null} if null string input\n     * @see #unescapeXml(java.lang.String)\n     */\n    public static final String escapeXml(String input) {\n        return ESCAPE_XML.translate(input);\n    }", "javadoc_start_line": 486, "annotations_start_line": 505, "method_start_line": 505, "end_line": 507}, {"file_path": "/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java", "method_name": "translate", "content": "    /**\n     * Helper for non-Writer usage. \n     * @param input CharSequence to be translated\n     * @return String output of translation\n     */\n    public final String translate(CharSequence input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(input.length() * 2);\n            translate(input, writer);\n            return writer.toString();\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            throw new RuntimeException(ioe);\n        }\n    }", "javadoc_start_line": 48, "annotations_start_line": 53, "method_start_line": 53, "end_line": 65}]}], "project": {"name": "Lang", "version": 17}}