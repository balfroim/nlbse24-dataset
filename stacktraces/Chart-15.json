{"tours": [{"failing_test": {"className": " org.jfree.chart.plot.junit.PiePlot3DTests", "methodName": "testDrawWithNullDataset", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/source/org/jfree/chart/plot/PiePlot.java", "method_name": "initialise", "content": "    /**\n     * Initialises the drawing procedure.  This method will be called before \n     * the first item is rendered, giving the plot an opportunity to initialise\n     * any state information it wants to maintain.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param plot  the plot.\n     * @param index  the secondary index (<code>null</code> for primary \n     *               renderer).\n     * @param info  collects chart rendering information for return to caller.\n     * \n     * @return A state object (maintains state information relevant to one \n     *         chart drawing).\n     */\n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\n     \n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n        \n    }", "javadoc_start_line": 2031, "annotations_start_line": 2046, "method_start_line": 2047, "end_line": 2056}, "steps": [{"file_path": "/source/org/jfree/chart/JFreeChart.java", "method_name": "draw", "content": "    /**\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\n     * printer).\n     * <P>\n     * This method is the focus of the entire JFreeChart library.\n     *\n     * @param g2  the graphics device.\n     * @param chartArea  the area within which the chart should be drawn.\n     * @param anchor  the anchor point (in Java2D space) for the chart \n     *                (<code>null</code> permitted).\n     * @param info  records info about the drawing (null means collect no info).\n     */\n    public void draw(Graphics2D g2, \n                     Rectangle2D chartArea, Point2D anchor, \n                     ChartRenderingInfo info) {\n\n        notifyListeners(new ChartProgressEvent(this, this, \n                ChartProgressEvent.DRAWING_STARTED, 0));\n\n        // record the chart area, if info is requested...\n        if (info != null) {\n            info.clear();\n            info.setChartArea(chartArea);\n        }\n\n        // ensure no drawing occurs outside chart area...\n        Shape savedClip = g2.getClip();\n        g2.clip(chartArea);\n\n        g2.addRenderingHints(this.renderingHints);\n\n        // draw the chart background...\n        if (this.backgroundPaint != null) {\n            g2.setPaint(this.backgroundPaint);\n            g2.fill(chartArea);\n        }\n\n        if (this.backgroundImage != null) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                    this.backgroundImageAlpha));\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, \n                    this.backgroundImage.getWidth(null), \n                    this.backgroundImage.getHeight(null));\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \n                    (int) dest.getY(), (int) dest.getWidth(), \n                    (int) dest.getHeight(), null);\n            g2.setComposite(originalComposite);\n        }\n\n        if (isBorderVisible()) {\n            Paint paint = getBorderPaint();\n            Stroke stroke = getBorderStroke();\n            if (paint != null && stroke != null) {\n                Rectangle2D borderArea = new Rectangle2D.Double(\n                        chartArea.getX(), chartArea.getY(), \n                        chartArea.getWidth() - 1.0, chartArea.getHeight() \n                        - 1.0);\n                g2.setPaint(paint);\n                g2.setStroke(stroke);\n                g2.draw(borderArea);\n            }\n        }\n\n        // draw the title and subtitles...\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\n        nonTitleArea.setRect(chartArea);\n        this.padding.trim(nonTitleArea);\n        \n        EntityCollection entities = null;\n        if (info != null) {\n            entities = info.getEntityCollection();   \n        }\n        if (this.title != null) {\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea, \n                    (entities != null));\n            if (e != null) {\n                entities.addAll(e);   \n            }\n        }\n\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title currentTitle = (Title) iterator.next();\n            EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, \n                    (entities != null));\n            if (e != null) {\n                entities.addAll(e);   \n            }\n        }\n\n        Rectangle2D plotArea = nonTitleArea;\n \n        // draw the plot (axes and data visualisation)\n        PlotRenderingInfo plotInfo = null;\n        if (info != null) {\n            plotInfo = info.getPlotInfo();\n        }\n        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n\n        g2.setClip(savedClip);\n\n        notifyListeners(new ChartProgressEvent(this, this, \n                ChartProgressEvent.DRAWING_FINISHED, 100));\n    }", "javadoc_start_line": 1120, "annotations_start_line": 1132, "method_start_line": 1134, "end_line": 1225}, {"file_path": "/source/org/jfree/chart/plot/PiePlot3D.java", "method_name": "draw", "content": "    /**\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \n     * printer).  This method is called by the \n     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \n     * to call it yourself.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the area within which the plot should be drawn.\n     * @param anchor  the anchor point.\n     * @param parentState  the state from the parent plot, if there is one.\n     * @param info  collects info about the drawing \n     *              (<code>null</code> permitted).\n     */\n    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo info) {\n\n        // adjust for insets...\n        RectangleInsets insets = getInsets();\n        insets.trim(plotArea);\n\n        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\n        if (info != null) {\n            info.setPlotArea(plotArea);\n            info.setDataArea(plotArea);\n        }\n\n        drawBackground(g2, plotArea);\n\n        Shape savedClip = g2.getClip();\n        g2.clip(plotArea);\n\n        // adjust the plot area by the interior spacing value\n        double gapPercent = getInteriorGap();\n        double labelPercent = 0.0;\n        if (getLabelGenerator() != null) {\n            labelPercent = getLabelGap() + getMaximumLabelWidth();   \n        }\n        double gapHorizontal = plotArea.getWidth() * (gapPercent \n                + labelPercent) * 2.0;\n        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\n\n        if (DEBUG_DRAW_INTERIOR) {\n            double hGap = plotArea.getWidth() * getInteriorGap();\n            double vGap = plotArea.getHeight() * getInteriorGap();\n            double igx1 = plotArea.getX() + hGap;\n            double igx2 = plotArea.getMaxX() - hGap;\n            double igy1 = plotArea.getY() + vGap;\n            double igy2 = plotArea.getMaxY() - vGap;\n            g2.setPaint(Color.lightGray);\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \n                    igy2 - igy1));\n        }\n\n        double linkX = plotArea.getX() + gapHorizontal / 2;\n        double linkY = plotArea.getY() + gapVertical / 2;\n        double linkW = plotArea.getWidth() - gapHorizontal;\n        double linkH = plotArea.getHeight() - gapVertical;\n        \n        // make the link area a square if the pie chart is to be circular...\n        if (isCircular()) { // is circular?\n            double min = Math.min(linkW, linkH) / 2;\n            linkX = (linkX + linkX + linkW) / 2 - min;\n            linkY = (linkY + linkY + linkH) / 2 - min;\n            linkW = 2 * min;\n            linkH = 2 * min;\n        }\n        \n        PiePlotState state = initialise(g2, plotArea, this, null, info);\n\n        // the link area defines the dog leg points for the linking lines to \n        // the labels\n        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \n                linkH * (1 - this.depthFactor));\n        state.setLinkArea(linkAreaXX);\n\n        if (DEBUG_DRAW_LINK_AREA) {\n            g2.setPaint(Color.blue);\n            g2.draw(linkAreaXX);\n            g2.setPaint(Color.yellow);\n            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \n                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\n        }\n        \n        // the explode area defines the max circle/ellipse for the exploded pie \n        // sections.\n        // it is defined by shrinking the linkArea by the linkMargin factor.\n        double hh = linkW * getLabelLinkMargin();\n        double vv = linkH * getLabelLinkMargin();\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh / 2.0, \n                linkY + vv / 2.0, linkW - hh, linkH - vv);\n       \n        state.setExplodedPieArea(explodeArea);\n        \n        // the pie area defines the circle/ellipse for regular pie sections.\n        // it is defined by shrinking the explodeArea by the explodeMargin \n        // factor. \n        double maximumExplodePercent = getMaximumExplodePercent();\n        double percent = maximumExplodePercent / (1.0 + maximumExplodePercent);\n        \n        double h1 = explodeArea.getWidth() * percent;\n        double v1 = explodeArea.getHeight() * percent;\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \n                + h1 / 2.0, explodeArea.getY() + v1 / 2.0,\n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\n\n        // the link area defines the dog-leg point for the linking lines to \n        // the labels\n        int depth = (int) (pieArea.getHeight() * this.depthFactor);\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \n                linkH - depth);\n        state.setLinkArea(linkArea);   \n\n        state.setPieArea(pieArea);\n        state.setPieCenterX(pieArea.getCenterX());\n        state.setPieCenterY(pieArea.getCenterY() - depth / 2.0);\n        state.setPieWRadius(pieArea.getWidth() / 2.0);\n        state.setPieHRadius((pieArea.getHeight() - depth) / 2.0);\n\n        // get the data source - return if null;\n        PieDataset dataset = getDataset();\n        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\n            drawNoDataMessage(g2, plotArea);\n            g2.setClip(savedClip);\n            drawOutline(g2, plotArea);\n            return;\n        }\n\n        // if too any elements\n        if (dataset.getKeys().size() > plotArea.getWidth()) {\n            String text = \"Too many elements\";\n            Font sfont = new Font(\"dialog\", Font.BOLD, 10);\n            g2.setFont(sfont);\n            FontMetrics fm = g2.getFontMetrics(sfont);\n            int stringWidth = fm.stringWidth(text);\n\n            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \n                    - stringWidth) / 2), (int) (plotArea.getY() \n                    + (plotArea.getHeight() / 2)));\n            return;\n        }\n        // if we are drawing a perfect circle, we need to readjust the top left\n        // coordinates of the drawing area for the arcs to arrive at this\n        // effect.\n        if (isCircular()) {\n            double min = Math.min(plotArea.getWidth(), \n                    plotArea.getHeight()) / 2;\n            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \n                    plotArea.getCenterY() - min, 2 * min, 2 * min);\n        }\n        // get a list of keys...\n        List sectionKeys = dataset.getKeys();\n\n        if (sectionKeys.size() == 0) {\n            return;\n        }\n\n        // establish the coordinates of the top left corner of the drawing area\n        double arcX = pieArea.getX();\n        double arcY = pieArea.getY();\n\n        //g2.clip(clipArea);\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                getForegroundAlpha()));\n\n        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\n        double runningTotal = 0;\n        if (depth < 0) {\n            return;  // if depth is negative don't draw anything\n        }\n\n        ArrayList arcList = new ArrayList();\n        Arc2D.Double arc;\n        Paint paint;\n        Paint outlinePaint;\n        Stroke outlineStroke;\n\n        Iterator iterator = sectionKeys.iterator();\n        while (iterator.hasNext()) {\n\n            Comparable currentKey = (Comparable) iterator.next();\n            Number dataValue = dataset.getValue(currentKey);\n            if (dataValue == null) {\n                arcList.add(null);\n                continue;\n            }\n            double value = dataValue.doubleValue();\n            if (value <= 0) {\n                arcList.add(null);\n                continue;\n            }\n            double startAngle = getStartAngle();\n            double direction = getDirection().getFactor();\n            double angle1 = startAngle + (direction * (runningTotal * 360)) \n                    / totalValue;\n            double angle2 = startAngle + (direction * (runningTotal + value) \n                    * 360) / totalValue;\n            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\n                arcList.add(new Arc2D.Double(arcX, arcY + depth, \n                        pieArea.getWidth(), pieArea.getHeight() - depth,\n                        angle1, angle2 - angle1, Arc2D.PIE));\n            }\n            else {\n                arcList.add(null);\n            }\n            runningTotal += value;\n        }\n\n        Shape oldClip = g2.getClip();\n\n        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \n                pieArea.getWidth(), pieArea.getHeight() - depth);\n\n        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \n                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\n\n        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \n                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \n                - top.getCenterY());\n\n        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \n                pieArea.getWidth(), bottom.getCenterY() - top.getY());\n\n        Area a = new Area(top);\n        a.add(new Area(lower));\n        Area b = new Area(bottom);\n        b.add(new Area(upper));\n        Area pie = new Area(a);\n        pie.intersect(b);\n\n        Area front = new Area(pie);\n        front.subtract(new Area(top));\n\n        Area back = new Area(pie);\n        back.subtract(new Area(bottom));\n\n        // draw the bottom circle\n        int[] xs;\n        int[] ys;\n        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \n                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\n\n        int categoryCount = arcList.size();\n        for (int categoryIndex = 0; categoryIndex < categoryCount; \n                 categoryIndex++) {\n            arc = (Arc2D.Double) arcList.get(categoryIndex);\n            if (arc == null) {\n                continue;\n            }\n            Comparable key = getSectionKey(categoryIndex);\n            paint = lookupSectionPaint(key, true);\n            outlinePaint = lookupSectionOutlinePaint(key);\n            outlineStroke = lookupSectionOutlineStroke(key);\n            g2.setPaint(paint);\n            g2.fill(arc);\n            g2.setPaint(outlinePaint);\n            g2.setStroke(outlineStroke);\n            g2.draw(arc);\n            g2.setPaint(paint);\n\n            Point2D p1 = arc.getStartPoint();\n\n            // draw the height\n            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\n                    (int) p1.getX(), (int) p1.getX()};\n            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \n                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\n            Polygon polygon = new Polygon(xs, ys, 4);\n            g2.setPaint(java.awt.Color.lightGray);\n            g2.fill(polygon);\n            g2.setPaint(outlinePaint);\n            g2.setStroke(outlineStroke);\n            g2.draw(polygon);\n            g2.setPaint(paint);\n\n        }\n\n        g2.setPaint(Color.gray);\n        g2.fill(back);\n        g2.fill(front);\n\n        // cycle through once drawing only the sides at the back...\n        int cat = 0;\n        iterator = arcList.iterator();\n        while (iterator.hasNext()) {\n            Arc2D segment = (Arc2D) iterator.next();\n            if (segment != null) {\n                Comparable key = getSectionKey(cat);\n                paint = lookupSectionPaint(key, true);\n                outlinePaint = lookupSectionOutlinePaint(key);\n                outlineStroke = lookupSectionOutlineStroke(key);\n                drawSide(g2, pieArea, segment, front, back, paint, \n                        outlinePaint, outlineStroke, false, true);\n            }\n            cat++;\n        }\n\n        // cycle through again drawing only the sides at the front...\n        cat = 0;\n        iterator = arcList.iterator();\n        while (iterator.hasNext()) {\n            Arc2D segment = (Arc2D) iterator.next();\n            if (segment != null) {\n                Comparable key = getSectionKey(cat);\n                paint = lookupSectionPaint(key);\n                outlinePaint = lookupSectionOutlinePaint(key);\n                outlineStroke = lookupSectionOutlineStroke(key);\n                drawSide(g2, pieArea, segment, front, back, paint, \n                        outlinePaint, outlineStroke, true, false);\n            }\n            cat++;\n        }\n\n        g2.setClip(oldClip);\n\n        // draw the sections at the top of the pie (and set up tooltips)...\n        Arc2D upperArc;\n        for (int sectionIndex = 0; sectionIndex < categoryCount; \n                 sectionIndex++) {\n            arc = (Arc2D.Double) arcList.get(sectionIndex);\n            if (arc == null) {\n                continue;\n            }\n            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\n                    pieArea.getHeight() - depth, arc.getAngleStart(), \n                    arc.getAngleExtent(), Arc2D.PIE);\n            \n            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\n            paint = lookupSectionPaint(currentKey, true);\n            outlinePaint = lookupSectionOutlinePaint(currentKey);\n            outlineStroke = lookupSectionOutlineStroke(currentKey);\n            g2.setPaint(paint);\n            g2.fill(upperArc);\n            g2.setStroke(outlineStroke);\n            g2.setPaint(outlinePaint);\n            g2.draw(upperArc);\n\n           // add a tooltip for the section...\n            if (info != null) {\n                EntityCollection entities \n                        = info.getOwner().getEntityCollection();\n                if (entities != null) {\n                    String tip = null;\n                    PieToolTipGenerator tipster = getToolTipGenerator();\n                    if (tipster != null) {\n                        // @mgs: using the method's return value was missing \n                        tip = tipster.generateToolTip(dataset, currentKey);\n                    }\n                    String url = null;\n                    if (getURLGenerator() != null) {\n                        url = getURLGenerator().generateURL(dataset, currentKey,\n                                getPieIndex());\n                    }\n                    PieSectionEntity entity = new PieSectionEntity(\n                            upperArc, dataset, getPieIndex(), sectionIndex, \n                            currentKey, tip, url);\n                    entities.add(entity);\n                }\n            }\n            List keys = dataset.getKeys();\n            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\n                    originalPlotArea.getX(), originalPlotArea.getY(), \n                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \n                    - depth);\n            if (getSimpleLabels()) {\n                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \n                        linkArea, state);\n            }\n            else {\n                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \n                        state);\n            }\n        }\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n        drawOutline(g2, originalPlotArea);\n\n    }", "javadoc_start_line": 212, "annotations_start_line": 225, "method_start_line": 227, "end_line": 591}, {"file_path": "/source/org/jfree/chart/plot/PiePlot.java", "method_name": "initialise", "content": "    /**\n     * Initialises the drawing procedure.  This method will be called before \n     * the first item is rendered, giving the plot an opportunity to initialise\n     * any state information it wants to maintain.\n     *\n     * @param g2  the graphics device.\n     * @param plotArea  the plot area (<code>null</code> not permitted).\n     * @param plot  the plot.\n     * @param index  the secondary index (<code>null</code> for primary \n     *               renderer).\n     * @param info  collects chart rendering information for return to caller.\n     * \n     * @return A state object (maintains state information relevant to one \n     *         chart drawing).\n     */\n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\n     \n        PiePlotState state = new PiePlotState(info);\n        state.setPassesRequired(2);\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n                    plot.getDataset()));\n        state.setLatestAngle(plot.getStartAngle());\n        return state;\n        \n    }", "javadoc_start_line": 2031, "annotations_start_line": 2046, "method_start_line": 2047, "end_line": 2056}]}, {"failing_test": {"className": " org.jfree.chart.plot.junit.PiePlot3DTests", "methodName": "testDrawWithNullDataset", "error": "junit.framework.AssertionFailedError", "message": ""}, "patched_method": {"file_path": "/source/org/jfree/chart/plot/PiePlot.java", "method_name": "getMaximumExplodePercent", "content": "    /**\n     * Returns the maximum explode percent.\n     * \n     * @return The percent.\n     */\n    public double getMaximumExplodePercent() {\n        double result = 0.0;\n        Iterator iterator = this.dataset.getKeys().iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Number explode = (Number) this.explodePercentages.get(key);\n            if (explode != null) {\n                result = Math.max(result, explode.doubleValue());   \n            }\n        }\n        return result;\n    }", "javadoc_start_line": 1372, "annotations_start_line": 1377, "method_start_line": 1377, "end_line": 1388}, "steps": [], "generation_failure": {"error": "Failed to generate stacktrace", "error_message": "[Errno 2] No such file or directory: './projects/Chart/15/results/stacktrace-testDrawWithNullDataset-getMaximumExplodePercent.csv'"}}], "project": {"name": "Chart", "version": 15}}