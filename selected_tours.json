[{"name":"Chart","version":4,"tour_id":0,"test":"{\"className\": \" org.jfree.chart.axis.junit.LogAxisTests\", \"methodName\": \"testXYAutoRange1\", \"error\": \"java.lang.NullPointerException\", \"message\": \"\"}","method":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/XYPlot.java\", \"method_name\": \"getDataRange\", \"content\": \"    \/**\\n     * Returns the range for the specified axis.\\n     *\\n     * @param axis  the axis.\\n     *\\n     * @return The range.\\n     *\/\\n    public Range getDataRange(ValueAxis axis) {\\n\\n        Range result = null;\\n        List mappedDatasets = new ArrayList();\\n        List includedAnnotations = new ArrayList();\\n        boolean isDomainAxis = true;\\n\\n        \/\/ is it a domain axis?\\n        int domainIndex = getDomainAxisIndex(axis);\\n        if (domainIndex >= 0) {\\n            isDomainAxis = true;\\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\\n                    new Integer(domainIndex)));\\n            if (domainIndex == 0) {\\n                \/\/ grab the plot's annotations\\n                Iterator iterator = this.annotations.iterator();\\n                while (iterator.hasNext()) {\\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\\n                        includedAnnotations.add(annotation);\\n                    }\\n                }\\n            }\\n        }\\n\\n        \/\/ or is it a range axis?\\n        int rangeIndex = getRangeAxisIndex(axis);\\n        if (rangeIndex >= 0) {\\n            isDomainAxis = false;\\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\\n                    new Integer(rangeIndex)));\\n            if (rangeIndex == 0) {\\n                Iterator iterator = this.annotations.iterator();\\n                while (iterator.hasNext()) {\\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\\n                        includedAnnotations.add(annotation);\\n                    }\\n                }\\n            }\\n        }\\n\\n        \/\/ iterate through the datasets that map to the axis and get the union\\n        \/\/ of the ranges.\\n        Iterator iterator = mappedDatasets.iterator();\\n        while (iterator.hasNext()) {\\n            XYDataset d = (XYDataset) iterator.next();\\n            if (d != null) {\\n                XYItemRenderer r = getRendererForDataset(d);\\n                if (isDomainAxis) {\\n                    if (r != null) {\\n                        result = Range.combine(result, r.findDomainBounds(d));\\n                    }\\n                    else {\\n                        result = Range.combine(result,\\n                                DatasetUtilities.findDomainBounds(d));\\n                    }\\n                }\\n                else {\\n                    if (r != null) {\\n                        result = Range.combine(result, r.findRangeBounds(d));\\n                    }\\n                    else {\\n                        result = Range.combine(result,\\n                                DatasetUtilities.findRangeBounds(d));\\n                    }\\n                }\\n                \\n                    Collection c = r.getAnnotations();\\n                    Iterator i = c.iterator();\\n                    while (i.hasNext()) {\\n                        XYAnnotation a = (XYAnnotation) i.next();\\n                        if (a instanceof XYAnnotationBoundsInfo) {\\n                            includedAnnotations.add(a);\\n                        }\\n                    }\\n            }\\n        }\\n\\n        Iterator it = includedAnnotations.iterator();\\n        while (it.hasNext()) {\\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\\n            if (xyabi.getIncludeInDataBounds()) {\\n                if (isDomainAxis) {\\n                    result = Range.combine(result, xyabi.getXRange());\\n                }\\n                else {\\n                    result = Range.combine(result, xyabi.getYRange());\\n                }\\n            }\\n        }\\n\\n        return result;\\n\\n    }\", \"javadoc_start_line\": 4418, \"annotations_start_line\": 4425, \"method_start_line\": 4425, \"end_line\": 4519}","steps":[{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/ChartFactory.java\", \"method_name\": \"createScatterPlot\", \"content\": \"    \/**\\n     * Creates a scatter plot with default settings.  The chart object\\n     * returned by this method uses an {@link XYPlot} instance as the plot,\\n     * with a {@link NumberAxis} for the domain axis, a  {@link NumberAxis}\\n     * as the range axis, and an {@link XYLineAndShapeRenderer} as the\\n     * renderer.\\n     *\\n     * @param title  the chart title (<code>null<\/code> permitted).\\n     * @param xAxisLabel  a label for the X-axis (<code>null<\/code> permitted).\\n     * @param yAxisLabel  a label for the Y-axis (<code>null<\/code> permitted).\\n     * @param dataset  the dataset for the chart (<code>null<\/code> permitted).\\n     * @param orientation  the plot orientation (horizontal or vertical)\\n     *                     (<code>null<\/code> NOT permitted).\\n     * @param legend  a flag specifying whether or not a legend is required.\\n     * @param tooltips  configure chart to generate tool tips?\\n     * @param urls  configure chart to generate URLs?\\n     *\\n     * @return A scatter plot.\\n     *\/\\n    public static JFreeChart createScatterPlot(String title, String xAxisLabel,\\n            String yAxisLabel, XYDataset dataset, PlotOrientation orientation,\\n            boolean legend, boolean tooltips, boolean urls) {\\n\\n        if (orientation == null) {\\n            throw new IllegalArgumentException(\\\"Null 'orientation' argument.\\\");\\n        }\\n        NumberAxis xAxis = new NumberAxis(xAxisLabel);\\n        xAxis.setAutoRangeIncludesZero(false);\\n        NumberAxis yAxis = new NumberAxis(yAxisLabel);\\n        yAxis.setAutoRangeIncludesZero(false);\\n\\n        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, null);\\n\\n        XYToolTipGenerator toolTipGenerator = null;\\n        if (tooltips) {\\n            toolTipGenerator = new StandardXYToolTipGenerator();\\n        }\\n\\n        XYURLGenerator urlGenerator = null;\\n        if (urls) {\\n            urlGenerator = new StandardXYURLGenerator();\\n        }\\n        XYItemRenderer renderer = new XYLineAndShapeRenderer(false, true);\\n        renderer.setBaseToolTipGenerator(toolTipGenerator);\\n        renderer.setBaseURLGenerator(urlGenerator);\\n        plot.setRenderer(renderer);\\n        plot.setOrientation(orientation);\\n\\n        JFreeChart chart = new JFreeChart(title, JFreeChart.DEFAULT_TITLE_FONT,\\n                plot, legend);\\n        currentTheme.apply(chart);\\n        return chart;\\n\\n    }\", \"javadoc_start_line\": 1459, \"annotations_start_line\": 1478, \"method_start_line\": 1480, \"end_line\": 1512}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/XYPlot.java\", \"method_name\": \"XYPlot\", \"content\": \"    \/**\\n     * Creates a new plot with the specified dataset, axes and renderer.  Any\\n     * of the arguments can be <code>null<\/code>, but in that case you should\\n     * take care to specify the value before using the plot (otherwise a\\n     * <code>NullPointerException<\/code> may be thrown).\\n     *\\n     * @param dataset  the dataset (<code>null<\/code> permitted).\\n     * @param domainAxis  the domain axis (<code>null<\/code> permitted).\\n     * @param rangeAxis  the range axis (<code>null<\/code> permitted).\\n     * @param renderer  the renderer (<code>null<\/code> permitted).\\n     *\/\\n    public XYPlot(XYDataset dataset,\\n                  ValueAxis domainAxis,\\n                  ValueAxis rangeAxis,\\n                  XYItemRenderer renderer) {\\n\\n        super();\\n\\n        this.orientation = PlotOrientation.VERTICAL;\\n        this.weight = 1;  \/\/ only relevant when this is a subplot\\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\\n\\n        \/\/ allocate storage for datasets, axes and renderers (all optional)\\n        this.domainAxes = new ObjectList();\\n        this.domainAxisLocations = new ObjectList();\\n        this.foregroundDomainMarkers = new HashMap();\\n        this.backgroundDomainMarkers = new HashMap();\\n\\n        this.rangeAxes = new ObjectList();\\n        this.rangeAxisLocations = new ObjectList();\\n        this.foregroundRangeMarkers = new HashMap();\\n        this.backgroundRangeMarkers = new HashMap();\\n\\n        this.datasets = new ObjectList();\\n        this.renderers = new ObjectList();\\n\\n        this.datasetToDomainAxesMap = new TreeMap();\\n        this.datasetToRangeAxesMap = new TreeMap();\\n\\n        this.annotations = new java.util.ArrayList();\\n\\n        this.datasets.set(0, dataset);\\n        if (dataset != null) {\\n            dataset.addChangeListener(this);\\n        }\\n\\n        this.renderers.set(0, renderer);\\n        if (renderer != null) {\\n            renderer.setPlot(this);\\n            renderer.addChangeListener(this);\\n        }\\n\\n        this.domainAxes.set(0, domainAxis);\\n        this.mapDatasetToDomainAxis(0, 0);\\n        if (domainAxis != null) {\\n            domainAxis.setPlot(this);\\n            domainAxis.addChangeListener(this);\\n        }\\n        this.domainAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\\n\\n        this.rangeAxes.set(0, rangeAxis);\\n        this.mapDatasetToRangeAxis(0, 0);\\n        if (rangeAxis != null) {\\n            rangeAxis.setPlot(this);\\n            rangeAxis.addChangeListener(this);\\n        }\\n        this.rangeAxisLocations.set(0, AxisLocation.BOTTOM_OR_LEFT);\\n\\n        configureDomainAxes();\\n        configureRangeAxes();\\n\\n        this.domainGridlinesVisible = true;\\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\\n\\n        this.domainMinorGridlinesVisible = false;\\n        this.domainMinorGridlineStroke = DEFAULT_GRIDLINE_STROKE;\\n        this.domainMinorGridlinePaint = Color.white;\\n\\n        this.domainZeroBaselineVisible = false;\\n        this.domainZeroBaselinePaint = Color.black;\\n        this.domainZeroBaselineStroke = new BasicStroke(0.5f);\\n\\n        this.rangeGridlinesVisible = true;\\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\\n\\n        this.rangeMinorGridlinesVisible = false;\\n        this.rangeMinorGridlineStroke = DEFAULT_GRIDLINE_STROKE;\\n        this.rangeMinorGridlinePaint = Color.white;\\n\\n        this.rangeZeroBaselineVisible = false;\\n        this.rangeZeroBaselinePaint = Color.black;\\n        this.rangeZeroBaselineStroke = new BasicStroke(0.5f);\\n\\n        this.domainCrosshairVisible = false;\\n        this.domainCrosshairValue = 0.0;\\n        this.domainCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\\n        this.domainCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\\n\\n        this.rangeCrosshairVisible = false;\\n        this.rangeCrosshairValue = 0.0;\\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\\n\\n    }\", \"javadoc_start_line\": 605, \"annotations_start_line\": 616, \"method_start_line\": 619, \"end_line\": 710}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/axis\/Axis.java\", \"method_name\": \"setPlot\", \"content\": \"    \/**\\n     * Sets a reference to the plot that the axis is assigned to.\\n     * <P>\\n     * This method is used internally, you shouldn't need to call it yourself.\\n     *\\n     * @param plot  the plot.\\n     *\\n     * @see #getPlot()\\n     *\/\\n    public void setPlot(Plot plot) {\\n        this.plot = plot;\\n        configure();\\n    }\", \"javadoc_start_line\": 1033, \"annotations_start_line\": 1042, \"method_start_line\": 1042, \"end_line\": 1045}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/axis\/NumberAxis.java\", \"method_name\": \"configure\", \"content\": \"    \/**\\n     * Configures the axis to work with the specified plot.  If the axis has\\n     * auto-scaling, then sets the maximum and minimum values.\\n     *\/\\n    public void configure() {\\n        if (isAutoRange()) {\\n            autoAdjustRange();\\n        }\\n    }\", \"javadoc_start_line\": 411, \"annotations_start_line\": 415, \"method_start_line\": 415, \"end_line\": 419}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/axis\/NumberAxis.java\", \"method_name\": \"autoAdjustRange\", \"content\": \"    \/**\\n     * Rescales the axis to ensure that all data is visible.\\n     *\/\\n    protected void autoAdjustRange() {\\n\\n        Plot plot = getPlot();\\n        if (plot == null) {\\n            return;  \/\/ no plot, no data\\n        }\\n\\n        if (plot instanceof ValueAxisPlot) {\\n            ValueAxisPlot vap = (ValueAxisPlot) plot;\\n\\n            Range r = vap.getDataRange(this);\\n            if (r == null) {\\n                r = getDefaultAutoRange();\\n            }\\n\\n            double upper = r.getUpperBound();\\n            double lower = r.getLowerBound();\\n            if (this.rangeType == RangeType.POSITIVE) {\\n                lower = Math.max(0.0, lower);\\n                upper = Math.max(0.0, upper);\\n            }\\n            else if (this.rangeType == RangeType.NEGATIVE) {\\n                lower = Math.min(0.0, lower);\\n                upper = Math.min(0.0, upper);\\n            }\\n\\n            if (getAutoRangeIncludesZero()) {\\n                lower = Math.min(lower, 0.0);\\n                upper = Math.max(upper, 0.0);\\n            }\\n            double range = upper - lower;\\n\\n            \/\/ if fixed auto range, then derive lower bound...\\n            double fixedAutoRange = getFixedAutoRange();\\n            if (fixedAutoRange > 0.0) {\\n                lower = upper - fixedAutoRange;\\n            }\\n            else {\\n                \/\/ ensure the autorange is at least <minRange> in size...\\n                double minRange = getAutoRangeMinimumSize();\\n                if (range < minRange) {\\n                    double expand = (minRange - range) \/ 2;\\n                    upper = upper + expand;\\n                    lower = lower - expand;\\n                    if (lower == upper) { \/\/ see bug report 1549218\\n                        double adjust = Math.abs(lower) \/ 10.0;\\n                        lower = lower - adjust;\\n                        upper = upper + adjust;\\n                    }\\n                    if (this.rangeType == RangeType.POSITIVE) {\\n                        if (lower < 0.0) {\\n                            upper = upper - lower;\\n                            lower = 0.0;\\n                        }\\n                    }\\n                    else if (this.rangeType == RangeType.NEGATIVE) {\\n                        if (upper > 0.0) {\\n                            lower = lower - upper;\\n                            upper = 0.0;\\n                        }\\n                    }\\n                }\\n\\n                if (getAutoRangeStickyZero()) {\\n                    if (upper <= 0.0) {\\n                        upper = Math.min(0.0, upper + getUpperMargin() * range);\\n                    }\\n                    else {\\n                        upper = upper + getUpperMargin() * range;\\n                    }\\n                    if (lower >= 0.0) {\\n                        lower = Math.max(0.0, lower - getLowerMargin() * range);\\n                    }\\n                    else {\\n                        lower = lower - getLowerMargin() * range;\\n                    }\\n                }\\n                else {\\n                    upper = upper + getUpperMargin() * range;\\n                    lower = lower - getLowerMargin() * range;\\n                }\\n            }\\n\\n            setRange(new Range(lower, upper), false, false);\\n        }\\n\\n    }\", \"javadoc_start_line\": 421, \"annotations_start_line\": 424, \"method_start_line\": 424, \"end_line\": 510}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/XYPlot.java\", \"method_name\": \"getDataRange\", \"content\": \"    \/**\\n     * Returns the range for the specified axis.\\n     *\\n     * @param axis  the axis.\\n     *\\n     * @return The range.\\n     *\/\\n    public Range getDataRange(ValueAxis axis) {\\n\\n        Range result = null;\\n        List mappedDatasets = new ArrayList();\\n        List includedAnnotations = new ArrayList();\\n        boolean isDomainAxis = true;\\n\\n        \/\/ is it a domain axis?\\n        int domainIndex = getDomainAxisIndex(axis);\\n        if (domainIndex >= 0) {\\n            isDomainAxis = true;\\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\\n                    new Integer(domainIndex)));\\n            if (domainIndex == 0) {\\n                \/\/ grab the plot's annotations\\n                Iterator iterator = this.annotations.iterator();\\n                while (iterator.hasNext()) {\\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\\n                        includedAnnotations.add(annotation);\\n                    }\\n                }\\n            }\\n        }\\n\\n        \/\/ or is it a range axis?\\n        int rangeIndex = getRangeAxisIndex(axis);\\n        if (rangeIndex >= 0) {\\n            isDomainAxis = false;\\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\\n                    new Integer(rangeIndex)));\\n            if (rangeIndex == 0) {\\n                Iterator iterator = this.annotations.iterator();\\n                while (iterator.hasNext()) {\\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\\n                        includedAnnotations.add(annotation);\\n                    }\\n                }\\n            }\\n        }\\n\\n        \/\/ iterate through the datasets that map to the axis and get the union\\n        \/\/ of the ranges.\\n        Iterator iterator = mappedDatasets.iterator();\\n        while (iterator.hasNext()) {\\n            XYDataset d = (XYDataset) iterator.next();\\n            if (d != null) {\\n                XYItemRenderer r = getRendererForDataset(d);\\n                if (isDomainAxis) {\\n                    if (r != null) {\\n                        result = Range.combine(result, r.findDomainBounds(d));\\n                    }\\n                    else {\\n                        result = Range.combine(result,\\n                                DatasetUtilities.findDomainBounds(d));\\n                    }\\n                }\\n                else {\\n                    if (r != null) {\\n                        result = Range.combine(result, r.findRangeBounds(d));\\n                    }\\n                    else {\\n                        result = Range.combine(result,\\n                                DatasetUtilities.findRangeBounds(d));\\n                    }\\n                }\\n                \\n                    Collection c = r.getAnnotations();\\n                    Iterator i = c.iterator();\\n                    while (i.hasNext()) {\\n                        XYAnnotation a = (XYAnnotation) i.next();\\n                        if (a instanceof XYAnnotationBoundsInfo) {\\n                            includedAnnotations.add(a);\\n                        }\\n                    }\\n            }\\n        }\\n\\n        Iterator it = includedAnnotations.iterator();\\n        while (it.hasNext()) {\\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\\n            if (xyabi.getIncludeInDataBounds()) {\\n                if (isDomainAxis) {\\n                    result = Range.combine(result, xyabi.getXRange());\\n                }\\n                else {\\n                    result = Range.combine(result, xyabi.getYRange());\\n                }\\n            }\\n        }\\n\\n        return result;\\n\\n    }\", \"javadoc_start_line\": 4418, \"annotations_start_line\": 4425, \"method_start_line\": 4425, \"end_line\": 4519}"}]},{"name":"Chart","version":13,"tour_id":0,"test":"{\"className\": \" org.jfree.chart.block.junit.BorderArrangementTests\", \"methodName\": \"testSizingWithWidthConstraint\", \"error\": \"java.lang.IllegalArgumentException\", \"message\": \"Range(double, double): require lower (0.0) <= upper (-2.3000000000000007).\"}","method":"{\"file_path\": \"\/source\/org\/jfree\/chart\/block\/BorderArrangement.java\", \"method_name\": \"arrangeFF\", \"content\": \"    \/**\\n     * Arranges the items within a container.\\n     *\\n     * @param container  the container.\\n     * @param constraint  the constraint.\\n     * @param g2  the graphics device.\\n     *\\n     * @return The container size after the arrangement.\\n     *\/\\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\\n                               RectangleConstraint constraint) {\\n        double[] w = new double[5];\\n        double[] h = new double[5];\\n        w[0] = constraint.getWidth();\\n        if (this.topBlock != null) {\\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\\n                    LengthConstraintType.FIXED, 0.0,\\n                    new Range(0.0, constraint.getHeight()),\\n                    LengthConstraintType.RANGE);\\n            Size2D size = this.topBlock.arrange(g2, c1);\\n            h[0] = size.height;\\n        }\\n        w[1] = w[0];\\n        if (this.bottomBlock != null) {\\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\\n            Size2D size = this.bottomBlock.arrange(g2, c2);\\n            h[1] = size.height;\\n        }\\n        h[2] = constraint.getHeight() - h[1] - h[0];\\n        if (this.leftBlock != null) {\\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\\n                    new Range(0.0, constraint.getWidth()),\\n                    LengthConstraintType.RANGE, h[2], null,\\n                    LengthConstraintType.FIXED);\\n            Size2D size = this.leftBlock.arrange(g2, c3);\\n            w[2] = size.width;\\n        }\\n        h[3] = h[2];\\n        if (this.rightBlock != null) {\\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\\n                    new Range(0.0, constraint.getWidth() - w[2]),\\n                    LengthConstraintType.RANGE, h[2], null,\\n                    LengthConstraintType.FIXED);\\n            Size2D size = this.rightBlock.arrange(g2, c4);\\n            w[3] = size.width;\\n        }\\n        h[4] = h[2];\\n        w[4] = constraint.getWidth() - w[3] - w[2];\\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\\n        if (this.centerBlock != null) {\\n            this.centerBlock.arrange(g2, c5);\\n        }\\n\\n        if (this.topBlock != null) {\\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\\n                    h[0]));\\n        }\\n        if (this.bottomBlock != null) {\\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\\n                    w[1], h[1]));\\n        }\\n        if (this.leftBlock != null) {\\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\\n                    h[2]));\\n        }\\n        if (this.rightBlock != null) {\\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\\n                    w[3], h[3]));\\n        }\\n        if (this.centerBlock != null) {\\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\\n                    h[4]));\\n        }\\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\\n    }\", \"javadoc_start_line\": 413, \"annotations_start_line\": 422, \"method_start_line\": 423, \"end_line\": 489}","steps":[{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/block\/BlockContainer.java\", \"method_name\": \"arrange\", \"content\": \"    \/**\\n     * Arranges the contents of the block, within the given constraints, and \\n     * returns the block size.\\n     * \\n     * @param g2  the graphics device.\\n     * @param constraint  the constraint (<code>null<\/code> not permitted).\\n     * \\n     * @return The block size (in Java2D units, never <code>null<\/code>).\\n     *\/\\n    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\\n        return this.arrangement.arrange(this, g2, constraint);\\n    }\", \"javadoc_start_line\": 172, \"annotations_start_line\": 181, \"method_start_line\": 181, \"end_line\": 183}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/block\/BorderArrangement.java\", \"method_name\": \"arrange\", \"content\": \"    \/**\\n     * Arranges the items in the specified container, subject to the given\\n     * constraint.\\n     *\\n     * @param container  the container.\\n     * @param g2  the graphics device.\\n     * @param constraint  the constraint.\\n     *\\n     * @return The block size.\\n     *\/\\n    public Size2D arrange(BlockContainer container,\\n                          Graphics2D g2,\\n                          RectangleConstraint constraint) {\\n        RectangleConstraint contentConstraint\\n                = container.toContentConstraint(constraint);\\n        Size2D contentSize = null;\\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\\n        if (w == LengthConstraintType.NONE) {\\n            if (h == LengthConstraintType.NONE) {\\n                contentSize = arrangeNN(container, g2);\\n            }\\n            else if (h == LengthConstraintType.FIXED) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n            else if (h == LengthConstraintType.RANGE) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n        }\\n        else if (w == LengthConstraintType.FIXED) {\\n            if (h == LengthConstraintType.NONE) {\\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\\n            }\\n            else if (h == LengthConstraintType.FIXED) {\\n                contentSize = arrangeFF(container, g2, constraint);\\n            }\\n            else if (h == LengthConstraintType.RANGE) {\\n                contentSize = arrangeFR(container, g2, constraint);\\n            }\\n        }\\n        else if (w == LengthConstraintType.RANGE) {\\n            if (h == LengthConstraintType.NONE) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n            else if (h == LengthConstraintType.FIXED) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n            else if (h == LengthConstraintType.RANGE) {\\n                contentSize = arrangeRR(container, constraint.getWidthRange(),\\n                        constraint.getHeightRange(), g2);\\n            }\\n        }\\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\\n                container.calculateTotalHeight(contentSize.getHeight()));\\n    }\", \"javadoc_start_line\": 118, \"annotations_start_line\": 128, \"method_start_line\": 130, \"end_line\": 172}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/block\/BorderArrangement.java\", \"method_name\": \"arrangeFN\", \"content\": \"    \/**\\n     * Arranges the container width a fixed width and no constraint on the\\n     * height.\\n     *\\n     * @param container  the container.\\n     * @param g2  the graphics device.\\n     * @param width  the fixed width.\\n     *\\n     * @return The container size after arranging the contents.\\n     *\/\\n    protected Size2D arrangeFN(BlockContainer container, Graphics2D g2,\\n                               double width) {\\n        double[] w = new double[5];\\n        double[] h = new double[5];\\n        RectangleConstraint c1 = new RectangleConstraint(width, null,\\n                LengthConstraintType.FIXED, 0.0, null,\\n                LengthConstraintType.NONE);\\n        if (this.topBlock != null) {\\n            Size2D size = this.topBlock.arrange(g2, c1);\\n            w[0] = size.width;\\n            h[0] = size.height;\\n        }\\n        if (this.bottomBlock != null) {\\n            Size2D size = this.bottomBlock.arrange(g2, c1);\\n            w[1] = size.width;\\n            h[1] = size.height;\\n        }\\n        RectangleConstraint c2 = new RectangleConstraint(0.0,\\n                new Range(0.0, width), LengthConstraintType.RANGE,\\n                0.0, null, LengthConstraintType.NONE);\\n        if (this.leftBlock != null) {\\n            Size2D size = this.leftBlock.arrange(g2, c2);\\n            w[2] = size.width;\\n            h[2] = size.height;\\n        }\\n        if (this.rightBlock != null) {\\n            double maxW = Math.max(width - w[2], 0.0);\\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\\n                    new Range(Math.min(w[2], maxW), maxW),\\n                    LengthConstraintType.RANGE, 0.0, null,\\n                    LengthConstraintType.NONE);\\n            Size2D size = this.rightBlock.arrange(g2, c3);\\n            w[3] = size.width;\\n            h[3] = size.height;\\n        }\\n\\n        h[2] = Math.max(h[2], h[3]);\\n        h[3] = h[2];\\n\\n        if (this.centerBlock != null) {\\n            RectangleConstraint c4 = new RectangleConstraint(width - w[2]\\n                    - w[3], null, LengthConstraintType.FIXED, 0.0, null,\\n                    LengthConstraintType.NONE);\\n            Size2D size = this.centerBlock.arrange(g2, c4);\\n            w[4] = size.width;\\n            h[4] = size.height;\\n        }\\n        double height = h[0] + h[1] + Math.max(h[2], Math.max(h[3], h[4]));\\n        return arrange(container, g2, new RectangleConstraint(width, height));\\n    }\", \"javadoc_start_line\": 265, \"annotations_start_line\": 275, \"method_start_line\": 276, \"end_line\": 324}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/block\/BorderArrangement.java\", \"method_name\": \"arrange\", \"content\": \"    \/**\\n     * Arranges the items in the specified container, subject to the given\\n     * constraint.\\n     *\\n     * @param container  the container.\\n     * @param g2  the graphics device.\\n     * @param constraint  the constraint.\\n     *\\n     * @return The block size.\\n     *\/\\n    public Size2D arrange(BlockContainer container,\\n                          Graphics2D g2,\\n                          RectangleConstraint constraint) {\\n        RectangleConstraint contentConstraint\\n                = container.toContentConstraint(constraint);\\n        Size2D contentSize = null;\\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\\n        if (w == LengthConstraintType.NONE) {\\n            if (h == LengthConstraintType.NONE) {\\n                contentSize = arrangeNN(container, g2);\\n            }\\n            else if (h == LengthConstraintType.FIXED) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n            else if (h == LengthConstraintType.RANGE) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n        }\\n        else if (w == LengthConstraintType.FIXED) {\\n            if (h == LengthConstraintType.NONE) {\\n                contentSize = arrangeFN(container, g2, constraint.getWidth());\\n            }\\n            else if (h == LengthConstraintType.FIXED) {\\n                contentSize = arrangeFF(container, g2, constraint);\\n            }\\n            else if (h == LengthConstraintType.RANGE) {\\n                contentSize = arrangeFR(container, g2, constraint);\\n            }\\n        }\\n        else if (w == LengthConstraintType.RANGE) {\\n            if (h == LengthConstraintType.NONE) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n            else if (h == LengthConstraintType.FIXED) {\\n                throw new RuntimeException(\\\"Not implemented.\\\");\\n            }\\n            else if (h == LengthConstraintType.RANGE) {\\n                contentSize = arrangeRR(container, constraint.getWidthRange(),\\n                        constraint.getHeightRange(), g2);\\n            }\\n        }\\n        return new Size2D(container.calculateTotalWidth(contentSize.getWidth()),\\n                container.calculateTotalHeight(contentSize.getHeight()));\\n    }\", \"javadoc_start_line\": 118, \"annotations_start_line\": 128, \"method_start_line\": 130, \"end_line\": 172}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/block\/BorderArrangement.java\", \"method_name\": \"arrangeFF\", \"content\": \"    \/**\\n     * Arranges the items within a container.\\n     *\\n     * @param container  the container.\\n     * @param constraint  the constraint.\\n     * @param g2  the graphics device.\\n     *\\n     * @return The container size after the arrangement.\\n     *\/\\n    protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\\n                               RectangleConstraint constraint) {\\n        double[] w = new double[5];\\n        double[] h = new double[5];\\n        w[0] = constraint.getWidth();\\n        if (this.topBlock != null) {\\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\\n                    LengthConstraintType.FIXED, 0.0,\\n                    new Range(0.0, constraint.getHeight()),\\n                    LengthConstraintType.RANGE);\\n            Size2D size = this.topBlock.arrange(g2, c1);\\n            h[0] = size.height;\\n        }\\n        w[1] = w[0];\\n        if (this.bottomBlock != null) {\\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\\n            Size2D size = this.bottomBlock.arrange(g2, c2);\\n            h[1] = size.height;\\n        }\\n        h[2] = constraint.getHeight() - h[1] - h[0];\\n        if (this.leftBlock != null) {\\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\\n                    new Range(0.0, constraint.getWidth()),\\n                    LengthConstraintType.RANGE, h[2], null,\\n                    LengthConstraintType.FIXED);\\n            Size2D size = this.leftBlock.arrange(g2, c3);\\n            w[2] = size.width;\\n        }\\n        h[3] = h[2];\\n        if (this.rightBlock != null) {\\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\\n                    new Range(0.0, constraint.getWidth() - w[2]),\\n                    LengthConstraintType.RANGE, h[2], null,\\n                    LengthConstraintType.FIXED);\\n            Size2D size = this.rightBlock.arrange(g2, c4);\\n            w[3] = size.width;\\n        }\\n        h[4] = h[2];\\n        w[4] = constraint.getWidth() - w[3] - w[2];\\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\\n        if (this.centerBlock != null) {\\n            this.centerBlock.arrange(g2, c5);\\n        }\\n\\n        if (this.topBlock != null) {\\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\\n                    h[0]));\\n        }\\n        if (this.bottomBlock != null) {\\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\\n                    w[1], h[1]));\\n        }\\n        if (this.leftBlock != null) {\\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\\n                    h[2]));\\n        }\\n        if (this.rightBlock != null) {\\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\\n                    w[3], h[3]));\\n        }\\n        if (this.centerBlock != null) {\\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\\n                    h[4]));\\n        }\\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\\n    }\", \"javadoc_start_line\": 413, \"annotations_start_line\": 422, \"method_start_line\": 423, \"end_line\": 489}"}]},{"name":"Chart","version":15,"tour_id":0,"test":"{\"className\": \" org.jfree.chart.plot.junit.PiePlot3DTests\", \"methodName\": \"testDrawWithNullDataset\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/PiePlot.java\", \"method_name\": \"initialise\", \"content\": \"    \/**\\n     * Initialises the drawing procedure.  This method will be called before \\n     * the first item is rendered, giving the plot an opportunity to initialise\\n     * any state information it wants to maintain.\\n     *\\n     * @param g2  the graphics device.\\n     * @param plotArea  the plot area (<code>null<\/code> not permitted).\\n     * @param plot  the plot.\\n     * @param index  the secondary index (<code>null<\/code> for primary \\n     *               renderer).\\n     * @param info  collects chart rendering information for return to caller.\\n     * \\n     * @return A state object (maintains state information relevant to one \\n     *         chart drawing).\\n     *\/\\n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\\n     \\n        PiePlotState state = new PiePlotState(info);\\n        state.setPassesRequired(2);\\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\\n                    plot.getDataset()));\\n        state.setLatestAngle(plot.getStartAngle());\\n        return state;\\n        \\n    }\", \"javadoc_start_line\": 2031, \"annotations_start_line\": 2046, \"method_start_line\": 2047, \"end_line\": 2056}","steps":[{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/JFreeChart.java\", \"method_name\": \"draw\", \"content\": \"    \/**\\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\\n     * printer).\\n     * <P>\\n     * This method is the focus of the entire JFreeChart library.\\n     *\\n     * @param g2  the graphics device.\\n     * @param chartArea  the area within which the chart should be drawn.\\n     * @param anchor  the anchor point (in Java2D space) for the chart \\n     *                (<code>null<\/code> permitted).\\n     * @param info  records info about the drawing (null means collect no info).\\n     *\/\\n    public void draw(Graphics2D g2, \\n                     Rectangle2D chartArea, Point2D anchor, \\n                     ChartRenderingInfo info) {\\n\\n        notifyListeners(new ChartProgressEvent(this, this, \\n                ChartProgressEvent.DRAWING_STARTED, 0));\\n\\n        \/\/ record the chart area, if info is requested...\\n        if (info != null) {\\n            info.clear();\\n            info.setChartArea(chartArea);\\n        }\\n\\n        \/\/ ensure no drawing occurs outside chart area...\\n        Shape savedClip = g2.getClip();\\n        g2.clip(chartArea);\\n\\n        g2.addRenderingHints(this.renderingHints);\\n\\n        \/\/ draw the chart background...\\n        if (this.backgroundPaint != null) {\\n            g2.setPaint(this.backgroundPaint);\\n            g2.fill(chartArea);\\n        }\\n\\n        if (this.backgroundImage != null) {\\n            Composite originalComposite = g2.getComposite();\\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \\n                    this.backgroundImageAlpha));\\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, \\n                    this.backgroundImage.getWidth(null), \\n                    this.backgroundImage.getHeight(null));\\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \\n                    (int) dest.getY(), (int) dest.getWidth(), \\n                    (int) dest.getHeight(), null);\\n            g2.setComposite(originalComposite);\\n        }\\n\\n        if (isBorderVisible()) {\\n            Paint paint = getBorderPaint();\\n            Stroke stroke = getBorderStroke();\\n            if (paint != null && stroke != null) {\\n                Rectangle2D borderArea = new Rectangle2D.Double(\\n                        chartArea.getX(), chartArea.getY(), \\n                        chartArea.getWidth() - 1.0, chartArea.getHeight() \\n                        - 1.0);\\n                g2.setPaint(paint);\\n                g2.setStroke(stroke);\\n                g2.draw(borderArea);\\n            }\\n        }\\n\\n        \/\/ draw the title and subtitles...\\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\\n        nonTitleArea.setRect(chartArea);\\n        this.padding.trim(nonTitleArea);\\n        \\n        EntityCollection entities = null;\\n        if (info != null) {\\n            entities = info.getEntityCollection();   \\n        }\\n        if (this.title != null) {\\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea, \\n                    (entities != null));\\n            if (e != null) {\\n                entities.addAll(e);   \\n            }\\n        }\\n\\n        Iterator iterator = this.subtitles.iterator();\\n        while (iterator.hasNext()) {\\n            Title currentTitle = (Title) iterator.next();\\n            EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, \\n                    (entities != null));\\n            if (e != null) {\\n                entities.addAll(e);   \\n            }\\n        }\\n\\n        Rectangle2D plotArea = nonTitleArea;\\n \\n        \/\/ draw the plot (axes and data visualisation)\\n        PlotRenderingInfo plotInfo = null;\\n        if (info != null) {\\n            plotInfo = info.getPlotInfo();\\n        }\\n        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\\n\\n        g2.setClip(savedClip);\\n\\n        notifyListeners(new ChartProgressEvent(this, this, \\n                ChartProgressEvent.DRAWING_FINISHED, 100));\\n    }\", \"javadoc_start_line\": 1120, \"annotations_start_line\": 1132, \"method_start_line\": 1134, \"end_line\": 1225}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/PiePlot3D.java\", \"method_name\": \"draw\", \"content\": \"    \/**\\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \\n     * printer).  This method is called by the \\n     * {@link org.jfree.chart.JFreeChart} class, you don't normally need \\n     * to call it yourself.\\n     *\\n     * @param g2  the graphics device.\\n     * @param plotArea  the area within which the plot should be drawn.\\n     * @param anchor  the anchor point.\\n     * @param parentState  the state from the parent plot, if there is one.\\n     * @param info  collects info about the drawing \\n     *              (<code>null<\/code> permitted).\\n     *\/\\n    public void draw(Graphics2D g2, Rectangle2D plotArea, Point2D anchor,\\n                     PlotState parentState,\\n                     PlotRenderingInfo info) {\\n\\n        \/\/ adjust for insets...\\n        RectangleInsets insets = getInsets();\\n        insets.trim(plotArea);\\n\\n        Rectangle2D originalPlotArea = (Rectangle2D) plotArea.clone();\\n        if (info != null) {\\n            info.setPlotArea(plotArea);\\n            info.setDataArea(plotArea);\\n        }\\n\\n        drawBackground(g2, plotArea);\\n\\n        Shape savedClip = g2.getClip();\\n        g2.clip(plotArea);\\n\\n        \/\/ adjust the plot area by the interior spacing value\\n        double gapPercent = getInteriorGap();\\n        double labelPercent = 0.0;\\n        if (getLabelGenerator() != null) {\\n            labelPercent = getLabelGap() + getMaximumLabelWidth();   \\n        }\\n        double gapHorizontal = plotArea.getWidth() * (gapPercent \\n                + labelPercent) * 2.0;\\n        double gapVertical = plotArea.getHeight() * gapPercent * 2.0;\\n\\n        if (DEBUG_DRAW_INTERIOR) {\\n            double hGap = plotArea.getWidth() * getInteriorGap();\\n            double vGap = plotArea.getHeight() * getInteriorGap();\\n            double igx1 = plotArea.getX() + hGap;\\n            double igx2 = plotArea.getMaxX() - hGap;\\n            double igy1 = plotArea.getY() + vGap;\\n            double igy2 = plotArea.getMaxY() - vGap;\\n            g2.setPaint(Color.lightGray);\\n            g2.draw(new Rectangle2D.Double(igx1, igy1, igx2 - igx1, \\n                    igy2 - igy1));\\n        }\\n\\n        double linkX = plotArea.getX() + gapHorizontal \/ 2;\\n        double linkY = plotArea.getY() + gapVertical \/ 2;\\n        double linkW = plotArea.getWidth() - gapHorizontal;\\n        double linkH = plotArea.getHeight() - gapVertical;\\n        \\n        \/\/ make the link area a square if the pie chart is to be circular...\\n        if (isCircular()) { \/\/ is circular?\\n            double min = Math.min(linkW, linkH) \/ 2;\\n            linkX = (linkX + linkX + linkW) \/ 2 - min;\\n            linkY = (linkY + linkY + linkH) \/ 2 - min;\\n            linkW = 2 * min;\\n            linkH = 2 * min;\\n        }\\n        \\n        PiePlotState state = initialise(g2, plotArea, this, null, info);\\n\\n        \/\/ the link area defines the dog leg points for the linking lines to \\n        \/\/ the labels\\n        Rectangle2D linkAreaXX = new Rectangle2D.Double(linkX, linkY, linkW, \\n                linkH * (1 - this.depthFactor));\\n        state.setLinkArea(linkAreaXX);\\n\\n        if (DEBUG_DRAW_LINK_AREA) {\\n            g2.setPaint(Color.blue);\\n            g2.draw(linkAreaXX);\\n            g2.setPaint(Color.yellow);\\n            g2.draw(new Ellipse2D.Double(linkAreaXX.getX(), linkAreaXX.getY(), \\n                    linkAreaXX.getWidth(), linkAreaXX.getHeight()));\\n        }\\n        \\n        \/\/ the explode area defines the max circle\/ellipse for the exploded pie \\n        \/\/ sections.\\n        \/\/ it is defined by shrinking the linkArea by the linkMargin factor.\\n        double hh = linkW * getLabelLinkMargin();\\n        double vv = linkH * getLabelLinkMargin();\\n        Rectangle2D explodeArea = new Rectangle2D.Double(linkX + hh \/ 2.0, \\n                linkY + vv \/ 2.0, linkW - hh, linkH - vv);\\n       \\n        state.setExplodedPieArea(explodeArea);\\n        \\n        \/\/ the pie area defines the circle\/ellipse for regular pie sections.\\n        \/\/ it is defined by shrinking the explodeArea by the explodeMargin \\n        \/\/ factor. \\n        double maximumExplodePercent = getMaximumExplodePercent();\\n        double percent = maximumExplodePercent \/ (1.0 + maximumExplodePercent);\\n        \\n        double h1 = explodeArea.getWidth() * percent;\\n        double v1 = explodeArea.getHeight() * percent;\\n        Rectangle2D pieArea = new Rectangle2D.Double(explodeArea.getX() \\n                + h1 \/ 2.0, explodeArea.getY() + v1 \/ 2.0,\\n                explodeArea.getWidth() - h1, explodeArea.getHeight() - v1);\\n\\n        \/\/ the link area defines the dog-leg point for the linking lines to \\n        \/\/ the labels\\n        int depth = (int) (pieArea.getHeight() * this.depthFactor);\\n        Rectangle2D linkArea = new Rectangle2D.Double(linkX, linkY, linkW, \\n                linkH - depth);\\n        state.setLinkArea(linkArea);   \\n\\n        state.setPieArea(pieArea);\\n        state.setPieCenterX(pieArea.getCenterX());\\n        state.setPieCenterY(pieArea.getCenterY() - depth \/ 2.0);\\n        state.setPieWRadius(pieArea.getWidth() \/ 2.0);\\n        state.setPieHRadius((pieArea.getHeight() - depth) \/ 2.0);\\n\\n        \/\/ get the data source - return if null;\\n        PieDataset dataset = getDataset();\\n        if (DatasetUtilities.isEmptyOrNull(getDataset())) {\\n            drawNoDataMessage(g2, plotArea);\\n            g2.setClip(savedClip);\\n            drawOutline(g2, plotArea);\\n            return;\\n        }\\n\\n        \/\/ if too any elements\\n        if (dataset.getKeys().size() > plotArea.getWidth()) {\\n            String text = \\\"Too many elements\\\";\\n            Font sfont = new Font(\\\"dialog\\\", Font.BOLD, 10);\\n            g2.setFont(sfont);\\n            FontMetrics fm = g2.getFontMetrics(sfont);\\n            int stringWidth = fm.stringWidth(text);\\n\\n            g2.drawString(text, (int) (plotArea.getX() + (plotArea.getWidth() \\n                    - stringWidth) \/ 2), (int) (plotArea.getY() \\n                    + (plotArea.getHeight() \/ 2)));\\n            return;\\n        }\\n        \/\/ if we are drawing a perfect circle, we need to readjust the top left\\n        \/\/ coordinates of the drawing area for the arcs to arrive at this\\n        \/\/ effect.\\n        if (isCircular()) {\\n            double min = Math.min(plotArea.getWidth(), \\n                    plotArea.getHeight()) \/ 2;\\n            plotArea = new Rectangle2D.Double(plotArea.getCenterX() - min, \\n                    plotArea.getCenterY() - min, 2 * min, 2 * min);\\n        }\\n        \/\/ get a list of keys...\\n        List sectionKeys = dataset.getKeys();\\n\\n        if (sectionKeys.size() == 0) {\\n            return;\\n        }\\n\\n        \/\/ establish the coordinates of the top left corner of the drawing area\\n        double arcX = pieArea.getX();\\n        double arcY = pieArea.getY();\\n\\n        \/\/g2.clip(clipArea);\\n        Composite originalComposite = g2.getComposite();\\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \\n                getForegroundAlpha()));\\n\\n        double totalValue = DatasetUtilities.calculatePieDatasetTotal(dataset);\\n        double runningTotal = 0;\\n        if (depth < 0) {\\n            return;  \/\/ if depth is negative don't draw anything\\n        }\\n\\n        ArrayList arcList = new ArrayList();\\n        Arc2D.Double arc;\\n        Paint paint;\\n        Paint outlinePaint;\\n        Stroke outlineStroke;\\n\\n        Iterator iterator = sectionKeys.iterator();\\n        while (iterator.hasNext()) {\\n\\n            Comparable currentKey = (Comparable) iterator.next();\\n            Number dataValue = dataset.getValue(currentKey);\\n            if (dataValue == null) {\\n                arcList.add(null);\\n                continue;\\n            }\\n            double value = dataValue.doubleValue();\\n            if (value <= 0) {\\n                arcList.add(null);\\n                continue;\\n            }\\n            double startAngle = getStartAngle();\\n            double direction = getDirection().getFactor();\\n            double angle1 = startAngle + (direction * (runningTotal * 360)) \\n                    \/ totalValue;\\n            double angle2 = startAngle + (direction * (runningTotal + value) \\n                    * 360) \/ totalValue;\\n            if (Math.abs(angle2 - angle1) > getMinimumArcAngleToDraw()) {\\n                arcList.add(new Arc2D.Double(arcX, arcY + depth, \\n                        pieArea.getWidth(), pieArea.getHeight() - depth,\\n                        angle1, angle2 - angle1, Arc2D.PIE));\\n            }\\n            else {\\n                arcList.add(null);\\n            }\\n            runningTotal += value;\\n        }\\n\\n        Shape oldClip = g2.getClip();\\n\\n        Ellipse2D top = new Ellipse2D.Double(pieArea.getX(), pieArea.getY(), \\n                pieArea.getWidth(), pieArea.getHeight() - depth);\\n\\n        Ellipse2D bottom = new Ellipse2D.Double(pieArea.getX(), pieArea.getY() \\n                + depth, pieArea.getWidth(), pieArea.getHeight() - depth);\\n\\n        Rectangle2D lower = new Rectangle2D.Double(top.getX(), \\n                top.getCenterY(), pieArea.getWidth(), bottom.getMaxY() \\n                - top.getCenterY());\\n\\n        Rectangle2D upper = new Rectangle2D.Double(pieArea.getX(), top.getY(), \\n                pieArea.getWidth(), bottom.getCenterY() - top.getY());\\n\\n        Area a = new Area(top);\\n        a.add(new Area(lower));\\n        Area b = new Area(bottom);\\n        b.add(new Area(upper));\\n        Area pie = new Area(a);\\n        pie.intersect(b);\\n\\n        Area front = new Area(pie);\\n        front.subtract(new Area(top));\\n\\n        Area back = new Area(pie);\\n        back.subtract(new Area(bottom));\\n\\n        \/\/ draw the bottom circle\\n        int[] xs;\\n        int[] ys;\\n        arc = new Arc2D.Double(arcX, arcY + depth, pieArea.getWidth(), \\n                pieArea.getHeight() - depth, 0, 360, Arc2D.PIE);\\n\\n        int categoryCount = arcList.size();\\n        for (int categoryIndex = 0; categoryIndex < categoryCount; \\n                 categoryIndex++) {\\n            arc = (Arc2D.Double) arcList.get(categoryIndex);\\n            if (arc == null) {\\n                continue;\\n            }\\n            Comparable key = getSectionKey(categoryIndex);\\n            paint = lookupSectionPaint(key, true);\\n            outlinePaint = lookupSectionOutlinePaint(key);\\n            outlineStroke = lookupSectionOutlineStroke(key);\\n            g2.setPaint(paint);\\n            g2.fill(arc);\\n            g2.setPaint(outlinePaint);\\n            g2.setStroke(outlineStroke);\\n            g2.draw(arc);\\n            g2.setPaint(paint);\\n\\n            Point2D p1 = arc.getStartPoint();\\n\\n            \/\/ draw the height\\n            xs = new int[] {(int) arc.getCenterX(), (int) arc.getCenterX(),\\n                    (int) p1.getX(), (int) p1.getX()};\\n            ys = new int[] {(int) arc.getCenterY(), (int) arc.getCenterY() \\n                    - depth, (int) p1.getY() - depth, (int) p1.getY()};\\n            Polygon polygon = new Polygon(xs, ys, 4);\\n            g2.setPaint(java.awt.Color.lightGray);\\n            g2.fill(polygon);\\n            g2.setPaint(outlinePaint);\\n            g2.setStroke(outlineStroke);\\n            g2.draw(polygon);\\n            g2.setPaint(paint);\\n\\n        }\\n\\n        g2.setPaint(Color.gray);\\n        g2.fill(back);\\n        g2.fill(front);\\n\\n        \/\/ cycle through once drawing only the sides at the back...\\n        int cat = 0;\\n        iterator = arcList.iterator();\\n        while (iterator.hasNext()) {\\n            Arc2D segment = (Arc2D) iterator.next();\\n            if (segment != null) {\\n                Comparable key = getSectionKey(cat);\\n                paint = lookupSectionPaint(key, true);\\n                outlinePaint = lookupSectionOutlinePaint(key);\\n                outlineStroke = lookupSectionOutlineStroke(key);\\n                drawSide(g2, pieArea, segment, front, back, paint, \\n                        outlinePaint, outlineStroke, false, true);\\n            }\\n            cat++;\\n        }\\n\\n        \/\/ cycle through again drawing only the sides at the front...\\n        cat = 0;\\n        iterator = arcList.iterator();\\n        while (iterator.hasNext()) {\\n            Arc2D segment = (Arc2D) iterator.next();\\n            if (segment != null) {\\n                Comparable key = getSectionKey(cat);\\n                paint = lookupSectionPaint(key);\\n                outlinePaint = lookupSectionOutlinePaint(key);\\n                outlineStroke = lookupSectionOutlineStroke(key);\\n                drawSide(g2, pieArea, segment, front, back, paint, \\n                        outlinePaint, outlineStroke, true, false);\\n            }\\n            cat++;\\n        }\\n\\n        g2.setClip(oldClip);\\n\\n        \/\/ draw the sections at the top of the pie (and set up tooltips)...\\n        Arc2D upperArc;\\n        for (int sectionIndex = 0; sectionIndex < categoryCount; \\n                 sectionIndex++) {\\n            arc = (Arc2D.Double) arcList.get(sectionIndex);\\n            if (arc == null) {\\n                continue;\\n            }\\n            upperArc = new Arc2D.Double(arcX, arcY, pieArea.getWidth(),\\n                    pieArea.getHeight() - depth, arc.getAngleStart(), \\n                    arc.getAngleExtent(), Arc2D.PIE);\\n            \\n            Comparable currentKey = (Comparable) sectionKeys.get(sectionIndex);\\n            paint = lookupSectionPaint(currentKey, true);\\n            outlinePaint = lookupSectionOutlinePaint(currentKey);\\n            outlineStroke = lookupSectionOutlineStroke(currentKey);\\n            g2.setPaint(paint);\\n            g2.fill(upperArc);\\n            g2.setStroke(outlineStroke);\\n            g2.setPaint(outlinePaint);\\n            g2.draw(upperArc);\\n\\n           \/\/ add a tooltip for the section...\\n            if (info != null) {\\n                EntityCollection entities \\n                        = info.getOwner().getEntityCollection();\\n                if (entities != null) {\\n                    String tip = null;\\n                    PieToolTipGenerator tipster = getToolTipGenerator();\\n                    if (tipster != null) {\\n                        \/\/ @mgs: using the method's return value was missing \\n                        tip = tipster.generateToolTip(dataset, currentKey);\\n                    }\\n                    String url = null;\\n                    if (getURLGenerator() != null) {\\n                        url = getURLGenerator().generateURL(dataset, currentKey,\\n                                getPieIndex());\\n                    }\\n                    PieSectionEntity entity = new PieSectionEntity(\\n                            upperArc, dataset, getPieIndex(), sectionIndex, \\n                            currentKey, tip, url);\\n                    entities.add(entity);\\n                }\\n            }\\n            List keys = dataset.getKeys();\\n            Rectangle2D adjustedPlotArea = new Rectangle2D.Double(\\n                    originalPlotArea.getX(), originalPlotArea.getY(), \\n                    originalPlotArea.getWidth(), originalPlotArea.getHeight() \\n                    - depth);\\n            if (getSimpleLabels()) {\\n                drawSimpleLabels(g2, keys, totalValue, adjustedPlotArea, \\n                        linkArea, state);\\n            }\\n            else {\\n                drawLabels(g2, keys, totalValue, adjustedPlotArea, linkArea, \\n                        state);\\n            }\\n        }\\n\\n        g2.setClip(savedClip);\\n        g2.setComposite(originalComposite);\\n        drawOutline(g2, originalPlotArea);\\n\\n    }\", \"javadoc_start_line\": 212, \"annotations_start_line\": 225, \"method_start_line\": 227, \"end_line\": 591}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/PiePlot.java\", \"method_name\": \"initialise\", \"content\": \"    \/**\\n     * Initialises the drawing procedure.  This method will be called before \\n     * the first item is rendered, giving the plot an opportunity to initialise\\n     * any state information it wants to maintain.\\n     *\\n     * @param g2  the graphics device.\\n     * @param plotArea  the plot area (<code>null<\/code> not permitted).\\n     * @param plot  the plot.\\n     * @param index  the secondary index (<code>null<\/code> for primary \\n     *               renderer).\\n     * @param info  collects chart rendering information for return to caller.\\n     * \\n     * @return A state object (maintains state information relevant to one \\n     *         chart drawing).\\n     *\/\\n    public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\\n            PiePlot plot, Integer index, PlotRenderingInfo info) {\\n     \\n        PiePlotState state = new PiePlotState(info);\\n        state.setPassesRequired(2);\\n            state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\\n                    plot.getDataset()));\\n        state.setLatestAngle(plot.getStartAngle());\\n        return state;\\n        \\n    }\", \"javadoc_start_line\": 2031, \"annotations_start_line\": 2046, \"method_start_line\": 2047, \"end_line\": 2056}"}]},{"name":"Chart","version":18,"tour_id":0,"test":"{\"className\": \" org.jfree.data.category.junit.DefaultCategoryDatasetTests\", \"methodName\": \"testBug1835955\", \"error\": \"java.lang.IndexOutOfBoundsException\", \"message\": \"Index: 0, Size: 0\"}","method":"{\"file_path\": \"\/source\/org\/jfree\/data\/DefaultKeyedValues.java\", \"method_name\": \"removeValue\", \"content\": \"    \/**\\n     * Removes a value from the collection.\\n     *\\n     * @param key  the item key (<code>null<\/code> not permitted).\\n     * \\n     * @throws IllegalArgumentException if <code>key<\/code> is \\n     *     <code>null<\/code>.\\n     * @throws UnknownKeyException if <code>key<\/code> is not recognised.\\n     *\/\\n    public void removeValue(Comparable key) {\\n        int index = getIndex(key);\\n        if (index < 0) {\\n\\t\\t\\treturn;\\n        }\\n        removeValue(index);\\n    }\", \"javadoc_start_line\": 323, \"annotations_start_line\": 332, \"method_start_line\": 332, \"end_line\": 338}","steps":[{"step":"{\"file_path\": \"\/source\/org\/jfree\/data\/category\/DefaultCategoryDataset.java\", \"method_name\": \"removeColumn\", \"content\": \"    \/**\\n     * Removes a column from the dataset and sends a {@link DatasetChangeEvent}\\n     * to all registered listeners.\\n     *\\n     * @param columnKey  the column key.\\n     * \\n     * @see #removeRow(Comparable)\\n     *\/\\n    public void removeColumn(Comparable columnKey) {\\n        this.data.removeColumn(columnKey);\\n        fireDatasetChanged();\\n    }\", \"javadoc_start_line\": 341, \"annotations_start_line\": 349, \"method_start_line\": 349, \"end_line\": 352}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/data\/DefaultKeyedValues2D.java\", \"method_name\": \"removeColumn\", \"content\": \"    \/**\\n     * Removes a column from the table.\\n     *\\n     * @param columnKey  the column key (<code>null<\/code> not permitted).\\n     * \\n     * @throws UnknownKeyException if the table does not contain a column with\\n     *     the specified key.\\n     * @throws IllegalArgumentException if <code>columnKey<\/code> is \\n     *     <code>null<\/code>.\\n     * \\n     * @see #removeColumn(int)\\n     * @see #removeRow(Comparable)\\n     *\/\\n    public void removeColumn(Comparable columnKey) {\\n        Iterator iterator = this.rows.iterator();\\n        while (iterator.hasNext()) {\\n            DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\\n                rowData.removeValue(columnKey);\\n        }\\n        this.columnKeys.remove(columnKey);\\n    }\", \"javadoc_start_line\": 441, \"annotations_start_line\": 454, \"method_start_line\": 454, \"end_line\": 461}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/data\/DefaultKeyedValues.java\", \"method_name\": \"removeValue\", \"content\": \"    \/**\\n     * Removes a value from the collection.\\n     *\\n     * @param key  the item key (<code>null<\/code> not permitted).\\n     * \\n     * @throws IllegalArgumentException if <code>key<\/code> is \\n     *     <code>null<\/code>.\\n     * @throws UnknownKeyException if <code>key<\/code> is not recognised.\\n     *\/\\n    public void removeValue(Comparable key) {\\n        int index = getIndex(key);\\n        if (index < 0) {\\n\\t\\t\\treturn;\\n        }\\n        removeValue(index);\\n    }\", \"javadoc_start_line\": 323, \"annotations_start_line\": 332, \"method_start_line\": 332, \"end_line\": 338}"}]},{"name":"Chart","version":25,"tour_id":0,"test":"{\"className\": \" org.jfree.chart.renderer.category.junit.StatisticalBarRendererTests\", \"methodName\": \"testDrawWithNullMeanVertical\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/source\/org\/jfree\/chart\/renderer\/category\/StatisticalBarRenderer.java\", \"method_name\": \"drawVerticalItem\", \"content\": \"    \/**\\n     * Draws an item for a plot with a vertical orientation.\\n     * \\n     * @param g2  the graphics device.\\n     * @param state  the renderer state.\\n     * @param dataArea  the data area.\\n     * @param plot  the plot.\\n     * @param domainAxis  the domain axis.\\n     * @param rangeAxis  the range axis.\\n     * @param dataset  the data.\\n     * @param row  the row index (zero-based).\\n     * @param column  the column index (zero-based).\\n     *\/\\n    protected void drawVerticalItem(Graphics2D g2,\\n                                    CategoryItemRendererState state,\\n                                    Rectangle2D dataArea,\\n                                    CategoryPlot plot,\\n                                    CategoryAxis domainAxis,\\n                                    ValueAxis rangeAxis,\\n                                    StatisticalCategoryDataset dataset,\\n                                    int row,\\n                                    int column) {\\n                                     \\n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\\n        \\n        \/\/ BAR X\\n        double rectX = domainAxis.getCategoryStart(\\n            column, getColumnCount(), dataArea, xAxisLocation\\n        );\\n\\n        int seriesCount = getRowCount();\\n        int categoryCount = getColumnCount();\\n        if (seriesCount > 1) {\\n            double seriesGap = dataArea.getWidth() * getItemMargin()\\n                               \/ (categoryCount * (seriesCount - 1));\\n            rectX = rectX + row * (state.getBarWidth() + seriesGap);\\n        }\\n        else {\\n            rectX = rectX + row * state.getBarWidth();\\n        }\\n\\n        \/\/ BAR Y\\n        Number meanValue = dataset.getMeanValue(row, column);\\n\\n        double value = meanValue.doubleValue();\\n        double base = 0.0;\\n        double lclip = getLowerClip();\\n        double uclip = getUpperClip();\\n\\n        if (uclip <= 0.0) {  \/\/ cases 1, 2, 3 and 4\\n            if (value >= uclip) {\\n                return; \/\/ bar is not visible\\n            }\\n            base = uclip;\\n            if (value <= lclip) {\\n                value = lclip;\\n            }\\n        }\\n        else if (lclip <= 0.0) { \/\/ cases 5, 6, 7 and 8\\n            if (value >= uclip) {\\n                value = uclip;\\n            }\\n            else {\\n                if (value <= lclip) {\\n                    value = lclip;\\n                }\\n            }\\n        }\\n        else { \/\/ cases 9, 10, 11 and 12\\n            if (value <= lclip) {\\n                return; \/\/ bar is not visible\\n            }\\n            base = getLowerClip();\\n            if (value >= uclip) {\\n               value = uclip;\\n            }\\n        }\\n\\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \\n                yAxisLocation);\\n        double rectY = Math.min(transY2, transY1);\\n\\n        double rectWidth = state.getBarWidth();\\n        double rectHeight = Math.abs(transY2 - transY1);\\n\\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \\n                rectHeight);\\n        Paint seriesPaint = getItemPaint(row, column);\\n        g2.setPaint(seriesPaint);\\n        g2.fill(bar);\\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\\n            g2.setStroke(getItemStroke(row, column));\\n            g2.setPaint(getItemOutlinePaint(row, column));\\n            g2.draw(bar);\\n        }\\n\\n        \/\/ standard deviation lines\\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \\n                    + valueDelta, dataArea, yAxisLocation);\\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \\n                    - valueDelta, dataArea, yAxisLocation);\\n\\n            if (this.errorIndicatorStroke != null) {\\n                g2.setStroke(this.errorIndicatorStroke);\\n            }\\n            else {\\n                g2.setStroke(getItemOutlineStroke(row, column));\\n            }\\n            if (this.errorIndicatorPaint != null) {\\n                g2.setPaint(this.errorIndicatorPaint);  \\n            }\\n            else {\\n                g2.setPaint(getItemOutlinePaint(row, column));   \\n            }\\n            Line2D line = null;\\n            line = new Line2D.Double(rectX + rectWidth \/ 2.0d, lowVal,\\n                                     rectX + rectWidth \/ 2.0d, highVal);\\n            g2.draw(line);\\n            line = new Line2D.Double(rectX + rectWidth \/ 2.0d - 5.0d, highVal,\\n                                     rectX + rectWidth \/ 2.0d + 5.0d, highVal);\\n            g2.draw(line);\\n            line = new Line2D.Double(rectX + rectWidth \/ 2.0d - 5.0d, lowVal,\\n                                     rectX + rectWidth \/ 2.0d + 5.0d, lowVal);\\n            g2.draw(line);\\n        \\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \\n                column);\\n        if (generator != null && isItemLabelVisible(row, column)) {\\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \\n                    (value < 0.0));\\n        }        \\n\\n        \/\/ add an item entity, if this information is being collected\\n        EntityCollection entities = state.getEntityCollection();\\n        if (entities != null) {\\n            addItemEntity(entities, dataset, row, column, bar);\\n        }\\n    }\", \"javadoc_start_line\": 360, \"annotations_start_line\": 373, \"method_start_line\": 381, \"end_line\": 500}","steps":[{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/JFreeChart.java\", \"method_name\": \"createBufferedImage\", \"content\": \"    \/**\\n     * Creates and returns a buffered image into which the chart has been drawn.\\n     *\\n     * @param width  the width.\\n     * @param height  the height.\\n     * @param info  carries back chart state information (<code>null<\/code> \\n     *              permitted).\\n     *\\n     * @return A buffered image.\\n     *\/\\n    public BufferedImage createBufferedImage(int width, int height, \\n                                             ChartRenderingInfo info) {\\n        return createBufferedImage(width, height, BufferedImage.TYPE_INT_RGB, \\n                info);\\n    }\", \"javadoc_start_line\": 1361, \"annotations_start_line\": 1371, \"method_start_line\": 1372, \"end_line\": 1375}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/JFreeChart.java\", \"method_name\": \"createBufferedImage\", \"content\": \"    \/**\\n     * Creates and returns a buffered image into which the chart has been drawn.\\n     *\\n     * @param width  the width.\\n     * @param height  the height.\\n     * @param imageType  the image type.\\n     * @param info  carries back chart state information (<code>null<\/code> \\n     *              permitted).\\n     *\\n     * @return A buffered image.\\n     *\/\\n    public BufferedImage createBufferedImage(int width, int height, \\n                                             int imageType, \\n                                             ChartRenderingInfo info) {\\n        BufferedImage image = new BufferedImage(width, height, imageType);\\n        Graphics2D g2 = image.createGraphics();\\n        draw(g2, new Rectangle2D.Double(0, 0, width, height), null, info);\\n        g2.dispose();\\n        return image;\\n    }\", \"javadoc_start_line\": 1377, \"annotations_start_line\": 1388, \"method_start_line\": 1390, \"end_line\": 1396}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/JFreeChart.java\", \"method_name\": \"draw\", \"content\": \"    \/**\\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\\n     * printer).\\n     * <P>\\n     * This method is the focus of the entire JFreeChart library.\\n     *\\n     * @param g2  the graphics device.\\n     * @param chartArea  the area within which the chart should be drawn.\\n     * @param anchor  the anchor point (in Java2D space) for the chart \\n     *                (<code>null<\/code> permitted).\\n     * @param info  records info about the drawing (null means collect no info).\\n     *\/\\n    public void draw(Graphics2D g2, \\n                     Rectangle2D chartArea, Point2D anchor, \\n                     ChartRenderingInfo info) {\\n\\n        notifyListeners(new ChartProgressEvent(this, this, \\n                ChartProgressEvent.DRAWING_STARTED, 0));\\n\\n        \/\/ record the chart area, if info is requested...\\n        if (info != null) {\\n            info.clear();\\n            info.setChartArea(chartArea);\\n        }\\n\\n        \/\/ ensure no drawing occurs outside chart area...\\n        Shape savedClip = g2.getClip();\\n        g2.clip(chartArea);\\n\\n        g2.addRenderingHints(this.renderingHints);\\n\\n        \/\/ draw the chart background...\\n        if (this.backgroundPaint != null) {\\n            g2.setPaint(this.backgroundPaint);\\n            g2.fill(chartArea);\\n        }\\n\\n        if (this.backgroundImage != null) {\\n            Composite originalComposite = g2.getComposite();\\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \\n                    this.backgroundImageAlpha));\\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, \\n                    this.backgroundImage.getWidth(null), \\n                    this.backgroundImage.getHeight(null));\\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \\n                    (int) dest.getY(), (int) dest.getWidth(), \\n                    (int) dest.getHeight(), null);\\n            g2.setComposite(originalComposite);\\n        }\\n\\n        if (isBorderVisible()) {\\n            Paint paint = getBorderPaint();\\n            Stroke stroke = getBorderStroke();\\n            if (paint != null && stroke != null) {\\n                Rectangle2D borderArea = new Rectangle2D.Double(\\n                        chartArea.getX(), chartArea.getY(), \\n                        chartArea.getWidth() - 1.0, chartArea.getHeight() \\n                        - 1.0);\\n                g2.setPaint(paint);\\n                g2.setStroke(stroke);\\n                g2.draw(borderArea);\\n            }\\n        }\\n\\n        \/\/ draw the title and subtitles...\\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\\n        nonTitleArea.setRect(chartArea);\\n        this.padding.trim(nonTitleArea);\\n        \\n        EntityCollection entities = null;\\n        if (info != null) {\\n            entities = info.getEntityCollection();   \\n        }\\n        if (this.title != null) {\\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea, \\n                    (entities != null));\\n            if (e != null) {\\n                entities.addAll(e);   \\n            }\\n        }\\n\\n        Iterator iterator = this.subtitles.iterator();\\n        while (iterator.hasNext()) {\\n            Title currentTitle = (Title) iterator.next();\\n            EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, \\n                    (entities != null));\\n            if (e != null) {\\n                entities.addAll(e);   \\n            }\\n        }\\n\\n        Rectangle2D plotArea = nonTitleArea;\\n \\n        \/\/ draw the plot (axes and data visualisation)\\n        PlotRenderingInfo plotInfo = null;\\n        if (info != null) {\\n            plotInfo = info.getPlotInfo();\\n        }\\n        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\\n\\n        g2.setClip(savedClip);\\n\\n        notifyListeners(new ChartProgressEvent(this, this, \\n                ChartProgressEvent.DRAWING_FINISHED, 100));\\n    }\", \"javadoc_start_line\": 1120, \"annotations_start_line\": 1132, \"method_start_line\": 1134, \"end_line\": 1225}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/CategoryPlot.java\", \"method_name\": \"draw\", \"content\": \"    \/**\\n     * Draws the plot on a Java 2D graphics device (such as the screen or a \\n     * printer).\\n     * <P>\\n     * At your option, you may supply an instance of {@link PlotRenderingInfo}.\\n     * If you do, it will be populated with information about the drawing,\\n     * including various plot dimensions and tooltip info.\\n     *\\n     * @param g2  the graphics device.\\n     * @param area  the area within which the plot (including axes) should \\n     *              be drawn.\\n     * @param anchor  the anchor point (<code>null<\/code> permitted).\\n     * @param parentState  the state from the parent plot, if there is one.\\n     * @param state  collects info as the chart is drawn (possibly \\n     *               <code>null<\/code>).\\n     *\/\\n    public void draw(Graphics2D g2, Rectangle2D area, \\n                     Point2D anchor,\\n                     PlotState parentState,\\n                     PlotRenderingInfo state) {\\n\\n        \/\/ if the plot area is too small, just return...\\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\\n        if (b1 || b2) {\\n            return;\\n        }\\n\\n        \/\/ record the plot area...\\n        if (state == null) {\\n            \/\/ if the incoming state is null, no information will be passed\\n            \/\/ back to the caller - but we create a temporary state to record\\n            \/\/ the plot area, since that is used later by the axes\\n            state = new PlotRenderingInfo(null);\\n        }\\n        state.setPlotArea(area);\\n\\n        \/\/ adjust the drawing area for the plot insets (if any)...\\n        RectangleInsets insets = getInsets();\\n        insets.trim(area);\\n\\n        \/\/ calculate the data area...\\n        AxisSpace space = calculateAxisSpace(g2, area);\\n        Rectangle2D dataArea = space.shrink(area, null);\\n        this.axisOffset.trim(dataArea);\\n\\n        state.setDataArea(dataArea);\\n\\n        \/\/ if there is a renderer, it draws the background, otherwise use the \\n        \/\/ default background...\\n        if (getRenderer() != null) {\\n            getRenderer().drawBackground(g2, this, dataArea);\\n        }\\n        else {\\n            drawBackground(g2, dataArea);\\n        }\\n       \\n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\\n\\n        \/\/ don't let anyone draw outside the data area\\n        Shape savedClip = g2.getClip();\\n        g2.clip(dataArea);\\n\\n        drawDomainGridlines(g2, dataArea);\\n\\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\\n        if (rangeAxisState == null) {\\n            if (parentState != null) {\\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\\n                        .get(getRangeAxis());\\n            }\\n        }\\n        if (rangeAxisState != null) {\\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\\n        }\\n        \\n        \/\/ draw the markers...\\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\\n        }        \\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\\n        }\\n\\n        \/\/ now render data items...\\n        boolean foundData = false;\\n\\n        \/\/ set up the alpha-transparency...\\n        Composite originalComposite = g2.getComposite();\\n        g2.setComposite(AlphaComposite.getInstance(\\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\\n\\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\\n        if (order == DatasetRenderingOrder.FORWARD) {\\n\\n            \/\/ draw background annotations\\n            int datasetCount = this.datasets.size();\\n            for (int i = 0; i < datasetCount; i++) {\\n                CategoryItemRenderer r = getRenderer(i);\\n                if (r != null) {\\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.BACKGROUND, state);\\n                }\\n            }\\n\\n            for (int i = 0; i < datasetCount; i++) {\\n                foundData = render(g2, dataArea, i, state) || foundData;\\n            }\\n\\n            \/\/ draw foreground annotations\\n            for (int i = 0; i < datasetCount; i++) {\\n                CategoryItemRenderer r = getRenderer(i);\\n                if (r != null) {\\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.FOREGROUND, state);\\n                }\\n            }\\n        }\\n        else {  \/\/ DatasetRenderingOrder.REVERSE\\n            \\n            \/\/ draw background annotations\\n            int datasetCount = this.datasets.size();\\n            for (int i = datasetCount - 1; i >= 0; i--) {\\n                CategoryItemRenderer r = getRenderer(i);\\n                if (r != null) {\\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.BACKGROUND, state);\\n                }\\n            }\\n            \\n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\\n                foundData = render(g2, dataArea, i, state) || foundData;   \\n            }\\n\\n            \/\/ draw foreground annotations\\n            for (int i = datasetCount - 1; i >= 0; i--) {\\n                CategoryItemRenderer r = getRenderer(i);\\n                if (r != null) {\\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.FOREGROUND, state);\\n                }\\n            }\\n        }\\n        \\n        \/\/ draw the foreground markers...\\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\\n        }\\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\\n        }\\n\\n        \/\/ draw the plot's annotations (if any)...\\n        drawAnnotations(g2, dataArea, state);\\n\\n        g2.setClip(savedClip);\\n        g2.setComposite(originalComposite);\\n\\n        if (!foundData) {\\n            drawNoDataMessage(g2, dataArea);\\n        }\\n\\n        \/\/ draw range crosshair if required...\\n        if (isRangeCrosshairVisible()) {\\n            \/\/ FIXME: this doesn't handle multiple range axes\\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \\n                    getRangeCrosshairValue(), getRangeAxis(),\\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\\n        }\\n\\n        \/\/ draw an outline around the plot area...\\n        if (getRenderer() != null) {\\n            getRenderer().drawOutline(g2, this, dataArea);\\n        }\\n        else {\\n            drawOutline(g2, dataArea);\\n        }\\n\\n    }\", \"javadoc_start_line\": 2536, \"annotations_start_line\": 2552, \"method_start_line\": 2555, \"end_line\": 2722}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/CategoryPlot.java\", \"method_name\": \"render\", \"content\": \"    \/**\\n     * Draws a representation of a dataset within the dataArea region using the\\n     * appropriate renderer.\\n     *\\n     * @param g2  the graphics device.\\n     * @param dataArea  the region in which the data is to be drawn.\\n     * @param index  the dataset and renderer index.\\n     * @param info  an optional object for collection dimension information.\\n     * \\n     * @return A boolean that indicates whether or not real data was found.\\n     *\/\\n    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \\n                          PlotRenderingInfo info) {\\n\\n        boolean foundData = false;\\n        CategoryDataset currentDataset = getDataset(index);\\n        CategoryItemRenderer renderer = getRenderer(index);\\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\\n        if (hasData && renderer != null) {\\n            \\n            foundData = true;\\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\\n                    this, index, info);\\n            int columnCount = currentDataset.getColumnCount();\\n            int rowCount = currentDataset.getRowCount();\\n            int passCount = renderer.getPassCount();\\n            for (int pass = 0; pass < passCount; pass++) {            \\n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\\n                    for (int column = 0; column < columnCount; column++) {\\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\\n                            for (int row = 0; row < rowCount; row++) {\\n                                renderer.drawItem(g2, state, dataArea, this, \\n                                        domainAxis, rangeAxis, currentDataset, \\n                                        row, column, pass);\\n                            }\\n                        }\\n                        else {\\n                            for (int row = rowCount - 1; row >= 0; row--) {\\n                                renderer.drawItem(g2, state, dataArea, this, \\n                                        domainAxis, rangeAxis, currentDataset, \\n                                        row, column, pass);\\n                            }                        \\n                        }\\n                    }\\n                }\\n                else {\\n                    for (int column = columnCount - 1; column >= 0; column--) {\\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\\n                            for (int row = 0; row < rowCount; row++) {\\n                                renderer.drawItem(g2, state, dataArea, this, \\n                                        domainAxis, rangeAxis, currentDataset, \\n                                        row, column, pass);\\n                            }\\n                        }\\n                        else {\\n                            for (int row = rowCount - 1; row >= 0; row--) {\\n                                renderer.drawItem(g2, state, dataArea, this, \\n                                        domainAxis, rangeAxis, currentDataset, \\n                                        row, column, pass);\\n                            }                        \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return foundData;\\n        \\n    }\", \"javadoc_start_line\": 2835, \"annotations_start_line\": 2846, \"method_start_line\": 2847, \"end_line\": 2904}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/renderer\/category\/StatisticalBarRenderer.java\", \"method_name\": \"drawItem\", \"content\": \"    \/**\\n     * Draws the bar with its standard deviation line range for a single \\n     * (series, category) data item.\\n     *\\n     * @param g2  the graphics device.\\n     * @param state  the renderer state.\\n     * @param dataArea  the data area.\\n     * @param plot  the plot.\\n     * @param domainAxis  the domain axis.\\n     * @param rangeAxis  the range axis.\\n     * @param data  the data.\\n     * @param row  the row index (zero-based).\\n     * @param column  the column index (zero-based).\\n     * @param pass  the pass index.\\n     *\/\\n    public void drawItem(Graphics2D g2,\\n                         CategoryItemRendererState state,\\n                         Rectangle2D dataArea,\\n                         CategoryPlot plot,\\n                         CategoryAxis domainAxis,\\n                         ValueAxis rangeAxis,\\n                         CategoryDataset data,\\n                         int row,\\n                         int column,\\n                         int pass) {\\n\\n        \/\/ defensive check\\n        if (!(data instanceof StatisticalCategoryDataset)) {\\n            throw new IllegalArgumentException(\\n                \\\"Requires StatisticalCategoryDataset.\\\");\\n        }\\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\\n\\n        PlotOrientation orientation = plot.getOrientation();\\n        if (orientation == PlotOrientation.HORIZONTAL) {\\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \\n                    rangeAxis, statData, row, column);\\n        }\\n        else if (orientation == PlotOrientation.VERTICAL) {\\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \\n                    statData, row, column);\\n        }\\n    }\", \"javadoc_start_line\": 173, \"annotations_start_line\": 188, \"method_start_line\": 197, \"end_line\": 215}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/renderer\/category\/StatisticalBarRenderer.java\", \"method_name\": \"drawVerticalItem\", \"content\": \"    \/**\\n     * Draws an item for a plot with a vertical orientation.\\n     * \\n     * @param g2  the graphics device.\\n     * @param state  the renderer state.\\n     * @param dataArea  the data area.\\n     * @param plot  the plot.\\n     * @param domainAxis  the domain axis.\\n     * @param rangeAxis  the range axis.\\n     * @param dataset  the data.\\n     * @param row  the row index (zero-based).\\n     * @param column  the column index (zero-based).\\n     *\/\\n    protected void drawVerticalItem(Graphics2D g2,\\n                                    CategoryItemRendererState state,\\n                                    Rectangle2D dataArea,\\n                                    CategoryPlot plot,\\n                                    CategoryAxis domainAxis,\\n                                    ValueAxis rangeAxis,\\n                                    StatisticalCategoryDataset dataset,\\n                                    int row,\\n                                    int column) {\\n                                     \\n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\\n        \\n        \/\/ BAR X\\n        double rectX = domainAxis.getCategoryStart(\\n            column, getColumnCount(), dataArea, xAxisLocation\\n        );\\n\\n        int seriesCount = getRowCount();\\n        int categoryCount = getColumnCount();\\n        if (seriesCount > 1) {\\n            double seriesGap = dataArea.getWidth() * getItemMargin()\\n                               \/ (categoryCount * (seriesCount - 1));\\n            rectX = rectX + row * (state.getBarWidth() + seriesGap);\\n        }\\n        else {\\n            rectX = rectX + row * state.getBarWidth();\\n        }\\n\\n        \/\/ BAR Y\\n        Number meanValue = dataset.getMeanValue(row, column);\\n\\n        double value = meanValue.doubleValue();\\n        double base = 0.0;\\n        double lclip = getLowerClip();\\n        double uclip = getUpperClip();\\n\\n        if (uclip <= 0.0) {  \/\/ cases 1, 2, 3 and 4\\n            if (value >= uclip) {\\n                return; \/\/ bar is not visible\\n            }\\n            base = uclip;\\n            if (value <= lclip) {\\n                value = lclip;\\n            }\\n        }\\n        else if (lclip <= 0.0) { \/\/ cases 5, 6, 7 and 8\\n            if (value >= uclip) {\\n                value = uclip;\\n            }\\n            else {\\n                if (value <= lclip) {\\n                    value = lclip;\\n                }\\n            }\\n        }\\n        else { \/\/ cases 9, 10, 11 and 12\\n            if (value <= lclip) {\\n                return; \/\/ bar is not visible\\n            }\\n            base = getLowerClip();\\n            if (value >= uclip) {\\n               value = uclip;\\n            }\\n        }\\n\\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \\n                yAxisLocation);\\n        double rectY = Math.min(transY2, transY1);\\n\\n        double rectWidth = state.getBarWidth();\\n        double rectHeight = Math.abs(transY2 - transY1);\\n\\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \\n                rectHeight);\\n        Paint seriesPaint = getItemPaint(row, column);\\n        g2.setPaint(seriesPaint);\\n        g2.fill(bar);\\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\\n            g2.setStroke(getItemStroke(row, column));\\n            g2.setPaint(getItemOutlinePaint(row, column));\\n            g2.draw(bar);\\n        }\\n\\n        \/\/ standard deviation lines\\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \\n                    + valueDelta, dataArea, yAxisLocation);\\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \\n                    - valueDelta, dataArea, yAxisLocation);\\n\\n            if (this.errorIndicatorStroke != null) {\\n                g2.setStroke(this.errorIndicatorStroke);\\n            }\\n            else {\\n                g2.setStroke(getItemOutlineStroke(row, column));\\n            }\\n            if (this.errorIndicatorPaint != null) {\\n                g2.setPaint(this.errorIndicatorPaint);  \\n            }\\n            else {\\n                g2.setPaint(getItemOutlinePaint(row, column));   \\n            }\\n            Line2D line = null;\\n            line = new Line2D.Double(rectX + rectWidth \/ 2.0d, lowVal,\\n                                     rectX + rectWidth \/ 2.0d, highVal);\\n            g2.draw(line);\\n            line = new Line2D.Double(rectX + rectWidth \/ 2.0d - 5.0d, highVal,\\n                                     rectX + rectWidth \/ 2.0d + 5.0d, highVal);\\n            g2.draw(line);\\n            line = new Line2D.Double(rectX + rectWidth \/ 2.0d - 5.0d, lowVal,\\n                                     rectX + rectWidth \/ 2.0d + 5.0d, lowVal);\\n            g2.draw(line);\\n        \\n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \\n                column);\\n        if (generator != null && isItemLabelVisible(row, column)) {\\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \\n                    (value < 0.0));\\n        }        \\n\\n        \/\/ add an item entity, if this information is being collected\\n        EntityCollection entities = state.getEntityCollection();\\n        if (entities != null) {\\n            addItemEntity(entities, dataset, row, column, bar);\\n        }\\n    }\", \"javadoc_start_line\": 360, \"annotations_start_line\": 373, \"method_start_line\": 381, \"end_line\": 500}"}]},{"name":"Chart","version":26,"tour_id":0,"test":"{\"className\": \" org.jfree.chart.junit.AreaChartTests\", \"methodName\": \"testDrawWithNullInfo\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/source\/org\/jfree\/chart\/axis\/Axis.java\", \"method_name\": \"drawLabel\", \"content\": \"    \/**\\n     * Draws the axis label.\\n     *\\n     * @param label  the label text.\\n     * @param g2  the graphics device.\\n     * @param plotArea  the plot area.\\n     * @param dataArea  the area inside the axes.\\n     * @param edge  the location of the axis.\\n     * @param state  the axis state (<code>null<\/code> not permitted).\\n     * @param plotState  the plot state (<code>null<\/code> permitted).\\n     *\\n     * @return Information about the axis.\\n     *\/\\n    protected AxisState drawLabel(String label, Graphics2D g2, \\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \\n            AxisState state, PlotRenderingInfo plotState) {\\n\\n        \/\/ it is unlikely that 'state' will be null, but check anyway...\\n        if (state == null) {\\n            throw new IllegalArgumentException(\\\"Null 'state' argument.\\\");\\n        }\\n        \\n        if ((label == null) || (label.equals(\\\"\\\"))) {\\n            return state;\\n        }\\n\\n        Font font = getLabelFont();\\n        RectangleInsets insets = getLabelInsets();\\n        g2.setFont(font);\\n        g2.setPaint(getLabelPaint());\\n        FontMetrics fm = g2.getFontMetrics();\\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\\n        Shape hotspot = null;\\n        \\n        if (edge == RectangleEdge.TOP) {\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle(), labelBounds.getCenterX(), \\n                    labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) dataArea.getCenterX();\\n            float labely = (float) (state.getCursor() - insets.getBottom() \\n                    - h \/ 2.0);\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \\n                    + insets.getBottom());\\n        }\\n        else if (edge == RectangleEdge.BOTTOM) {\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle(), labelBounds.getCenterX(), \\n                    labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) dataArea.getCenterX();\\n            float labely = (float) (state.getCursor() + insets.getTop() \\n                    + h \/ 2.0);\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \\n                    + insets.getBottom());\\n        }\\n        else if (edge == RectangleEdge.LEFT) {\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle() - Math.PI \/ 2.0, labelBounds.getCenterX(), \\n                    labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) (state.getCursor() - insets.getRight() \\n                    - w \/ 2.0);\\n            float labely = (float) dataArea.getCenterY();\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle() - Math.PI \/ 2.0, \\n                    TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \\n                    + insets.getRight());\\n        }\\n        else if (edge == RectangleEdge.RIGHT) {\\n\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle() + Math.PI \/ 2.0, \\n                    labelBounds.getCenterX(), labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) (state.getCursor() \\n                            + insets.getLeft() + w \/ 2.0);\\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \\n                    \/ 2.0);\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle() + Math.PI \/ 2.0, \\n                    TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \\n                    + insets.getRight());\\n\\n        }\\n        if (plotState != null && hotspot != null) {\\n            ChartRenderingInfo owner = plotState.getOwner();\\n                EntityCollection entities = owner.getEntityCollection();\\n                if (entities != null) {\\n                    entities.add(new AxisLabelEntity(this, hotspot, \\n                            this.labelToolTip, this.labelURL));\\n                }\\n        }\\n        return state;\\n\\n    }\", \"javadoc_start_line\": 1079, \"annotations_start_line\": 1092, \"method_start_line\": 1094, \"end_line\": 1200}","steps":[{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/JFreeChart.java\", \"method_name\": \"createBufferedImage\", \"content\": \"    \/**\\n     * Creates and returns a buffered image into which the chart has been drawn.\\n     *\\n     * @param width  the width.\\n     * @param height  the height.\\n     * @param info  carries back chart state information (<code>null<\/code> \\n     *              permitted).\\n     *\\n     * @return A buffered image.\\n     *\/\\n    public BufferedImage createBufferedImage(int width, int height, \\n                                             ChartRenderingInfo info) {\\n        return createBufferedImage(width, height, BufferedImage.TYPE_INT_RGB, \\n                info);\\n    }\", \"javadoc_start_line\": 1355, \"annotations_start_line\": 1365, \"method_start_line\": 1366, \"end_line\": 1369}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/JFreeChart.java\", \"method_name\": \"createBufferedImage\", \"content\": \"    \/**\\n     * Creates and returns a buffered image into which the chart has been drawn.\\n     *\\n     * @param width  the width.\\n     * @param height  the height.\\n     * @param imageType  the image type.\\n     * @param info  carries back chart state information (<code>null<\/code> \\n     *              permitted).\\n     *\\n     * @return A buffered image.\\n     *\/\\n    public BufferedImage createBufferedImage(int width, int height, \\n                                             int imageType, \\n                                             ChartRenderingInfo info) {\\n        BufferedImage image = new BufferedImage(width, height, imageType);\\n        Graphics2D g2 = image.createGraphics();\\n        draw(g2, new Rectangle2D.Double(0, 0, width, height), null, info);\\n        g2.dispose();\\n        return image;\\n    }\", \"javadoc_start_line\": 1371, \"annotations_start_line\": 1382, \"method_start_line\": 1384, \"end_line\": 1390}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/JFreeChart.java\", \"method_name\": \"draw\", \"content\": \"    \/**\\n     * Draws the chart on a Java 2D graphics device (such as the screen or a\\n     * printer).\\n     * <P>\\n     * This method is the focus of the entire JFreeChart library.\\n     *\\n     * @param g2  the graphics device.\\n     * @param chartArea  the area within which the chart should be drawn.\\n     * @param anchor  the anchor point (in Java2D space) for the chart \\n     *                (<code>null<\/code> permitted).\\n     * @param info  records info about the drawing (null means collect no info).\\n     *\/\\n    public void draw(Graphics2D g2, \\n                     Rectangle2D chartArea, Point2D anchor, \\n                     ChartRenderingInfo info) {\\n\\n        notifyListeners(new ChartProgressEvent(this, this, \\n                ChartProgressEvent.DRAWING_STARTED, 0));\\n\\n        \/\/ record the chart area, if info is requested...\\n        if (info != null) {\\n            info.clear();\\n            info.setChartArea(chartArea);\\n        }\\n\\n        \/\/ ensure no drawing occurs outside chart area...\\n        Shape savedClip = g2.getClip();\\n        g2.clip(chartArea);\\n\\n        g2.addRenderingHints(this.renderingHints);\\n\\n        \/\/ draw the chart background...\\n        if (this.backgroundPaint != null) {\\n            g2.setPaint(this.backgroundPaint);\\n            g2.fill(chartArea);\\n        }\\n\\n        if (this.backgroundImage != null) {\\n            Composite originalComposite = g2.getComposite();\\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \\n                    this.backgroundImageAlpha));\\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, \\n                    this.backgroundImage.getWidth(null), \\n                    this.backgroundImage.getHeight(null));\\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \\n                    (int) dest.getY(), (int) dest.getWidth(), \\n                    (int) dest.getHeight(), null);\\n            g2.setComposite(originalComposite);\\n        }\\n\\n        if (isBorderVisible()) {\\n            Paint paint = getBorderPaint();\\n            Stroke stroke = getBorderStroke();\\n            if (paint != null && stroke != null) {\\n                Rectangle2D borderArea = new Rectangle2D.Double(\\n                        chartArea.getX(), chartArea.getY(), \\n                        chartArea.getWidth() - 1.0, chartArea.getHeight() \\n                        - 1.0);\\n                g2.setPaint(paint);\\n                g2.setStroke(stroke);\\n                g2.draw(borderArea);\\n            }\\n        }\\n\\n        \/\/ draw the title and subtitles...\\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\\n        nonTitleArea.setRect(chartArea);\\n        this.padding.trim(nonTitleArea);\\n        \\n        EntityCollection entities = null;\\n        if (info != null) {\\n            entities = info.getEntityCollection();   \\n        }\\n        if (this.title != null) {\\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea, \\n                    (entities != null));\\n            if (e != null) {\\n                entities.addAll(e);   \\n            }\\n        }\\n\\n        Iterator iterator = this.subtitles.iterator();\\n        while (iterator.hasNext()) {\\n            Title currentTitle = (Title) iterator.next();\\n            EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, \\n                    (entities != null));\\n            if (e != null) {\\n                entities.addAll(e);   \\n            }\\n        }\\n\\n        Rectangle2D plotArea = nonTitleArea;\\n \\n        \/\/ draw the plot (axes and data visualisation)\\n        PlotRenderingInfo plotInfo = null;\\n        if (info != null) {\\n            plotInfo = info.getPlotInfo();\\n        }\\n        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\\n\\n        g2.setClip(savedClip);\\n\\n        notifyListeners(new ChartProgressEvent(this, this, \\n                ChartProgressEvent.DRAWING_FINISHED, 100));\\n    }\", \"javadoc_start_line\": 1114, \"annotations_start_line\": 1126, \"method_start_line\": 1128, \"end_line\": 1219}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/XYPlot.java\", \"method_name\": \"draw\", \"content\": \"    \/**\\n     * Draws the plot within the specified area on a graphics device.\\n     *\\n     * @param g2  the graphics device.\\n     * @param area  the plot area (in Java2D space).\\n     * @param anchor  an anchor point in Java2D space (<code>null<\/code>\\n     *                permitted).\\n     * @param parentState  the state from the parent plot, if there is one\\n     *                     (<code>null<\/code> permitted).\\n     * @param info  collects chart drawing information (<code>null<\/code>\\n     *              permitted).\\n     *\/\\n    public void draw(Graphics2D g2,\\n                     Rectangle2D area,\\n                     Point2D anchor,\\n                     PlotState parentState,\\n                     PlotRenderingInfo info) {\\n\\n        \/\/ if the plot area is too small, just return...\\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\\n        if (b1 || b2) {\\n            return;\\n        }\\n\\n        \/\/ record the plot area...\\n        if (info != null) {\\n            info.setPlotArea(area);\\n        }\\n\\n        \/\/ adjust the drawing area for the plot insets (if any)...\\n        RectangleInsets insets = getInsets();\\n        insets.trim(area);\\n\\n        AxisSpace space = calculateAxisSpace(g2, area);\\n        Rectangle2D dataArea = space.shrink(area, null);\\n        this.axisOffset.trim(dataArea);\\n\\n        if (info != null) {\\n            info.setDataArea(dataArea);\\n        }\\n\\n        \/\/ draw the plot background and axes...\\n        drawBackground(g2, dataArea);\\n        Map axisStateMap = drawAxes(g2, area, dataArea, info);\\n\\n        PlotOrientation orient = getOrientation();\\n\\n        \/\/ the anchor point is typically the point where the mouse last\\n        \/\/ clicked - the crosshairs will be driven off this point...\\n        if (anchor != null && !dataArea.contains(anchor)) {\\n            anchor = null;\\n        }\\n        CrosshairState crosshairState = new CrosshairState();\\n        crosshairState.setCrosshairDistance(Double.POSITIVE_INFINITY);\\n        crosshairState.setAnchor(anchor);\\n        \\n        crosshairState.setAnchorX(Double.NaN);\\n        crosshairState.setAnchorY(Double.NaN);            \\n        if (anchor != null) {\\n            ValueAxis domainAxis = getDomainAxis();\\n            if (domainAxis != null) {\\n                double x;\\n                if (orient == PlotOrientation.VERTICAL) {\\n                    x = domainAxis.java2DToValue(anchor.getX(), dataArea, \\n                            getDomainAxisEdge());\\n                } \\n                else {\\n                    x = domainAxis.java2DToValue(anchor.getY(), dataArea, \\n                            getDomainAxisEdge());\\n                }\\n                crosshairState.setAnchorX(x);\\n            }\\n            ValueAxis rangeAxis = getRangeAxis();\\n            if (rangeAxis != null) {\\n                double y;\\n                if (orient == PlotOrientation.VERTICAL) {\\n                    y = rangeAxis.java2DToValue(anchor.getY(), dataArea, \\n                            getRangeAxisEdge());\\n                } \\n                else {\\n                    y = rangeAxis.java2DToValue(anchor.getX(), dataArea, \\n                            getRangeAxisEdge());\\n                }\\n                crosshairState.setAnchorY(y);                \\n            }\\n        }\\n        crosshairState.setCrosshairX(getDomainCrosshairValue());\\n        crosshairState.setCrosshairY(getRangeCrosshairValue());\\n        Shape originalClip = g2.getClip();\\n        Composite originalComposite = g2.getComposite();\\n\\n        g2.clip(dataArea);\\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \\n                getForegroundAlpha()));\\n\\n        AxisState domainAxisState = (AxisState) axisStateMap.get(\\n                getDomainAxis());\\n        if (domainAxisState == null) {\\n            if (parentState != null) {\\n                domainAxisState = (AxisState) parentState.getSharedAxisStates()\\n                        .get(getDomainAxis());\\n            }\\n        }\\n\\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\\n        if (rangeAxisState == null) {\\n            if (parentState != null) {\\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\\n                        .get(getRangeAxis());\\n            }\\n        }\\n        if (domainAxisState != null) {\\n            drawDomainTickBands(g2, dataArea, domainAxisState.getTicks());\\n        }\\n        if (rangeAxisState != null) {\\n            drawRangeTickBands(g2, dataArea, rangeAxisState.getTicks());\\n        }\\n        if (domainAxisState != null) {\\n            drawDomainGridlines(g2, dataArea, domainAxisState.getTicks());\\n            drawZeroDomainBaseline(g2, dataArea);\\n        }\\n        if (rangeAxisState != null) {\\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\\n            drawZeroRangeBaseline(g2, dataArea);\\n        }\\n\\n        \/\/ draw the markers that are associated with a specific renderer...\\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\\n        }\\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\\n        }\\n\\n        \/\/ now draw annotations and render data items...\\n        boolean foundData = false;\\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\\n        if (order == DatasetRenderingOrder.FORWARD) {\\n\\n            \/\/ draw background annotations\\n            int rendererCount = this.renderers.size();\\n            for (int i = 0; i < rendererCount; i++) {\\n                XYItemRenderer r = getRenderer(i);\\n                if (r != null) {\\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.BACKGROUND, info);\\n                }\\n            }\\n\\n            \/\/ render data items...\\n            for (int i = 0; i < getDatasetCount(); i++) {\\n                foundData = render(g2, dataArea, i, info, crosshairState)\\n                    || foundData;\\n            }\\n\\n            \/\/ draw foreground annotations\\n            for (int i = 0; i < rendererCount; i++) {\\n                XYItemRenderer r = getRenderer(i);\\n                if (r != null) {\\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.FOREGROUND, info);\\n                }\\n            }\\n\\n        }\\n        else if (order == DatasetRenderingOrder.REVERSE) {\\n\\n            \/\/ draw background annotations\\n            int rendererCount = this.renderers.size();\\n            for (int i = rendererCount - 1; i >= 0; i--) {\\n                XYItemRenderer r = getRenderer(i);\\n                if (i >= getDatasetCount()) { \/\/ we need the dataset to make\\n                    continue;                 \/\/ a link to the axes\\n                }\\n                if (r != null) {\\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.BACKGROUND, info);\\n                }\\n            }\\n\\n            for (int i = getDatasetCount() - 1; i >= 0; i--) {\\n                foundData = render(g2, dataArea, i, info, crosshairState)\\n                    || foundData;\\n            }\\n\\n            \/\/ draw foreground annotations\\n            for (int i = rendererCount - 1; i >= 0; i--) {\\n                XYItemRenderer r = getRenderer(i);\\n                if (i >= getDatasetCount()) { \/\/ we need the dataset to make\\n                    continue;                 \/\/ a link to the axes\\n                }\\n                if (r != null) {\\n                    ValueAxis domainAxis = getDomainAxisForDataset(i);\\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\\n                            Layer.FOREGROUND, info);\\n                }\\n            }\\n\\n        }\\n\\n        \/\/ draw domain crosshair if required...\\n        int xAxisIndex = crosshairState.getDomainAxisIndex();\\n        ValueAxis xAxis = getDomainAxis(xAxisIndex);\\n        RectangleEdge xAxisEdge = getDomainAxisEdge(xAxisIndex);\\n        if (!this.domainCrosshairLockedOnData && anchor != null) {\\n            double xx;\\n            if (orient == PlotOrientation.VERTICAL) {\\n                xx = xAxis.java2DToValue(anchor.getX(), dataArea, xAxisEdge);\\n            } \\n            else {\\n                xx = xAxis.java2DToValue(anchor.getY(), dataArea, xAxisEdge);\\n            }\\n            crosshairState.setCrosshairX(xx);\\n        }\\n        setDomainCrosshairValue(crosshairState.getCrosshairX(), false);\\n        if (isDomainCrosshairVisible()) {\\n            double x = getDomainCrosshairValue();\\n            Paint paint = getDomainCrosshairPaint();\\n            Stroke stroke = getDomainCrosshairStroke();\\n            drawDomainCrosshair(g2, dataArea, orient, x, xAxis, stroke, paint);\\n        }\\n\\n        \/\/ draw range crosshair if required...\\n        int yAxisIndex = crosshairState.getRangeAxisIndex();\\n        ValueAxis yAxis = getRangeAxis(yAxisIndex);\\n        RectangleEdge yAxisEdge = getRangeAxisEdge(yAxisIndex);\\n        if (!this.rangeCrosshairLockedOnData && anchor != null) {\\n            double yy;\\n            if (orient == PlotOrientation.VERTICAL) {\\n                yy = yAxis.java2DToValue(anchor.getY(), dataArea, yAxisEdge);\\n            } else {\\n                yy = yAxis.java2DToValue(anchor.getX(), dataArea, yAxisEdge);\\n            }\\n            crosshairState.setCrosshairY(yy);\\n        }\\n        setRangeCrosshairValue(crosshairState.getCrosshairY(), false);\\n        if (isRangeCrosshairVisible()) {\\n            double y = getRangeCrosshairValue();\\n            Paint paint = getRangeCrosshairPaint();\\n            Stroke stroke = getRangeCrosshairStroke();\\n            drawRangeCrosshair(g2, dataArea, orient, y, yAxis, stroke, paint);\\n        }\\n\\n        if (!foundData) {\\n            drawNoDataMessage(g2, dataArea);\\n        }\\n\\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\\n        }\\n        for (int i = 0; i < this.renderers.size(); i++) {\\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\\n        }\\n\\n        drawAnnotations(g2, dataArea, info);\\n        g2.setClip(originalClip);\\n        g2.setComposite(originalComposite);\\n\\n        drawOutline(g2, dataArea);\\n\\n    }\", \"javadoc_start_line\": 2494, \"annotations_start_line\": 2506, \"method_start_line\": 2510, \"end_line\": 2762}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/plot\/XYPlot.java\", \"method_name\": \"drawAxes\", \"content\": \"    \/**\\n     * A utility method for drawing the axes.\\n     *\\n     * @param g2  the graphics device (<code>null<\/code> not permitted).\\n     * @param plotArea  the plot area (<code>null<\/code> not permitted).\\n     * @param dataArea  the data area (<code>null<\/code> not permitted).\\n     * @param plotState  collects information about the plot (<code>null<\/code>\\n     *                   permitted).\\n     *\\n     * @return A map containing the state for each axis drawn.\\n     *\/\\n    protected Map drawAxes(Graphics2D g2,\\n                           Rectangle2D plotArea,\\n                           Rectangle2D dataArea,\\n                           PlotRenderingInfo plotState) {\\n\\n        AxisCollection axisCollection = new AxisCollection();\\n\\n        \/\/ add domain axes to lists...\\n        for (int index = 0; index < this.domainAxes.size(); index++) {\\n            ValueAxis axis = (ValueAxis) this.domainAxes.get(index);\\n            if (axis != null) {\\n                axisCollection.add(axis, getDomainAxisEdge(index));\\n            }\\n        }\\n\\n        \/\/ add range axes to lists...\\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\\n            if (yAxis != null) {\\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\\n            }\\n        }\\n\\n        Map axisStateMap = new HashMap();\\n\\n        \/\/ draw the top axes\\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\\n                dataArea.getHeight());\\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\\n        while (iterator.hasNext()) {\\n            ValueAxis axis = (ValueAxis) iterator.next();\\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \\n                    RectangleEdge.TOP, plotState);\\n            cursor = info.getCursor();\\n            axisStateMap.put(axis, info);\\n        }\\n\\n        \/\/ draw the bottom axes\\n        cursor = dataArea.getMaxY()\\n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\\n        iterator = axisCollection.getAxesAtBottom().iterator();\\n        while (iterator.hasNext()) {\\n            ValueAxis axis = (ValueAxis) iterator.next();\\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \\n                    RectangleEdge.BOTTOM, plotState);\\n            cursor = info.getCursor();\\n            axisStateMap.put(axis, info);\\n        }\\n\\n        \/\/ draw the left axes\\n        cursor = dataArea.getMinX()\\n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\\n        iterator = axisCollection.getAxesAtLeft().iterator();\\n        while (iterator.hasNext()) {\\n            ValueAxis axis = (ValueAxis) iterator.next();\\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \\n                    RectangleEdge.LEFT, plotState);\\n            cursor = info.getCursor();\\n            axisStateMap.put(axis, info);\\n        }\\n\\n        \/\/ draw the right axes\\n        cursor = dataArea.getMaxX()\\n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\\n        iterator = axisCollection.getAxesAtRight().iterator();\\n        while (iterator.hasNext()) {\\n            ValueAxis axis = (ValueAxis) iterator.next();\\n            AxisState info = axis.draw(g2, cursor, plotArea, dataArea, \\n                    RectangleEdge.RIGHT, plotState);\\n            cursor = info.getCursor();\\n            axisStateMap.put(axis, info);\\n        }\\n\\n        return axisStateMap;\\n    }\", \"javadoc_start_line\": 2960, \"annotations_start_line\": 2971, \"method_start_line\": 2974, \"end_line\": 3045}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/axis\/NumberAxis.java\", \"method_name\": \"draw\", \"content\": \"    \/**\\n     * Draws the axis on a Java 2D graphics device (such as the screen or a \\n     * printer).\\n     *\\n     * @param g2  the graphics device (<code>null<\/code> not permitted).\\n     * @param cursor  the cursor location.\\n     * @param plotArea  the area within which the axes and data should be drawn\\n     *                  (<code>null<\/code> not permitted).\\n     * @param dataArea  the area within which the data should be drawn \\n     *                  (<code>null<\/code> not permitted).\\n     * @param edge  the location of the axis (<code>null<\/code> not permitted).\\n     * @param plotState  collects information about the plot \\n     *                   (<code>null<\/code> permitted).\\n     * \\n     * @return The axis state (never <code>null<\/code>).\\n     *\/\\n    public AxisState draw(Graphics2D g2, \\n                          double cursor,\\n                          Rectangle2D plotArea, \\n                          Rectangle2D dataArea, \\n                          RectangleEdge edge,\\n                          PlotRenderingInfo plotState) {\\n\\n        AxisState state = null;\\n        \/\/ if the axis is not visible, don't draw it...\\n        if (!isVisible()) {\\n            state = new AxisState(cursor);\\n            \/\/ even though the axis is not visible, we need ticks for the \\n            \/\/ gridlines...\\n            List ticks = refreshTicks(g2, state, dataArea, edge); \\n            state.setTicks(ticks);\\n            return state;\\n        }\\n\\n        \/\/ draw the tick marks and labels...\\n        state = drawTickMarksAndLabels(g2, cursor, plotArea, dataArea, edge);\\n\\n\/\/        \/\/ draw the marker band (if there is one)...\\n\/\/        if (getMarkerBand() != null) {\\n\/\/            if (edge == RectangleEdge.BOTTOM) {\\n\/\/                cursor = cursor - getMarkerBand().getHeight(g2);\\n\/\/            }\\n\/\/            getMarkerBand().draw(g2, plotArea, dataArea, 0, cursor);\\n\/\/        }\\n        \\n        \/\/ draw the axis label...\\n        state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state,\\n                plotState);\\n\\n        return state;\\n        \\n    }\", \"javadoc_start_line\": 634, \"annotations_start_line\": 650, \"method_start_line\": 655, \"end_line\": 685}"},{"step":"{\"file_path\": \"\/source\/org\/jfree\/chart\/axis\/Axis.java\", \"method_name\": \"drawLabel\", \"content\": \"    \/**\\n     * Draws the axis label.\\n     *\\n     * @param label  the label text.\\n     * @param g2  the graphics device.\\n     * @param plotArea  the plot area.\\n     * @param dataArea  the area inside the axes.\\n     * @param edge  the location of the axis.\\n     * @param state  the axis state (<code>null<\/code> not permitted).\\n     * @param plotState  the plot state (<code>null<\/code> permitted).\\n     *\\n     * @return Information about the axis.\\n     *\/\\n    protected AxisState drawLabel(String label, Graphics2D g2, \\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \\n            AxisState state, PlotRenderingInfo plotState) {\\n\\n        \/\/ it is unlikely that 'state' will be null, but check anyway...\\n        if (state == null) {\\n            throw new IllegalArgumentException(\\\"Null 'state' argument.\\\");\\n        }\\n        \\n        if ((label == null) || (label.equals(\\\"\\\"))) {\\n            return state;\\n        }\\n\\n        Font font = getLabelFont();\\n        RectangleInsets insets = getLabelInsets();\\n        g2.setFont(font);\\n        g2.setPaint(getLabelPaint());\\n        FontMetrics fm = g2.getFontMetrics();\\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\\n        Shape hotspot = null;\\n        \\n        if (edge == RectangleEdge.TOP) {\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle(), labelBounds.getCenterX(), \\n                    labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) dataArea.getCenterX();\\n            float labely = (float) (state.getCursor() - insets.getBottom() \\n                    - h \/ 2.0);\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \\n                    + insets.getBottom());\\n        }\\n        else if (edge == RectangleEdge.BOTTOM) {\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle(), labelBounds.getCenterX(), \\n                    labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) dataArea.getCenterX();\\n            float labely = (float) (state.getCursor() + insets.getTop() \\n                    + h \/ 2.0);\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \\n                    + insets.getBottom());\\n        }\\n        else if (edge == RectangleEdge.LEFT) {\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle() - Math.PI \/ 2.0, labelBounds.getCenterX(), \\n                    labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) (state.getCursor() - insets.getRight() \\n                    - w \/ 2.0);\\n            float labely = (float) dataArea.getCenterY();\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle() - Math.PI \/ 2.0, \\n                    TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \\n                    + insets.getRight());\\n        }\\n        else if (edge == RectangleEdge.RIGHT) {\\n\\n            AffineTransform t = AffineTransform.getRotateInstance(\\n                    getLabelAngle() + Math.PI \/ 2.0, \\n                    labelBounds.getCenterX(), labelBounds.getCenterY());\\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\\n            labelBounds = rotatedLabelBounds.getBounds2D();\\n            float w = (float) labelBounds.getWidth();\\n            float h = (float) labelBounds.getHeight();\\n            float labelx = (float) (state.getCursor() \\n                            + insets.getLeft() + w \/ 2.0);\\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \\n                    \/ 2.0);\\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \\n                    TextAnchor.CENTER, getLabelAngle() + Math.PI \/ 2.0, \\n                    TextAnchor.CENTER);\\n            hotspot = new Rectangle2D.Float(labelx - w \/ 2.0f, \\n                    labely - h \/ 2.0f, w, h);\\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \\n                    + insets.getRight());\\n\\n        }\\n        if (plotState != null && hotspot != null) {\\n            ChartRenderingInfo owner = plotState.getOwner();\\n                EntityCollection entities = owner.getEntityCollection();\\n                if (entities != null) {\\n                    entities.add(new AxisLabelEntity(this, hotspot, \\n                            this.labelToolTip, this.labelURL));\\n                }\\n        }\\n        return state;\\n\\n    }\", \"javadoc_start_line\": 1079, \"annotations_start_line\": 1092, \"method_start_line\": 1094, \"end_line\": 1200}"}]},{"name":"Closure","version":2,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeCheckTest\", \"methodName\": \"testBadInterfaceExtendsNonExistentInterfaces\", \"error\": \"java.lang.NullPointerException\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"checkInterfaceConflictProperties\", \"content\": \"  \/**\\n   * Check whether there's any property conflict for for a particular super\\n   * interface\\n   * @param t The node traversal object that supplies context\\n   * @param n The node being visited\\n   * @param functionName The function name being checked\\n   * @param properties The property names in the super interfaces that have\\n   * been visited\\n   * @param currentProperties The property names in the super interface\\n   * that have been visited\\n   * @param interfaceType The super interface that is being visited\\n   *\/\\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\\n      String functionName, HashMap<String, ObjectType> properties,\\n      HashMap<String, ObjectType> currentProperties,\\n      ObjectType interfaceType) {\\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\\n    Set<String> currentPropertyNames;\\n      \/\/ This can be the case if interfaceType is proxy to a non-existent\\n      \/\/ object (which is a bad type annotation, but shouldn't crash).\\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\\n    for (String name : currentPropertyNames) {\\n      ObjectType oType = properties.get(name);\\n      if (oType != null) {\\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\\n            oType.getPropertyType(name))) {\\n          compiler.report(\\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\\n                  functionName, name, oType.toString(),\\n                  interfaceType.toString()));\\n        }\\n      }\\n      currentProperties.put(name, interfaceType);\\n    }\\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\\n      checkInterfaceConflictProperties(t, n, functionName, properties,\\n          currentProperties, iType);\\n    }\\n  }\", \"javadoc_start_line\": 1554, \"annotations_start_line\": 1566, \"method_start_line\": 1569, \"end_line\": 1592}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 378, \"annotations_start_line\": 379, \"method_start_line\": 379, \"end_line\": 396}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Main entry point for this phase of processing. This follows the pattern for\\n   * JSCompiler phases.\\n   *\\n   * @param externsRoot The root of the externs parse tree.\\n   * @param jsRoot The root of the input parse tree to be checked.\\n   *\/\\n  @Override\\n  public void process(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkNotNull(scopeCreator);\\n    Preconditions.checkNotNull(topScope);\\n\\n    Node externsAndJs = jsRoot.getParent();\\n    Preconditions.checkState(externsAndJs != null);\\n    Preconditions.checkState(\\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\\n\\n    if (externsRoot != null) {\\n      check(externsRoot, true);\\n    }\\n    check(jsRoot, false);\\n  }\", \"javadoc_start_line\": 355, \"annotations_start_line\": 362, \"method_start_line\": 363, \"end_line\": 376}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"check\", \"content\": \"  public void check(Node node, boolean externs) {\\n    Preconditions.checkNotNull(node);\\n\\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\\n    inExterns = externs;\\n    t.traverseWithScope(node, topScope);\\n    if (externs) {\\n      inferJSDocInfo.process(node, null);\\n    } else {\\n      inferJSDocInfo.process(null, node);\\n    }\\n  }\", \"javadoc_start_line\": 399, \"annotations_start_line\": 399, \"method_start_line\": 399, \"end_line\": 410}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseWithScope\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively with a scope, starting with the given\\n   * root. This should only be used in the global scope. Otherwise, use\\n   * {@link #traverseAtScope}.\\n   *\/\\n  void traverseWithScope(Node root, Scope s) {\\n    Preconditions.checkState(s.isGlobal());\\n\\n    inputId = null;\\n    sourceName = \\\"\\\";\\n    curNode = root;\\n    pushScope(s);\\n    traverseBranch(root, null);\\n    popScope();\\n  }\", \"javadoc_start_line\": 331, \"annotations_start_line\": 336, \"method_start_line\": 336, \"end_line\": 345}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visit\", \"content\": \"  \/**\\n   * This is the meat of the type checking.  It is basically one big switch,\\n   * with each case representing one type of parse tree node.  The individual\\n   * cases are usually pretty straightforward.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of the node n.\\n   *\/\\n  @Override\\n  public void visit(NodeTraversal t, Node n, Node parent) {\\n    JSType childType;\\n    JSType leftType, rightType;\\n    Node left, right;\\n    \/\/ To be explicitly set to false if the node is not typeable.\\n    boolean typeable = true;\\n\\n    switch (n.getType()) {\\n      case Token.CAST:\\n        Node expr = n.getFirstChild();\\n        ensureTyped(t, n, getJSType(expr));\\n\\n        \/\/ If the cast, tightens the type apply it, so it is available post\\n        \/\/ normalization.\\n        JSType castType = getJSType(n);\\n        JSType exprType = getJSType(expr);\\n        if (castType.isSubtype(exprType)) {\\n          expr.setJSType(castType);\\n        }\\n        break;\\n\\n      case Token.NAME:\\n        typeable = visitName(t, n, parent);\\n        break;\\n\\n      case Token.PARAM_LIST:\\n        typeable = false;\\n        break;\\n\\n      case Token.COMMA:\\n        ensureTyped(t, n, getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.THIS:\\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\\n        break;\\n\\n      case Token.NULL:\\n        ensureTyped(t, n, NULL_TYPE);\\n        break;\\n\\n      case Token.NUMBER:\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.STRING:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.STRING_KEY:\\n        typeable = false;\\n        break;\\n\\n      case Token.GETTER_DEF:\\n      case Token.SETTER_DEF:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        ensureTyped(t, n, ARRAY_TYPE);\\n        break;\\n\\n      case Token.REGEXP:\\n        ensureTyped(t, n, REGEXP_TYPE);\\n        break;\\n\\n      case Token.GETPROP:\\n        visitGetProp(t, n, parent);\\n        typeable = !(parent.isAssign() &&\\n                     parent.getFirstChild() == n);\\n        break;\\n\\n      case Token.GETELEM:\\n        visitGetElem(t, n);\\n        \/\/ The type of GETELEM is always unknown, so no point counting that.\\n        \/\/ If that unknown leaks elsewhere (say by an assignment to another\\n        \/\/ variable), then it will be counted.\\n        typeable = false;\\n        break;\\n\\n      case Token.VAR:\\n        visitVar(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.NEW:\\n        visitNew(t, n);\\n        break;\\n\\n      case Token.CALL:\\n        visitCall(t, n);\\n        typeable = !parent.isExprResult();\\n        break;\\n\\n      case Token.RETURN:\\n        visitReturn(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.DEC:\\n      case Token.INC:\\n        left = n.getFirstChild();\\n        checkPropCreation(t, left);\\n        validator.expectNumber(t, left, getJSType(left), \\\"increment\/decrement\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.NOT:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.VOID:\\n        ensureTyped(t, n, VOID_TYPE);\\n        break;\\n\\n      case Token.TYPEOF:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.BITNOT:\\n        childType = getJSType(n.getFirstChild());\\n        if (!childType.matchesInt32Context()) {\\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\\n              childType.toString());\\n        }\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        left = n.getFirstChild();\\n        validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.EQ:\\n      case Token.NE:\\n      case Token.SHEQ:\\n      case Token.SHNE: {\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n\\n        if (left.isTypeOf()) {\\n          if (right.isString()) {\\n            checkTypeofString(t, right, right.getString());\\n          }\\n        } else if (right.isTypeOf() && left.isString()) {\\n          checkTypeofString(t, left, left.getString());\\n        }\\n\\n        leftType = getJSType(left);\\n        rightType = getJSType(right);\\n\\n        \/\/ We do not want to warn about explicit comparisons to VOID. People\\n        \/\/ often do this if they think their type annotations screwed up.\\n        \/\/\\n        \/\/ We do want to warn about cases where people compare things like\\n        \/\/ (Array|null) == (Function|null)\\n        \/\/ because it probably means they screwed up.\\n        \/\/\\n        \/\/ This heuristic here is not perfect, but should catch cases we\\n        \/\/ care about without too many false negatives.\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n\\n        TernaryValue result = TernaryValue.UNKNOWN;\\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\\n          if (n.isNE()) {\\n            result = result.not();\\n          }\\n        } else {\\n          \/\/ SHEQ or SHNE\\n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\\n                  rightTypeRestricted)) {\\n            result = n.getType() == Token.SHEQ ?\\n                TernaryValue.FALSE : TernaryValue.TRUE;\\n          }\\n        }\\n\\n        if (result != TernaryValue.UNKNOWN) {\\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\\n              rightType.toString(), result.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n        if (rightType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, leftType, \\\"left side of numeric comparison\\\");\\n        } else if (leftType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, rightType, \\\"right side of numeric comparison\\\");\\n        } else if (leftType.matchesNumberContext() &&\\n                   rightType.matchesNumberContext()) {\\n          \/\/ OK.\\n        } else {\\n          \/\/ Whether the comparison is numeric will be determined at runtime\\n          \/\/ each time the expression is evaluated. Regardless, both operands\\n          \/\/ should match a string context.\\n          String message = \\\"left side of comparison\\\";\\n          validator.expectString(t, n, leftType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, leftType, message, getNativeType(STRING_TYPE));\\n          message = \\\"right side of comparison\\\";\\n          validator.expectString(t, n, rightType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, rightType, message, getNativeType(STRING_TYPE));\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.IN:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        rightType = getJSType(right);\\n        validator.expectString(t, left, getJSType(left), \\\"left side of 'in'\\\");\\n        validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\");\\n        if (rightType.isStruct()) {\\n          report(t, right, IN_USED_WITH_STRUCT);\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.INSTANCEOF:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\\n        validator.expectAnyObject(\\n            t, left, getJSType(left), \\\"deterministic instanceof yields false\\\");\\n        validator.expectActualObject(\\n            t, right, rightType, \\\"instanceof requires an object\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.ASSIGN:\\n        visitAssign(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_MUL:\\n        checkPropCreation(t, n.getFirstChild());\\n        \/\/ fall through\\n\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.BITAND:\\n      case Token.SUB:\\n      case Token.ADD:\\n      case Token.MUL:\\n        visitBinaryOperator(n.getType(), t, n);\\n        break;\\n\\n      case Token.DELPROP:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.CASE:\\n        JSType switchType = getJSType(parent.getFirstChild());\\n        JSType caseType = getJSType(n.getFirstChild());\\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\\n        typeable = false;\\n        break;\\n\\n      case Token.WITH: {\\n        Node child = n.getFirstChild();\\n        childType = getJSType(child);\\n        validator.expectObject(t, child, childType, \\\"with requires an object\\\");\\n        typeable = false;\\n        break;\\n      }\\n\\n      case Token.FUNCTION:\\n        visitFunction(t, n);\\n        break;\\n\\n      \/\/ These nodes have no interesting type behavior.\\n      case Token.LABEL:\\n      case Token.LABEL_NAME:\\n      case Token.SWITCH:\\n      case Token.BREAK:\\n      case Token.CATCH:\\n      case Token.TRY:\\n      case Token.SCRIPT:\\n      case Token.EXPR_RESULT:\\n      case Token.BLOCK:\\n      case Token.EMPTY:\\n      case Token.DEFAULT_CASE:\\n      case Token.CONTINUE:\\n      case Token.DEBUGGER:\\n      case Token.THROW:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes require data flow analysis.\\n      case Token.DO:\\n      case Token.IF:\\n      case Token.WHILE:\\n        typeable = false;\\n        break;\\n\\n      case Token.FOR:\\n        if (NodeUtil.isForIn(n)) {\\n          Node obj = n.getChildAtIndex(1);\\n          if (getJSType(obj).isStruct()) {\\n            report(t, obj, IN_USED_WITH_STRUCT);\\n          }\\n        }\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes are typed during the type inference.\\n      case Token.AND:\\n      case Token.HOOK:\\n      case Token.OBJECTLIT:\\n      case Token.OR:\\n        if (n.getJSType() != null) { \/\/ If we didn't run type inference.\\n          ensureTyped(t, n);\\n        } else {\\n          \/\/ If this is an enum, then give that type to the objectlit as well.\\n          if ((n.isObjectLit())\\n              && (parent.getJSType() instanceof EnumType)) {\\n            ensureTyped(t, n, parent.getJSType());\\n          } else {\\n            ensureTyped(t, n);\\n          }\\n        }\\n        if (n.isObjectLit()) {\\n          JSType typ = getJSType(n);\\n          for (Node key : n.children()) {\\n            visitObjLitKey(t, key, n, typ);\\n          }\\n        }\\n        break;\\n\\n      default:\\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\\n        ensureTyped(t, n);\\n        break;\\n    }\\n\\n    \/\/ Don't count externs since the user's code may not even use that part.\\n    typeable = typeable && !inExterns;\\n\\n    if (typeable) {\\n      doPercentTypedAccounting(t, n);\\n    }\\n\\n    checkNoTypeCheckSection(n, false);\\n  }\", \"javadoc_start_line\": 467, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 854}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitFunction\", \"content\": \"  \/**\\n   * Visits a {@link Token#FUNCTION} node.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   *\/\\n  private void visitFunction(NodeTraversal t, Node n) {\\n    FunctionType functionType = JSType.toMaybeFunctionType(n.getJSType());\\n    String functionPrivateName = n.getFirstChild().getString();\\n    if (functionType.isConstructor()) {\\n      FunctionType baseConstructor = functionType.getSuperClassConstructor();\\n      if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\\n          baseConstructor != null &&\\n          baseConstructor.isInterface()) {\\n        compiler.report(\\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE,\\n                        \\\"constructor\\\", functionPrivateName));\\n      } else {\\n        if (baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE)) {\\n          ObjectType proto = functionType.getPrototype();\\n          if (functionType.makesStructs() && !proto.isStruct()) {\\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\\n                                        \\\"struct\\\", functionPrivateName));\\n          } else if (functionType.makesDicts() && !proto.isDict()) {\\n            compiler.report(t.makeError(n, CONFLICTING_EXTENDED_TYPE,\\n                                        \\\"dict\\\", functionPrivateName));\\n          }\\n        }\\n        \/\/ All interfaces are properly implemented by a class\\n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\\n          boolean badImplementedType = false;\\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\\n          if (baseInterfaceObj != null) {\\n            FunctionType interfaceConstructor =\\n              baseInterfaceObj.getConstructor();\\n            if (interfaceConstructor != null &&\\n                !interfaceConstructor.isInterface()) {\\n              badImplementedType = true;\\n            }\\n          } else {\\n            badImplementedType = true;\\n          }\\n          if (badImplementedType) {\\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\\n          }\\n        }\\n        \/\/ check properties\\n        validator.expectAllInterfaceProperties(t, n, functionType);\\n      }\\n    } else if (functionType.isInterface()) {\\n      \/\/ Interface must extend only interfaces\\n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\\n        if (extInterface.getConstructor() != null\\n            && !extInterface.getConstructor().isInterface()) {\\n          compiler.report(\\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE,\\n                          \\\"interface\\\", functionPrivateName));\\n        }\\n      }\\n\\n      \/\/ Check whether the extended interfaces have any conflicts\\n      if (functionType.getExtendedInterfacesCount() > 1) {\\n        \/\/ Only check when extending more than one interfaces\\n        HashMap<String, ObjectType> properties\\n            = new HashMap<String, ObjectType>();\\n        HashMap<String, ObjectType> currentProperties\\n            = new HashMap<String, ObjectType>();\\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\\n          currentProperties.clear();\\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\\n              properties, currentProperties, interfaceType);\\n          properties.putAll(currentProperties);\\n        }\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 1594, \"annotations_start_line\": 1601, \"method_start_line\": 1601, \"end_line\": 1670}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"checkInterfaceConflictProperties\", \"content\": \"  \/**\\n   * Check whether there's any property conflict for for a particular super\\n   * interface\\n   * @param t The node traversal object that supplies context\\n   * @param n The node being visited\\n   * @param functionName The function name being checked\\n   * @param properties The property names in the super interfaces that have\\n   * been visited\\n   * @param currentProperties The property names in the super interface\\n   * that have been visited\\n   * @param interfaceType The super interface that is being visited\\n   *\/\\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\\n      String functionName, HashMap<String, ObjectType> properties,\\n      HashMap<String, ObjectType> currentProperties,\\n      ObjectType interfaceType) {\\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\\n    Set<String> currentPropertyNames;\\n      \/\/ This can be the case if interfaceType is proxy to a non-existent\\n      \/\/ object (which is a bad type annotation, but shouldn't crash).\\n      currentPropertyNames = implicitProto.getOwnPropertyNames();\\n    for (String name : currentPropertyNames) {\\n      ObjectType oType = properties.get(name);\\n      if (oType != null) {\\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\\n            oType.getPropertyType(name))) {\\n          compiler.report(\\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\\n                  functionName, name, oType.toString(),\\n                  interfaceType.toString()));\\n        }\\n      }\\n      currentProperties.put(name, interfaceType);\\n    }\\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\\n      checkInterfaceConflictProperties(t, n, functionName, properties,\\n          currentProperties, iType);\\n    }\\n  }\", \"javadoc_start_line\": 1554, \"annotations_start_line\": 1566, \"method_start_line\": 1569, \"end_line\": 1592}"}]},{"name":"Closure","version":3,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.FlowSensitiveInlineVariablesTest\", \"methodName\": \"testDoNotInlineCatchExpression1a\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/FlowSensitiveInlineVariables.java\", \"method_name\": \"enterScope\", \"content\": \"  public void enterScope(NodeTraversal t) {\\n\\n    if (t.inGlobalScope()) {\\n      return; \/\/ Don't even brother. All global variables are likely escaped.\\n    }\\n\\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\\n        t.getScope().getVarCount()) {\\n      return;\\n    }\\n\\n    \/\/ Compute the forward reaching definition.\\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\\n    \/\/ Process the body of the function.\\n    Preconditions.checkState(t.getScopeRoot().isFunction());\\n    cfa.process(null, t.getScopeRoot().getLastChild());\\n    cfg = cfa.getCfg();\\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\\n    reachingDef.analyze();\\n    candidates = Lists.newLinkedList();\\n\\n    \/\/ Using the forward reaching definition search to find all the inline\\n    \/\/ candidates\\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\\n        t.getScopeRoot().getLastChild());\\n\\n    \/\/ Compute the backward reaching use. The CFG can be reused.\\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\\n    reachingUses.analyze();\\n    for (Candidate c : candidates) {\\n      if (c.canInline()) {\\n        c.inlineVariable();\\n\\n        \/\/ If definition c has dependencies, then inlining it may have\\n        \/\/ introduced new dependencies for our other inlining candidates.\\n        \/\/\\n        \/\/ MustBeReachingVariableDef uses this dependency graph in its\\n        \/\/ analysis, so some of these candidates may no longer be valid.\\n        \/\/ We keep track of when the variable dependency graph changed\\n        \/\/ so that we can back off appropriately.\\n        if (!c.defMetadata.depends.isEmpty()) {\\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\\n        }\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 125, \"annotations_start_line\": 124, \"method_start_line\": 125, \"end_line\": 170}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  public void traverseRoots(Node ... roots) {\\n    traverseRoots(Lists.newArrayList(roots));\\n  }\", \"javadoc_start_line\": 284, \"annotations_start_line\": 284, \"method_start_line\": 284, \"end_line\": 286}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  public void traverseRoots(List<Node> roots) {\\n    if (roots.isEmpty()) {\\n      return;\\n    }\\n\\n    try {\\n      Node scopeRoot = roots.get(0).getParent();\\n      Preconditions.checkState(scopeRoot != null);\\n\\n      inputId = NodeUtil.getInputId(scopeRoot);\\n      sourceName = \\\"\\\";\\n      curNode = scopeRoot;\\n      pushScope(scopeRoot);\\n\\n      for (Node root : roots) {\\n        Preconditions.checkState(root.getParent() == scopeRoot);\\n        traverseBranch(root, scopeRoot);\\n      }\\n\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 288, \"annotations_start_line\": 288, \"method_start_line\": 288, \"end_line\": 311}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseFunction\", \"content\": \"  \/**\\n   * Traverses a function.\\n   *\/\\n  private void traverseFunction(Node n, Node parent) {\\n    Preconditions.checkState(n.getChildCount() == 3);\\n    Preconditions.checkState(n.isFunction());\\n\\n    final Node fnName = n.getFirstChild();\\n\\n    boolean isFunctionExpression = (parent != null)\\n        && NodeUtil.isFunctionExpression(n);\\n\\n    if (!isFunctionExpression) {\\n      \/\/ Functions declarations are in the scope containing the declaration.\\n      traverseBranch(fnName, n);\\n    }\\n\\n    curNode = n;\\n    pushScope(n);\\n\\n    if (isFunctionExpression) {\\n      \/\/ Function expression names are only accessible within the function\\n      \/\/ scope.\\n      traverseBranch(fnName, n);\\n    }\\n\\n    final Node args = fnName.getNext();\\n    final Node body = args.getNext();\\n\\n    \/\/ Args\\n    traverseBranch(args, n);\\n\\n    \/\/ Body\\n    Preconditions.checkState(body.getNext() == null &&\\n            body.isBlock(), body);\\n    traverseBranch(body, n);\\n\\n    popScope();\\n  }\", \"javadoc_start_line\": 508, \"annotations_start_line\": 511, \"method_start_line\": 511, \"end_line\": 546}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"pushScope\", \"content\": \"  \/** Creates a new scope (e.g. when entering a function). *\/\\n  private void pushScope(Node node) {\\n    Preconditions.checkState(curNode != null);\\n    scopeRoots.push(node);\\n    cfgs.push(null);\\n    if (scopeCallback != null) {\\n      scopeCallback.enterScope(this);\\n    }\\n  }\", \"javadoc_start_line\": 562, \"annotations_start_line\": 563, \"method_start_line\": 563, \"end_line\": 570}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/FlowSensitiveInlineVariables.java\", \"method_name\": \"enterScope\", \"content\": \"  public void enterScope(NodeTraversal t) {\\n\\n    if (t.inGlobalScope()) {\\n      return; \/\/ Don't even brother. All global variables are likely escaped.\\n    }\\n\\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\\n        t.getScope().getVarCount()) {\\n      return;\\n    }\\n\\n    \/\/ Compute the forward reaching definition.\\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\\n    \/\/ Process the body of the function.\\n    Preconditions.checkState(t.getScopeRoot().isFunction());\\n    cfa.process(null, t.getScopeRoot().getLastChild());\\n    cfg = cfa.getCfg();\\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\\n    reachingDef.analyze();\\n    candidates = Lists.newLinkedList();\\n\\n    \/\/ Using the forward reaching definition search to find all the inline\\n    \/\/ candidates\\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\\n        t.getScopeRoot().getLastChild());\\n\\n    \/\/ Compute the backward reaching use. The CFG can be reused.\\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\\n    reachingUses.analyze();\\n    for (Candidate c : candidates) {\\n      if (c.canInline()) {\\n        c.inlineVariable();\\n\\n        \/\/ If definition c has dependencies, then inlining it may have\\n        \/\/ introduced new dependencies for our other inlining candidates.\\n        \/\/\\n        \/\/ MustBeReachingVariableDef uses this dependency graph in its\\n        \/\/ analysis, so some of these candidates may no longer be valid.\\n        \/\/ We keep track of when the variable dependency graph changed\\n        \/\/ so that we can back off appropriately.\\n        if (!c.defMetadata.depends.isEmpty()) {\\n          inlinedNewDependencies.add(t.getScope().getVar(c.varName));\\n        }\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 125, \"annotations_start_line\": 124, \"method_start_line\": 125, \"end_line\": 170}"}]},{"name":"Closure","version":4,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeCheckTest\", \"methodName\": \"testImplementsExtendsLoop\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"unexpected warning(s) : JSC_IMPLEMENTS_NON_INTERFACE. can only implement interfaces at [testcode] line 2 : 29, JSC_IMPLEMENTS_NON_INTERFACE. can only implement interfaces at [testcode] line 3 : 26 expected:<1> but was:<2>\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/NamedType.java\", \"method_name\": \"resolveInternal\", \"content\": \"  \/**\\n   * Resolve the referenced type within the enclosing scope.\\n   *\/\\n  @Override\\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\\n    \/\/ TODO(user): Investigate whether it is really necessary to keep two\\n    \/\/ different mechanisms for resolving named types, and if so, which order\\n    \/\/ makes more sense. Now, resolution via registry is first in order to\\n    \/\/ avoid triggering the warnings built into the resolution via properties.\\n    boolean resolved = resolveViaRegistry(t, enclosing);\\n    if (detectImplicitPrototypeCycle()) {\\n      handleTypeCycle(t);\\n    }\\n\\n    if (resolved) {\\n      super.resolveInternal(t, enclosing);\\n      finishPropertyContinuations();\\n      return registry.isLastGeneration() ?\\n          getReferencedType() : this;\\n    }\\n\\n    resolveViaProperties(t, enclosing);\\n    if (detectImplicitPrototypeCycle()) {\\n      handleTypeCycle(t);\\n    }\\n\\n    super.resolveInternal(t, enclosing);\\n    if (isResolved()) {\\n      finishPropertyContinuations();\\n    }\\n    return registry.isLastGeneration() ?\\n        getReferencedType() : this;\\n  }\", \"javadoc_start_line\": 180, \"annotations_start_line\": 183, \"method_start_line\": 184, \"end_line\": 212}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 371, \"annotations_start_line\": 372, \"method_start_line\": 372, \"end_line\": 389}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/MemoizedScopeCreator.java\", \"method_name\": \"createScope\", \"content\": \"  public Scope createScope(Node n, Scope parent) {\\n    Scope scope = scopes.get(n);\\n    if (scope == null) {\\n      scope = delegate.createScope(n, parent);\\n      scopes.put(n, scope);\\n    } else {\\n      Preconditions.checkState(parent == scope.getParent());\\n    }\\n    return scope;\\n  }\", \"javadoc_start_line\": 79, \"annotations_start_line\": 78, \"method_start_line\": 79, \"end_line\": 88}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypedScopeCreator.java\", \"method_name\": \"createScope\", \"content\": \"  \/**\\n   * Creates a scope with all types declared. Declares newly discovered types\\n   * and type properties in the type registry.\\n   *\/\\n  @Override\\n  public Scope createScope(Node root, Scope parent) {\\n    \/\/ Constructing the global scope is very different than constructing\\n    \/\/ inner scopes, because only global scopes can contain named classes that\\n    \/\/ show up in the type registry.\\n    Scope newScope = null;\\n    AbstractScopeBuilder scopeBuilder = null;\\n    if (parent == null) {\\n      JSType globalThis =\\n          typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\\n\\n      \/\/ Mark the main root, the externs root, and the src root\\n      \/\/ with the global this type.\\n      root.setJSType(globalThis);\\n      root.getFirstChild().setJSType(globalThis);\\n      root.getLastChild().setJSType(globalThis);\\n\\n      \/\/ Run a first-order analysis over the syntax tree.\\n      (new FirstOrderFunctionAnalyzer(compiler, functionAnalysisResults))\\n          .process(root.getFirstChild(), root.getLastChild());\\n\\n      \/\/ Find all the classes in the global scope.\\n      newScope = createInitialScope(root);\\n\\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\\n      scopeBuilder = globalScopeBuilder;\\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\\n    } else {\\n      newScope = new Scope(parent, root);\\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\\n      scopeBuilder = localScopeBuilder;\\n      localScopeBuilder.build();\\n    }\\n\\n    scopeBuilder.resolveStubDeclarations();\\n    scopeBuilder.resolveTypes();\\n\\n    \/\/ Gather the properties in each function that we found in the\\n    \/\/ global scope, if that function has a @this type that we can\\n    \/\/ build properties on.\\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\\n      JSType type = functionNode.getJSType();\\n      if (type != null && type.isFunctionType()) {\\n        FunctionType fnType = type.toMaybeFunctionType();\\n        JSType fnThisType = fnType.getTypeOfThis();\\n        if (!fnThisType.isUnknownType()) {\\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\\n              scopeBuilder.new CollectProperties(fnThisType));\\n        }\\n      }\\n    }\\n\\n    if (parent == null) {\\n      codingConvention.defineDelegateProxyPrototypeProperties(\\n          typeRegistry, newScope, delegateProxyPrototypes,\\n          delegateCallingConventions);\\n    }\\n    return newScope;\\n  }\", \"javadoc_start_line\": 193, \"annotations_start_line\": 197, \"method_start_line\": 198, \"end_line\": 255}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/JSType.java\", \"method_name\": \"resolve\", \"content\": \"  \/**\\n   * Resolve this type in the given scope.\\n   *\\n   * The returned value must be equal to {@code this}, as defined by\\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\\n   * may modify the internal state of {@code this}, as long as it does\\n   * so in a way that preserves Object equality.\\n   *\\n   * For efficiency, we should only resolve a type once per compilation job.\\n   * For incremental compilations, one compilation job may need the\\n   * artifacts from a previous generation, so we will eventually need\\n   * a generational flag instead of a boolean one.\\n   *\/\\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\\n    if (resolved) {\\n      \/\/ TODO(nicksantos): Check to see if resolve() looped back on itself.\\n      \/\/ Preconditions.checkNotNull(resolveResult);\\n      if (resolveResult == null) {\\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\\n      }\\n      return resolveResult;\\n    }\\n    resolved = true;\\n    resolveResult = resolveInternal(t, scope);\\n    resolveResult.setResolvedTypeInternal(resolveResult);\\n    return resolveResult;\\n  }\", \"javadoc_start_line\": 1406, \"annotations_start_line\": 1419, \"method_start_line\": 1419, \"end_line\": 1432}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/FunctionType.java\", \"method_name\": \"resolveInternal\", \"content\": \"  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\\n    setResolvedTypeInternal(this);\\n\\n    call = (ArrowType) safeResolve(call, t, scope);\\n    if (prototypeSlot != null) {\\n      prototypeSlot.setType(\\n          safeResolve(prototypeSlot.getType(), t, scope));\\n    }\\n\\n    \/\/ Warning about typeOfThis if it doesn't resolve to an ObjectType\\n    \/\/ is handled further upstream.\\n    \/\/\\n    \/\/ TODO(nicksantos): Handle this correctly if we have a UnionType.\\n    \/\/\\n    \/\/ TODO(nicksantos): In ES3, the run-time coerces \\\"null\\\" to the global\\n    \/\/ activation object. In ES5, it leaves it as null. Just punt on this\\n    \/\/ issue for now by coercing out null. This is complicated by the\\n    \/\/ fact that when most people write @this {Foo}, they really don't\\n    \/\/ mean \\\"nullable Foo\\\". For certain tags (like @extends) we de-nullify\\n    \/\/ the name for them.\\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\\n    if (maybeTypeOfThis != null) {\\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\\n    }\\n    if (maybeTypeOfThis instanceof ObjectType) {\\n      typeOfThis = maybeTypeOfThis;\\n    }\\n\\n    boolean changed = false;\\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\\n        ImmutableList.builder();\\n    for (ObjectType iface : implementedInterfaces) {\\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\\n      resolvedInterfaces.add(resolvedIface);\\n      changed |= (resolvedIface != iface);\\n    }\\n    if (changed) {\\n      implementedInterfaces = resolvedInterfaces.build();\\n    }\\n\\n    if (subTypes != null) {\\n      for (int i = 0; i < subTypes.size(); i++) {\\n        subTypes.set(\\n            i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope)));\\n      }\\n    }\\n\\n    return super.resolveInternal(t, scope);\\n  }\", \"javadoc_start_line\": 1159, \"annotations_start_line\": 1158, \"method_start_line\": 1159, \"end_line\": 1207}"}]},{"name":"Closure","version":5,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.InlineObjectLiteralsTest\", \"methodName\": \"testNoInlineDeletedProperties\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/InlineObjectLiterals.java\", \"method_name\": \"isInlinableObject\", \"content\": \"    \/**\\n     * Counts the number of direct (full) references to an object.\\n     * Specifically, we check for references of the following type:\\n     * <pre>\\n     *   x;\\n     *   x.fn();\\n     * <\/pre>\\n     *\/\\n    private boolean isInlinableObject(List<Reference> refs) {\\n      boolean ret = false;\\n      Set<String> validProperties = Sets.newHashSet();\\n      for (Reference ref : refs) {\\n        Node name = ref.getNode();\\n        Node parent = ref.getParent();\\n        Node gramps = ref.getGrandparent();\\n\\n        \/\/ Ignore most indirect references, like x.y (but not x.y(),\\n        \/\/ since the function referenced by y might reference 'this').\\n        \/\/\\n        if (parent.isGetProp()) {\\n          Preconditions.checkState(parent.getFirstChild() == name);\\n          \/\/ A call target may be using the object as a 'this' value.\\n          if (gramps.isCall()\\n              && gramps.getFirstChild() == parent) {\\n            return false;\\n          }\\n\\n          \/\/ Deleting a property has different semantics from deleting\\n          \/\/ a variable, so deleted properties should not be inlined.\\n\\n          \/\/ NOTE(nicksantos): This pass's object-splitting algorithm has\\n          \/\/ a blind spot. It assumes that if a property isn't defined on an\\n          \/\/ object, then the value is undefined. This is not true, because\\n          \/\/ Object.prototype can have arbitrary properties on it.\\n          \/\/\\n          \/\/ We short-circuit this problem by bailing out if we see a reference\\n          \/\/ to a property that isn't defined on the object literal. This\\n          \/\/ isn't a perfect algorithm, but it should catch most cases.\\n          String propName = parent.getLastChild().getString();\\n          if (!validProperties.contains(propName)) {\\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\\n              validProperties.add(propName);\\n            } else {\\n              return false;\\n            }\\n          }\\n          continue;\\n        }\\n\\n        \/\/ Only rewrite VAR declarations or simple assignment statements\\n        if (!isVarOrAssignExprLhs(name)) {\\n           return false;\\n        }\\n\\n        Node val = ref.getAssignedValue();\\n        if (val == null) {\\n          \/\/ A var with no assignment.\\n          continue;\\n        }\\n\\n        \/\/ We're looking for object literal assignments only.\\n        if (!val.isObjectLit()) {\\n          return false;\\n        }\\n\\n        \/\/ Make sure that the value is not self-referential. IOW,\\n        \/\/ disallow things like x = {b: x.a}.\\n        \/\/\\n        \/\/ TODO: Only exclude unorderable self-referential\\n        \/\/ assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\\n        \/\/ but x = {a: 1, b: x.a} is.\\n        \/\/\\n        \/\/ Also, ES5 getters\/setters aren't handled by this pass.\\n        for (Node child = val.getFirstChild(); child != null;\\n             child = child.getNext()) {\\n          if (child.isGetterDef() ||\\n              child.isSetterDef()) {\\n            \/\/ ES5 get\/set not supported.\\n            return false;\\n          }\\n\\n          validProperties.add(child.getString());\\n\\n          Node childVal = child.getFirstChild();\\n          \/\/ Check if childVal is the parent of any of the passed in\\n          \/\/ references, as that is how self-referential assignments\\n          \/\/ will happen.\\n          for (Reference t : refs) {\\n            Node refNode = t.getParent();\\n            while (!NodeUtil.isStatementBlock(refNode)) {\\n              if (refNode == childVal) {\\n                \/\/ There's a self-referential assignment\\n                return false;\\n              }\\n              refNode = refNode.getParent();\\n            }\\n          }\\n        }\\n\\n\\n        \/\/ We have found an acceptable object literal assignment. As\\n        \/\/ long as there are no other assignments that mess things up,\\n        \/\/ we can inline.\\n        ret = true;\\n      }\\n      return ret;\\n    }\", \"javadoc_start_line\": 147, \"annotations_start_line\": 155, \"method_start_line\": 155, \"end_line\": 253}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/InlineObjectLiterals.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\\n        compiler, new InliningBehavior());\\n    callback.process(externs, root);\\n  }\", \"javadoc_start_line\": 64, \"annotations_start_line\": 63, \"method_start_line\": 64, \"end_line\": 68}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Convenience method for running this pass over a tree with this\\n   * class as a callback.\\n   *\/\\n  @Override\\n  public void process(Node externs, Node root) {\\n    NodeTraversal.traverseRoots(\\n        compiler, Lists.newArrayList(externs, root), this);\\n  }\", \"javadoc_start_line\": 104, \"annotations_start_line\": 108, \"method_start_line\": 109, \"end_line\": 112}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  \/**\\n   * Traverses a list of node trees.\\n   *\/\\n  public static void traverseRoots(\\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverseRoots(roots);\\n  }\", \"javadoc_start_line\": 459, \"annotations_start_line\": 462, \"method_start_line\": 463, \"end_line\": 466}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  public void traverseRoots(List<Node> roots) {\\n    if (roots.isEmpty()) {\\n      return;\\n    }\\n\\n    try {\\n      Node scopeRoot = roots.get(0).getParent();\\n      Preconditions.checkState(scopeRoot != null);\\n\\n      inputId = NodeUtil.getInputId(scopeRoot);\\n      sourceName = \\\"\\\";\\n      curNode = scopeRoot;\\n      pushScope(scopeRoot);\\n\\n      for (Node root : roots) {\\n        Preconditions.checkState(root.getParent() == scopeRoot);\\n        traverseBranch(root, scopeRoot);\\n      }\\n\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 288, \"annotations_start_line\": 288, \"method_start_line\": 288, \"end_line\": 311}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseFunction\", \"content\": \"  \/**\\n   * Traverses a function.\\n   *\/\\n  private void traverseFunction(Node n, Node parent) {\\n    Preconditions.checkState(n.getChildCount() == 3);\\n    Preconditions.checkState(n.isFunction());\\n\\n    final Node fnName = n.getFirstChild();\\n\\n    boolean isFunctionExpression = (parent != null)\\n        && NodeUtil.isFunctionExpression(n);\\n\\n    if (!isFunctionExpression) {\\n      \/\/ Functions declarations are in the scope containing the declaration.\\n      traverseBranch(fnName, n);\\n    }\\n\\n    curNode = n;\\n    pushScope(n);\\n\\n    if (isFunctionExpression) {\\n      \/\/ Function expression names are only accessible within the function\\n      \/\/ scope.\\n      traverseBranch(fnName, n);\\n    }\\n\\n    final Node args = fnName.getNext();\\n    final Node body = args.getNext();\\n\\n    \/\/ Args\\n    traverseBranch(args, n);\\n\\n    \/\/ Body\\n    Preconditions.checkState(body.getNext() == null &&\\n            body.isBlock(), body);\\n    traverseBranch(body, n);\\n\\n    popScope();\\n  }\", \"javadoc_start_line\": 508, \"annotations_start_line\": 511, \"method_start_line\": 511, \"end_line\": 546}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"popScope\", \"content\": \"  \/** Pops back to the previous scope (e.g. when leaving a function). *\/\\n  private void popScope() {\\n    if (scopeCallback != null) {\\n      scopeCallback.exitScope(this);\\n    }\\n    if (scopeRoots.isEmpty()) {\\n      scopes.pop();\\n    } else {\\n      scopeRoots.pop();\\n    }\\n    cfgs.pop();\\n  }\", \"javadoc_start_line\": 582, \"annotations_start_line\": 583, \"method_start_line\": 583, \"end_line\": 593}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"exitScope\", \"content\": \"  \/**\\n   * Updates block stack and invokes any additional behavior.\\n   *\/\\n  @Override\\n  public void exitScope(NodeTraversal t) {\\n    blockStack.pop();\\n    if (t.getScope().isGlobal()) {\\n      \/\/ Update global scope reference lists when we are done with it.\\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\\n    } else {\\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\\n    }\\n  }\", \"javadoc_start_line\": 176, \"annotations_start_line\": 179, \"method_start_line\": 180, \"end_line\": 189}"}]},{"name":"Closure","version":6,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.LooseTypeCheckTest\", \"methodName\": \"testTypeRedefinition\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<2> but was:<1>\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeValidator.java\", \"method_name\": \"expectCanAssignTo\", \"content\": \"  \/**\\n   * Expect that the first type can be assigned to a symbol of the second\\n   * type.\\n   *\\n   * @param t The node traversal.\\n   * @param n The node to issue warnings on.\\n   * @param rightType The type on the RHS of the assign.\\n   * @param leftType The type of the symbol on the LHS of the assign.\\n   * @param msg An extra message for the mismatch warning, if necessary.\\n   * @return True if the types matched, false otherwise.\\n   *\/\\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\\n      JSType leftType, String msg) {\\n    if (!rightType.canAssignTo(leftType)) {\\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\\n        registerMismatch(rightType, leftType, null);\\n      } else {\\n      mismatch(t, n, msg, rightType, leftType);\\n      }\\n      return false;\\n    }\\n    return true;\\n  }\", \"javadoc_start_line\": 391, \"annotations_start_line\": 402, \"method_start_line\": 403, \"end_line\": 413}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 371, \"annotations_start_line\": 372, \"method_start_line\": 372, \"end_line\": 389}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Main entry point for this phase of processing. This follows the pattern for\\n   * JSCompiler phases.\\n   *\\n   * @param externsRoot The root of the externs parse tree.\\n   * @param jsRoot The root of the input parse tree to be checked.\\n   *\/\\n  @Override\\n  public void process(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkNotNull(scopeCreator);\\n    Preconditions.checkNotNull(topScope);\\n\\n    Node externsAndJs = jsRoot.getParent();\\n    Preconditions.checkState(externsAndJs != null);\\n    Preconditions.checkState(\\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\\n\\n    if (externsRoot != null) {\\n      check(externsRoot, true);\\n    }\\n    check(jsRoot, false);\\n  }\", \"javadoc_start_line\": 348, \"annotations_start_line\": 355, \"method_start_line\": 356, \"end_line\": 369}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"check\", \"content\": \"  public void check(Node node, boolean externs) {\\n    Preconditions.checkNotNull(node);\\n\\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\\n    inExterns = externs;\\n    t.traverseWithScope(node, topScope);\\n    if (externs) {\\n      inferJSDocInfo.process(node, null);\\n    } else {\\n      inferJSDocInfo.process(null, node);\\n    }\\n  }\", \"javadoc_start_line\": 392, \"annotations_start_line\": 392, \"method_start_line\": 392, \"end_line\": 403}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseWithScope\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively with a scope, starting with the given\\n   * root. This should only be used in the global scope. Otherwise, use\\n   * {@link #traverseAtScope}.\\n   *\/\\n  void traverseWithScope(Node root, Scope s) {\\n    Preconditions.checkState(s.isGlobal());\\n\\n    inputId = null;\\n    sourceName = \\\"\\\";\\n    curNode = root;\\n    pushScope(s);\\n    traverseBranch(root, null);\\n    popScope();\\n  }\", \"javadoc_start_line\": 331, \"annotations_start_line\": 336, \"method_start_line\": 336, \"end_line\": 345}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visit\", \"content\": \"  \/**\\n   * This is the meat of the type checking.  It is basically one big switch,\\n   * with each case representing one type of parse tree node.  The individual\\n   * cases are usually pretty straightforward.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of the node n.\\n   *\/\\n  @Override\\n  public void visit(NodeTraversal t, Node n, Node parent) {\\n    JSType childType;\\n    JSType leftType, rightType;\\n    Node left, right;\\n    \/\/ To be explicitly set to false if the node is not typeable.\\n    boolean typeable = true;\\n\\n    switch (n.getType()) {\\n      case Token.NAME:\\n        typeable = visitName(t, n, parent);\\n        break;\\n\\n      case Token.PARAM_LIST:\\n        typeable = false;\\n        break;\\n\\n      case Token.COMMA:\\n        ensureTyped(t, n, getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.THIS:\\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\\n        break;\\n\\n      case Token.NULL:\\n        ensureTyped(t, n, NULL_TYPE);\\n        break;\\n\\n      case Token.NUMBER:\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.STRING:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.STRING_KEY:\\n        typeable = false;\\n        break;\\n\\n      case Token.GETTER_DEF:\\n      case Token.SETTER_DEF:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        ensureTyped(t, n, ARRAY_TYPE);\\n        break;\\n\\n      case Token.REGEXP:\\n        ensureTyped(t, n, REGEXP_TYPE);\\n        break;\\n\\n      case Token.GETPROP:\\n        visitGetProp(t, n, parent);\\n        typeable = !(parent.isAssign() &&\\n                     parent.getFirstChild() == n);\\n        break;\\n\\n      case Token.GETELEM:\\n        visitGetElem(t, n);\\n        \/\/ The type of GETELEM is always unknown, so no point counting that.\\n        \/\/ If that unknown leaks elsewhere (say by an assignment to another\\n        \/\/ variable), then it will be counted.\\n        typeable = false;\\n        break;\\n\\n      case Token.VAR:\\n        visitVar(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.NEW:\\n        visitNew(t, n);\\n        break;\\n\\n      case Token.CALL:\\n        visitCall(t, n);\\n        typeable = !parent.isExprResult();\\n        break;\\n\\n      case Token.RETURN:\\n        visitReturn(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.DEC:\\n      case Token.INC:\\n        left = n.getFirstChild();\\n        checkPropCreation(t, left);\\n        validator.expectNumber(t, left, getJSType(left), \\\"increment\/decrement\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.NOT:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.VOID:\\n        ensureTyped(t, n, VOID_TYPE);\\n        break;\\n\\n      case Token.TYPEOF:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.BITNOT:\\n        childType = getJSType(n.getFirstChild());\\n        if (!childType.matchesInt32Context()) {\\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\\n              childType.toString());\\n        }\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        left = n.getFirstChild();\\n        validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.EQ:\\n      case Token.NE:\\n      case Token.SHEQ:\\n      case Token.SHNE: {\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n\\n        if (left.isTypeOf()) {\\n          if (right.isString()) {\\n            checkTypeofString(t, right, right.getString());\\n          }\\n        } else if (right.isTypeOf() && left.isString()) {\\n          checkTypeofString(t, left, left.getString());\\n        }\\n\\n        leftType = getJSType(left);\\n        rightType = getJSType(right);\\n\\n        \/\/ We do not want to warn about explicit comparisons to VOID. People\\n        \/\/ often do this if they think their type annotations screwed up.\\n        \/\/\\n        \/\/ We do want to warn about cases where people compare things like\\n        \/\/ (Array|null) == (Function|null)\\n        \/\/ because it probably means they screwed up.\\n        \/\/\\n        \/\/ This heuristic here is not perfect, but should catch cases we\\n        \/\/ care about without too many false negatives.\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n\\n        TernaryValue result = TernaryValue.UNKNOWN;\\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\\n          if (n.isNE()) {\\n            result = result.not();\\n          }\\n        } else {\\n          \/\/ SHEQ or SHNE\\n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\\n                  rightTypeRestricted)) {\\n            result = n.getType() == Token.SHEQ ?\\n                TernaryValue.FALSE : TernaryValue.TRUE;\\n          }\\n        }\\n\\n        if (result != TernaryValue.UNKNOWN) {\\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\\n              rightType.toString(), result.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n        if (rightType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, leftType, \\\"left side of numeric comparison\\\");\\n        } else if (leftType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, rightType, \\\"right side of numeric comparison\\\");\\n        } else if (leftType.matchesNumberContext() &&\\n                   rightType.matchesNumberContext()) {\\n          \/\/ OK.\\n        } else {\\n          \/\/ Whether the comparison is numeric will be determined at runtime\\n          \/\/ each time the expression is evaluated. Regardless, both operands\\n          \/\/ should match a string context.\\n          String message = \\\"left side of comparison\\\";\\n          validator.expectString(t, n, leftType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, leftType, message, getNativeType(STRING_TYPE));\\n          message = \\\"right side of comparison\\\";\\n          validator.expectString(t, n, rightType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, rightType, message, getNativeType(STRING_TYPE));\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.IN:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        rightType = getJSType(right);\\n        validator.expectString(t, left, getJSType(left), \\\"left side of 'in'\\\");\\n        validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\");\\n        if (rightType.isStruct()) {\\n          report(t, right, IN_USED_WITH_STRUCT);\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.INSTANCEOF:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\\n        validator.expectAnyObject(\\n            t, left, getJSType(left), \\\"deterministic instanceof yields false\\\");\\n        validator.expectActualObject(\\n            t, right, rightType, \\\"instanceof requires an object\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.ASSIGN:\\n        visitAssign(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_MUL:\\n        checkPropCreation(t, n.getFirstChild());\\n        \/\/ fall through\\n\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.BITAND:\\n      case Token.SUB:\\n      case Token.ADD:\\n      case Token.MUL:\\n        visitBinaryOperator(n.getType(), t, n);\\n        break;\\n\\n      case Token.DELPROP:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.CASE:\\n        JSType switchType = getJSType(parent.getFirstChild());\\n        JSType caseType = getJSType(n.getFirstChild());\\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\\n        typeable = false;\\n        break;\\n\\n      case Token.WITH: {\\n        Node child = n.getFirstChild();\\n        childType = getJSType(child);\\n        validator.expectObject(t, child, childType, \\\"with requires an object\\\");\\n        typeable = false;\\n        break;\\n      }\\n\\n      case Token.FUNCTION:\\n        visitFunction(t, n);\\n        break;\\n\\n      \/\/ These nodes have no interesting type behavior.\\n      case Token.LABEL:\\n      case Token.LABEL_NAME:\\n      case Token.SWITCH:\\n      case Token.BREAK:\\n      case Token.CATCH:\\n      case Token.TRY:\\n      case Token.SCRIPT:\\n      case Token.EXPR_RESULT:\\n      case Token.BLOCK:\\n      case Token.EMPTY:\\n      case Token.DEFAULT_CASE:\\n      case Token.CONTINUE:\\n      case Token.DEBUGGER:\\n      case Token.THROW:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes require data flow analysis.\\n      case Token.DO:\\n      case Token.IF:\\n      case Token.WHILE:\\n        typeable = false;\\n        break;\\n\\n      case Token.FOR:\\n        if (NodeUtil.isForIn(n)) {\\n          Node obj = n.getChildAtIndex(1);\\n          if (getJSType(obj).isStruct()) {\\n            report(t, obj, IN_USED_WITH_STRUCT);\\n          }\\n        }\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes are typed during the type inference.\\n      case Token.AND:\\n      case Token.HOOK:\\n      case Token.OBJECTLIT:\\n      case Token.OR:\\n        if (n.getJSType() != null) { \/\/ If we didn't run type inference.\\n          ensureTyped(t, n);\\n        } else {\\n          \/\/ If this is an enum, then give that type to the objectlit as well.\\n          if ((n.isObjectLit())\\n              && (parent.getJSType() instanceof EnumType)) {\\n            ensureTyped(t, n, parent.getJSType());\\n          } else {\\n            ensureTyped(t, n);\\n          }\\n        }\\n        if (n.isObjectLit()) {\\n          for (Node key : n.children()) {\\n            visitObjLitKey(t, key, n);\\n          }\\n        }\\n        break;\\n\\n      default:\\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\\n        ensureTyped(t, n);\\n        break;\\n    }\\n\\n    \/\/ Don't count externs since the user's code may not even use that part.\\n    typeable = typeable && !inExterns;\\n\\n    if (typeable) {\\n      doPercentTypedAccounting(t, n);\\n    }\\n\\n    checkNoTypeCheckSection(n, false);\\n  }\", \"javadoc_start_line\": 460, \"annotations_start_line\": 470, \"method_start_line\": 471, \"end_line\": 833}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitAssign\", \"content\": \"  \/**\\n   * Visits an assignment <code>lvalue = rvalue<\/code>. If the\\n   * <code>lvalue<\/code> is a prototype modification, we change the schema\\n   * of the object type it is referring to.\\n   * @param t the traversal\\n   * @param assign the assign node\\n   * (<code>assign.isAssign()<\/code> is an implicit invariant)\\n   *\/\\n  private void visitAssign(NodeTraversal t, Node assign) {\\n    JSDocInfo info = assign.getJSDocInfo();\\n    Node lvalue = assign.getFirstChild();\\n    Node rvalue = assign.getLastChild();\\n\\n    \/\/ Check property sets to 'object.property' when 'object' is known.\\n    if (lvalue.isGetProp()) {\\n      Node object = lvalue.getFirstChild();\\n      JSType objectJsType = getJSType(object);\\n      Node property = lvalue.getLastChild();\\n      String pname = property.getString();\\n\\n      \/\/ the first name in this getprop refers to an interface\\n      \/\/ we perform checks in addition to the ones below\\n      if (object.isGetProp()) {\\n        JSType jsType = getJSType(object.getFirstChild());\\n        if (jsType.isInterface() &&\\n            object.getLastChild().getString().equals(\\\"prototype\\\")) {\\n          visitInterfaceGetprop(t, assign, object, pname, lvalue, rvalue);\\n        }\\n      }\\n\\n      checkEnumAlias(t, info, rvalue);\\n      checkPropCreation(t, lvalue);\\n\\n      \/\/ Prototype assignments are special, because they actually affect\\n      \/\/ the definition of a class. These are mostly validated\\n      \/\/ during TypedScopeCreator, and we only look for the \\\"dumb\\\" cases here.\\n      \/\/ object.prototype = ...;\\n      if (pname.equals(\\\"prototype\\\")) {\\n        if (objectJsType != null && objectJsType.isFunctionType()) {\\n          FunctionType functionType = objectJsType.toMaybeFunctionType();\\n          if (functionType.isConstructor()) {\\n            JSType rvalueType = rvalue.getJSType();\\n            validator.expectObject(t, rvalue, rvalueType,\\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\\n            \/\/ Only assign structs to the prototype of a @struct constructor\\n            if (functionType.makesStructs() && !rvalueType.isStruct()) {\\n              String funName = functionType.getTypeOfThis().toString();\\n              compiler.report(t.makeError(assign, CONFLICTING_EXTENDED_TYPE,\\n                                          \\\"struct\\\", funName));\\n            }\\n            return;\\n          }\\n        }\\n      }\\n\\n      \/\/ The generic checks for 'object.property' when 'object' is known,\\n      \/\/ and 'property' is declared on it.\\n      \/\/ object.property = ...;\\n      ObjectType type = ObjectType.cast(\\n          objectJsType.restrictByNotNullOrUndefined());\\n      if (type != null) {\\n        if (type.hasProperty(pname) &&\\n            !type.isPropertyTypeInferred(pname) &&\\n            !propertyIsImplicitCast(type, pname)) {\\n          JSType expectedType = type.getPropertyType(pname);\\n          if (!expectedType.isUnknownType()) {\\n            validator.expectCanAssignToPropertyOf(\\n                t, assign, getJSType(rvalue),\\n                expectedType, object, pname);\\n            checkPropertyInheritanceOnGetpropAssign(\\n                t, assign, object, pname, info, expectedType);\\n            return;\\n          }\\n        }\\n      }\\n\\n      \/\/ If we couldn't get the property type with normal object property\\n      \/\/ lookups, then check inheritance anyway with the unknown type.\\n      checkPropertyInheritanceOnGetpropAssign(\\n          t, assign, object, pname, info, getNativeType(UNKNOWN_TYPE));\\n    }\\n\\n    \/\/ Check qualified name sets to 'object' and 'object.property'.\\n    \/\/ This can sometimes handle cases when the type of 'object' is not known.\\n    \/\/ e.g.,\\n    \/\/ var obj = createUnknownType();\\n    \/\/ \/** @type {number} *\/ obj.foo = true;\\n    JSType leftType = getJSType(lvalue);\\n    if (lvalue.isQualifiedName()) {\\n      \/\/ variable with inferred type case\\n      JSType rvalueType = getJSType(assign.getLastChild());\\n      Var var = t.getScope().getVar(lvalue.getQualifiedName());\\n      if (var != null) {\\n        if (var.isTypeInferred()) {\\n          return;\\n        }\\n\\n        if (NodeUtil.getRootOfQualifiedName(lvalue).isThis() &&\\n            t.getScope() != var.getScope()) {\\n          \/\/ Don't look at \\\"this.foo\\\" variables from other scopes.\\n          return;\\n        }\\n\\n        if (var.getType() != null) {\\n          leftType = var.getType();\\n        }\\n      }\\n    }\\n\\n    \/\/ Fall through case for arbitrary LHS and arbitrary RHS.\\n    Node rightChild = assign.getLastChild();\\n    JSType rightType = getJSType(rightChild);\\n    if (validator.expectCanAssignTo(\\n            t, assign, rightType, leftType, \\\"assignment\\\")) {\\n      ensureTyped(t, assign, rightType);\\n    } else {\\n      ensureTyped(t, assign);\\n    }\\n  }\", \"javadoc_start_line\": 862, \"annotations_start_line\": 870, \"method_start_line\": 870, \"end_line\": 980}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"checkEnumAlias\", \"content\": \"  \/**\\n   * <p>Checks enum aliases.\\n   *\\n   * <p>We verify that the enum element type of the enum used\\n   * for initialization is a subtype of the enum element type of\\n   * the enum the value is being copied in.<\/p>\\n   *\\n   * <p>Example:<\/p>\\n   * <pre>var myEnum = myOtherEnum;<\/pre>\\n   *\\n   * <p>Enum aliases are irregular, so we need special code for this :(<\/p>\\n   *\\n   * @param value the value used for initialization of the enum\\n   *\/\\n  private void checkEnumAlias(\\n      NodeTraversal t, JSDocInfo declInfo, Node value) {\\n    if (declInfo == null || !declInfo.hasEnumParameterType()) {\\n      return;\\n    }\\n\\n    JSType valueType = getJSType(value);\\n    if (!valueType.isEnumType()) {\\n      return;\\n    }\\n\\n    EnumType valueEnumType = valueType.toMaybeEnumType();\\n    JSType valueEnumPrimitiveType =\\n        valueEnumType.getElementsType().getPrimitiveType();\\n    validator.expectCanAssignTo(t, value, valueEnumPrimitiveType,\\n        declInfo.getEnumParameterType().evaluate(t.getScope(), typeRegistry),\\n        \\\"incompatible enum element types\\\");\\n  }\", \"javadoc_start_line\": 1844, \"annotations_start_line\": 1858, \"method_start_line\": 1859, \"end_line\": 1875}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeValidator.java\", \"method_name\": \"expectCanAssignTo\", \"content\": \"  \/**\\n   * Expect that the first type can be assigned to a symbol of the second\\n   * type.\\n   *\\n   * @param t The node traversal.\\n   * @param n The node to issue warnings on.\\n   * @param rightType The type on the RHS of the assign.\\n   * @param leftType The type of the symbol on the LHS of the assign.\\n   * @param msg An extra message for the mismatch warning, if necessary.\\n   * @return True if the types matched, false otherwise.\\n   *\/\\n  boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\\n      JSType leftType, String msg) {\\n    if (!rightType.canAssignTo(leftType)) {\\n      if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\\n        registerMismatch(rightType, leftType, null);\\n      } else {\\n      mismatch(t, n, msg, rightType, leftType);\\n      }\\n      return false;\\n    }\\n    return true;\\n  }\", \"javadoc_start_line\": 391, \"annotations_start_line\": 402, \"method_start_line\": 403, \"end_line\": 413}"}]},{"name":"Closure","version":10,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.PeepholeFoldConstantsTest\", \"methodName\": \"testIssue821\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeUtil.java\", \"method_name\": \"mayBeString\", \"content\": \"  static boolean mayBeString(Node n, boolean recurse) {\\n    if (recurse) {\\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\\n    } else {\\n      return mayBeStringHelper(n);\\n    }\\n  }\", \"javadoc_start_line\": 1415, \"annotations_start_line\": 1415, \"method_start_line\": 1415, \"end_line\": 1421}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\\n    compiler.addChangeHandler(handler);\\n    beginTraversal();\\n    traverse(root);\\n    endTraversal();\\n    compiler.removeChangeHandler(handler);\\n  }\", \"javadoc_start_line\": 104, \"annotations_start_line\": 103, \"method_start_line\": 104, \"end_line\": 111}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while(c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 113, \"method_start_line\": 113, \"end_line\": 138}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while(c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 113, \"method_start_line\": 113, \"end_line\": 138}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while(c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 113, \"method_start_line\": 113, \"end_line\": 138}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while(c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 113, \"method_start_line\": 113, \"end_line\": 138}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while(c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 113, \"method_start_line\": 113, \"end_line\": 138}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"visit\", \"content\": \"  public void visit(Node n) {\\n    Node currentVersionOfNode = n;\\n    boolean somethingChanged = false;\\n\\n    do {\\n      somethingChanged = false;\\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\\n        Node newVersionOfNode =\\n            optimization.optimizeSubtree(currentVersionOfNode);\\n\\n        if (newVersionOfNode != currentVersionOfNode) {\\n          somethingChanged = true;\\n\\n          currentVersionOfNode = newVersionOfNode;\\n        }\\n\\n        if (currentVersionOfNode == null) {\\n          return;\\n        }\\n      }\\n    } while(somethingChanged);\\n  }\", \"javadoc_start_line\": 173, \"annotations_start_line\": 173, \"method_start_line\": 173, \"end_line\": 194}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"optimizeSubtree\", \"content\": \"  Node optimizeSubtree(Node subtree) {\\n    switch(subtree.getType()) {\\n      case Token.NEW:\\n        return tryFoldCtorCall(subtree);\\n\\n      case Token.TYPEOF:\\n        return tryFoldTypeof(subtree);\\n\\n      case Token.NOT:\\n      case Token.POS:\\n      case Token.NEG:\\n      case Token.BITNOT:\\n        tryReduceOperandsForOp(subtree);\\n        return tryFoldUnaryOperator(subtree);\\n\\n      case Token.VOID:\\n        return tryReduceVoid(subtree);\\n\\n      default:\\n        tryReduceOperandsForOp(subtree);\\n        return tryFoldBinaryOperator(subtree);\\n    }\\n  }\", \"javadoc_start_line\": 75, \"annotations_start_line\": 74, \"method_start_line\": 75, \"end_line\": 97}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"tryFoldBinaryOperator\", \"content\": \"  private Node tryFoldBinaryOperator(Node subtree) {\\n    Node left = subtree.getFirstChild();\\n\\n    if (left == null) {\\n      return subtree;\\n    }\\n\\n    Node right = left.getNext();\\n\\n    if (right == null) {\\n      return subtree;\\n    }\\n\\n    \/\/ If we've reached here, node is truly a binary operator.\\n    switch(subtree.getType()) {\\n      case Token.GETPROP:\\n        return tryFoldGetProp(subtree, left, right);\\n\\n      case Token.GETELEM:\\n        return tryFoldGetElem(subtree, left, right);\\n\\n      case Token.INSTANCEOF:\\n        return tryFoldInstanceof(subtree, left, right);\\n\\n      case Token.AND:\\n      case Token.OR:\\n        return tryFoldAndOr(subtree, left, right);\\n\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n        return tryFoldShift(subtree, left, right);\\n\\n      case Token.ASSIGN:\\n        return tryFoldAssign(subtree, left, right);\\n\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_MUL:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n        return tryUnfoldAssignOp(subtree, left, right);\\n\\n      case Token.ADD:\\n        return tryFoldAdd(subtree, left, right);\\n\\n      case Token.SUB:\\n      case Token.DIV:\\n      case Token.MOD:\\n        return tryFoldArithmeticOp(subtree, left, right);\\n\\n      case Token.MUL:\\n      case Token.BITAND:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n        Node result = tryFoldArithmeticOp(subtree, left, right);\\n        if (result != subtree) {\\n          return result;\\n        }\\n        return tryFoldLeftChildOp(subtree, left, right);\\n\\n      case Token.LT:\\n      case Token.GT:\\n      case Token.LE:\\n      case Token.GE:\\n      case Token.EQ:\\n      case Token.NE:\\n      case Token.SHEQ:\\n      case Token.SHNE:\\n        return tryFoldComparison(subtree, left, right);\\n\\n      default:\\n        return subtree;\\n    }\\n  }\", \"javadoc_start_line\": 99, \"annotations_start_line\": 99, \"method_start_line\": 99, \"end_line\": 179}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"tryFoldAdd\", \"content\": \"  private Node tryFoldAdd(Node node, Node left, Node right) {\\n    Preconditions.checkArgument(node.isAdd());\\n\\n    if (NodeUtil.mayBeString(node, true)) {\\n      if (NodeUtil.isLiteralValue(left, false) &&\\n          NodeUtil.isLiteralValue(right, false)) {\\n        \/\/ '6' + 7\\n        return tryFoldAddConstantString(node, left, right);\\n      } else {\\n        \/\/ a + 7 or 6 + a\\n        return tryFoldChildAddString(node, left, right);\\n      }\\n    } else {\\n      \/\/ Try arithmetic add\\n      Node result = tryFoldArithmeticOp(node, left, right);\\n      if (result != node) {\\n        return result;\\n      }\\n      return tryFoldLeftChildOp(node, left, right);\\n    }\\n  }\", \"javadoc_start_line\": 827, \"annotations_start_line\": 827, \"method_start_line\": 827, \"end_line\": 847}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"tryFoldLeftChildOp\", \"content\": \"  \/**\\n   * Expressions such as [foo() * 10 * 20] generate parse trees\\n   * where no node has two const children ((foo() * 10) * 20), so\\n   * performArithmeticOp() won't fold it -- tryFoldLeftChildOp() will.\\n   * Specifically, it folds associative expressions where:\\n   *  - The left child is also an associative expression of the same time.\\n   *  - The right child is a constant NUMBER constant.\\n   *  - The left child's right child is a NUMBER constant.\\n   *\/\\n  private Node tryFoldLeftChildOp(Node n, Node left, Node right) {\\n    int opType = n.getType();\\n    Preconditions.checkState(\\n        (NodeUtil.isAssociative(opType) && NodeUtil.isCommutative(opType))\\n        || n.isAdd());\\n\\n    Preconditions.checkState(\\n        !n.isAdd()|| !NodeUtil.mayBeString(n));\\n\\n    \/\/ Use getNumberValue to handle constants like \\\"NaN\\\" and \\\"Infinity\\\"\\n    \/\/ other values are converted to numbers elsewhere.\\n    Double rightValObj = NodeUtil.getNumberValue(right);\\n    if (rightValObj != null && left.getType() == opType) {\\n      Preconditions.checkState(left.getChildCount() == 2);\\n\\n      Node ll = left.getFirstChild();\\n      Node lr = ll.getNext();\\n\\n      Node valueToCombine = ll;\\n      Node replacement = performArithmeticOp(opType, valueToCombine, right);\\n      if (replacement == null) {\\n        valueToCombine = lr;\\n        replacement = performArithmeticOp(opType, valueToCombine, right);\\n      }\\n      if (replacement != null) {\\n        \/\/ Remove the child that has been combined\\n        left.removeChild(valueToCombine);\\n        \/\/ Replace the left op with the remaining child.\\n        n.replaceChild(left, left.removeFirstChild());\\n        \/\/ New \\\"-Infinity\\\" node need location info explicitly\\n        \/\/ added.\\n        replacement.copyInformationFromForTree(right);\\n        n.replaceChild(right, replacement);\\n        reportCodeChange();\\n      }\\n    }\\n\\n    return n;\\n  }\", \"javadoc_start_line\": 778, \"annotations_start_line\": 787, \"method_start_line\": 787, \"end_line\": 825}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeUtil.java\", \"method_name\": \"mayBeString\", \"content\": \"  \/**\\n   * @returns Whether the results is possibly a string.\\n   *\/\\n  static boolean mayBeString(Node n) {\\n    return mayBeString(n, true);\\n  }\", \"javadoc_start_line\": 1408, \"annotations_start_line\": 1411, \"method_start_line\": 1411, \"end_line\": 1413}"}]},{"name":"Closure","version":11,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeCheckTest\", \"methodName\": \"testGetprop4\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected a warning\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitGetProp\", \"content\": \"  \/**\\n   * Visits a GETPROP node.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of <code>n<\/code>\\n   *\/\\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\\n    \/\/ obj.prop or obj.method()\\n    \/\/ Lots of types can appear on the left, a call to a void function can\\n    \/\/ never be on the left. getPropertyType will decide what is acceptable\\n    \/\/ and what isn't.\\n    Node property = n.getLastChild();\\n    Node objNode = n.getFirstChild();\\n    JSType childType = getJSType(objNode);\\n\\n    if (childType.isDict()) {\\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \\\"'.'\\\", \\\"dict\\\");\\n    } else if (n.getJSType() != null && parent.isAssign()) {\\n      return;\\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\\n        \\\"No properties on this expression\\\", getNativeType(OBJECT_TYPE))) {\\n      checkPropertyAccess(childType, property.getString(), t, n);\\n    }\\n    ensureTyped(t, n);\\n  }\", \"javadoc_start_line\": 1295, \"annotations_start_line\": 1303, \"method_start_line\": 1303, \"end_line\": 1321}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 360, \"annotations_start_line\": 361, \"method_start_line\": 361, \"end_line\": 378}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Main entry point for this phase of processing. This follows the pattern for\\n   * JSCompiler phases.\\n   *\\n   * @param externsRoot The root of the externs parse tree.\\n   * @param jsRoot The root of the input parse tree to be checked.\\n   *\/\\n  @Override\\n  public void process(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkNotNull(scopeCreator);\\n    Preconditions.checkNotNull(topScope);\\n\\n    Node externsAndJs = jsRoot.getParent();\\n    Preconditions.checkState(externsAndJs != null);\\n    Preconditions.checkState(\\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\\n\\n    if (externsRoot != null) {\\n      check(externsRoot, true);\\n    }\\n    check(jsRoot, false);\\n  }\", \"javadoc_start_line\": 337, \"annotations_start_line\": 344, \"method_start_line\": 345, \"end_line\": 358}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"check\", \"content\": \"  public void check(Node node, boolean externs) {\\n    Preconditions.checkNotNull(node);\\n\\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\\n    inExterns = externs;\\n    t.traverseWithScope(node, topScope);\\n    if (externs) {\\n      inferJSDocInfo.process(node, null);\\n    } else {\\n      inferJSDocInfo.process(null, node);\\n    }\\n  }\", \"javadoc_start_line\": 381, \"annotations_start_line\": 381, \"method_start_line\": 381, \"end_line\": 392}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseWithScope\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively with a scope, starting with the given\\n   * root. This should only be used in the global scope. Otherwise, use\\n   * {@link #traverseAtScope}.\\n   *\/\\n  void traverseWithScope(Node root, Scope s) {\\n    Preconditions.checkState(s.isGlobal());\\n\\n    inputId = null;\\n    sourceName = \\\"\\\";\\n    curNode = root;\\n    pushScope(s);\\n    traverseBranch(root, null);\\n    popScope();\\n  }\", \"javadoc_start_line\": 331, \"annotations_start_line\": 336, \"method_start_line\": 336, \"end_line\": 345}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 474, \"annotations_start_line\": 477, \"method_start_line\": 478, \"end_line\": 506}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visit\", \"content\": \"  \/**\\n   * This is the meat of the type checking.  It is basically one big switch,\\n   * with each case representing one type of parse tree node.  The individual\\n   * cases are usually pretty straightforward.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of the node n.\\n   *\/\\n  @Override\\n  public void visit(NodeTraversal t, Node n, Node parent) {\\n    JSType childType;\\n    JSType leftType, rightType;\\n    Node left, right;\\n    \/\/ To be explicitly set to false if the node is not typeable.\\n    boolean typeable = true;\\n\\n    switch (n.getType()) {\\n      case Token.NAME:\\n        typeable = visitName(t, n, parent);\\n        break;\\n\\n      case Token.PARAM_LIST:\\n        typeable = false;\\n        break;\\n\\n      case Token.COMMA:\\n        ensureTyped(t, n, getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.THIS:\\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\\n        break;\\n\\n      case Token.NULL:\\n        ensureTyped(t, n, NULL_TYPE);\\n        break;\\n\\n      case Token.NUMBER:\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.STRING:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.STRING_KEY:\\n        typeable = false;\\n        break;\\n\\n      case Token.GETTER_DEF:\\n      case Token.SETTER_DEF:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        ensureTyped(t, n, ARRAY_TYPE);\\n        break;\\n\\n      case Token.REGEXP:\\n        ensureTyped(t, n, REGEXP_TYPE);\\n        break;\\n\\n      case Token.GETPROP:\\n        visitGetProp(t, n, parent);\\n        typeable = !(parent.isAssign() &&\\n                     parent.getFirstChild() == n);\\n        break;\\n\\n      case Token.GETELEM:\\n        visitGetElem(t, n);\\n        \/\/ The type of GETELEM is always unknown, so no point counting that.\\n        \/\/ If that unknown leaks elsewhere (say by an assignment to another\\n        \/\/ variable), then it will be counted.\\n        typeable = false;\\n        break;\\n\\n      case Token.VAR:\\n        visitVar(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.NEW:\\n        visitNew(t, n);\\n        break;\\n\\n      case Token.CALL:\\n        visitCall(t, n);\\n        typeable = !parent.isExprResult();\\n        break;\\n\\n      case Token.RETURN:\\n        visitReturn(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.DEC:\\n      case Token.INC:\\n        left = n.getFirstChild();\\n        validator.expectNumber(\\n            t, left, getJSType(left), \\\"increment\/decrement\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.NOT:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.VOID:\\n        ensureTyped(t, n, VOID_TYPE);\\n        break;\\n\\n      case Token.TYPEOF:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.BITNOT:\\n        childType = getJSType(n.getFirstChild());\\n        if (!childType.matchesInt32Context()) {\\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\\n              childType.toString());\\n        }\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        left = n.getFirstChild();\\n        validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.EQ:\\n      case Token.NE:\\n      case Token.SHEQ:\\n      case Token.SHNE: {\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n\\n        if (left.isTypeOf()) {\\n          if (right.isString()) {\\n            checkTypeofString(t, right, right.getString());\\n          }\\n        } else if (right.isTypeOf() && left.isString()) {\\n          checkTypeofString(t, left, left.getString());\\n        }\\n\\n        leftType = getJSType(left);\\n        rightType = getJSType(right);\\n\\n        \/\/ We do not want to warn about explicit comparisons to VOID. People\\n        \/\/ often do this if they think their type annotations screwed up.\\n        \/\/\\n        \/\/ We do want to warn about cases where people compare things like\\n        \/\/ (Array|null) == (Function|null)\\n        \/\/ because it probably means they screwed up.\\n        \/\/\\n        \/\/ This heuristic here is not perfect, but should catch cases we\\n        \/\/ care about without too many false negatives.\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n\\n        TernaryValue result = TernaryValue.UNKNOWN;\\n        if (n.getType() == Token.EQ || n.getType() == Token.NE) {\\n          result = leftTypeRestricted.testForEquality(rightTypeRestricted);\\n          if (n.isNE()) {\\n            result = result.not();\\n          }\\n        } else {\\n          \/\/ SHEQ or SHNE\\n          if (!leftTypeRestricted.canTestForShallowEqualityWith(\\n                  rightTypeRestricted)) {\\n            result = n.getType() == Token.SHEQ ?\\n                TernaryValue.FALSE : TernaryValue.TRUE;\\n          }\\n        }\\n\\n        if (result != TernaryValue.UNKNOWN) {\\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\\n              rightType.toString(), result.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n        if (rightType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, leftType, \\\"left side of numeric comparison\\\");\\n        } else if (leftType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, rightType, \\\"right side of numeric comparison\\\");\\n        } else if (leftType.matchesNumberContext() &&\\n                   rightType.matchesNumberContext()) {\\n          \/\/ OK.\\n        } else {\\n          \/\/ Whether the comparison is numeric will be determined at runtime\\n          \/\/ each time the expression is evaluated. Regardless, both operands\\n          \/\/ should match a string context.\\n          String message = \\\"left side of comparison\\\";\\n          validator.expectString(t, n, leftType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, leftType, message, getNativeType(STRING_TYPE));\\n          message = \\\"right side of comparison\\\";\\n          validator.expectString(t, n, rightType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, rightType, message, getNativeType(STRING_TYPE));\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.IN:\\n        validator.expectObject(t, n, getJSType(n.getLastChild()),\\n                               \\\"'in' requires an object\\\");\\n        left = n.getFirstChild();\\n        validator.expectString(t, left, getJSType(left), \\\"left side of 'in'\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.INSTANCEOF:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\\n        validator.expectAnyObject(\\n            t, left, getJSType(left), \\\"deterministic instanceof yields false\\\");\\n        validator.expectActualObject(\\n            t, right, rightType, \\\"instanceof requires an object\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.ASSIGN:\\n        visitAssign(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_MUL:\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.BITAND:\\n      case Token.SUB:\\n      case Token.ADD:\\n      case Token.MUL:\\n        visitBinaryOperator(n.getType(), t, n);\\n        break;\\n\\n      case Token.DELPROP:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.CASE:\\n        JSType switchType = getJSType(parent.getFirstChild());\\n        JSType caseType = getJSType(n.getFirstChild());\\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\\n        typeable = false;\\n        break;\\n\\n      case Token.WITH: {\\n        Node child = n.getFirstChild();\\n        childType = getJSType(child);\\n        validator.expectObject(t, child, childType, \\\"with requires an object\\\");\\n        typeable = false;\\n        break;\\n      }\\n\\n      case Token.FUNCTION:\\n        visitFunction(t, n);\\n        break;\\n\\n      \/\/ These nodes have no interesting type behavior.\\n      case Token.LABEL:\\n      case Token.LABEL_NAME:\\n      case Token.SWITCH:\\n      case Token.BREAK:\\n      case Token.CATCH:\\n      case Token.TRY:\\n      case Token.SCRIPT:\\n      case Token.EXPR_RESULT:\\n      case Token.BLOCK:\\n      case Token.EMPTY:\\n      case Token.DEFAULT_CASE:\\n      case Token.CONTINUE:\\n      case Token.DEBUGGER:\\n      case Token.THROW:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes require data flow analysis.\\n      case Token.DO:\\n      case Token.FOR:\\n      case Token.IF:\\n      case Token.WHILE:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes are typed during the type inference.\\n      case Token.AND:\\n      case Token.HOOK:\\n      case Token.OBJECTLIT:\\n      case Token.OR:\\n        if (n.getJSType() != null) { \/\/ If we didn't run type inference.\\n          ensureTyped(t, n);\\n        } else {\\n          \/\/ If this is an enum, then give that type to the objectlit as well.\\n          if ((n.isObjectLit())\\n              && (parent.getJSType() instanceof EnumType)) {\\n            ensureTyped(t, n, parent.getJSType());\\n          } else {\\n            ensureTyped(t, n);\\n          }\\n        }\\n        if (n.isObjectLit()) {\\n          for (Node key : n.children()) {\\n            visitObjLitKey(t, key, n);\\n          }\\n        }\\n        break;\\n\\n      default:\\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\\n        ensureTyped(t, n);\\n        break;\\n    }\\n\\n    \/\/ Don't count externs since the user's code may not even use that part.\\n    typeable = typeable && !inExterns;\\n\\n    if (typeable) {\\n      doPercentTypedAccounting(t, n);\\n    }\\n\\n    checkNoTypeCheckSection(n, false);\\n  }\", \"javadoc_start_line\": 449, \"annotations_start_line\": 459, \"method_start_line\": 460, \"end_line\": 806}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitGetProp\", \"content\": \"  \/**\\n   * Visits a GETPROP node.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of <code>n<\/code>\\n   *\/\\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\\n    \/\/ obj.prop or obj.method()\\n    \/\/ Lots of types can appear on the left, a call to a void function can\\n    \/\/ never be on the left. getPropertyType will decide what is acceptable\\n    \/\/ and what isn't.\\n    Node property = n.getLastChild();\\n    Node objNode = n.getFirstChild();\\n    JSType childType = getJSType(objNode);\\n\\n    if (childType.isDict()) {\\n      report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \\\"'.'\\\", \\\"dict\\\");\\n    } else if (n.getJSType() != null && parent.isAssign()) {\\n      return;\\n    } else if (validator.expectNotNullOrUndefined(t, n, childType,\\n        \\\"No properties on this expression\\\", getNativeType(OBJECT_TYPE))) {\\n      checkPropertyAccess(childType, property.getString(), t, n);\\n    }\\n    ensureTyped(t, n);\\n  }\", \"javadoc_start_line\": 1295, \"annotations_start_line\": 1303, \"method_start_line\": 1303, \"end_line\": 1321}"}]},{"name":"Closure","version":25,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeInferenceTest\", \"methodName\": \"testBackwardsInferenceNew\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"expected:<{[foo: (number|undefined)]}> but was:<{[]}>\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"traverseNew\", \"content\": \"  private FlowScope traverseNew(Node n, FlowScope scope) {\\n\\n    Node constructor = n.getFirstChild();\\n    scope = traverse(constructor, scope);\\n    JSType constructorType = constructor.getJSType();\\n    JSType type = null;\\n    if (constructorType != null) {\\n      constructorType = constructorType.restrictByNotNullOrUndefined();\\n      if (constructorType.isUnknownType()) {\\n        type = getNativeType(UNKNOWN_TYPE);\\n      } else {\\n        FunctionType ct = constructorType.toMaybeFunctionType();\\n        if (ct == null && constructorType instanceof FunctionType) {\\n          \/\/ If constructorType is a NoObjectType, then toMaybeFunctionType will\\n          \/\/ return null. But NoObjectType implements the FunctionType\\n          \/\/ interface, precisely because it can validly construct objects.\\n          ct = (FunctionType) constructorType;\\n        }\\n        if (ct != null && ct.isConstructor()) {\\n          type = ct.getInstanceType();\\n        }\\n      }\\n    }\\n    n.setJSType(type);\\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\\n      scope = traverse(arg, scope);\\n    }\\n    return scope;\\n  }\", \"javadoc_start_line\": 1035, \"annotations_start_line\": 1035, \"method_start_line\": 1035, \"end_line\": 1063}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/DataFlowAnalysis.java\", \"method_name\": \"analyze\", \"content\": \"  \/**\\n   * Finds a fixed-point solution using at most {@link #MAX_STEPS}\\n   * iterations.\\n   *\\n   * @see #analyze(int)\\n   *\/\\n  final void analyze() {\\n    analyze(MAX_STEPS);\\n  }\", \"javadoc_start_line\": 173, \"annotations_start_line\": 179, \"method_start_line\": 179, \"end_line\": 181}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/DataFlowAnalysis.java\", \"method_name\": \"analyze\", \"content\": \"  \/**\\n   * Finds a fixed-point solution. The function has the side effect of replacing\\n   * the existing node annotations with the computed solutions using {@link\\n   * com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.\\n   *\\n   * <p>Initially, each node's input and output flow state contains the value\\n   * given by {@link #createInitialEstimateLattice()} (with the exception of the\\n   * entry node of the graph which takes on the {@link #createEntryLattice()}\\n   * value. Each node will use the output state of its predecessor and compute a\\n   * output state according to the instruction. At that time, any nodes that\\n   * depends on the node's newly modified output value will need to recompute\\n   * their output state again. Each step will perform a computation at one node\\n   * until no extra computation will modify any existing output state anymore.\\n   *\\n   * @param maxSteps Max number of iterations before the method stops and throw\\n   *        a {@link MaxIterationsExceededException}. This will prevent the\\n   *        analysis from going into a infinite loop.\\n   *\/\\n  final void analyze(int maxSteps) {\\n    initialize();\\n    int step = 0;\\n    while (!orderedWorkSet.isEmpty()) {\\n      if (step > maxSteps) {\\n        throw new MaxIterationsExceededException(\\n          \\\"Analysis did not terminate after \\\" + maxSteps + \\\" iterations\\\");\\n      }\\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\\n      orderedWorkSet.remove(curNode);\\n      joinInputs(curNode);\\n      if (flow(curNode)) {\\n        \/\/ If there is a change in the current node, we want to grab the list\\n        \/\/ of nodes that this node affects.\\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\\n            cfg.getDirectedSuccNodes(curNode) :\\n            cfg.getDirectedPredNodes(curNode);\\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\\n          if (nextNode != cfg.getImplicitReturn()) {\\n            orderedWorkSet.add(nextNode);\\n          }\\n        }\\n      }\\n      step++;\\n    }\\n    if (isForward()) {\\n      joinInputs(getCfg().getImplicitReturn());\\n    }\\n  }\", \"javadoc_start_line\": 183, \"annotations_start_line\": 201, \"method_start_line\": 201, \"end_line\": 229}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"<clinit>\", \"content\": \"class TypeInference\", \"javadoc_start_line\": 58, \"annotations_start_line\": 58, \"method_start_line\": 58, \"end_line\": 58}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"branchedFlowThrough\", \"content\": \"  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\\n    \/\/ NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\\n    \/\/ edges. If we wanted to be perfect, we'd actually JOIN all the out\\n    \/\/ lattices of this flow with the in lattice, and then make that the out\\n    \/\/ lattice for the ON_EX edge. But it's probably to expensive to be\\n    \/\/ worthwhile.\\n    FlowScope output = flowThrough(source, input);\\n    Node condition = null;\\n    FlowScope conditionFlowScope = null;\\n    BooleanOutcomePair conditionOutcomes = null;\\n\\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\\n      Branch branch = branchEdge.getValue();\\n      FlowScope newScope = output;\\n\\n      switch (branch) {\\n        case ON_TRUE:\\n          if (NodeUtil.isForIn(source)) {\\n            \/\/ item is assigned a property name, so its type should be string.\\n            Node item = source.getFirstChild();\\n            Node obj = item.getNext();\\n\\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\\n\\n            if (item.isVar()) {\\n              item = item.getFirstChild();\\n            }\\n            if (item.isName()) {\\n              JSType iterKeyType = getNativeType(STRING_TYPE);\\n              ObjectType objType = getJSType(obj).dereference();\\n              JSType objIndexType = objType == null ?\\n                  null : objType.getIndexType();\\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\\n                JSType narrowedKeyType =\\n                    iterKeyType.getGreatestSubtype(objIndexType);\\n                if (!narrowedKeyType.isEmptyType()) {\\n                  iterKeyType = narrowedKeyType;\\n                }\\n              }\\n              redeclareSimpleVar(informed, item, iterKeyType);\\n            }\\n            newScope = informed;\\n            break;\\n          }\\n\\n          \/\/ FALL THROUGH\\n\\n        case ON_FALSE:\\n          if (condition == null) {\\n            condition = NodeUtil.getConditionExpression(source);\\n            if (condition == null && source.isCase()) {\\n              condition = source;\\n\\n              \/\/ conditionFlowScope is cached from previous iterations\\n              \/\/ of the loop.\\n              if (conditionFlowScope == null) {\\n                conditionFlowScope = traverse(\\n                    condition.getFirstChild(), output.createChildFlowScope());\\n              }\\n            }\\n          }\\n\\n          if (condition != null) {\\n            if (condition.isAnd() ||\\n                condition.isOr()) {\\n              \/\/ When handling the short-circuiting binary operators,\\n              \/\/ the outcome scope on true can be different than the outcome\\n              \/\/ scope on false.\\n              \/\/\\n              \/\/ TODO(nicksantos): The \\\"right\\\" way to do this is to\\n              \/\/ carry the known outcome all the way through the\\n              \/\/ recursive traversal, so that we can construct a\\n              \/\/ different flow scope based on the outcome. However,\\n              \/\/ this would require a bunch of code and a bunch of\\n              \/\/ extra computation for an edge case. This seems to be\\n              \/\/ a \\\"good enough\\\" approximation.\\n\\n              \/\/ conditionOutcomes is cached from previous iterations\\n              \/\/ of the loop.\\n              if (conditionOutcomes == null) {\\n                conditionOutcomes = condition.isAnd() ?\\n                    traverseAnd(condition, output.createChildFlowScope()) :\\n                    traverseOr(condition, output.createChildFlowScope());\\n              }\\n              newScope =\\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\\n                      condition,\\n                      conditionOutcomes.getOutcomeFlowScope(\\n                          condition.getType(), branch == Branch.ON_TRUE),\\n                      branch == Branch.ON_TRUE);\\n            } else {\\n              \/\/ conditionFlowScope is cached from previous iterations\\n              \/\/ of the loop.\\n              if (conditionFlowScope == null) {\\n                conditionFlowScope =\\n                    traverse(condition, output.createChildFlowScope());\\n              }\\n              newScope =\\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\\n            }\\n          }\\n          break;\\n      }\\n\\n      result.add(newScope.optimize());\\n    }\\n    return result;\\n  }\", \"javadoc_start_line\": 139, \"annotations_start_line\": 137, \"method_start_line\": 139, \"end_line\": 249}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"flowThrough\", \"content\": \"  FlowScope flowThrough(Node n, FlowScope input) {\\n    \/\/ If we have not walked a path from <entry> to <n>, then we don't\\n    \/\/ want to infer anything about this scope.\\n    if (input == bottomScope) {\\n      return input;\\n    }\\n\\n    FlowScope output = input.createChildFlowScope();\\n    output = traverse(n, output);\\n    return output;\\n  }\", \"javadoc_start_line\": 125, \"annotations_start_line\": 124, \"method_start_line\": 125, \"end_line\": 135}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"traverse\", \"content\": \"  private FlowScope traverse(Node n, FlowScope scope) {\\n    switch (n.getType()) {\\n      case Token.ASSIGN:\\n        scope = traverseAssign(n, scope);\\n        break;\\n\\n      case Token.NAME:\\n        scope = traverseName(n, scope);\\n        break;\\n\\n      case Token.GETPROP:\\n        scope = traverseGetProp(n, scope);\\n        break;\\n\\n      case Token.AND:\\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\\n            .createChildFlowScope();\\n        break;\\n\\n      case Token.OR:\\n        scope = traverseOr(n, scope).getJoinedFlowScope()\\n            .createChildFlowScope();\\n        break;\\n\\n      case Token.HOOK:\\n        scope = traverseHook(n, scope);\\n        break;\\n\\n      case Token.OBJECTLIT:\\n        scope = traverseObjectLiteral(n, scope);\\n        break;\\n\\n      case Token.CALL:\\n        scope = traverseCall(n, scope);\\n        break;\\n\\n      case Token.NEW:\\n        scope = traverseNew(n, scope);\\n        break;\\n\\n      case Token.ASSIGN_ADD:\\n      case Token.ADD:\\n        scope = traverseAdd(n, scope);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        scope = traverse(n.getFirstChild(), scope);  \/\/ Find types.\\n        n.setJSType(getNativeType(NUMBER_TYPE));\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        scope = traverseArrayLiteral(n, scope);\\n        break;\\n\\n      case Token.THIS:\\n        n.setJSType(scope.getTypeOfThis());\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_MUL:\\n      case Token.ASSIGN_SUB:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITAND:\\n      case Token.BITXOR:\\n      case Token.BITOR:\\n      case Token.MUL:\\n      case Token.SUB:\\n      case Token.DEC:\\n      case Token.INC:\\n      case Token.BITNOT:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getNativeType(NUMBER_TYPE));\\n        break;\\n\\n      case Token.PARAM_LIST:\\n        scope = traverse(n.getFirstChild(), scope);\\n        n.setJSType(getJSType(n.getFirstChild()));\\n        break;\\n\\n      case Token.COMMA:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TYPEOF:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getNativeType(STRING_TYPE));\\n        break;\\n\\n      case Token.DELPROP:\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n      case Token.NOT:\\n      case Token.EQ:\\n      case Token.NE:\\n      case Token.SHEQ:\\n      case Token.SHNE:\\n      case Token.INSTANCEOF:\\n      case Token.IN:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\\n        break;\\n\\n      case Token.GETELEM:\\n        scope = traverseGetElem(n, scope);\\n        break;\\n\\n      case Token.EXPR_RESULT:\\n        scope = traverseChildren(n, scope);\\n        if (n.getFirstChild().isGetProp()) {\\n          ensurePropertyDeclared(n.getFirstChild());\\n        }\\n        break;\\n\\n      case Token.SWITCH:\\n        scope = traverse(n.getFirstChild(), scope);\\n        break;\\n\\n      case Token.RETURN:\\n        scope = traverseReturn(n, scope);\\n        break;\\n\\n      case Token.VAR:\\n      case Token.THROW:\\n        scope = traverseChildren(n, scope);\\n        break;\\n\\n      case Token.CATCH:\\n        scope = traverseCatch(n, scope);\\n        break;\\n    }\\n    if (!n.isFunction()) {\\n      JSDocInfo info = n.getJSDocInfo();\\n      if (info != null && info.hasType()) {\\n        JSType castType = info.getType().evaluate(syntacticScope, registry);\\n\\n        \/\/ A stubbed type cast on a qualified name should take\\n        \/\/ effect for all subsequent accesses of that name,\\n        \/\/ so treat it the same as an assign to that name.\\n        if (n.isQualifiedName() &&\\n            n.getParent().isExprResult()) {\\n          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\\n        }\\n\\n        n.setJSType(castType);\\n      }\\n    }\\n\\n    return scope;\\n  }\", \"javadoc_start_line\": 251, \"annotations_start_line\": 251, \"method_start_line\": 251, \"end_line\": 414}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"traverseChildren\", \"content\": \"  private FlowScope traverseChildren(Node n, FlowScope scope) {\\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\\n      scope = traverse(el, scope);\\n    }\\n    return scope;\\n  }\", \"javadoc_start_line\": 1069, \"annotations_start_line\": 1069, \"method_start_line\": 1069, \"end_line\": 1074}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"traverse\", \"content\": \"  private FlowScope traverse(Node n, FlowScope scope) {\\n    switch (n.getType()) {\\n      case Token.ASSIGN:\\n        scope = traverseAssign(n, scope);\\n        break;\\n\\n      case Token.NAME:\\n        scope = traverseName(n, scope);\\n        break;\\n\\n      case Token.GETPROP:\\n        scope = traverseGetProp(n, scope);\\n        break;\\n\\n      case Token.AND:\\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\\n            .createChildFlowScope();\\n        break;\\n\\n      case Token.OR:\\n        scope = traverseOr(n, scope).getJoinedFlowScope()\\n            .createChildFlowScope();\\n        break;\\n\\n      case Token.HOOK:\\n        scope = traverseHook(n, scope);\\n        break;\\n\\n      case Token.OBJECTLIT:\\n        scope = traverseObjectLiteral(n, scope);\\n        break;\\n\\n      case Token.CALL:\\n        scope = traverseCall(n, scope);\\n        break;\\n\\n      case Token.NEW:\\n        scope = traverseNew(n, scope);\\n        break;\\n\\n      case Token.ASSIGN_ADD:\\n      case Token.ADD:\\n        scope = traverseAdd(n, scope);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        scope = traverse(n.getFirstChild(), scope);  \/\/ Find types.\\n        n.setJSType(getNativeType(NUMBER_TYPE));\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        scope = traverseArrayLiteral(n, scope);\\n        break;\\n\\n      case Token.THIS:\\n        n.setJSType(scope.getTypeOfThis());\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_MUL:\\n      case Token.ASSIGN_SUB:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITAND:\\n      case Token.BITXOR:\\n      case Token.BITOR:\\n      case Token.MUL:\\n      case Token.SUB:\\n      case Token.DEC:\\n      case Token.INC:\\n      case Token.BITNOT:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getNativeType(NUMBER_TYPE));\\n        break;\\n\\n      case Token.PARAM_LIST:\\n        scope = traverse(n.getFirstChild(), scope);\\n        n.setJSType(getJSType(n.getFirstChild()));\\n        break;\\n\\n      case Token.COMMA:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TYPEOF:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getNativeType(STRING_TYPE));\\n        break;\\n\\n      case Token.DELPROP:\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n      case Token.NOT:\\n      case Token.EQ:\\n      case Token.NE:\\n      case Token.SHEQ:\\n      case Token.SHNE:\\n      case Token.INSTANCEOF:\\n      case Token.IN:\\n        scope = traverseChildren(n, scope);\\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\\n        break;\\n\\n      case Token.GETELEM:\\n        scope = traverseGetElem(n, scope);\\n        break;\\n\\n      case Token.EXPR_RESULT:\\n        scope = traverseChildren(n, scope);\\n        if (n.getFirstChild().isGetProp()) {\\n          ensurePropertyDeclared(n.getFirstChild());\\n        }\\n        break;\\n\\n      case Token.SWITCH:\\n        scope = traverse(n.getFirstChild(), scope);\\n        break;\\n\\n      case Token.RETURN:\\n        scope = traverseReturn(n, scope);\\n        break;\\n\\n      case Token.VAR:\\n      case Token.THROW:\\n        scope = traverseChildren(n, scope);\\n        break;\\n\\n      case Token.CATCH:\\n        scope = traverseCatch(n, scope);\\n        break;\\n    }\\n    if (!n.isFunction()) {\\n      JSDocInfo info = n.getJSDocInfo();\\n      if (info != null && info.hasType()) {\\n        JSType castType = info.getType().evaluate(syntacticScope, registry);\\n\\n        \/\/ A stubbed type cast on a qualified name should take\\n        \/\/ effect for all subsequent accesses of that name,\\n        \/\/ so treat it the same as an assign to that name.\\n        if (n.isQualifiedName() &&\\n            n.getParent().isExprResult()) {\\n          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\\n        }\\n\\n        n.setJSType(castType);\\n      }\\n    }\\n\\n    return scope;\\n  }\", \"javadoc_start_line\": 251, \"annotations_start_line\": 251, \"method_start_line\": 251, \"end_line\": 414}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeInference.java\", \"method_name\": \"traverseNew\", \"content\": \"  private FlowScope traverseNew(Node n, FlowScope scope) {\\n\\n    Node constructor = n.getFirstChild();\\n    scope = traverse(constructor, scope);\\n    JSType constructorType = constructor.getJSType();\\n    JSType type = null;\\n    if (constructorType != null) {\\n      constructorType = constructorType.restrictByNotNullOrUndefined();\\n      if (constructorType.isUnknownType()) {\\n        type = getNativeType(UNKNOWN_TYPE);\\n      } else {\\n        FunctionType ct = constructorType.toMaybeFunctionType();\\n        if (ct == null && constructorType instanceof FunctionType) {\\n          \/\/ If constructorType is a NoObjectType, then toMaybeFunctionType will\\n          \/\/ return null. But NoObjectType implements the FunctionType\\n          \/\/ interface, precisely because it can validly construct objects.\\n          ct = (FunctionType) constructorType;\\n        }\\n        if (ct != null && ct.isConstructor()) {\\n          type = ct.getInstanceType();\\n        }\\n      }\\n    }\\n    n.setJSType(type);\\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\\n      scope = traverse(arg, scope);\\n    }\\n    return scope;\\n  }\", \"javadoc_start_line\": 1035, \"annotations_start_line\": 1035, \"method_start_line\": 1035, \"end_line\": 1063}"}]},{"name":"Closure","version":32,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.IntegrationTest\", \"methodName\": \"testIssue701\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"expected:<\/*\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"extractMultilineTextualBlock\", \"content\": \"  \/**\\n   * Extracts the text found on the current line and all subsequent\\n   * until either an annotation, end of comment or end of file is reached.\\n   * Note that if this method detects an end of line as the first token, it\\n   * will quit immediately (indicating that there is no text where it was\\n   * expected).  Note that token = info.token; should be called after this\\n   * method is used to update the token properly in the parser.\\n   *\\n   * @param token The start token.\\n   * @param option How to handle whitespace.\\n   *\\n   * @return The extraction information.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\\n                                                      WhitespaceOption option) {\\n\\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\\n        token == JsDocToken.EOF) {\\n      return new ExtractionInfo(\\\"\\\", token);\\n    }\\n\\n    stream.update();\\n    int startLineno = stream.getLineno();\\n    int startCharno = stream.getCharno() + 1;\\n\\n    \/\/ Read the content from the first line.\\n    String line = stream.getRemainingJSDocLine();\\n    if (option != WhitespaceOption.PRESERVE) {\\n      line = line.trim();\\n    }\\n\\n    StringBuilder builder = new StringBuilder();\\n    builder.append(line);\\n\\n    state = State.SEARCHING_ANNOTATION;\\n    token = next();\\n\\n    boolean ignoreStar = false;\\n\\n    \/\/ Track the start of the line to count whitespace that\\n    \/\/ the tokenizer skipped. Because this case is rare, it's easier\\n    \/\/ to do this here than in the tokenizer.\\n\\n    do {\\n      switch (token) {\\n        case STAR:\\n          if (ignoreStar) {\\n            \/\/ Mark the position after the star as the new start of the line.\\n          } else {\\n            \/\/ The star is part of the comment.\\n            if (builder.length() > 0) {\\n              builder.append(' ');\\n            }\\n\\n            builder.append('*');\\n          }\\n\\n          token = next();\\n          continue;\\n\\n        case EOL:\\n          if (option != WhitespaceOption.SINGLE_LINE) {\\n            builder.append(\\\"\\\\n\\\");\\n          }\\n\\n          ignoreStar = true;\\n          token = next();\\n          continue;\\n\\n        default:\\n          ignoreStar = false;\\n          state = State.SEARCHING_ANNOTATION;\\n\\n              \/\/ All tokens must be separated by a space.\\n\\n          if (token == JsDocToken.EOC ||\\n              token == JsDocToken.EOF ||\\n              \/\/ When we're capturing a license block, annotations\\n              \/\/ in the block are ok.\\n              (token == JsDocToken.ANNOTATION &&\\n               option != WhitespaceOption.PRESERVE)) {\\n            String multilineText = builder.toString();\\n\\n            if (option != WhitespaceOption.PRESERVE) {\\n              multilineText = multilineText.trim();\\n            }\\n\\n            int endLineno = stream.getLineno();\\n            int endCharno = stream.getCharno();\\n\\n            if (multilineText.length() > 0) {\\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\\n                  endLineno, endCharno);\\n            }\\n\\n            return new ExtractionInfo(multilineText, token);\\n          }\\n\\n          if (builder.length() > 0) {\\n            builder.append(' ');\\n          }\\n          builder.append(toString(token));\\n\\n          line = stream.getRemainingJSDocLine();\\n\\n          if (option != WhitespaceOption.PRESERVE) {\\n            line = trimEnd(line);\\n          }\\n\\n          builder.append(line);\\n          token = next();\\n      }\\n    } while (true);\\n  }\", \"javadoc_start_line\": 1315, \"annotations_start_line\": 1328, \"method_start_line\": 1330, \"end_line\": 1429}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"parseInputs\", \"content\": \"  \/**\\n   * Parses the externs and main inputs.\\n   *\\n   * @return A synthetic root node whose two children are the externs root\\n   *     and the main root\\n   *\/\\n  Node parseInputs() {\\n    boolean devMode = options.devMode != DevMode.OFF;\\n\\n    \/\/ If old roots exist (we are parsing a second time), detach each of the\\n    \/\/ individual file parse trees.\\n    if (externsRoot != null) {\\n      externsRoot.detachChildren();\\n    }\\n    if (jsRoot != null) {\\n      jsRoot.detachChildren();\\n    }\\n\\n    \/\/ Parse main js sources.\\n    jsRoot = IR.block();\\n    jsRoot.setIsSyntheticBlock(true);\\n\\n    externsRoot = IR.block();\\n    externsRoot.setIsSyntheticBlock(true);\\n\\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\\n    externAndJsRoot.setIsSyntheticBlock(true);\\n\\n    if (options.tracer.isOn()) {\\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\\n      addChangeHandler(tracker.getCodeChangeHandler());\\n    }\\n\\n    Tracer tracer = newTracer(\\\"parseInputs\\\");\\n\\n    try {\\n      \/\/ Parse externs sources.\\n      for (CompilerInput input : externs) {\\n        Node n = input.getAstRoot(this);\\n        if (hasErrors()) {\\n          return null;\\n        }\\n        externsRoot.addChildToBack(n);\\n      }\\n\\n      \/\/ Modules inferred in ProcessCommonJS pass.\\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\\n        processAMDAndCommonJSModules();\\n      }\\n\\n      \/\/ Check if inputs need to be rebuilt from modules.\\n      boolean staleInputs = false;\\n\\n      \/\/ Check if the sources need to be re-ordered.\\n      if (options.dependencyOptions.needsManagement() &&\\n          !options.skipAllPasses &&\\n          options.closurePass) {\\n        for (CompilerInput input : inputs) {\\n          \/\/ Forward-declare all the provided types, so that they\\n          \/\/ are not flagged even if they are dropped from the process.\\n          for (String provide : input.getProvides()) {\\n            getTypeRegistry().forwardDeclareType(provide);\\n          }\\n        }\\n\\n        try {\\n          inputs =\\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\\n              .manageDependencies(options.dependencyOptions, inputs);\\n          staleInputs = true;\\n        } catch (CircularDependencyException e) {\\n          report(JSError.make(\\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\\n\\n          \/\/ If in IDE mode, we ignore the error and keep going.\\n          if (hasErrors()) {\\n            return null;\\n          }\\n        } catch (MissingProvideException e) {\\n          report(JSError.make(\\n              MISSING_ENTRY_ERROR, e.getMessage()));\\n\\n          \/\/ If in IDE mode, we ignore the error and keep going.\\n          if (hasErrors()) {\\n            return null;\\n          }\\n        }\\n      }\\n\\n      for (CompilerInput input : inputs) {\\n        Node n = input.getAstRoot(this);\\n\\n        \/\/ Inputs can have a null AST during initial parse.\\n        if (n == null) {\\n          continue;\\n        }\\n\\n        if (n.getJSDocInfo() != null) {\\n          JSDocInfo info = n.getJSDocInfo();\\n          if (info.isExterns()) {\\n            \/\/ If the input file is explicitly marked as an externs file, then\\n            \/\/ assume the programmer made a mistake and throw it into\\n            \/\/ the externs pile anyways.\\n            externsRoot.addChildToBack(n);\\n            input.setIsExtern(true);\\n\\n            input.getModule().remove(input);\\n\\n            externs.add(input);\\n            staleInputs = true;\\n          } else if (info.isNoCompile()) {\\n            input.getModule().remove(input);\\n            staleInputs = true;\\n          }\\n        }\\n      }\\n\\n      if (staleInputs) {\\n        fillEmptyModules(modules);\\n        rebuildInputsFromModules();\\n      }\\n\\n      \/\/ Build the AST.\\n      for (CompilerInput input : inputs) {\\n        Node n = input.getAstRoot(this);\\n        if (n == null) {\\n          continue;\\n        }\\n\\n        if (devMode) {\\n          runSanityCheck();\\n          if (hasErrors()) {\\n            return null;\\n          }\\n        }\\n\\n        if (options.sourceMapOutputPath != null ||\\n            options.nameReferenceReportPath != null) {\\n\\n          \/\/ Annotate the nodes in the tree with information from the\\n          \/\/ input file. This information is used to construct the SourceMap.\\n          SourceInformationAnnotator sia =\\n              new SourceInformationAnnotator(\\n                  input.getName(), options.devMode != DevMode.OFF);\\n          NodeTraversal.traverse(this, n, sia);\\n        }\\n\\n        jsRoot.addChildToBack(n);\\n      }\\n\\n      if (hasErrors()) {\\n        return null;\\n      }\\n      return externAndJsRoot;\\n    } finally {\\n      stopTracer(tracer, \\\"parseInputs\\\");\\n    }\\n  }\", \"javadoc_start_line\": 1230, \"annotations_start_line\": 1236, \"method_start_line\": 1236, \"end_line\": 1387}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CompilerInput.java\", \"method_name\": \"getAstRoot\", \"content\": \"  public Node getAstRoot(AbstractCompiler compiler) {\\n    Node root = ast.getAstRoot(compiler);\\n    \/\/ The root maybe null if the AST can not be created.\\n    if (root != null) {\\n      Preconditions.checkState(root.isScript());\\n      Preconditions.checkNotNull(root.getInputId());\\n    }\\n    return root;\\n  }\", \"javadoc_start_line\": 115, \"annotations_start_line\": 114, \"method_start_line\": 115, \"end_line\": 123}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/JsAst.java\", \"method_name\": \"getAstRoot\", \"content\": \"  public Node getAstRoot(AbstractCompiler compiler) {\\n    if (root == null) {\\n      parse(compiler);\\n      root.setInputId(inputId);\\n    }\\n    return root;\\n  }\", \"javadoc_start_line\": 50, \"annotations_start_line\": 49, \"method_start_line\": 50, \"end_line\": 56}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/JsAst.java\", \"method_name\": \"parse\", \"content\": \"  private void parse(AbstractCompiler compiler) {\\n    try {\\n      logger_.fine(\\\"Parsing: \\\" + sourceFile.getName());\\n      root = ParserRunner.parse(sourceFile, sourceFile.getCode(),\\n          compiler.getParserConfig(),\\n          compiler.getDefaultErrorReporter(),\\n          logger_);\\n    } catch (IOException e) {\\n      compiler.report(\\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\\n    }\\n\\n    if (root == null || compiler.hasHaltingErrors()) {\\n      \/\/ There was a parse error or IOException, so use a dummy block.\\n      root = IR.script();\\n    } else {\\n      compiler.prepareAst(root);\\n    }\\n\\n    \/\/ Set the source name so that the compiler passes can track\\n    \/\/ the source file and module.\\n    root.setStaticSourceFile(sourceFile);\\n  }\", \"javadoc_start_line\": 83, \"annotations_start_line\": 83, \"method_start_line\": 83, \"end_line\": 105}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/ParserRunner.java\", \"method_name\": \"parse\", \"content\": \"  \/**\\n   * Parses the JavaScript text given by a reader.\\n   *\\n   * @param sourceString Source code from the file.\\n   * @param errorReporter An error.\\n   * @param logger A logger.\\n   * @return The AST of the given text.\\n   * @throws IOException\\n   *\/\\n  public static Node parse(StaticSourceFile sourceFile,\\n                           String sourceString,\\n                           Config config,\\n                           ErrorReporter errorReporter,\\n                           Logger logger) throws IOException {\\n    Context cx = Context.enter();\\n    cx.setErrorReporter(errorReporter);\\n    cx.setLanguageVersion(Context.VERSION_1_5);\\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\\n    compilerEnv.initFromContext(cx);\\n    compilerEnv.setRecordingComments(true);\\n    compilerEnv.setRecordingLocalJsDocComments(true);\\n\\n    \/\/ ES5 specifically allows trailing commas\\n    compilerEnv.setWarnTrailingComma(\\n        config.languageMode == LanguageMode.ECMASCRIPT3);\\n\\n    \/\/ Do our own identifier check for ECMASCRIPT 5\\n    boolean acceptEs5 =\\n        config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3;\\n    compilerEnv.setReservedKeywordAsIdentifier(acceptEs5);\\n    compilerEnv.setAllowKeywordAsObjectPropertyName(acceptEs5);\\n\\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\\n    compilerEnv.setIdeMode(config.isIdeMode);\\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\\n\\n    Parser p = new Parser(compilerEnv, errorReporter);\\n    AstRoot astRoot = null;\\n    try {\\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\\n    } catch (EvaluatorException e) {\\n      logger.info(\\n          \\\"Error parsing \\\" + sourceFile.getName() + \\\": \\\" + e.getMessage());\\n    } finally {\\n      Context.exit();\\n    }\\n    Node root = null;\\n    if (astRoot != null) {\\n      root = IRFactory.transformTree(\\n          astRoot, sourceFile, sourceString, config, errorReporter);\\n      root.setIsSyntheticBlock(true);\\n    }\\n    return root;\\n  }\", \"javadoc_start_line\": 95, \"annotations_start_line\": 104, \"method_start_line\": 108, \"end_line\": 148}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"transformTree\", \"content\": \"  public static Node transformTree(AstRoot node,\\n                                   StaticSourceFile sourceFile,\\n                                   String sourceString,\\n                                   Config config,\\n                                   ErrorReporter errorReporter) {\\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\\n        config, errorReporter);\\n    Node irNode = irFactory.transform(node);\\n\\n    if (node.getComments() != null) {\\n      for (Comment comment : node.getComments()) {\\n        if (comment.getCommentType() == CommentType.JSDOC &&\\n            !irFactory.parsedComments.contains(comment)) {\\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\\n          irFactory.handleBlockComment(comment);\\n        }\\n      }\\n    }\\n\\n    irFactory.setFileOverviewJsDoc(irNode);\\n\\n    return irNode;\\n  }\", \"javadoc_start_line\": 166, \"annotations_start_line\": 166, \"method_start_line\": 170, \"end_line\": 189}"},{"step":"{\"file_path\": \"\/lib\/rhino\/src\/org\/mozilla\/javascript\/IRFactory.java\", \"method_name\": \"transform\", \"content\": \"    public Node transform(AstNode node) {\\n        switch (node.getType()) {\\n          case Token.ARRAYCOMP:\\n              return transformArrayComp((ArrayComprehension)node);\\n          case Token.ARRAYLIT:\\n              return transformArrayLiteral((ArrayLiteral)node);\\n          case Token.BLOCK:\\n              return transformBlock(node);\\n          case Token.BREAK:\\n              return transformBreak((BreakStatement)node);\\n          case Token.CALL:\\n              return transformFunctionCall((FunctionCall)node);\\n          case Token.CONTINUE:\\n              return transformContinue((ContinueStatement)node);\\n          case Token.DO:\\n              return transformDoLoop((DoLoop)node);\\n          case Token.EMPTY:\\n              return node;\\n          case Token.FOR:\\n              if (node instanceof ForInLoop) {\\n                  return transformForInLoop((ForInLoop)node);\\n              } else {\\n                  return transformForLoop((ForLoop)node);\\n              }\\n          case Token.FUNCTION:\\n              return transformFunction((FunctionNode)node);\\n          case Token.GENEXPR:\\n              return transformGenExpr((GeneratorExpression)node);\\n          case Token.GETELEM:\\n              return transformElementGet((ElementGet)node);\\n          case Token.GETPROP:\\n              return transformPropertyGet((PropertyGet)node);\\n          case Token.HOOK:\\n              return transformCondExpr((ConditionalExpression)node);\\n          case Token.IF:\\n              return transformIf((IfStatement)node);\\n\\n          case Token.TRUE:\\n          case Token.FALSE:\\n          case Token.THIS:\\n          case Token.NULL:\\n          case Token.DEBUGGER:\\n              return transformLiteral(node);\\n\\n          case Token.NAME:\\n              return transformName((Name)node);\\n          case Token.NUMBER:\\n              return transformNumber((NumberLiteral)node);\\n          case Token.NEW:\\n              return transformNewExpr((NewExpression)node);\\n          case Token.OBJECTLIT:\\n              return transformObjectLiteral((ObjectLiteral)node);\\n          case Token.REGEXP:\\n              return transformRegExp((RegExpLiteral)node);\\n          case Token.RETURN:\\n              return transformReturn((ReturnStatement)node);\\n          case Token.SCRIPT:\\n              return transformScript((ScriptNode)node);\\n          case Token.STRING:\\n              return transformString((StringLiteral)node);\\n          case Token.SWITCH:\\n              return transformSwitch((SwitchStatement)node);\\n          case Token.THROW:\\n              return transformThrow((ThrowStatement)node);\\n          case Token.TRY:\\n              return transformTry((TryStatement)node);\\n          case Token.WHILE:\\n              return transformWhileLoop((WhileLoop)node);\\n          case Token.WITH:\\n              return transformWith((WithStatement)node);\\n          case Token.YIELD:\\n              return transformYield((Yield)node);\\n          default:\\n              if (node instanceof ExpressionStatement) {\\n                  return transformExprStmt((ExpressionStatement)node);\\n              }\\n              if (node instanceof Assignment) {\\n                  return transformAssignment((Assignment)node);\\n              }\\n              if (node instanceof UnaryExpression) {\\n                  return transformUnary((UnaryExpression)node);\\n              }\\n              if (node instanceof XmlMemberGet) {\\n                  return transformXmlMemberGet((XmlMemberGet)node);\\n              }\\n              if (node instanceof InfixExpression) {\\n                  return transformInfix((InfixExpression)node);\\n              }\\n              if (node instanceof VariableDeclaration) {\\n                  return transformVariables((VariableDeclaration)node);\\n              }\\n              if (node instanceof ParenthesizedExpression) {\\n                  return transformParenExpr((ParenthesizedExpression)node);\\n              }\\n              if (node instanceof LabeledStatement) {\\n                  return transformLabeledStatement((LabeledStatement)node);\\n              }\\n              if (node instanceof LetNode) {\\n                  return transformLetNode((LetNode)node);\\n              }\\n              if (node instanceof XmlRef) {\\n                  return transformXmlRef((XmlRef)node);\\n              }\\n              if (node instanceof XmlLiteral) {\\n                  return transformXmlLiteral((XmlLiteral)node);\\n              }\\n              throw new IllegalArgumentException(\\\"Can't transform: \\\" + node);\\n        }\\n    }\", \"javadoc_start_line\": 112, \"annotations_start_line\": 112, \"method_start_line\": 112, \"end_line\": 220}"},{"step":"{\"file_path\": \"\/lib\/rhino\/src\/org\/mozilla\/javascript\/IRFactory.java\", \"method_name\": \"transformArrayComp\", \"content\": \"    private Node transformArrayComp(ArrayComprehension node) {\\n        \/\/ An array comprehension expression such as\\n        \/\/\\n        \/\/   [expr for (x in foo) for each ([y, z] in bar) if (cond)]\\n        \/\/\\n        \/\/ is rewritten approximately as\\n        \/\/\\n        \/\/ new Scope(ARRAYCOMP) {\\n        \/\/   new Node(BLOCK) {\\n        \/\/     let tmp1 = new Array;\\n        \/\/     for (let x in foo) {\\n        \/\/       for each (let tmp2 in bar) {\\n        \/\/         if (cond) {\\n        \/\/           tmp1.push([y, z] = tmp2, expr);\\n        \/\/         }\\n        \/\/       }\\n        \/\/     }\\n        \/\/   }\\n        \/\/   createName(tmp1)\\n        \/\/ }\\n\\n        int lineno = node.getLineno();\\n        Scope scopeNode = createScopeNode(Token.ARRAYCOMP, lineno);\\n        String arrayName = currentScriptOrFn.getNextTempName();\\n        pushScope(scopeNode);\\n        try {\\n            defineSymbol(Token.LET, arrayName, false);\\n            Node block = new Node(Token.BLOCK, lineno);\\n            Node newArray = createCallOrNew(Token.NEW, createName(\\\"Array\\\"));\\n            Node init = new Node(Token.EXPR_VOID,\\n                                 createAssignment(Token.ASSIGN,\\n                                                  createName(arrayName),\\n                                                  newArray),\\n                                 lineno);\\n            block.addChildToBack(init);\\n            block.addChildToBack(arrayCompTransformHelper(node, arrayName));\\n            scopeNode.addChildToBack(block);\\n            scopeNode.addChildToBack(createName(arrayName));\\n            return scopeNode;\\n        } finally {\\n            popScope();\\n        }\\n    }\", \"javadoc_start_line\": 222, \"annotations_start_line\": 222, \"method_start_line\": 222, \"end_line\": 264}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"handlePossibleFileOverviewJsDoc\", \"content\": \"  private void handlePossibleFileOverviewJsDoc(Comment comment, Node irNode) {\\n    JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\\n    parsedComments.add(comment);\\n    handlePossibleFileOverviewJsDoc(jsDocParser);\\n  }\", \"javadoc_start_line\": 254, \"annotations_start_line\": 254, \"method_start_line\": 254, \"end_line\": 258}"},{"step":"{\"file_path\": \"\/lib\/rhino\/src\/org\/mozilla\/javascript\/IRFactory.java\", \"method_name\": \"arrayCompTransformHelper\", \"content\": \"    private Node arrayCompTransformHelper(ArrayComprehension node,\\n                                          String arrayName) {\\n        decompiler.addToken(Token.LB);\\n        int lineno = node.getLineno();\\n        Node expr = transform(node.getResult());\\n\\n        List<ArrayComprehensionLoop> loops = node.getLoops();\\n        int numLoops = loops.size();\\n\\n        \/\/ Walk through loops, collecting and defining their iterator symbols.\\n        Node[] iterators = new Node[numLoops];\\n        Node[] iteratedObjs = new Node[numLoops];\\n\\n        for (int i = 0; i < numLoops; i++) {\\n            ArrayComprehensionLoop acl = loops.get(i);\\n            decompiler.addName(\\\" \\\");\\n            decompiler.addToken(Token.FOR);\\n            if (acl.isForEach()) {\\n                decompiler.addName(\\\"each \\\");\\n            }\\n            decompiler.addToken(Token.LP);\\n\\n            AstNode iter = acl.getIterator();\\n            String name = null;\\n            if (iter.getType() == Token.NAME) {\\n                name = iter.getString();\\n                decompiler.addName(name);\\n            } else {\\n                \/\/ destructuring assignment\\n                decompile(iter);\\n                name = currentScriptOrFn.getNextTempName();\\n                defineSymbol(Token.LP, name, false);\\n                expr = createBinary(Token.COMMA,\\n                                    createAssignment(Token.ASSIGN,\\n                                                     iter,\\n                                                     createName(name)),\\n                                    expr);\\n            }\\n            Node init = createName(name);\\n            \/\/ Define as a let since we want the scope of the variable to\\n            \/\/ be restricted to the array comprehension\\n            defineSymbol(Token.LET, name, false);\\n            iterators[i] = init;\\n\\n            decompiler.addToken(Token.IN);\\n            iteratedObjs[i] = transform(acl.getIteratedObject());\\n            decompiler.addToken(Token.RP);\\n        }\\n\\n        \/\/ generate code for tmpArray.push(body)\\n        Node call = createCallOrNew(Token.CALL,\\n                                    createPropertyGet(createName(arrayName),\\n                                                      null,\\n                                                      \\\"push\\\", 0));\\n\\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\\n\\n        if (node.getFilter() != null) {\\n            decompiler.addName(\\\" \\\");\\n            decompiler.addToken(Token.IF);\\n            decompiler.addToken(Token.LP);\\n            body = createIf(transform(node.getFilter()), body, null, lineno);\\n            decompiler.addToken(Token.RP);\\n        }\\n\\n        \/\/ Now walk loops in reverse to build up the body statement.\\n        int pushed = 0;\\n        try {\\n            for (int i = numLoops-1; i >= 0; i--) {\\n                ArrayComprehensionLoop acl = loops.get(i);\\n                Scope loop = createLoopNode(null,  \/\/ no label\\n                                            acl.getLineno());\\n                pushScope(loop);\\n                pushed++;\\n                body = createForIn(Token.LET,\\n                                   loop,\\n                                   iterators[i],\\n                                   iteratedObjs[i],\\n                                   body,\\n                                   acl.isForEach());\\n            }\\n        } finally {\\n            for (int i = 0; i < pushed; i++) {\\n                popScope();\\n            }\\n        }\\n\\n        decompiler.addToken(Token.RB);\\n\\n        \/\/ Now that we've accumulated any destructuring forms,\\n        \/\/ add expr to the call node; it's pushed on each iteration.\\n        call.addChildToBack(expr);\\n        return body;\\n    }\", \"javadoc_start_line\": 266, \"annotations_start_line\": 266, \"method_start_line\": 267, \"end_line\": 359}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"createJsDocInfoParser\", \"content\": \"  \/**\\n   * Creates a JsDocInfoParser and parses the JsDoc string.\\n   *\\n   * Used both for handling individual JSDoc comments and for handling\\n   * file-level JSDoc comments (@fileoverview and @license).\\n   *\\n   * @param node The JsDoc Comment node to parse.\\n   * @param irNode\\n   * @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or\\n   *     normal jsdoc, or no jsdoc (if the method parses to the wrong level).\\n   *\/\\n  private JsDocInfoParser createJsDocInfoParser(Comment node, Node irNode) {\\n    String comment = node.getValue();\\n    int lineno = node.getLineno();\\n    int position = node.getAbsolutePosition();\\n\\n    \/\/ The JsDocInfoParser expects the comment without the initial '\/**'.\\n    int numOpeningChars = 3;\\n    JsDocInfoParser jsdocParser =\\n      new JsDocInfoParser(\\n          new JsDocTokenStream(comment.substring(numOpeningChars),\\n                               lineno,\\n                               position2charno(position) + numOpeningChars),\\n          node,\\n          irNode,\\n          config,\\n          errorReporter);\\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\\n    jsdocParser.parse();\\n    return jsdocParser;\\n  }\", \"javadoc_start_line\": 326, \"annotations_start_line\": 337, \"method_start_line\": 337, \"end_line\": 357}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parse\", \"content\": \"  \/**\\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\\n   * {@link JsDocToken#EOC} is returned.\\n   *\\n   * @return {@code true} if JSDoc information was correctly parsed,\\n   *     {@code false} otherwise\\n   *\/\\n  boolean parse() {\\n    int lineno;\\n    int charno;\\n\\n    \/\/ JSTypes are represented as Rhino AST nodes, and then resolved later.\\n    JSTypeExpression type;\\n\\n    state = State.SEARCHING_ANNOTATION;\\n    skipEOLs();\\n\\n    JsDocToken token = next();\\n\\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\\n\\n    \/\/ Always record that we have a comment.\\n    if (jsdocBuilder.shouldParseDocumentation()) {\\n      ExtractionInfo blockInfo = extractBlockComment(token);\\n      token = blockInfo.token;\\n      if (!blockInfo.string.isEmpty()) {\\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\\n      }\\n    } else {\\n      if (token != JsDocToken.ANNOTATION &&\\n          token != JsDocToken.EOC) {\\n        \/\/ Mark that there was a description, but don't bother marking\\n        \/\/ what it was.\\n        jsdocBuilder.recordBlockDescription(\\\"\\\");\\n      }\\n    }\\n\\n    \/\/ Parse the actual JsDoc.\\n    retry: for (;;) {\\n      switch (token) {\\n        case ANNOTATION:\\n          if (state == State.SEARCHING_ANNOTATION) {\\n            state = State.SEARCHING_NEWLINE;\\n            lineno = stream.getLineno();\\n            charno = stream.getCharno();\\n\\n            String annotationName = stream.getString();\\n            Annotation annotation = annotationNames.get(annotationName);\\n            if (annotation == null) {\\n              parser.addParserWarning(\\\"msg.bad.jsdoc.tag\\\", annotationName,\\n                  stream.getLineno(), stream.getCharno());\\n            } else {\\n              \/\/ Mark the beginning of the annotation.\\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\\n\\n              switch (annotation) {\\n                case AUTHOR:\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\\n                    String author = authorInfo.string;\\n\\n                    if (author.length() == 0) {\\n                      parser.addParserWarning(\\\"msg.jsdoc.authormissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      jsdocBuilder.addAuthor(author);\\n                    }\\n                    token = authorInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case CONSISTENTIDGENERATOR:\\n                  if (!jsdocBuilder.recordConsistentIdGenerator()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.consistidgen\\\",\\n                      stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case CONSTANT:\\n                  if (!jsdocBuilder.recordConstancy()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.const\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case CONSTRUCTOR:\\n                  if (!jsdocBuilder.recordConstructor()) {\\n                    if (jsdocBuilder.isInterfaceRecorded()) {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case DEPRECATED:\\n                  if (!jsdocBuilder.recordDeprecated()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.deprecated\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n\\n                  \/\/ Find the reason\/description, if any.\\n                  ExtractionInfo reasonInfo =\\n                      extractMultilineTextualBlock(token);\\n\\n                  String reason = reasonInfo.string;\\n\\n                  if (reason.length() > 0) {\\n                    jsdocBuilder.recordDeprecationReason(reason);\\n                  }\\n\\n                  token = reasonInfo.token;\\n                  continue retry;\\n\\n                case INTERFACE:\\n                  if (!jsdocBuilder.recordInterface()) {\\n                    if (jsdocBuilder.isConstructorRecorded()) {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case DESC:\\n                  if (jsdocBuilder.isDescriptionRecorded()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.desc.extra\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                    token = eatTokensUntilEOL();\\n                    continue retry;\\n                  } else {\\n                    ExtractionInfo descriptionInfo =\\n                        extractMultilineTextualBlock(token);\\n\\n                    String description = descriptionInfo.string;\\n\\n                    jsdocBuilder.recordDescription(description);\\n                    token = descriptionInfo.token;\\n                    continue retry;\\n                  }\\n\\n                case FILE_OVERVIEW:\\n                  String fileOverview = \\\"\\\";\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo fileOverviewInfo =\\n                        extractMultilineTextualBlock(token,\\n                            WhitespaceOption.TRIM);\\n\\n                    fileOverview = fileOverviewInfo.string;\\n\\n                    token = fileOverviewInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n\\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\\n                      fileOverviewJSDocInfo != null) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.fileoverview.extra\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  continue retry;\\n\\n                case LICENSE:\\n                case PRESERVE:\\n                  ExtractionInfo preserveInfo =\\n                      extractMultilineTextualBlock(token,\\n                                                   WhitespaceOption.PRESERVE);\\n\\n                  String preserve = preserveInfo.string;\\n\\n                  if (preserve.length() > 0) {\\n                    if (fileLevelJsDocBuilder != null) {\\n                      fileLevelJsDocBuilder.append(preserve);\\n                    }\\n                  }\\n\\n                  token = preserveInfo.token;\\n                  continue retry;\\n\\n                case ENUM:\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n\\n                  type = null;\\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\\n                    type = createJSTypeExpression(\\n                        parseAndRecordTypeNode(token));\\n                  }\\n\\n                  if (type == null) {\\n                    type = createJSTypeExpression(newStringNode(\\\"number\\\"));\\n                  }\\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\\n                    parser.addTypeWarning(\\n                        \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                  }\\n                  token = eatTokensUntilEOL(token);\\n                  continue retry;\\n\\n                case EXPORT:\\n                  if (!jsdocBuilder.recordExport()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.export\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case EXPOSE:\\n                  if (!jsdocBuilder.recordExpose()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.expose\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case EXTERNS:\\n                  if (!jsdocBuilder.recordExterns()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.externs\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case JAVA_DISPATCH:\\n                  if (!jsdocBuilder.recordJavaDispatch()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.javadispatch\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case EXTENDS:\\n                case IMPLEMENTS:\\n                  skipEOLs();\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n                  boolean matchingRc = false;\\n\\n                  if (token == JsDocToken.LC) {\\n                    token = next();\\n                    matchingRc = true;\\n                  }\\n\\n                  if (token == JsDocToken.STRING) {\\n                    Node typeNode = parseAndRecordTypeNameNode(\\n                        token, lineno, charno, matchingRc);\\n\\n                    lineno = stream.getLineno();\\n                    charno = stream.getCharno();\\n\\n                    typeNode = wrapNode(Token.BANG, typeNode);\\n                    if (typeNode != null && !matchingRc) {\\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\\n                    }\\n                    type = createJSTypeExpression(typeNode);\\n\\n                    if (annotation == Annotation.EXTENDS) {\\n                      \/\/ record the extended type, check later\\n                      extendedTypes.add(new ExtendedTypeInfo(\\n                          type, stream.getLineno(), stream.getCharno()));\\n                    } else {\\n                      Preconditions.checkState(\\n                          annotation == Annotation.IMPLEMENTS);\\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\\n                        parser.addTypeWarning(\\\"msg.jsdoc.implements.duplicate\\\",\\n                            lineno, charno);\\n                      }\\n                    }\\n                    token = next();\\n                    if (matchingRc) {\\n                      if (token != JsDocToken.RC) {\\n                        parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\",\\n                            stream.getLineno(), stream.getCharno());\\n                      }\\n                    } else if (token != JsDocToken.EOL &&\\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\\n                      parser.addTypeWarning(\\\"msg.end.annotation.expected\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  } else {\\n                    parser.addTypeWarning(\\\"msg.no.type.name\\\", lineno, charno);\\n                  }\\n                  token = eatTokensUntilEOL(token);\\n                  continue retry;\\n\\n                case HIDDEN:\\n                  if (!jsdocBuilder.recordHiddenness()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.hidden\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case LENDS:\\n                  skipEOLs();\\n\\n                  matchingRc = false;\\n                  if (match(JsDocToken.LC)) {\\n                    token = next();\\n                    matchingRc = true;\\n                  }\\n\\n                  if (match(JsDocToken.STRING)) {\\n                    token = next();\\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.lends.incompatible\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  } else {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.lends.missing\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n\\n                  if (matchingRc && !match(JsDocToken.RC)) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case MEANING:\\n                  ExtractionInfo meaningInfo =\\n                      extractMultilineTextualBlock(token);\\n                  String meaning = meaningInfo.string;\\n                  token = meaningInfo.token;\\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.meaning.extra\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  continue retry;\\n\\n                case NO_ALIAS:\\n                  if (!jsdocBuilder.recordNoAlias()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.noalias\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_COMPILE:\\n                  if (!jsdocBuilder.recordNoCompile()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.nocompile\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_TYPE_CHECK:\\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.nocheck\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NOT_IMPLEMENTED:\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case INHERIT_DOC:\\n                case OVERRIDE:\\n                  if (!jsdocBuilder.recordOverride()) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.override\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case THROWS:\\n                  skipEOLs();\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n                  type = null;\\n\\n                  if (token == JsDocToken.LC) {\\n                    type = createJSTypeExpression(\\n                        parseAndRecordTypeNode(token));\\n\\n                    if (type == null) {\\n                      \/\/ parsing error reported during recursive descent\\n                      \/\/ recovering parsing\\n                      token = eatTokensUntilEOL();\\n                      continue retry;\\n                    }\\n                  }\\n\\n                  \/\/ *Update* the token to that after the type annotation.\\n                  token = current();\\n\\n                  \/\/ Save the throw type.\\n                  jsdocBuilder.recordThrowType(type);\\n\\n                  \/\/ Find the throw's description (if applicable).\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo descriptionInfo =\\n                        extractMultilineTextualBlock(token);\\n\\n                    String description = descriptionInfo.string;\\n\\n                    if (description.length() > 0) {\\n                      jsdocBuilder.recordThrowDescription(type, description);\\n                    }\\n\\n                    token = descriptionInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case PARAM:\\n                  skipEOLs();\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n                  type = null;\\n\\n                  if (token == JsDocToken.LC) {\\n                    type = createJSTypeExpression(\\n                        parseAndRecordParamTypeNode(token));\\n\\n                    if (type == null) {\\n                      \/\/ parsing error reported during recursive descent\\n                      \/\/ recovering parsing\\n                      token = eatTokensUntilEOL();\\n                      continue retry;\\n                    }\\n                    skipEOLs();\\n                    token = next();\\n                    lineno = stream.getLineno();\\n                    charno = stream.getCharno();\\n                  }\\n\\n                  String name = null;\\n                  boolean isBracketedParam = JsDocToken.LB == token;\\n                  if (isBracketedParam) {\\n                    token = next();\\n                  }\\n\\n                  if (JsDocToken.STRING != token) {\\n                    parser.addTypeWarning(\\\"msg.missing.variable.name\\\",\\n                        lineno, charno);\\n                  } else {\\n                    name = stream.getString();\\n\\n                    if (isBracketedParam) {\\n                      token = next();\\n\\n                      \/\/ Throw out JsDocToolkit's \\\"default\\\" parameter\\n                      \/\/ annotation.  It makes no sense under our type\\n                      \/\/ system.\\n                      if (JsDocToken.EQUALS == token) {\\n                        token = next();\\n                        if (JsDocToken.STRING == token) {\\n                          token = next();\\n                        }\\n                      }\\n\\n                      if (JsDocToken.RB != token) {\\n                        reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\");\\n                      } else if (type != null) {\\n                        \/\/ Make the type expression optional, if it isn't\\n                        \/\/ already.\\n                        type = JSTypeExpression.makeOptionalArg(type);\\n                      }\\n                    }\\n\\n                    \/\/ If the param name has a DOT in it, just throw it out\\n                    \/\/ quietly. We do not handle the JsDocToolkit method\\n                    \/\/ for handling properties of params.\\n                    if (name.indexOf('.') > -1) {\\n                      name = null;\\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\\n                      if (jsdocBuilder.hasParameter(name)) {\\n                        parser.addTypeWarning(\\\"msg.dup.variable.name\\\", name,\\n                            lineno, charno);\\n                      } else {\\n                        parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", name,\\n                            lineno, charno);\\n                      }\\n                    }\\n                  }\\n\\n                  if (name == null) {\\n                    token = eatTokensUntilEOL(token);\\n                    continue retry;\\n                  }\\n\\n                  jsdocBuilder.markName(name, sourceFile, lineno, charno);\\n\\n                  \/\/ Find the parameter's description (if applicable).\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo paramDescriptionInfo =\\n                        extractMultilineTextualBlock(token);\\n\\n                    String paramDescription = paramDescriptionInfo.string;\\n\\n                    if (paramDescription.length() > 0) {\\n                      jsdocBuilder.recordParameterDescription(name,\\n                          paramDescription);\\n                    }\\n\\n                    token = paramDescriptionInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case PRESERVE_TRY:\\n                  if (!jsdocBuilder.recordPreserveTry()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.preservertry\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case PRIVATE:\\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.visibility.private\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case PROTECTED:\\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.visibility.protected\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case PUBLIC:\\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.visibility.public\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_SHADOW:\\n                  if (!jsdocBuilder.recordNoShadow()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.noshadow\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_SIDE_EFFECTS:\\n                  if (!jsdocBuilder.recordNoSideEffects()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.nosideeffects\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case MODIFIES:\\n                  token = parseModifiesTag(next());\\n                  continue retry;\\n\\n                case IMPLICIT_CAST:\\n                  if (!jsdocBuilder.recordImplicitCast()) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.implicitcast\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case SEE:\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\\n                    String reference = referenceInfo.string;\\n\\n                    if (reference.length() == 0) {\\n                      parser.addParserWarning(\\\"msg.jsdoc.seemissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      jsdocBuilder.addReference(reference);\\n                    }\\n\\n                    token = referenceInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case SUPPRESS:\\n                  token = parseSuppressTag(next());\\n                  continue retry;\\n\\n                case TEMPLATE:\\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\\n                  String templateTypeName = templateInfo.string;\\n\\n                  if (templateTypeName.length() == 0) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.templatemissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\\n                      templateTypeName)) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.template.at.most.once\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n\\n                  token = templateInfo.token;\\n                  continue retry;\\n\\n                case IDGENERATOR:\\n                  if (!jsdocBuilder.recordIdGenerator()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.idgen\\\",\\n                      stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case VERSION:\\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\\n                  String version = versionInfo.string;\\n\\n                  if (version.length() == 0) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.versionmissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                  } else {\\n                    if (!jsdocBuilder.recordVersion(version)) {\\n                       parser.addParserWarning(\\\"msg.jsdoc.extraversion\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  }\\n\\n                  token = versionInfo.token;\\n                  continue retry;\\n\\n                case DEFINE:\\n                case RETURN:\\n                case THIS:\\n                case TYPE:\\n                case TYPEDEF:\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n\\n                  Node typeNode = null;\\n                  if (!lookAheadForTypeAnnotation() &&\\n                      annotation == Annotation.RETURN) {\\n                    \/\/ If RETURN doesn't have a type annotation, record\\n                    \/\/ it as the unknown type.\\n                    typeNode = newNode(Token.QMARK);\\n                  } else {\\n                    skipEOLs();\\n                    token = next();\\n                    typeNode = parseAndRecordTypeNode(token);\\n                  }\\n\\n                  if (annotation == Annotation.THIS) {\\n                    typeNode = wrapNode(Token.BANG, typeNode);\\n                    if (typeNode != null && token != JsDocToken.LC) {\\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\\n                    }\\n                  }\\n                  type = createJSTypeExpression(typeNode);\\n\\n                  if (type == null) {\\n                    \/\/ error reported during recursive descent\\n                    \/\/ recovering parsing\\n                  } else {\\n                    switch (annotation) {\\n                      case DEFINE:\\n                        if (!jsdocBuilder.recordDefineType(type)) {\\n                          parser.addParserWarning(\\\"msg.jsdoc.define\\\",\\n                              lineno, charno);\\n                        }\\n                        break;\\n\\n                      case RETURN:\\n                        if (!jsdocBuilder.recordReturnType(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                          break;\\n                        }\\n\\n                        \/\/ Find the return's description (if applicable).\\n                        if (jsdocBuilder.shouldParseDocumentation()) {\\n                          ExtractionInfo returnDescriptionInfo =\\n                              extractMultilineTextualBlock(token);\\n\\n                          String returnDescription =\\n                              returnDescriptionInfo.string;\\n\\n                          if (returnDescription.length() > 0) {\\n                            jsdocBuilder.recordReturnDescription(\\n                                returnDescription);\\n                          }\\n\\n                          token = returnDescriptionInfo.token;\\n                        } else {\\n                          token = eatTokensUntilEOL(token);\\n                        }\\n                        continue retry;\\n\\n                      case THIS:\\n                        if (!jsdocBuilder.recordThisType(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                        }\\n                        break;\\n\\n                      case TYPE:\\n                        if (!jsdocBuilder.recordType(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                        }\\n                        break;\\n\\n                      case TYPEDEF:\\n                        if (!jsdocBuilder.recordTypedef(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                        }\\n                        break;\\n                    }\\n                  }\\n\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n              }\\n            }\\n          }\\n          break;\\n\\n        case EOC:\\n          if (hasParsedFileOverviewDocInfo()) {\\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\\n          }\\n          checkExtendedTypes(extendedTypes);\\n          return true;\\n\\n        case EOF:\\n          \/\/ discard any accumulated information\\n          jsdocBuilder.build(null);\\n          parser.addParserWarning(\\\"msg.unexpected.eof\\\",\\n              stream.getLineno(), stream.getCharno());\\n          checkExtendedTypes(extendedTypes);\\n          return false;\\n\\n        case EOL:\\n          if (state == State.SEARCHING_NEWLINE) {\\n            state = State.SEARCHING_ANNOTATION;\\n          }\\n          token = next();\\n          continue retry;\\n\\n        default:\\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\\n            token = next();\\n            continue retry;\\n          } else {\\n            state = State.SEARCHING_NEWLINE;\\n            token = eatTokensUntilEOL();\\n            continue retry;\\n          }\\n      }\\n\\n      \/\/ next token\\n      token = next();\\n    }\\n  }\", \"javadoc_start_line\": 173, \"annotations_start_line\": 181, \"method_start_line\": 181, \"end_line\": 949}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"extractMultilineTextualBlock\", \"content\": \"  \/**\\n   * Extracts the text found on the current line and all subsequent\\n   * until either an annotation, end of comment or end of file is reached.\\n   * Note that if this method detects an end of line as the first token, it\\n   * will quit immediately (indicating that there is no text where it was\\n   * expected).  Note that token = info.token; should be called after this\\n   * method is used to update the token properly in the parser.\\n   *\\n   * @param token The start token.\\n   * @param option How to handle whitespace.\\n   *\\n   * @return The extraction information.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\\n                                                      WhitespaceOption option) {\\n\\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\\n        token == JsDocToken.EOF) {\\n      return new ExtractionInfo(\\\"\\\", token);\\n    }\\n\\n    stream.update();\\n    int startLineno = stream.getLineno();\\n    int startCharno = stream.getCharno() + 1;\\n\\n    \/\/ Read the content from the first line.\\n    String line = stream.getRemainingJSDocLine();\\n    if (option != WhitespaceOption.PRESERVE) {\\n      line = line.trim();\\n    }\\n\\n    StringBuilder builder = new StringBuilder();\\n    builder.append(line);\\n\\n    state = State.SEARCHING_ANNOTATION;\\n    token = next();\\n\\n    boolean ignoreStar = false;\\n\\n    \/\/ Track the start of the line to count whitespace that\\n    \/\/ the tokenizer skipped. Because this case is rare, it's easier\\n    \/\/ to do this here than in the tokenizer.\\n\\n    do {\\n      switch (token) {\\n        case STAR:\\n          if (ignoreStar) {\\n            \/\/ Mark the position after the star as the new start of the line.\\n          } else {\\n            \/\/ The star is part of the comment.\\n            if (builder.length() > 0) {\\n              builder.append(' ');\\n            }\\n\\n            builder.append('*');\\n          }\\n\\n          token = next();\\n          continue;\\n\\n        case EOL:\\n          if (option != WhitespaceOption.SINGLE_LINE) {\\n            builder.append(\\\"\\\\n\\\");\\n          }\\n\\n          ignoreStar = true;\\n          token = next();\\n          continue;\\n\\n        default:\\n          ignoreStar = false;\\n          state = State.SEARCHING_ANNOTATION;\\n\\n              \/\/ All tokens must be separated by a space.\\n\\n          if (token == JsDocToken.EOC ||\\n              token == JsDocToken.EOF ||\\n              \/\/ When we're capturing a license block, annotations\\n              \/\/ in the block are ok.\\n              (token == JsDocToken.ANNOTATION &&\\n               option != WhitespaceOption.PRESERVE)) {\\n            String multilineText = builder.toString();\\n\\n            if (option != WhitespaceOption.PRESERVE) {\\n              multilineText = multilineText.trim();\\n            }\\n\\n            int endLineno = stream.getLineno();\\n            int endCharno = stream.getCharno();\\n\\n            if (multilineText.length() > 0) {\\n              jsdocBuilder.markText(multilineText, startLineno, startCharno,\\n                  endLineno, endCharno);\\n            }\\n\\n            return new ExtractionInfo(multilineText, token);\\n          }\\n\\n          if (builder.length() > 0) {\\n            builder.append(' ');\\n          }\\n          builder.append(toString(token));\\n\\n          line = stream.getRemainingJSDocLine();\\n\\n          if (option != WhitespaceOption.PRESERVE) {\\n            line = trimEnd(line);\\n          }\\n\\n          builder.append(line);\\n          token = next();\\n      }\\n    } while (true);\\n  }\", \"javadoc_start_line\": 1315, \"annotations_start_line\": 1328, \"method_start_line\": 1330, \"end_line\": 1429}"}]},{"name":"Closure","version":53,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.InlineObjectLiteralsTest\", \"methodName\": \"testBug545\", \"error\": \"java.lang.RuntimeException\", \"message\": \"INTERNAL COMPILER ERROR.\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/InlineObjectLiterals.java\", \"method_name\": \"replaceAssignmentExpression\", \"content\": \"    \/**\\n     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.\\n     * Note that the resulting expression will always evaluate to\\n     * true, as would the x = {...} expression.\\n     *\/\\n    private void replaceAssignmentExpression(Var v, Reference ref,\\n                                             Map<String, String> varmap) {\\n      \/\/ Compute all of the assignments necessary\\n      List<Node> nodes = Lists.newArrayList();\\n      Node val = ref.getAssignedValue();\\n      blacklistVarReferencesInTree(val, v.scope);\\n      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\\n      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\\n      for (Node key = val.getFirstChild(); key != null;\\n           key = key.getNext()) {\\n        String var = key.getString();\\n        Node value = key.removeFirstChild();\\n        \/\/ TODO(user): Copy type information.\\n        nodes.add(\\n          new Node(Token.ASSIGN,\\n                   Node.newString(Token.NAME, varmap.get(var)), value));\\n        all.remove(var);\\n      }\\n\\n      \/\/ TODO(user): Better source information.\\n      for (String var : all) {\\n        nodes.add(\\n          new Node(Token.ASSIGN,\\n                   Node.newString(Token.NAME, varmap.get(var)),\\n                   NodeUtil.newUndefinedNode(null)));\\n      }\\n\\n      Node replacement;\\n        \/\/ All assignments evaluate to true, so make sure that the\\n        \/\/ expr statement evaluates to true in case it matters.\\n        nodes.add(new Node(Token.TRUE));\\n\\n        \/\/ Join these using COMMA.  A COMMA node must have 2 children, so we\\n        \/\/ create a tree. In the tree the first child be the COMMA to match\\n        \/\/ the parser, otherwise tree equality tests fail.\\n        nodes = Lists.reverse(nodes);\\n        replacement = new Node(Token.COMMA);\\n        Node cur = replacement;\\n        int i;\\n        for (i = 0; i < nodes.size() - 2; i++) {\\n          cur.addChildToFront(nodes.get(i));\\n          Node t = new Node(Token.COMMA);\\n          cur.addChildToFront(t);\\n          cur = t;\\n        }\\n        cur.addChildToFront(nodes.get(i));\\n        cur.addChildToFront(nodes.get(i + 1));\\n\\n      Node replace = ref.getParent();\\n      replacement.copyInformationFromForTree(replace);\\n\\n      if (replace.getType() == Token.VAR) {\\n        replace.getParent().replaceChild(\\n            replace, NodeUtil.newExpr(replacement));\\n      } else {\\n        replace.getParent().replaceChild(replace, replacement);\\n      }\\n    }\", \"javadoc_start_line\": 298, \"annotations_start_line\": 303, \"method_start_line\": 304, \"end_line\": 360}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/InlineObjectLiterals.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\\n        compiler, new InliningBehavior());\\n    callback.process(externs, root);\\n  }\", \"javadoc_start_line\": 63, \"annotations_start_line\": 62, \"method_start_line\": 63, \"end_line\": 67}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Convenience method for running this pass over a tree with this\\n   * class as a callback.\\n   *\/\\n  @Override\\n  public void process(Node externs, Node root) {\\n    NodeTraversal.traverseRoots(\\n        compiler, Lists.newArrayList(externs, root), this);\\n  }\", \"javadoc_start_line\": 104, \"annotations_start_line\": 108, \"method_start_line\": 109, \"end_line\": 112}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  \/**\\n   * Traverses a list of node trees.\\n   *\/\\n  public static void traverseRoots(\\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverseRoots(roots);\\n  }\", \"javadoc_start_line\": 440, \"annotations_start_line\": 443, \"method_start_line\": 444, \"end_line\": 447}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  public void traverseRoots(List<Node> roots) {\\n    if (roots.isEmpty()) {\\n      return;\\n    }\\n\\n    try {\\n      Node scopeRoot = roots.get(0).getParent();\\n      Preconditions.checkState(scopeRoot != null);\\n\\n      inputId = NodeUtil.getInputId(scopeRoot);\\n      sourceName = \\\"\\\";\\n      curNode = scopeRoot;\\n      pushScope(scopeRoot);\\n\\n      for (Node root : roots) {\\n        Preconditions.checkState(root.getParent() == scopeRoot);\\n        traverseBranch(root, scopeRoot);\\n      }\\n\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 270, \"annotations_start_line\": 270, \"method_start_line\": 270, \"end_line\": 293}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 449, \"annotations_start_line\": 452, \"method_start_line\": 453, \"end_line\": 481}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 449, \"annotations_start_line\": 452, \"method_start_line\": 453, \"end_line\": 481}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 449, \"annotations_start_line\": 452, \"method_start_line\": 453, \"end_line\": 481}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseFunction\", \"content\": \"  \/**\\n   * Traverses a function.\\n   *\/\\n  private void traverseFunction(Node n, Node parent) {\\n    Preconditions.checkState(n.getChildCount() == 3);\\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\\n\\n    final Node fnName = n.getFirstChild();\\n\\n    boolean isFunctionExpression = (parent != null)\\n        && NodeUtil.isFunctionExpression(n);\\n\\n    if (!isFunctionExpression) {\\n      \/\/ Functions declarations are in the scope containing the declaration.\\n      traverseBranch(fnName, n);\\n    }\\n\\n    curNode = n;\\n    pushScope(n);\\n\\n    if (isFunctionExpression) {\\n      \/\/ Function expression names are only accessible within the function\\n      \/\/ scope.\\n      traverseBranch(fnName, n);\\n    }\\n\\n    final Node args = fnName.getNext();\\n    final Node body = args.getNext();\\n\\n    \/\/ Args\\n    traverseBranch(args, n);\\n\\n    \/\/ Body\\n    Preconditions.checkState(body.getNext() == null &&\\n            body.getType() == Token.BLOCK);\\n    traverseBranch(body, n);\\n\\n    popScope();\\n  }\", \"javadoc_start_line\": 483, \"annotations_start_line\": 486, \"method_start_line\": 486, \"end_line\": 521}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"popScope\", \"content\": \"  \/** Pops back to the previous scope (e.g. when leaving a function). *\/\\n  private void popScope() {\\n    if (scopeCallback != null) {\\n      scopeCallback.exitScope(this);\\n    }\\n    if (scopeRoots.isEmpty()) {\\n      scopes.pop();\\n    } else {\\n      scopeRoots.pop();\\n    }\\n    cfgs.pop();\\n  }\", \"javadoc_start_line\": 557, \"annotations_start_line\": 558, \"method_start_line\": 558, \"end_line\": 568}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"exitScope\", \"content\": \"  \/**\\n   * Updates block statck and invokes any additional behavior.\\n   *\/\\n  @Override\\n  public void exitScope(NodeTraversal t) {\\n    blockStack.pop();\\n    if (t.getScope().isGlobal()) {\\n      \/\/ Update global scope reference lists when we are done with it.\\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\\n    } else {\\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\\n    }\\n  }\", \"javadoc_start_line\": 176, \"annotations_start_line\": 179, \"method_start_line\": 180, \"end_line\": 189}"}]},{"name":"Closure","version":56,"tour_id":1,"test":"{\"className\": \" com.google.javascript.jscomp.JsMessageExtractorTest\", \"methodName\": \"testSyntaxError1\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/SourceFile.java\", \"method_name\": \"getLine\", \"content\": \"  \/**\\n   * Gets the source line for the indicated line number.\\n   *\\n   * @param lineNumber the line number, 1 being the first line of the file.\\n   * @return The line indicated. Does not include the newline at the end\\n   *     of the file. Returns {@code null} if it does not exist,\\n   *     or if there was an IO exception.\\n   *\/\\n  public String getLine(int lineNumber) {\\n    String js = \\\"\\\";\\n    try {\\n      \/\/ NOTE(nicksantos): Right now, this is optimized for few warnings.\\n      \/\/ This is probably the right trade-off, but will be slow if there\\n      \/\/ are lots of warnings in one file.\\n      js = getCode();\\n    } catch (IOException e) {\\n      return null;\\n    }\\n\\n    int pos = 0;\\n    int startLine = 1;\\n\\n    \/\/ If we've saved a previous offset and it's for a line less than the\\n    \/\/ one we're searching for, then start at that point.\\n    if (lineNumber >= lastLine) {\\n      pos = lastOffset;\\n      startLine = lastLine;\\n    }\\n\\n    for (int n = startLine; n < lineNumber; n++) {\\n      int nextpos = js.indexOf('\\\\n', pos);\\n      if (nextpos == -1) {\\n        return null;\\n      }\\n      pos = nextpos + 1;\\n    }\\n\\n    \/\/ Remember this offset for the next search we do.\\n    lastOffset = pos;\\n    lastLine = lineNumber;\\n\\n    if (js.indexOf('\\\\n', pos) == -1) {\\n      \/\/ If next new line cannot be found, there are two cases\\n      \/\/ 1. pos already reaches the end of file, then null should be returned\\n      \/\/ 2. otherwise, return the contents between pos and the end of file.\\n        return null;\\n    } else {\\n      return js.substring(pos, js.indexOf('\\\\n', pos));\\n    }\\n  }\", \"javadoc_start_line\": 197, \"annotations_start_line\": 205, \"method_start_line\": 205, \"end_line\": 246}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/JsMessageExtractor.java\", \"method_name\": \"extractMessages\", \"content\": \"  \/**\\n   * Extracts js messages from javascript code.\\n   *\/\\n  public Collection<JsMessage> extractMessages(JSSourceFile... inputs)\\n      throws IOException {\\n    return extractMessages(ImmutableList.copyOf(inputs));\\n  }\", \"javadoc_start_line\": 95, \"annotations_start_line\": 98, \"method_start_line\": 99, \"end_line\": 101}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/JsMessageExtractor.java\", \"method_name\": \"extractMessages\", \"content\": \"  \/**\\n   * Extracts js messages from javascript code.\\n   *\\n   * @param inputs  the javascript source code inputs\\n   * @return the extracted messages collection\\n   * @throws IOException if there is a problem reading the js code\\n   * @throws RuntimeException if there are problems parsing the js code or the\\n   *     js messages, or if two messages have the same key\\n   *\/\\n  public Collection<JsMessage> extractMessages(\\n      Iterable<JSSourceFile> inputs) throws IOException {\\n\\n    Compiler compiler = new Compiler();\\n    compiler.init(\\n        new JSSourceFile[] {},\\n        Iterables.toArray(inputs, JSSourceFile.class),\\n        new CompilerOptions());\\n\\n    ExtractMessagesVisitor extractCompilerPass =\\n        new ExtractMessagesVisitor(compiler);\\n    for (JSSourceFile input : inputs) {\\n      \/\/ Parse the js files individually, to prevent out-of-memory\\n      \/\/ problems.\\n      Node root = new JsAst(input).getAstRoot(compiler);\\n\\n      \/\/ Traverse the returned nodes and extract messages.\\n      extractCompilerPass.process(null, root);\\n    }\\n\\n    JSError[] errors = compiler.getErrors();\\n    \/\/ Check for errors.\\n    if (errors.length > 0) {\\n      StringBuilder msg = new StringBuilder(\\\"JSCompiler errors\\\\n\\\");\\n      MessageFormatter formatter = new LightweightMessageFormatter(compiler);\\n      for (JSError e : errors) {\\n        msg.append(formatter.formatError(e));\\n      }\\n      throw new RuntimeException(msg.toString());\\n    }\\n\\n    return extractCompilerPass.getMessages();\\n  }\", \"javadoc_start_line\": 104, \"annotations_start_line\": 113, \"method_start_line\": 114, \"end_line\": 145}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/LightweightMessageFormatter.java\", \"method_name\": \"formatError\", \"content\": \"  public String formatError(JSError error) {\\n    return format(error, false);\\n  }\", \"javadoc_start_line\": 59, \"annotations_start_line\": 58, \"method_start_line\": 59, \"end_line\": 61}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/LightweightMessageFormatter.java\", \"method_name\": \"format\", \"content\": \"  private String format(JSError error, boolean warning) {\\n    \/\/ extract source excerpt\\n    SourceExcerptProvider source = getSource();\\n    String sourceExcerpt = source == null ? null :\\n        excerpt.get(\\n            source, error.sourceName, error.lineNumber, excerptFormatter);\\n\\n    \/\/ formatting the message\\n    StringBuilder b = new StringBuilder();\\n    if (error.sourceName != null) {\\n      b.append(error.sourceName);\\n      if (error.lineNumber > 0) {\\n        b.append(':');\\n        b.append(error.lineNumber);\\n      }\\n      b.append(\\\": \\\");\\n    }\\n\\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\\n    b.append(\\\" - \\\");\\n\\n    b.append(error.description);\\n    b.append('\\\\n');\\n    if (sourceExcerpt != null) {\\n      b.append(sourceExcerpt);\\n      b.append('\\\\n');\\n      int charno = error.getCharno();\\n\\n      \/\/ padding equal to the excerpt and arrow at the end\\n      \/\/ charno == sourceExpert.length() means something is missing\\n      \/\/ at the end of the line\\n      if (excerpt.equals(LINE)\\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\\n        for (int i = 0; i < charno; i++) {\\n          char c = sourceExcerpt.charAt(i);\\n          if (Character.isWhitespace(c)) {\\n            b.append(c);\\n          } else {\\n            b.append(' ');\\n          }\\n        }\\n        b.append(\\\"^\\\\n\\\");\\n      }\\n    }\\n    return b.toString();\\n  }\", \"javadoc_start_line\": 68, \"annotations_start_line\": 68, \"method_start_line\": 68, \"end_line\": 113}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"getSourceLine\", \"content\": \"  public String getSourceLine(String sourceName, int lineNumber) {\\n    if (lineNumber < 1) {\\n      return null;\\n    }\\n    SourceFile input = getSourceFileByName(sourceName);\\n    if (input != null) {\\n      return input.getLine(lineNumber);\\n    }\\n    return null;\\n  }\", \"javadoc_start_line\": 1898, \"annotations_start_line\": 1897, \"method_start_line\": 1898, \"end_line\": 1907}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/SourceFile.java\", \"method_name\": \"getLine\", \"content\": \"  \/**\\n   * Gets the source line for the indicated line number.\\n   *\\n   * @param lineNumber the line number, 1 being the first line of the file.\\n   * @return The line indicated. Does not include the newline at the end\\n   *     of the file. Returns {@code null} if it does not exist,\\n   *     or if there was an IO exception.\\n   *\/\\n  public String getLine(int lineNumber) {\\n    String js = \\\"\\\";\\n    try {\\n      \/\/ NOTE(nicksantos): Right now, this is optimized for few warnings.\\n      \/\/ This is probably the right trade-off, but will be slow if there\\n      \/\/ are lots of warnings in one file.\\n      js = getCode();\\n    } catch (IOException e) {\\n      return null;\\n    }\\n\\n    int pos = 0;\\n    int startLine = 1;\\n\\n    \/\/ If we've saved a previous offset and it's for a line less than the\\n    \/\/ one we're searching for, then start at that point.\\n    if (lineNumber >= lastLine) {\\n      pos = lastOffset;\\n      startLine = lastLine;\\n    }\\n\\n    for (int n = startLine; n < lineNumber; n++) {\\n      int nextpos = js.indexOf('\\\\n', pos);\\n      if (nextpos == -1) {\\n        return null;\\n      }\\n      pos = nextpos + 1;\\n    }\\n\\n    \/\/ Remember this offset for the next search we do.\\n    lastOffset = pos;\\n    lastLine = lineNumber;\\n\\n    if (js.indexOf('\\\\n', pos) == -1) {\\n      \/\/ If next new line cannot be found, there are two cases\\n      \/\/ 1. pos already reaches the end of file, then null should be returned\\n      \/\/ 2. otherwise, return the contents between pos and the end of file.\\n        return null;\\n    } else {\\n      return js.substring(pos, js.indexOf('\\\\n', pos));\\n    }\\n  }\", \"javadoc_start_line\": 197, \"annotations_start_line\": 205, \"method_start_line\": 205, \"end_line\": 246}"}]},{"name":"Closure","version":58,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.LiveVariableAnalysisTest\", \"methodName\": \"testExpressionInForIn\", \"error\": \"java.lang.IllegalStateException\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/LiveVariablesAnalysis.java\", \"method_name\": \"computeGenKill\", \"content\": \"  \/**\\n   * Computes the GEN and KILL set.\\n   *\\n   * @param n Root node.\\n   * @param gen Local variables that are live because of the instruction at\\n   *        {@code n} will be added to this set.\\n   * @param kill Local variables that are killed because of the instruction at\\n   *        {@code n} will be added to this set.\\n   * @param conditional {@code true} if any assignments encountered are\\n   *        conditionally executed. These assignments might not kill a variable.\\n   *\/\\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\\n      boolean conditional) {\\n\\n    switch (n.getType()) {\\n      case Token.SCRIPT:\\n      case Token.BLOCK:\\n      case Token.FUNCTION:\\n        return;\\n\\n      case Token.WHILE:\\n      case Token.DO:\\n      case Token.IF:\\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\\n            conditional);\\n        return;\\n\\n      case Token.FOR:\\n        if (!NodeUtil.isForIn(n)) {\\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\\n              conditional);\\n        } else {\\n          \/\/ for(x in y) {...}\\n          Node lhs = n.getFirstChild();\\n          Node rhs = lhs.getNext();\\n          if (NodeUtil.isVar(lhs)) {\\n            \/\/ for(var x in y) {...}\\n            lhs = lhs.getLastChild();\\n          }\\n            addToSetIfLocal(lhs, kill);\\n            addToSetIfLocal(lhs, gen);\\n          computeGenKill(rhs, gen, kill, conditional);\\n        }\\n        return;\\n\\n      case Token.VAR:\\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n          if (c.hasChildren()) {\\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\\n            if (!conditional) {\\n              addToSetIfLocal(c, kill);\\n            }\\n          }\\n        }\\n        return;\\n\\n      case Token.AND:\\n      case Token.OR:\\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\\n        \/\/ May short circuit.\\n        computeGenKill(n.getLastChild(), gen, kill, true);\\n        return;\\n\\n      case Token.HOOK:\\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\\n        \/\/ Assume both sides are conditional.\\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\\n        computeGenKill(n.getLastChild(), gen, kill, true);\\n        return;\\n\\n      case Token.NAME:\\n        if (isArgumentsName(n)) {\\n          markAllParametersEscaped();\\n        } else {\\n          addToSetIfLocal(n, gen);\\n        }\\n        return;\\n\\n      default:\\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\\n          Node lhs = n.getFirstChild();\\n          if (!conditional) {\\n            addToSetIfLocal(lhs, kill);\\n          }\\n          if (!NodeUtil.isAssign(n)) {\\n            \/\/ assignments such as a += 1 reads a.\\n            addToSetIfLocal(lhs, gen);\\n          }\\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\\n        } else {\\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n            computeGenKill(c, gen, kill, conditional);\\n          }\\n        }\\n        return;\\n    }\\n  }\", \"javadoc_start_line\": 167, \"annotations_start_line\": 178, \"method_start_line\": 179, \"end_line\": 263}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/DataFlowAnalysis.java\", \"method_name\": \"analyze\", \"content\": \"  \/**\\n   * Finds a fixed-point solution using at most {@link #MAX_STEPS}\\n   * iterations.\\n   *\\n   * @see #analyze(int)\\n   *\/\\n  final void analyze() {\\n    analyze(MAX_STEPS);\\n  }\", \"javadoc_start_line\": 173, \"annotations_start_line\": 179, \"method_start_line\": 179, \"end_line\": 181}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/DataFlowAnalysis.java\", \"method_name\": \"analyze\", \"content\": \"  \/**\\n   * Finds a fixed-point solution. The function has the side effect of replacing\\n   * the existing node annotations with the computed solutions using {@link\\n   * com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.\\n   *\\n   * <p>Initially, each node's input and output flow state contains the value\\n   * given by {@link #createInitialEstimateLattice()} (with the exception of the\\n   * entry node of the graph which takes on the {@link #createEntryLattice()}\\n   * value. Each node will use the output state of its predecessor and compute a\\n   * output state according to the instruction. At that time, any nodes that\\n   * depends on the node's newly modified output value will need to recompute\\n   * their output state again. Each step will perform a computation at one node\\n   * until no extra computation will modify any existing output state anymore.\\n   *\\n   * @param maxSteps Max number of iterations before the method stops and throw\\n   *        a {@link MaxIterationsExceededException}. This will prevent the\\n   *        analysis from going into a infinite loop.\\n   *\/\\n  final void analyze(int maxSteps) {\\n    initialize();\\n    int step = 0;\\n    while (!orderedWorkSet.isEmpty()) {\\n      if (step > maxSteps) {\\n        throw new MaxIterationsExceededException(\\n          \\\"Analysis did not terminate after \\\" + maxSteps + \\\" iterations\\\");\\n      }\\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\\n      orderedWorkSet.remove(curNode);\\n      joinInputs(curNode);\\n      if (flow(curNode)) {\\n        \/\/ If there is a change in the current node, we want to grab the list\\n        \/\/ of nodes that this node affects.\\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\\n            cfg.getDirectedSuccNodes(curNode) :\\n            cfg.getDirectedPredNodes(curNode);\\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\\n          if (nextNode != cfg.getImplicitReturn()) {\\n            orderedWorkSet.add(nextNode);\\n          }\\n        }\\n      }\\n      step++;\\n    }\\n    if (isForward()) {\\n      joinInputs(getCfg().getImplicitReturn());\\n    }\\n  }\", \"javadoc_start_line\": 183, \"annotations_start_line\": 201, \"method_start_line\": 201, \"end_line\": 229}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/DataFlowAnalysis.java\", \"method_name\": \"flow\", \"content\": \"  \/**\\n   * Performs a single flow through a node.\\n   *\\n   * @return {@code true} if the flow state differs from the previous state.\\n   *\/\\n  protected boolean flow(DiGraphNode<N, Branch> node) {\\n    FlowState<L> state = node.getAnnotation();\\n    if (isForward()) {\\n      L outBefore = state.out;\\n      state.out = flowThrough(node.getValue(), state.in);\\n      return !outBefore.equals(state.out);\\n    } else {\\n      L inBefore = state.in;\\n      state.in = flowThrough(node.getValue(), state.out);\\n      return !inBefore.equals(state.in);\\n    }\\n  }\", \"javadoc_start_line\": 262, \"annotations_start_line\": 267, \"method_start_line\": 267, \"end_line\": 278}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/LiveVariablesAnalysis.java\", \"method_name\": \"<clinit>\", \"content\": \"class LiveVariablesAnalysis extends\", \"javadoc_start_line\": 47, \"annotations_start_line\": 47, \"method_start_line\": 47, \"end_line\": 47}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/LiveVariablesAnalysis.java\", \"method_name\": \"flowThrough\", \"content\": \"  LiveVariableLattice flowThrough(Node node, LiveVariableLattice input) {\\n    final BitSet gen = new BitSet(input.liveSet.size());\\n    final BitSet kill = new BitSet(input.liveSet.size());\\n\\n    \/\/ Make kills conditional if the node can end abruptly by an exception.\\n    boolean conditional = false;\\n    List<DiGraphEdge<Node, Branch>> edgeList = getCfg().getOutEdges(node);\\n    for (DiGraphEdge<Node, Branch> edge : edgeList) {\\n      if (Branch.ON_EX.equals(edge.getValue())) {\\n        conditional = true;\\n      }\\n    }\\n    computeGenKill(node, gen, kill, conditional);\\n    LiveVariableLattice result = new LiveVariableLattice(input);\\n    \/\/ L_in = L_out - Kill + Gen\\n    result.liveSet.andNot(kill);\\n    result.liveSet.or(gen);\\n    return result;\\n  }\", \"javadoc_start_line\": 147, \"annotations_start_line\": 146, \"method_start_line\": 147, \"end_line\": 165}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/LiveVariablesAnalysis.java\", \"method_name\": \"computeGenKill\", \"content\": \"  \/**\\n   * Computes the GEN and KILL set.\\n   *\\n   * @param n Root node.\\n   * @param gen Local variables that are live because of the instruction at\\n   *        {@code n} will be added to this set.\\n   * @param kill Local variables that are killed because of the instruction at\\n   *        {@code n} will be added to this set.\\n   * @param conditional {@code true} if any assignments encountered are\\n   *        conditionally executed. These assignments might not kill a variable.\\n   *\/\\n  private void computeGenKill(Node n, BitSet gen, BitSet kill,\\n      boolean conditional) {\\n\\n    switch (n.getType()) {\\n      case Token.SCRIPT:\\n      case Token.BLOCK:\\n      case Token.FUNCTION:\\n        return;\\n\\n      case Token.WHILE:\\n      case Token.DO:\\n      case Token.IF:\\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\\n            conditional);\\n        return;\\n\\n      case Token.FOR:\\n        if (!NodeUtil.isForIn(n)) {\\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\\n              conditional);\\n        } else {\\n          \/\/ for(x in y) {...}\\n          Node lhs = n.getFirstChild();\\n          Node rhs = lhs.getNext();\\n          if (NodeUtil.isVar(lhs)) {\\n            \/\/ for(var x in y) {...}\\n            lhs = lhs.getLastChild();\\n          }\\n            addToSetIfLocal(lhs, kill);\\n            addToSetIfLocal(lhs, gen);\\n          computeGenKill(rhs, gen, kill, conditional);\\n        }\\n        return;\\n\\n      case Token.VAR:\\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n          if (c.hasChildren()) {\\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\\n            if (!conditional) {\\n              addToSetIfLocal(c, kill);\\n            }\\n          }\\n        }\\n        return;\\n\\n      case Token.AND:\\n      case Token.OR:\\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\\n        \/\/ May short circuit.\\n        computeGenKill(n.getLastChild(), gen, kill, true);\\n        return;\\n\\n      case Token.HOOK:\\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\\n        \/\/ Assume both sides are conditional.\\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\\n        computeGenKill(n.getLastChild(), gen, kill, true);\\n        return;\\n\\n      case Token.NAME:\\n        if (isArgumentsName(n)) {\\n          markAllParametersEscaped();\\n        } else {\\n          addToSetIfLocal(n, gen);\\n        }\\n        return;\\n\\n      default:\\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\\n          Node lhs = n.getFirstChild();\\n          if (!conditional) {\\n            addToSetIfLocal(lhs, kill);\\n          }\\n          if (!NodeUtil.isAssign(n)) {\\n            \/\/ assignments such as a += 1 reads a.\\n            addToSetIfLocal(lhs, gen);\\n          }\\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\\n        } else {\\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n            computeGenKill(c, gen, kill, conditional);\\n          }\\n        }\\n        return;\\n    }\\n  }\", \"javadoc_start_line\": 167, \"annotations_start_line\": 178, \"method_start_line\": 179, \"end_line\": 263}"}]},{"name":"Closure","version":59,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.CommandLineRunnerTest\", \"methodName\": \"testCheckGlobalThisOff\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"Expected no warnings or errors\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"initOptions\", \"content\": \"  \/**\\n   * Initialize the compiler options. Only necessary if you're not doing\\n   * a normal compile() job.\\n   *\/\\n  public void initOptions(CompilerOptions options) {\\n    this.options = options;\\n    if (errorManager == null) {\\n      if (outStream == null) {\\n        setErrorManager(\\n            new LoggerErrorManager(createMessageFormatter(), logger));\\n      } else {\\n        PrintStreamErrorManager printer =\\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\\n        setErrorManager(printer);\\n      }\\n    }\\n\\n    \/\/ DiagnosticGroups override the plain checkTypes option.\\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\\n      options.checkTypes = true;\\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\\n      options.checkTypes = false;\\n    } else if (!options.checkTypes) {\\n      \/\/ If DiagnosticGroups did not override the plain checkTypes\\n      \/\/ option, and checkTypes is enabled, then turn off the\\n      \/\/ parser type warnings.\\n      options.setWarningLevel(\\n          DiagnosticGroup.forType(\\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\\n          CheckLevel.OFF);\\n    }\\n\\n    if (options.checkGlobalThisLevel.isOn()) {\\n      options.setWarningLevel(\\n          DiagnosticGroups.GLOBAL_THIS,\\n          options.checkGlobalThisLevel);\\n    }\\n\\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\\n      options.setWarningLevel(\\n          DiagnosticGroups.ES5_STRICT,\\n          CheckLevel.ERROR);\\n    }\\n\\n    \/\/ Initialize the warnings guard.\\n    List<WarningsGuard> guards = Lists.newArrayList();\\n    guards.add(\\n        new SuppressDocWarningsGuard(\\n            getDiagnosticGroups().getRegisteredGroups()));\\n    guards.add(options.getWarningsGuard());\\n\\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\\n\\n    \/\/ All passes must run the variable check. This synthesizes\\n    \/\/ variables later so that the compiler doesn't crash. It also\\n    \/\/ checks the externs file for validity. If you don't want to warn\\n    \/\/ about missing variable declarations, we shut that specific\\n    \/\/ error off.\\n    if (!options.checkSymbols &&\\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\\n    }\\n\\n    this.warningsGuard = composedGuards;\\n  }\", \"javadoc_start_line\": 222, \"annotations_start_line\": 226, \"method_start_line\": 226, \"end_line\": 288}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/AbstractCommandLineRunner.java\", \"method_name\": \"run\", \"content\": \"  \/**\\n   * Runs the Compiler and calls System.exit() with the exit status of the\\n   * compiler.\\n   *\/\\n  final public void run() {\\n    int result = 0;\\n    int runs = 1;\\n    if (config.computePhaseOrdering) {\\n      runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;\\n      PhaseOptimizer.randomizeLoops();\\n    }\\n    try {\\n      for (int i = 0; i < runs && result == 0; i++) {\\n        runTimeStats.recordStartRun();\\n        result = doRun();\\n        runTimeStats.recordEndRun();\\n      }\\n    } catch (AbstractCommandLineRunner.FlagUsageException e) {\\n      System.err.println(e.getMessage());\\n      result = -1;\\n    } catch (Throwable t) {\\n      t.printStackTrace();\\n      result = -2;\\n    }\\n\\n    if (config.computePhaseOrdering) {\\n      runTimeStats.outputBestPhaseOrdering();\\n    }\\n\\n    try {\\n      if (jsOutput instanceof Closeable) {\\n        ((Closeable) jsOutput).close();\\n      }\\n    } catch (IOException e) {\\n      throw Throwables.propagate(e);\\n    }\\n\\n    if (testMode) {\\n      exitCodeReceiverForTesting.apply(result);\\n    } else {\\n      System.exit(result);\\n    }\\n  }\", \"javadoc_start_line\": 280, \"annotations_start_line\": 284, \"method_start_line\": 284, \"end_line\": 322}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/AbstractCommandLineRunner.java\", \"method_name\": \"doRun\", \"content\": \"  \/**\\n   * Parses command-line arguments and runs the compiler.\\n   *\\n   * @return system exit status\\n   *\/\\n  protected int doRun() throws FlagUsageException, IOException {\\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\\n\\n    List<JSSourceFile> externs = createExterns();\\n\\n    compiler = createCompiler();\\n    B options = createOptions();\\n\\n    List<JSModule> modules = null;\\n    Result result = null;\\n\\n    setRunOptions(options);\\n\\n    boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\\n    if (writeOutputToFile) {\\n      jsOutput = fileNameToOutputWriter(options.jsOutputFile);\\n    } else if (jsOutput instanceof OutputStream) {\\n      jsOutput = streamToOutputWriter((OutputStream) jsOutput);\\n    }\\n\\n    List<String> jsFiles = config.js;\\n    List<String> moduleSpecs = config.module;\\n    if (!moduleSpecs.isEmpty()) {\\n      modules = createJsModules(moduleSpecs, jsFiles);\\n      if (config.skipNormalOutputs) {\\n        compiler.initModules(externs, modules, options);\\n      } else {\\n        result = compiler.compileModules(externs, modules, options);\\n      }\\n    } else {\\n      List<JSSourceFile> inputs = createSourceInputs(jsFiles);\\n      if (config.skipNormalOutputs) {\\n        compiler.init(externs, inputs, options);\\n      } else {\\n        result = compiler.compile(externs, inputs, options);\\n      }\\n    }\\n\\n    int errCode = processResults(result, modules, options);\\n    \/\/ Flush the output if we are writing to a file.\\n    \/\/ We can't close yet, because we may need to write phase ordering\\n    \/\/ info to it later.\\n    if (jsOutput instanceof Flushable) {\\n      ((Flushable) jsOutput).flush();\\n    }\\n    return errCode;\\n  }\", \"javadoc_start_line\": 614, \"annotations_start_line\": 619, \"method_start_line\": 619, \"end_line\": 665}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"compile\", \"content\": \"  \/**\\n   * Compiles a list of inputs.\\n   *\/\\n  public Result compile(List<JSSourceFile> externs,\\n      List<JSSourceFile> inputs, CompilerOptions options) {\\n    \/\/ The compile method should only be called once.\\n    Preconditions.checkState(jsRoot == null);\\n\\n    try {\\n      init(externs, inputs, options);\\n      if (hasErrors()) {\\n        return getResult();\\n      }\\n      return compile();\\n    } finally {\\n      Tracer t = newTracer(\\\"generateReport\\\");\\n      errorManager.generateReport();\\n      stopTracer(t, \\\"generateReport\\\");\\n    }\\n  }\", \"javadoc_start_line\": 501, \"annotations_start_line\": 504, \"method_start_line\": 505, \"end_line\": 520}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"initModules\", \"content\": \"  \/**\\n   * Initializes the instance state needed for a compile job if the sources\\n   * are in modules.\\n   *\/\\n  public void initModules(\\n      List<JSSourceFile> externs, List<JSModule> modules,\\n      CompilerOptions options) {\\n    initOptions(options);\\n\\n    checkFirstModule(modules);\\n    fillEmptyModules(modules);\\n\\n    this.externs = makeCompilerInput(externs, true);\\n\\n    \/\/ Generate the module graph, and report any errors in the module\\n    \/\/ specification as errors.\\n    this.modules = modules;\\n    if (modules.size() > 1) {\\n      try {\\n        this.moduleGraph = new JSModuleGraph(modules);\\n      } catch (JSModuleGraph.ModuleDependenceException e) {\\n        \/\/ problems with the module format.  Report as an error.  The\\n        \/\/ message gives all details.\\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\\n                e.getModule().getName(), e.getDependentModule().getName()));\\n        return;\\n      }\\n    } else {\\n      this.moduleGraph = null;\\n    }\\n\\n    this.inputs = getAllInputsFromModules(modules);\\n    initBasedOnOptions();\\n\\n    initInputsByNameMap();\\n  }\", \"javadoc_start_line\": 322, \"annotations_start_line\": 326, \"method_start_line\": 328, \"end_line\": 357}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"initOptions\", \"content\": \"  \/**\\n   * Initialize the compiler options. Only necessary if you're not doing\\n   * a normal compile() job.\\n   *\/\\n  public void initOptions(CompilerOptions options) {\\n    this.options = options;\\n    if (errorManager == null) {\\n      if (outStream == null) {\\n        setErrorManager(\\n            new LoggerErrorManager(createMessageFormatter(), logger));\\n      } else {\\n        PrintStreamErrorManager printer =\\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\\n        setErrorManager(printer);\\n      }\\n    }\\n\\n    \/\/ DiagnosticGroups override the plain checkTypes option.\\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\\n      options.checkTypes = true;\\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\\n      options.checkTypes = false;\\n    } else if (!options.checkTypes) {\\n      \/\/ If DiagnosticGroups did not override the plain checkTypes\\n      \/\/ option, and checkTypes is enabled, then turn off the\\n      \/\/ parser type warnings.\\n      options.setWarningLevel(\\n          DiagnosticGroup.forType(\\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\\n          CheckLevel.OFF);\\n    }\\n\\n    if (options.checkGlobalThisLevel.isOn()) {\\n      options.setWarningLevel(\\n          DiagnosticGroups.GLOBAL_THIS,\\n          options.checkGlobalThisLevel);\\n    }\\n\\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\\n      options.setWarningLevel(\\n          DiagnosticGroups.ES5_STRICT,\\n          CheckLevel.ERROR);\\n    }\\n\\n    \/\/ Initialize the warnings guard.\\n    List<WarningsGuard> guards = Lists.newArrayList();\\n    guards.add(\\n        new SuppressDocWarningsGuard(\\n            getDiagnosticGroups().getRegisteredGroups()));\\n    guards.add(options.getWarningsGuard());\\n\\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\\n\\n    \/\/ All passes must run the variable check. This synthesizes\\n    \/\/ variables later so that the compiler doesn't crash. It also\\n    \/\/ checks the externs file for validity. If you don't want to warn\\n    \/\/ about missing variable declarations, we shut that specific\\n    \/\/ error off.\\n    if (!options.checkSymbols &&\\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\\n    }\\n\\n    this.warningsGuard = composedGuards;\\n  }\", \"javadoc_start_line\": 222, \"annotations_start_line\": 226, \"method_start_line\": 226, \"end_line\": 288}"}]},{"name":"Closure","version":61,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.PeepholeRemoveDeadCodeTest\", \"methodName\": \"testCall1\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeUtil.java\", \"method_name\": \"functionCallHasSideEffects\", \"content\": \"  \/**\\n   * Returns true if calls to this function have side effects.\\n   *\\n   * @param callNode The call node to inspected.\\n   * @param compiler A compiler object to provide program state changing\\n   *     context information. Can be null.\\n   *\/\\n  static boolean functionCallHasSideEffects(\\n      Node callNode, @Nullable AbstractCompiler compiler) {\\n    if (callNode.getType() != Token.CALL) {\\n      throw new IllegalStateException(\\n          \\\"Expected CALL node, got \\\" + Token.name(callNode.getType()));\\n    }\\n\\n    if (callNode.isNoSideEffectsCall()) {\\n      return false;\\n    }\\n\\n    Node nameNode = callNode.getFirstChild();\\n\\n    \/\/ Built-in functions with no side effects.\\n    if (nameNode.getType() == Token.NAME) {\\n      String name = nameNode.getString();\\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\\n        return false;\\n      }\\n    } else if (nameNode.getType() == Token.GETPROP) {\\n      if (callNode.hasOneChild()\\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\\n                nameNode.getLastChild().getString())) {\\n        return false;\\n      }\\n\\n      if (callNode.isOnlyModifiesThisCall()\\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\\n        return false;\\n      }\\n\\n      \/\/ Functions in the \\\"Math\\\" namespace have no side effects.\\n\\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\\n          return false;\\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\\n            && STRING_REGEXP_METHODS.contains(\\n                nameNode.getLastChild().getString())) {\\n          Node param = nameNode.getNext();\\n          if (param != null &&\\n              (param.getType() == Token.STRING\\n                  || param.getType() == Token.REGEXP))\\n          return false;\\n        }\\n      }\\n    }\\n\\n    return true;\\n  }\", \"javadoc_start_line\": 919, \"annotations_start_line\": 926, \"method_start_line\": 927, \"end_line\": 976}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    NodeTraversal t = new NodeTraversal(compiler, this);\\n\\n    beginTraversal(t);\\n    t.traverse(root);\\n    endTraversal(t);\\n  }\", \"javadoc_start_line\": 53, \"annotations_start_line\": 52, \"method_start_line\": 53, \"end_line\": 59}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 241, \"annotations_start_line\": 244, \"method_start_line\": 244, \"end_line\": 254}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"visit\", \"content\": \"  public void visit(NodeTraversal t, Node n, Node parent) {\\n    Node currentVersionOfNode = n;\\n    boolean somethingChanged = false;\\n\\n    do {\\n      somethingChanged = false;\\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\\n        Node newVersionOfNode =\\n            optimization.optimizeSubtree(currentVersionOfNode);\\n\\n        if (newVersionOfNode != currentVersionOfNode) {\\n          somethingChanged = true;\\n\\n          currentVersionOfNode = newVersionOfNode;\\n        }\\n\\n        if (currentVersionOfNode == null) {\\n          return;\\n        }\\n      }\\n    } while(somethingChanged);\\n  }\", \"javadoc_start_line\": 62, \"annotations_start_line\": 61, \"method_start_line\": 62, \"end_line\": 83}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeRemoveDeadCode.java\", \"method_name\": \"optimizeSubtree\", \"content\": \"  Node optimizeSubtree(Node subtree) {\\n    switch(subtree.getType()) {\\n      case Token.ASSIGN:\\n        return tryFoldAssignment(subtree);\\n      case Token.COMMA:\\n        return tryFoldComma(subtree);\\n      case Token.SCRIPT:\\n      case Token.BLOCK:\\n        return tryOptimizeBlock(subtree);\\n      case Token.EXPR_RESULT:\\n        subtree = tryFoldExpr(subtree);\\n        return subtree;\\n      case Token.HOOK:\\n        return tryFoldHook(subtree);\\n      case Token.SWITCH:\\n        return tryOptimizeSwitch(subtree);\\n      case Token.IF:\\n        return tryFoldIf(subtree);\\n      case Token.WHILE:\\n        return tryFoldWhile(subtree);\\n       case Token.FOR: {\\n          Node condition = NodeUtil.getConditionExpression(subtree);\\n          if (condition != null) {\\n            tryFoldForCondition(condition);\\n          }\\n        }\\n        return tryFoldFor(subtree);\\n      case Token.DO:\\n        return tryFoldDo(subtree);\\n      case Token.TRY:\\n        return tryFoldTry(subtree);\\n      default:\\n          return subtree;\\n    }\\n  }\", \"javadoc_start_line\": 40, \"annotations_start_line\": 39, \"method_start_line\": 40, \"end_line\": 74}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeRemoveDeadCode.java\", \"method_name\": \"tryOptimizeBlock\", \"content\": \"  \/**\\n   * Try removing unneeded block nodes and their useless children\\n   *\/\\n  Node tryOptimizeBlock(Node n) {\\n    \/\/ Remove any useless children\\n    for (Node c = n.getFirstChild(); c != null; ) {\\n      Node next = c.getNext();  \/\/ save c.next, since 'c' may be removed\\n      if (!mayHaveSideEffects(c) && !c.isSyntheticBlock()) {\\n        \/\/ TODO(johnlenz): determine what this is actually removing. Candidates\\n        \/\/    include: EMPTY nodes, control structures without children\\n        \/\/    (removing infinite loops), empty try blocks.  What else?\\n        n.removeChild(c);  \/\/ lazy kids\\n        reportCodeChange();\\n      } else {\\n        tryOptimizeConditionalAfterAssign(c);\\n      }\\n      c = next;\\n    }\\n\\n    if (n.isSyntheticBlock() ||  n.getParent() == null) {\\n      return n;\\n    }\\n\\n    \/\/ Try to remove the block.\\n    if (NodeUtil.tryMergeBlock(n)) {\\n      reportCodeChange();\\n      return null;\\n    }\\n\\n    return n;\\n  }\", \"javadoc_start_line\": 443, \"annotations_start_line\": 446, \"method_start_line\": 446, \"end_line\": 473}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/AbstractPeepholeOptimization.java\", \"method_name\": \"mayHaveSideEffects\", \"content\": \"  \/**\\n   * @return Whether the node may have side effects when executed.\\n   *\/\\n  boolean mayHaveSideEffects(Node n) {\\n    return NodeUtil.mayHaveSideEffects(n, currentTraversal.getCompiler());\\n  }\", \"javadoc_start_line\": 114, \"annotations_start_line\": 117, \"method_start_line\": 117, \"end_line\": 119}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeUtil.java\", \"method_name\": \"mayHaveSideEffects\", \"content\": \"  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\\n    return checkForStateChangeHelper(n, false, compiler);\\n  }\", \"javadoc_start_line\": 713, \"annotations_start_line\": 713, \"method_start_line\": 713, \"end_line\": 715}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeUtil.java\", \"method_name\": \"checkForStateChangeHelper\", \"content\": \"  \/**\\n   * Returns true if some node in n's subtree changes application state.\\n   * If {@code checkForNewObjects} is true, we assume that newly created\\n   * mutable objects (like object literals) change state. Otherwise, we assume\\n   * that they have no side effects.\\n   *\/\\n  private static boolean checkForStateChangeHelper(\\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\\n    \/\/ Rather than id which ops may have side effects, id the ones\\n    \/\/ that we know to be safe\\n    switch (n.getType()) {\\n      \/\/ other side-effect free statements and expressions\\n      case Token.AND:\\n      case Token.BLOCK:\\n      case Token.EXPR_RESULT:\\n      case Token.HOOK:\\n      case Token.IF:\\n      case Token.IN:\\n      case Token.LP:\\n      case Token.NUMBER:\\n      case Token.OR:\\n      case Token.THIS:\\n      case Token.TRUE:\\n      case Token.FALSE:\\n      case Token.NULL:\\n      case Token.STRING:\\n      case Token.SWITCH:\\n      case Token.TRY:\\n      case Token.EMPTY:\\n        break;\\n\\n      \/\/ Throws are by definition side effects\\n      case Token.THROW:\\n        return true;\\n\\n      case Token.OBJECTLIT:\\n        if (checkForNewObjects) {\\n          return true;\\n        }\\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n          if (checkForStateChangeHelper(\\n                  c.getFirstChild(), checkForNewObjects, compiler)) {\\n            return true;\\n          }\\n        }\\n        return false;\\n\\n      case Token.ARRAYLIT:\\n      case Token.REGEXP:\\n        if (checkForNewObjects) {\\n          return true;\\n        }\\n        break;\\n\\n      case Token.VAR:    \/\/ empty var statement (no declaration)\\n      case Token.NAME:   \/\/ variable by itself\\n        if (n.getFirstChild() != null) {\\n          return true;\\n        }\\n        break;\\n\\n      case Token.FUNCTION:\\n        \/\/ Function expressions don't have side-effects, but function\\n        \/\/ declarations change the namespace. Either way, we don't need to\\n        \/\/ check the children, since they aren't executed at declaration time.\\n        return checkForNewObjects || !isFunctionExpression(n);\\n\\n      case Token.NEW:\\n        if (checkForNewObjects) {\\n          return true;\\n        }\\n\\n        if (!constructorCallHasSideEffects(n)) {\\n          \/\/ loop below will see if the constructor parameters have\\n          \/\/ side-effects\\n          break;\\n        }\\n        return true;\\n\\n      case Token.CALL:\\n        \/\/ calls to functions that have no side effects have the no\\n        \/\/ side effect property set.\\n        if (!functionCallHasSideEffects(n, compiler)) {\\n          \/\/ loop below will see if the function parameters have\\n          \/\/ side-effects\\n          break;\\n        }\\n        return true;\\n\\n      default:\\n        if (isSimpleOperatorType(n.getType())) {\\n          break;\\n        }\\n\\n        if (isAssignmentOp(n)) {\\n          Node assignTarget = n.getFirstChild();\\n          if (isName(assignTarget)) {\\n            return true;\\n          }\\n\\n          \/\/ Assignments will have side effects if\\n          \/\/ a) The RHS has side effects, or\\n          \/\/ b) The LHS has side effects, or\\n          \/\/ c) A name on the LHS will exist beyond the life of this statement.\\n          if (checkForStateChangeHelper(\\n                  n.getFirstChild(), checkForNewObjects, compiler) ||\\n              checkForStateChangeHelper(\\n                  n.getLastChild(), checkForNewObjects, compiler)) {\\n            return true;\\n          }\\n\\n          if (isGet(assignTarget)) {\\n            \/\/ If the object being assigned to is a local object, don't\\n            \/\/ consider this a side-effect as it can't be referenced\\n            \/\/ elsewhere.  Don't do this recursively as the property might\\n            \/\/ be an alias of another object, unlike a literal below.\\n            Node current = assignTarget.getFirstChild();\\n            if (evaluatesToLocalValue(current)) {\\n              return false;\\n            }\\n\\n            \/\/ A literal value as defined by \\\"isLiteralValue\\\" is guaranteed\\n            \/\/ not to be an alias, or any components which are aliases of\\n            \/\/ other objects.\\n            \/\/ If the root object is a literal don't consider this a\\n            \/\/ side-effect.\\n            while (isGet(current)) {\\n              current = current.getFirstChild();\\n            }\\n\\n            return !isLiteralValue(current, true);\\n          } else {\\n            \/\/ TODO(johnlenz): remove this code and make this an exception. This\\n            \/\/ is here only for legacy reasons, the AST is not valid but\\n            \/\/ preserve existing behavior.\\n            return !isLiteralValue(assignTarget, true);\\n          }\\n        }\\n\\n        return true;\\n    }\\n\\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\", \"javadoc_start_line\": 717, \"annotations_start_line\": 723, \"method_start_line\": 724, \"end_line\": 866}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeUtil.java\", \"method_name\": \"checkForStateChangeHelper\", \"content\": \"  \/**\\n   * Returns true if some node in n's subtree changes application state.\\n   * If {@code checkForNewObjects} is true, we assume that newly created\\n   * mutable objects (like object literals) change state. Otherwise, we assume\\n   * that they have no side effects.\\n   *\/\\n  private static boolean checkForStateChangeHelper(\\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\\n    \/\/ Rather than id which ops may have side effects, id the ones\\n    \/\/ that we know to be safe\\n    switch (n.getType()) {\\n      \/\/ other side-effect free statements and expressions\\n      case Token.AND:\\n      case Token.BLOCK:\\n      case Token.EXPR_RESULT:\\n      case Token.HOOK:\\n      case Token.IF:\\n      case Token.IN:\\n      case Token.LP:\\n      case Token.NUMBER:\\n      case Token.OR:\\n      case Token.THIS:\\n      case Token.TRUE:\\n      case Token.FALSE:\\n      case Token.NULL:\\n      case Token.STRING:\\n      case Token.SWITCH:\\n      case Token.TRY:\\n      case Token.EMPTY:\\n        break;\\n\\n      \/\/ Throws are by definition side effects\\n      case Token.THROW:\\n        return true;\\n\\n      case Token.OBJECTLIT:\\n        if (checkForNewObjects) {\\n          return true;\\n        }\\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n          if (checkForStateChangeHelper(\\n                  c.getFirstChild(), checkForNewObjects, compiler)) {\\n            return true;\\n          }\\n        }\\n        return false;\\n\\n      case Token.ARRAYLIT:\\n      case Token.REGEXP:\\n        if (checkForNewObjects) {\\n          return true;\\n        }\\n        break;\\n\\n      case Token.VAR:    \/\/ empty var statement (no declaration)\\n      case Token.NAME:   \/\/ variable by itself\\n        if (n.getFirstChild() != null) {\\n          return true;\\n        }\\n        break;\\n\\n      case Token.FUNCTION:\\n        \/\/ Function expressions don't have side-effects, but function\\n        \/\/ declarations change the namespace. Either way, we don't need to\\n        \/\/ check the children, since they aren't executed at declaration time.\\n        return checkForNewObjects || !isFunctionExpression(n);\\n\\n      case Token.NEW:\\n        if (checkForNewObjects) {\\n          return true;\\n        }\\n\\n        if (!constructorCallHasSideEffects(n)) {\\n          \/\/ loop below will see if the constructor parameters have\\n          \/\/ side-effects\\n          break;\\n        }\\n        return true;\\n\\n      case Token.CALL:\\n        \/\/ calls to functions that have no side effects have the no\\n        \/\/ side effect property set.\\n        if (!functionCallHasSideEffects(n, compiler)) {\\n          \/\/ loop below will see if the function parameters have\\n          \/\/ side-effects\\n          break;\\n        }\\n        return true;\\n\\n      default:\\n        if (isSimpleOperatorType(n.getType())) {\\n          break;\\n        }\\n\\n        if (isAssignmentOp(n)) {\\n          Node assignTarget = n.getFirstChild();\\n          if (isName(assignTarget)) {\\n            return true;\\n          }\\n\\n          \/\/ Assignments will have side effects if\\n          \/\/ a) The RHS has side effects, or\\n          \/\/ b) The LHS has side effects, or\\n          \/\/ c) A name on the LHS will exist beyond the life of this statement.\\n          if (checkForStateChangeHelper(\\n                  n.getFirstChild(), checkForNewObjects, compiler) ||\\n              checkForStateChangeHelper(\\n                  n.getLastChild(), checkForNewObjects, compiler)) {\\n            return true;\\n          }\\n\\n          if (isGet(assignTarget)) {\\n            \/\/ If the object being assigned to is a local object, don't\\n            \/\/ consider this a side-effect as it can't be referenced\\n            \/\/ elsewhere.  Don't do this recursively as the property might\\n            \/\/ be an alias of another object, unlike a literal below.\\n            Node current = assignTarget.getFirstChild();\\n            if (evaluatesToLocalValue(current)) {\\n              return false;\\n            }\\n\\n            \/\/ A literal value as defined by \\\"isLiteralValue\\\" is guaranteed\\n            \/\/ not to be an alias, or any components which are aliases of\\n            \/\/ other objects.\\n            \/\/ If the root object is a literal don't consider this a\\n            \/\/ side-effect.\\n            while (isGet(current)) {\\n              current = current.getFirstChild();\\n            }\\n\\n            return !isLiteralValue(current, true);\\n          } else {\\n            \/\/ TODO(johnlenz): remove this code and make this an exception. This\\n            \/\/ is here only for legacy reasons, the AST is not valid but\\n            \/\/ preserve existing behavior.\\n            return !isLiteralValue(assignTarget, true);\\n          }\\n        }\\n\\n        return true;\\n    }\\n\\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\\n      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\", \"javadoc_start_line\": 717, \"annotations_start_line\": 723, \"method_start_line\": 724, \"end_line\": 866}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeUtil.java\", \"method_name\": \"functionCallHasSideEffects\", \"content\": \"  \/**\\n   * Returns true if calls to this function have side effects.\\n   *\\n   * @param callNode The call node to inspected.\\n   * @param compiler A compiler object to provide program state changing\\n   *     context information. Can be null.\\n   *\/\\n  static boolean functionCallHasSideEffects(\\n      Node callNode, @Nullable AbstractCompiler compiler) {\\n    if (callNode.getType() != Token.CALL) {\\n      throw new IllegalStateException(\\n          \\\"Expected CALL node, got \\\" + Token.name(callNode.getType()));\\n    }\\n\\n    if (callNode.isNoSideEffectsCall()) {\\n      return false;\\n    }\\n\\n    Node nameNode = callNode.getFirstChild();\\n\\n    \/\/ Built-in functions with no side effects.\\n    if (nameNode.getType() == Token.NAME) {\\n      String name = nameNode.getString();\\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\\n        return false;\\n      }\\n    } else if (nameNode.getType() == Token.GETPROP) {\\n      if (callNode.hasOneChild()\\n          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\\n                nameNode.getLastChild().getString())) {\\n        return false;\\n      }\\n\\n      if (callNode.isOnlyModifiesThisCall()\\n          && evaluatesToLocalValue(nameNode.getFirstChild())) {\\n        return false;\\n      }\\n\\n      \/\/ Functions in the \\\"Math\\\" namespace have no side effects.\\n\\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\\n        if (nameNode.getFirstChild().getType() == Token.REGEXP\\n            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\\n          return false;\\n        } else if (nameNode.getFirstChild().getType() == Token.STRING\\n            && STRING_REGEXP_METHODS.contains(\\n                nameNode.getLastChild().getString())) {\\n          Node param = nameNode.getNext();\\n          if (param != null &&\\n              (param.getType() == Token.STRING\\n                  || param.getType() == Token.REGEXP))\\n          return false;\\n        }\\n      }\\n    }\\n\\n    return true;\\n  }\", \"javadoc_start_line\": 919, \"annotations_start_line\": 926, \"method_start_line\": 927, \"end_line\": 976}"}]},{"name":"Closure","version":66,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeCheckTest\", \"methodName\": \"testGetTypedPercent5\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<100.0> but was:<62.5>\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visit\", \"content\": \"  \/**\\n   * This is the meat of the type checking.  It is basically one big switch,\\n   * with each case representing one type of parse tree node.  The individual\\n   * cases are usually pretty straightforward.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of the node n.\\n   *\/\\n  public void visit(NodeTraversal t, Node n, Node parent) {\\n    JSType childType;\\n    JSType leftType, rightType;\\n    Node left, right;\\n    \/\/ To be explicitly set to false if the node is not typeable.\\n    boolean typeable = true;\\n\\n    switch (n.getType()) {\\n      case Token.NAME:\\n        typeable = visitName(t, n, parent);\\n        break;\\n\\n      case Token.LP:\\n        \/\/ If this is under a FUNCTION node, it is a parameter list and can be\\n        \/\/ ignored here.\\n        if (parent.getType() != Token.FUNCTION) {\\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        } else {\\n          typeable = false;\\n        }\\n        break;\\n\\n      case Token.COMMA:\\n        ensureTyped(t, n, getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.THIS:\\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        ensureTyped(t, n);\\n        break;\\n\\n      case Token.GET_REF:\\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        break;\\n\\n      case Token.NULL:\\n        ensureTyped(t, n, NULL_TYPE);\\n        break;\\n\\n      case Token.NUMBER:\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.STRING:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\\n          ensureTyped(t, n, STRING_TYPE);\\n          \/\/ Object literal keys are not typeable\\n        }\\n        break;\\n\\n      case Token.GET:\\n      case Token.SET:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        ensureTyped(t, n, ARRAY_TYPE);\\n        break;\\n\\n      case Token.REGEXP:\\n        ensureTyped(t, n, REGEXP_TYPE);\\n        break;\\n\\n      case Token.GETPROP:\\n        visitGetProp(t, n, parent);\\n        typeable = !(parent.getType() == Token.ASSIGN &&\\n                     parent.getFirstChild() == n);\\n        break;\\n\\n      case Token.GETELEM:\\n        visitGetElem(t, n);\\n        \/\/ The type of GETELEM is always unknown, so no point counting that.\\n        \/\/ If that unknown leaks elsewhere (say by an assignment to another\\n        \/\/ variable), then it will be counted.\\n        typeable = false;\\n        break;\\n\\n      case Token.VAR:\\n        visitVar(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.NEW:\\n        visitNew(t, n);\\n        typeable = true;\\n        break;\\n\\n      case Token.CALL:\\n        visitCall(t, n);\\n        typeable = !NodeUtil.isExpressionNode(parent);\\n        break;\\n\\n      case Token.RETURN:\\n        visitReturn(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.DEC:\\n      case Token.INC:\\n        left = n.getFirstChild();\\n        validator.expectNumber(\\n            t, left, getJSType(left), \\\"increment\/decrement\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.NOT:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.VOID:\\n        ensureTyped(t, n, VOID_TYPE);\\n        break;\\n\\n      case Token.TYPEOF:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.BITNOT:\\n        childType = getJSType(n.getFirstChild());\\n        if (!childType.matchesInt32Context()) {\\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\\n              childType.toString());\\n        }\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        left = n.getFirstChild();\\n        validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.EQ:\\n      case Token.NE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        TernaryValue result =\\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\\n        if (result != TernaryValue.UNKNOWN) {\\n          if (n.getType() == Token.NE) {\\n            result = result.not();\\n          }\\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\\n              rightType.toString(), result.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.SHEQ:\\n      case Token.SHNE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\\n                rightTypeRestricted)) {\\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\\n              rightType.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n        if (rightType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, leftType, \\\"left side of numeric comparison\\\");\\n        } else if (leftType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, rightType, \\\"right side of numeric comparison\\\");\\n        } else if (leftType.matchesNumberContext() &&\\n                   rightType.matchesNumberContext()) {\\n          \/\/ OK.\\n        } else {\\n          \/\/ Whether the comparison is numeric will be determined at runtime\\n          \/\/ each time the expression is evaluated. Regardless, both operands\\n          \/\/ should match a string context.\\n          String message = \\\"left side of comparison\\\";\\n          validator.expectString(t, n, leftType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, leftType, message, getNativeType(STRING_TYPE));\\n          message = \\\"right side of comparison\\\";\\n          validator.expectString(t, n, rightType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, rightType, message, getNativeType(STRING_TYPE));\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.IN:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right);\\n        validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\");\\n        validator.expectString(t, left, leftType, \\\"left side of 'in'\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.INSTANCEOF:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\\n\\n        validator.expectAnyObject(\\n            t, left, leftType, \\\"deterministic instanceof yields false\\\");\\n        validator.expectActualObject(\\n            t, right, rightType, \\\"instanceof requires an object\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.ASSIGN:\\n        visitAssign(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_MUL:\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.BITAND:\\n      case Token.SUB:\\n      case Token.ADD:\\n      case Token.MUL:\\n        visitBinaryOperator(n.getType(), t, n);\\n        break;\\n\\n      case Token.DELPROP:\\n        if (!isReference(n.getFirstChild())) {\\n          report(t, n, BAD_DELETE);\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.CASE:\\n        JSType switchType = getJSType(parent.getFirstChild());\\n        JSType caseType = getJSType(n.getFirstChild());\\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\\n        typeable = false;\\n        break;\\n\\n      case Token.WITH: {\\n        Node child = n.getFirstChild();\\n        childType = getJSType(child);\\n        validator.expectObject(\\n            t, child, childType, \\\"with requires an object\\\");\\n        typeable = false;\\n        break;\\n      }\\n\\n      case Token.FUNCTION:\\n        visitFunction(t, n);\\n        break;\\n\\n      \/\/ These nodes have no interesting type behavior.\\n      case Token.LABEL:\\n      case Token.LABEL_NAME:\\n      case Token.SWITCH:\\n      case Token.BREAK:\\n      case Token.CATCH:\\n      case Token.TRY:\\n      case Token.SCRIPT:\\n      case Token.EXPR_RESULT:\\n      case Token.BLOCK:\\n      case Token.EMPTY:\\n      case Token.DEFAULT:\\n      case Token.CONTINUE:\\n      case Token.DEBUGGER:\\n      case Token.THROW:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes require data flow analysis.\\n      case Token.DO:\\n      case Token.FOR:\\n      case Token.IF:\\n      case Token.WHILE:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes are typed during the type inference.\\n      case Token.AND:\\n      case Token.HOOK:\\n      case Token.OBJECTLIT:\\n      case Token.OR:\\n        if (n.getJSType() != null) { \/\/ If we didn't run type inference.\\n          ensureTyped(t, n);\\n        } else {\\n          \/\/ If this is an enum, then give that type to the objectlit as well.\\n          if ((n.getType() == Token.OBJECTLIT)\\n              && (parent.getJSType() instanceof EnumType)) {\\n            ensureTyped(t, n, parent.getJSType());\\n          } else {\\n            ensureTyped(t, n);\\n          }\\n        }\\n        if (n.getType() == Token.OBJECTLIT) {\\n          for (Node key : n.children()) {\\n            visitObjLitKey(t, key, n);\\n          }\\n        }\\n        break;\\n\\n      default:\\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\\n        ensureTyped(t, n);\\n        break;\\n    }\\n\\n    \/\/ Don't count externs since the user's code may not even use that part.\\n    typeable = typeable && !inExterns;\\n\\n    if (typeable) {\\n      doPercentTypedAccounting(t, n);\\n    }\\n\\n    checkNoTypeCheckSection(n, false);\\n  }\", \"javadoc_start_line\": 451, \"annotations_start_line\": 461, \"method_start_line\": 461, \"end_line\": 813}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 361, \"annotations_start_line\": 362, \"method_start_line\": 362, \"end_line\": 379}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Main entry point for this phase of processing. This follows the pattern for\\n   * JSCompiler phases.\\n   *\\n   * @param externsRoot The root of the externs parse tree.\\n   * @param jsRoot The root of the input parse tree to be checked.\\n   *\/\\n  public void process(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkNotNull(scopeCreator);\\n    Preconditions.checkNotNull(topScope);\\n\\n    Node externsAndJs = jsRoot.getParent();\\n    Preconditions.checkState(externsAndJs != null);\\n    Preconditions.checkState(\\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\\n\\n    if (externsRoot != null) {\\n      check(externsRoot, true);\\n    }\\n    check(jsRoot, false);\\n  }\", \"javadoc_start_line\": 339, \"annotations_start_line\": 346, \"method_start_line\": 346, \"end_line\": 359}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"check\", \"content\": \"  public void check(Node node, boolean externs) {\\n    Preconditions.checkNotNull(node);\\n\\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\\n    inExterns = externs;\\n    t.traverseWithScope(node, topScope);\\n    if (externs) {\\n      inferJSDocInfo.process(node, null);\\n    } else {\\n      inferJSDocInfo.process(null, node);\\n    }\\n  }\", \"javadoc_start_line\": 382, \"annotations_start_line\": 382, \"method_start_line\": 382, \"end_line\": 393}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseWithScope\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively with a scope, starting with the given\\n   * root. This should only be used in the global scope. Otherwise, use\\n   * {@link #traverseAtScope}.\\n   *\/\\n  void traverseWithScope(Node root, Scope s) {\\n    Preconditions.checkState(s.isGlobal());\\n\\n    sourceName = \\\"\\\";\\n    curNode = root;\\n    pushScope(s);\\n    traverseBranch(root, null);\\n    popScope();\\n  }\", \"javadoc_start_line\": 301, \"annotations_start_line\": 306, \"method_start_line\": 306, \"end_line\": 314}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visit\", \"content\": \"  \/**\\n   * This is the meat of the type checking.  It is basically one big switch,\\n   * with each case representing one type of parse tree node.  The individual\\n   * cases are usually pretty straightforward.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of the node n.\\n   *\/\\n  public void visit(NodeTraversal t, Node n, Node parent) {\\n    JSType childType;\\n    JSType leftType, rightType;\\n    Node left, right;\\n    \/\/ To be explicitly set to false if the node is not typeable.\\n    boolean typeable = true;\\n\\n    switch (n.getType()) {\\n      case Token.NAME:\\n        typeable = visitName(t, n, parent);\\n        break;\\n\\n      case Token.LP:\\n        \/\/ If this is under a FUNCTION node, it is a parameter list and can be\\n        \/\/ ignored here.\\n        if (parent.getType() != Token.FUNCTION) {\\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        } else {\\n          typeable = false;\\n        }\\n        break;\\n\\n      case Token.COMMA:\\n        ensureTyped(t, n, getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.THIS:\\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        ensureTyped(t, n);\\n        break;\\n\\n      case Token.GET_REF:\\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        break;\\n\\n      case Token.NULL:\\n        ensureTyped(t, n, NULL_TYPE);\\n        break;\\n\\n      case Token.NUMBER:\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.STRING:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\\n          ensureTyped(t, n, STRING_TYPE);\\n          \/\/ Object literal keys are not typeable\\n        }\\n        break;\\n\\n      case Token.GET:\\n      case Token.SET:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        ensureTyped(t, n, ARRAY_TYPE);\\n        break;\\n\\n      case Token.REGEXP:\\n        ensureTyped(t, n, REGEXP_TYPE);\\n        break;\\n\\n      case Token.GETPROP:\\n        visitGetProp(t, n, parent);\\n        typeable = !(parent.getType() == Token.ASSIGN &&\\n                     parent.getFirstChild() == n);\\n        break;\\n\\n      case Token.GETELEM:\\n        visitGetElem(t, n);\\n        \/\/ The type of GETELEM is always unknown, so no point counting that.\\n        \/\/ If that unknown leaks elsewhere (say by an assignment to another\\n        \/\/ variable), then it will be counted.\\n        typeable = false;\\n        break;\\n\\n      case Token.VAR:\\n        visitVar(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.NEW:\\n        visitNew(t, n);\\n        typeable = true;\\n        break;\\n\\n      case Token.CALL:\\n        visitCall(t, n);\\n        typeable = !NodeUtil.isExpressionNode(parent);\\n        break;\\n\\n      case Token.RETURN:\\n        visitReturn(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.DEC:\\n      case Token.INC:\\n        left = n.getFirstChild();\\n        validator.expectNumber(\\n            t, left, getJSType(left), \\\"increment\/decrement\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.NOT:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.VOID:\\n        ensureTyped(t, n, VOID_TYPE);\\n        break;\\n\\n      case Token.TYPEOF:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.BITNOT:\\n        childType = getJSType(n.getFirstChild());\\n        if (!childType.matchesInt32Context()) {\\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\\n              childType.toString());\\n        }\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        left = n.getFirstChild();\\n        validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.EQ:\\n      case Token.NE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        TernaryValue result =\\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\\n        if (result != TernaryValue.UNKNOWN) {\\n          if (n.getType() == Token.NE) {\\n            result = result.not();\\n          }\\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\\n              rightType.toString(), result.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.SHEQ:\\n      case Token.SHNE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\\n                rightTypeRestricted)) {\\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\\n              rightType.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n        if (rightType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, leftType, \\\"left side of numeric comparison\\\");\\n        } else if (leftType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, rightType, \\\"right side of numeric comparison\\\");\\n        } else if (leftType.matchesNumberContext() &&\\n                   rightType.matchesNumberContext()) {\\n          \/\/ OK.\\n        } else {\\n          \/\/ Whether the comparison is numeric will be determined at runtime\\n          \/\/ each time the expression is evaluated. Regardless, both operands\\n          \/\/ should match a string context.\\n          String message = \\\"left side of comparison\\\";\\n          validator.expectString(t, n, leftType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, leftType, message, getNativeType(STRING_TYPE));\\n          message = \\\"right side of comparison\\\";\\n          validator.expectString(t, n, rightType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, rightType, message, getNativeType(STRING_TYPE));\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.IN:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right);\\n        validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\");\\n        validator.expectString(t, left, leftType, \\\"left side of 'in'\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.INSTANCEOF:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\\n\\n        validator.expectAnyObject(\\n            t, left, leftType, \\\"deterministic instanceof yields false\\\");\\n        validator.expectActualObject(\\n            t, right, rightType, \\\"instanceof requires an object\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.ASSIGN:\\n        visitAssign(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_MUL:\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.BITAND:\\n      case Token.SUB:\\n      case Token.ADD:\\n      case Token.MUL:\\n        visitBinaryOperator(n.getType(), t, n);\\n        break;\\n\\n      case Token.DELPROP:\\n        if (!isReference(n.getFirstChild())) {\\n          report(t, n, BAD_DELETE);\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.CASE:\\n        JSType switchType = getJSType(parent.getFirstChild());\\n        JSType caseType = getJSType(n.getFirstChild());\\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\\n        typeable = false;\\n        break;\\n\\n      case Token.WITH: {\\n        Node child = n.getFirstChild();\\n        childType = getJSType(child);\\n        validator.expectObject(\\n            t, child, childType, \\\"with requires an object\\\");\\n        typeable = false;\\n        break;\\n      }\\n\\n      case Token.FUNCTION:\\n        visitFunction(t, n);\\n        break;\\n\\n      \/\/ These nodes have no interesting type behavior.\\n      case Token.LABEL:\\n      case Token.LABEL_NAME:\\n      case Token.SWITCH:\\n      case Token.BREAK:\\n      case Token.CATCH:\\n      case Token.TRY:\\n      case Token.SCRIPT:\\n      case Token.EXPR_RESULT:\\n      case Token.BLOCK:\\n      case Token.EMPTY:\\n      case Token.DEFAULT:\\n      case Token.CONTINUE:\\n      case Token.DEBUGGER:\\n      case Token.THROW:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes require data flow analysis.\\n      case Token.DO:\\n      case Token.FOR:\\n      case Token.IF:\\n      case Token.WHILE:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes are typed during the type inference.\\n      case Token.AND:\\n      case Token.HOOK:\\n      case Token.OBJECTLIT:\\n      case Token.OR:\\n        if (n.getJSType() != null) { \/\/ If we didn't run type inference.\\n          ensureTyped(t, n);\\n        } else {\\n          \/\/ If this is an enum, then give that type to the objectlit as well.\\n          if ((n.getType() == Token.OBJECTLIT)\\n              && (parent.getJSType() instanceof EnumType)) {\\n            ensureTyped(t, n, parent.getJSType());\\n          } else {\\n            ensureTyped(t, n);\\n          }\\n        }\\n        if (n.getType() == Token.OBJECTLIT) {\\n          for (Node key : n.children()) {\\n            visitObjLitKey(t, key, n);\\n          }\\n        }\\n        break;\\n\\n      default:\\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\\n        ensureTyped(t, n);\\n        break;\\n    }\\n\\n    \/\/ Don't count externs since the user's code may not even use that part.\\n    typeable = typeable && !inExterns;\\n\\n    if (typeable) {\\n      doPercentTypedAccounting(t, n);\\n    }\\n\\n    checkNoTypeCheckSection(n, false);\\n  }\", \"javadoc_start_line\": 451, \"annotations_start_line\": 461, \"method_start_line\": 461, \"end_line\": 813}"}]},{"name":"Closure","version":67,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.RemoveUnusedPrototypePropertiesTest\", \"methodName\": \"testAliasing7\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/AnalyzePrototypeProperties.java\", \"method_name\": \"isPrototypePropertyAssign\", \"content\": \"    private boolean isPrototypePropertyAssign(Node assign) {\\n      Node n = assign.getFirstChild();\\n      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\\n          && n.getType() == Token.GETPROP\\n          ) {\\n        \/\/ We want to exclude the assignment itself from the usage list\\n        boolean isChainedProperty =\\n            n.getFirstChild().getType() == Token.GETPROP;\\n\\n        if (isChainedProperty) {\\n          Node child = n.getFirstChild().getFirstChild().getNext();\\n\\n          if (child.getType() == Token.STRING &&\\n              child.getString().equals(\\\"prototype\\\")) {\\n            return true;\\n          }\\n        }\\n      }\\n\\n      return false;\\n    }\", \"javadoc_start_line\": 314, \"annotations_start_line\": 314, \"method_start_line\": 314, \"end_line\": 334}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/RemoveUnusedPrototypeProperties.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externRoot, Node root) {\\n    AnalyzePrototypeProperties analyzer =\\n        new AnalyzePrototypeProperties(compiler,\\n            null \/* no module graph *\/, canModifyExterns, anchorUnusedVars);\\n    analyzer.process(externRoot, root);\\n    removeUnusedSymbols(analyzer.getAllNameInfo());\\n  }\", \"javadoc_start_line\": 68, \"annotations_start_line\": 67, \"method_start_line\": 68, \"end_line\": 74}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/AnalyzePrototypeProperties.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externRoot, Node root) {\\n    if (!canModifyExterns) {\\n      NodeTraversal.traverse(compiler, externRoot,\\n          new ProcessExternProperties());\\n    }\\n\\n    NodeTraversal.traverse(compiler, root, new ProcessProperties());\\n\\n    FixedPointGraphTraversal<NameInfo, JSModule> t =\\n        FixedPointGraphTraversal.newTraversal(new PropagateReferences());\\n    t.computeFixedPoint(symbolGraph,\\n        Sets.newHashSet(externNode, globalNode));\\n  }\", \"javadoc_start_line\": 145, \"annotations_start_line\": 145, \"method_start_line\": 145, \"end_line\": 157}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a node recursively.\\n   *\/\\n  public static void traverse(\\n      AbstractCompiler compiler, Node root, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverse(root);\\n  }\", \"javadoc_start_line\": 416, \"annotations_start_line\": 419, \"method_start_line\": 420, \"end_line\": 423}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 241, \"annotations_start_line\": 244, \"method_start_line\": 244, \"end_line\": 254}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"}]},{"name":"Closure","version":68,"tour_id":1,"test":"{\"className\": \" com.google.javascript.jscomp.parsing.JsDocInfoParserTest\", \"methodName\": \"testIssue477\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"extra warning: Unexpected end of file\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseFunctionType\", \"content\": \"  \/**\\n   * FunctionType := 'function' FunctionSignatureType\\n   * FunctionSignatureType :=\\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\\n   *\/\\n  private Node parseFunctionType(JsDocToken token) {\\n    \/\/ NOTE(nicksantos): We're not implementing generics at the moment, so\\n    \/\/ just throw out TypeParameters.\\n    if (token != JsDocToken.LP) {\\n      return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.lp\\\");\\n    }\\n\\n    Node functionType = newNode(Token.FUNCTION);\\n    Node parameters = null;\\n    skipEOLs();\\n    if (!match(JsDocToken.RP)) {\\n      token = next();\\n\\n      boolean hasParams = true;\\n      if (token == JsDocToken.STRING) {\\n        String tokenStr = stream.getString();\\n        boolean isThis = \\\"this\\\".equals(tokenStr);\\n        boolean isNew = \\\"new\\\".equals(tokenStr);\\n        if (isThis || isNew) {\\n          if (match(JsDocToken.COLON)) {\\n            next();\\n            skipEOLs();\\n            Node contextType = wrapNode(\\n                isThis ? Token.THIS : Token.NEW,\\n                parseTypeName(next()));\\n            if (contextType == null) {\\n              return null;\\n            }\\n\\n            functionType.addChildToFront(contextType);\\n          } else {\\n            return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.colon\\\");\\n          }\\n\\n          if (match(JsDocToken.COMMA)) {\\n            next();\\n            skipEOLs();\\n            token = next();\\n          } else {\\n            hasParams = false;\\n          }\\n        }\\n      }\\n\\n      if (hasParams) {\\n        parameters = parseParametersType(token);\\n        if (parameters == null) {\\n          return null;\\n        }\\n      }\\n    }\\n\\n    if (parameters != null) {\\n      functionType.addChildToBack(parameters);\\n    }\\n\\n    skipEOLs();\\n    if (!match(JsDocToken.RP)) {\\n      return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rp\\\");\\n    }\\n\\n    skipEOLs();\\n    Node resultType = parseResultType(next());\\n    if (resultType == null) {\\n      return null;\\n    } else {\\n      functionType.addChildToBack(resultType);\\n    }\\n    return functionType;\\n  }\", \"javadoc_start_line\": 1752, \"annotations_start_line\": 1757, \"method_start_line\": 1757, \"end_line\": 1826}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parse\", \"content\": \"  \/**\\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\\n   * {@link JsDocToken#EOC} is returned.\\n   *\\n   * @return {@code true} if JSDoc information was correctly parsed,\\n   *     {@code false} otherwise\\n   *\/\\n  boolean parse() {\\n    int lineno;\\n    int charno;\\n\\n    \/\/ JSTypes are represented as Rhino AST nodes, and then resolved later.\\n    JSTypeExpression type;\\n\\n    state = State.SEARCHING_ANNOTATION;\\n    skipEOLs();\\n\\n    JsDocToken token = next();\\n\\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\\n\\n    \/\/ Always record that we have a comment.\\n    if (jsdocBuilder.shouldParseDocumentation()) {\\n      ExtractionInfo blockInfo = extractBlockComment(token);\\n      token = blockInfo.token;\\n      if (!blockInfo.string.isEmpty()) {\\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\\n      }\\n    } else {\\n      if (token != JsDocToken.ANNOTATION &&\\n          token != JsDocToken.EOC) {\\n        \/\/ Mark that there was a description, but don't bother marking\\n        \/\/ what it was.\\n        jsdocBuilder.recordBlockDescription(\\\"\\\");\\n      }\\n    }\\n\\n    \/\/ Parse the actual JsDoc.\\n    retry: for (;;) {\\n      switch (token) {\\n        case ANNOTATION:\\n          if (state == State.SEARCHING_ANNOTATION) {\\n            state = State.SEARCHING_NEWLINE;\\n            lineno = stream.getLineno();\\n            charno = stream.getCharno();\\n\\n            String annotationName = stream.getString();\\n            Annotation annotation = annotationNames.get(annotationName);\\n            if (annotation == null) {\\n              parser.addParserWarning(\\\"msg.bad.jsdoc.tag\\\", annotationName,\\n                  stream.getLineno(), stream.getCharno());\\n            } else {\\n              \/\/ Mark the beginning of the annotation.\\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\\n\\n              switch (annotation) {\\n                case AUTHOR:\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\\n                    String author = authorInfo.string;\\n\\n                    if (author.length() == 0) {\\n                      parser.addParserWarning(\\\"msg.jsdoc.authormissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      jsdocBuilder.addAuthor(author);\\n                    }\\n                    token = authorInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case CONSTANT:\\n                  if (!jsdocBuilder.recordConstancy()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.const\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case CONSTRUCTOR:\\n                  if (!jsdocBuilder.recordConstructor()) {\\n                    if (jsdocBuilder.isInterfaceRecorded()) {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case DEPRECATED:\\n                  if (!jsdocBuilder.recordDeprecated()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.deprecated\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n\\n                  \/\/ Find the reason\/description, if any.\\n                  ExtractionInfo reasonInfo =\\n                      extractMultilineTextualBlock(token);\\n\\n                  String reason = reasonInfo.string;\\n\\n                  if (reason.length() > 0) {\\n                    jsdocBuilder.recordDeprecationReason(reason);\\n                  }\\n\\n                  token = reasonInfo.token;\\n                  continue retry;\\n\\n                case INTERFACE:\\n                  if (!jsdocBuilder.recordInterface()) {\\n                    if (jsdocBuilder.isConstructorRecorded()) {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case DESC:\\n                  if (jsdocBuilder.isDescriptionRecorded()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.desc.extra\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                    token = eatTokensUntilEOL();\\n                    continue retry;\\n                  } else {\\n                    ExtractionInfo descriptionInfo =\\n                        extractMultilineTextualBlock(token);\\n\\n                    String description = descriptionInfo.string;\\n\\n                    jsdocBuilder.recordDescription(description);\\n                    token = descriptionInfo.token;\\n                    continue retry;\\n                  }\\n\\n                case FILE_OVERVIEW:\\n                  String fileOverview = \\\"\\\";\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo fileOverviewInfo =\\n                        extractMultilineTextualBlock(token,\\n                            WhitespaceOption.TRIM);\\n\\n                    fileOverview = fileOverviewInfo.string;\\n\\n                    token = fileOverviewInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n\\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\\n                      fileOverviewJSDocInfo != null) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.fileoverview.extra\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  continue retry;\\n\\n                case LICENSE:\\n                case PRESERVE:\\n                  ExtractionInfo preserveInfo =\\n                      extractMultilineTextualBlock(token,\\n                                                   WhitespaceOption.PRESERVE);\\n\\n                  String preserve = preserveInfo.string;\\n\\n                  if (preserve.length() > 0) {\\n                    if (fileLevelJsDocBuilder != null) {\\n                      fileLevelJsDocBuilder.append(preserve);\\n                    }\\n                  }\\n\\n                  token = preserveInfo.token;\\n                  continue retry;\\n\\n                case ENUM:\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n\\n                  type = null;\\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\\n                    type = createJSTypeExpression(\\n                        parseAndRecordTypeNode(token));\\n                  }\\n\\n                  if (type == null) {\\n                    type = createJSTypeExpression(newStringNode(\\\"number\\\"));\\n                  }\\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\\n                    parser.addTypeWarning(\\n                        \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                  }\\n                  token = eatTokensUntilEOL(token);\\n                  continue retry;\\n\\n                case EXPORT:\\n                  if (!jsdocBuilder.recordExport()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.export\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case EXTERNS:\\n                  if (!jsdocBuilder.recordExterns()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.externs\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case JAVA_DISPATCH:\\n                  if (!jsdocBuilder.recordJavaDispatch()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.javadispatch\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case EXTENDS:\\n                case IMPLEMENTS:\\n                  skipEOLs();\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n                  boolean matchingRc = false;\\n\\n                  if (token == JsDocToken.LC) {\\n                    token = next();\\n                    matchingRc = true;\\n                  }\\n\\n                  if (token == JsDocToken.STRING) {\\n                    Node typeNode = parseAndRecordTypeNameNode(\\n                        token, lineno, charno, matchingRc);\\n\\n                    lineno = stream.getLineno();\\n                    charno = stream.getCharno();\\n\\n                    typeNode = wrapNode(Token.BANG, typeNode);\\n                    if (typeNode != null && !matchingRc) {\\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\\n                    }\\n                    type = createJSTypeExpression(typeNode);\\n\\n                    if (annotation == Annotation.EXTENDS) {\\n                      \/\/ record the extended type, check later\\n                      extendedTypes.add(new ExtendedTypeInfo(\\n                          type, stream.getLineno(), stream.getCharno()));\\n                    } else {\\n                      Preconditions.checkState(\\n                          annotation == Annotation.IMPLEMENTS);\\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\\n                        parser.addTypeWarning(\\\"msg.jsdoc.implements.duplicate\\\",\\n                            lineno, charno);\\n                      }\\n                    }\\n                    token = next();\\n                    if (matchingRc) {\\n                      if (token != JsDocToken.RC) {\\n                        parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\",\\n                            stream.getLineno(), stream.getCharno());\\n                      }\\n                    } else if (token != JsDocToken.EOL &&\\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\\n                      parser.addTypeWarning(\\\"msg.end.annotation.expected\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  } else {\\n                    parser.addTypeWarning(\\\"msg.no.type.name\\\", lineno, charno);\\n                  }\\n                  token = eatTokensUntilEOL(token);\\n                  continue retry;\\n\\n                case HIDDEN:\\n                  if (!jsdocBuilder.recordHiddenness()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.hidden\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case LENDS:\\n                  skipEOLs();\\n\\n                  matchingRc = false;\\n                  if (match(JsDocToken.LC)) {\\n                    token = next();\\n                    matchingRc = true;\\n                  }\\n\\n                  if (match(JsDocToken.STRING)) {\\n                    token = next();\\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\\n                      parser.addTypeWarning(\\\"msg.jsdoc.lends.incompatible\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  } else {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.lends.missing\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n\\n                  if (matchingRc && !match(JsDocToken.RC)) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case MEANING:\\n                  ExtractionInfo meaningInfo =\\n                      extractMultilineTextualBlock(token);\\n                  String meaning = meaningInfo.string;\\n                  token = meaningInfo.token;\\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.meaning.extra\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  continue retry;\\n\\n                case NO_ALIAS:\\n                  if (!jsdocBuilder.recordNoAlias()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.noalias\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_COMPILE:\\n                  if (!jsdocBuilder.recordNoCompile()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.nocompile\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_TYPE_CHECK:\\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.nocheck\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NOT_IMPLEMENTED:\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case INHERIT_DOC:\\n                case OVERRIDE:\\n                  if (!jsdocBuilder.recordOverride()) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.override\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case THROWS:\\n                  skipEOLs();\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n                  type = null;\\n\\n                  if (token == JsDocToken.LC) {\\n                    type = createJSTypeExpression(\\n                        parseAndRecordTypeNode(token));\\n\\n                    if (type == null) {\\n                      \/\/ parsing error reported during recursive descent\\n                      \/\/ recovering parsing\\n                      token = eatTokensUntilEOL();\\n                      continue retry;\\n                    }\\n                  }\\n\\n                  \/\/ *Update* the token to that after the type annotation.\\n                  token = current();\\n\\n                  \/\/ Save the throw type.\\n                  jsdocBuilder.recordThrowType(type);\\n\\n                  \/\/ Find the throw's description (if applicable).\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo descriptionInfo =\\n                        extractMultilineTextualBlock(token);\\n\\n                    String description = descriptionInfo.string;\\n\\n                    if (description.length() > 0) {\\n                      jsdocBuilder.recordThrowDescription(type, description);\\n                    }\\n\\n                    token = descriptionInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case PARAM:\\n                  skipEOLs();\\n                  token = next();\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n                  type = null;\\n\\n                  if (token == JsDocToken.LC) {\\n                    type = createJSTypeExpression(\\n                        parseAndRecordParamTypeNode(token));\\n\\n                    if (type == null) {\\n                      \/\/ parsing error reported during recursive descent\\n                      \/\/ recovering parsing\\n                      token = eatTokensUntilEOL();\\n                      continue retry;\\n                    }\\n                    skipEOLs();\\n                    token = next();\\n                    lineno = stream.getLineno();\\n                    charno = stream.getCharno();\\n                  }\\n\\n                  String name = null;\\n                  boolean isBracketedParam = JsDocToken.LB == token;\\n                  if (isBracketedParam) {\\n                    token = next();\\n                  }\\n\\n                  if (JsDocToken.STRING != token) {\\n                    parser.addTypeWarning(\\\"msg.missing.variable.name\\\",\\n                        lineno, charno);\\n                  } else {\\n                    name = stream.getString();\\n\\n                    if (isBracketedParam) {\\n                      token = next();\\n\\n                      \/\/ Throw out JsDocToolkit's \\\"default\\\" parameter\\n                      \/\/ annotation.  It makes no sense under our type\\n                      \/\/ system.\\n                      if (JsDocToken.EQUALS == token) {\\n                        token = next();\\n                        if (JsDocToken.STRING == token) {\\n                          token = next();\\n                        }\\n                      }\\n\\n                      if (JsDocToken.RB != token) {\\n                        reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\");\\n                      } else if (type != null) {\\n                        \/\/ Make the type expression optional, if it isn't\\n                        \/\/ already.\\n                        type = JSTypeExpression.makeOptionalArg(type);\\n                      }\\n                    }\\n\\n                    \/\/ If the param name has a DOT in it, just throw it out\\n                    \/\/ quietly. We do not handle the JsDocToolkit method\\n                    \/\/ for handling properties of params.\\n                    if (name.indexOf('.') > -1) {\\n                      name = null;\\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\\n                      if (jsdocBuilder.hasParameter(name)) {\\n                        parser.addTypeWarning(\\\"msg.dup.variable.name\\\", name,\\n                            lineno, charno);\\n                      } else {\\n                        parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", name,\\n                            lineno, charno);\\n                      }\\n                    }\\n                  }\\n\\n                  if (name == null) {\\n                    token = eatTokensUntilEOL(token);\\n                    continue retry;\\n                  }\\n\\n                  jsdocBuilder.markName(name, lineno, charno);\\n\\n                  \/\/ Find the parameter's description (if applicable).\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo paramDescriptionInfo =\\n                        extractMultilineTextualBlock(token);\\n\\n                    String paramDescription = paramDescriptionInfo.string;\\n\\n                    if (paramDescription.length() > 0) {\\n                      jsdocBuilder.recordParameterDescription(name,\\n                          paramDescription);\\n                    }\\n\\n                    token = paramDescriptionInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case PRESERVE_TRY:\\n                  if (!jsdocBuilder.recordPreserveTry()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.preservertry\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case PRIVATE:\\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.visibility.private\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case PROTECTED:\\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.visibility.protected\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case PUBLIC:\\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.visibility.public\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_SHADOW:\\n                  if (!jsdocBuilder.recordNoShadow()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.noshadow\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case NO_SIDE_EFFECTS:\\n                  if (!jsdocBuilder.recordNoSideEffects()) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.nosideeffects\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case MODIFIES:\\n                  token = parseModifiesTag(next());\\n                  continue retry;\\n\\n                case IMPLICIT_CAST:\\n                  if (!jsdocBuilder.recordImplicitCast()) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.implicitcast\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n                  token = eatTokensUntilEOL();\\n                  continue retry;\\n\\n                case SEE:\\n                  if (jsdocBuilder.shouldParseDocumentation()) {\\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\\n                    String reference = referenceInfo.string;\\n\\n                    if (reference.length() == 0) {\\n                      parser.addParserWarning(\\\"msg.jsdoc.seemissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    } else {\\n                      jsdocBuilder.addReference(reference);\\n                    }\\n\\n                    token = referenceInfo.token;\\n                  } else {\\n                    token = eatTokensUntilEOL(token);\\n                  }\\n                  continue retry;\\n\\n                case SUPPRESS:\\n                  token = parseSuppressTag(next());\\n                  continue retry;\\n\\n                case TEMPLATE:\\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\\n                  String templateTypeName = templateInfo.string;\\n\\n                  if (templateTypeName.length() == 0) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.templatemissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\\n                      templateTypeName)) {\\n                    parser.addTypeWarning(\\\"msg.jsdoc.template.at.most.once\\\",\\n                        stream.getLineno(), stream.getCharno());\\n                  }\\n\\n                  token = templateInfo.token;\\n                  continue retry;\\n\\n                case VERSION:\\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\\n                  String version = versionInfo.string;\\n\\n                  if (version.length() == 0) {\\n                    parser.addParserWarning(\\\"msg.jsdoc.versionmissing\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                  } else {\\n                    if (!jsdocBuilder.recordVersion(version)) {\\n                       parser.addParserWarning(\\\"msg.jsdoc.extraversion\\\",\\n                          stream.getLineno(), stream.getCharno());\\n                    }\\n                  }\\n\\n                  token = versionInfo.token;\\n                  continue retry;\\n\\n                case DEFINE:\\n                case RETURN:\\n                case THIS:\\n                case TYPE:\\n                case TYPEDEF:\\n                  lineno = stream.getLineno();\\n                  charno = stream.getCharno();\\n\\n                  Node typeNode = null;\\n                  if (!lookAheadForTypeAnnotation() &&\\n                      annotation == Annotation.RETURN) {\\n                    \/\/ If RETURN doesn't have a type annotation, record\\n                    \/\/ it as the unknown type.\\n                    typeNode = newNode(Token.QMARK);\\n                  } else {\\n                    skipEOLs();\\n                    token = next();\\n                    typeNode = parseAndRecordTypeNode(token, lineno, charno);\\n                  }\\n\\n                  if (annotation == Annotation.THIS) {\\n                    typeNode = wrapNode(Token.BANG, typeNode);\\n                    if (typeNode != null && token != JsDocToken.LC) {\\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\\n                    }\\n                  }\\n                  type = createJSTypeExpression(typeNode);\\n\\n                  if (type == null) {\\n                    \/\/ error reported during recursive descent\\n                    \/\/ recovering parsing\\n                  } else {\\n                    switch (annotation) {\\n                      case DEFINE:\\n                        if (!jsdocBuilder.recordDefineType(type)) {\\n                          parser.addParserWarning(\\\"msg.jsdoc.define\\\",\\n                              lineno, charno);\\n                        }\\n                        break;\\n\\n                      case RETURN:\\n                        if (!jsdocBuilder.recordReturnType(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                          break;\\n                        }\\n\\n                        \/\/ Find the return's description (if applicable).\\n                        if (jsdocBuilder.shouldParseDocumentation()) {\\n                          ExtractionInfo returnDescriptionInfo =\\n                              extractMultilineTextualBlock(token);\\n\\n                          String returnDescription =\\n                              returnDescriptionInfo.string;\\n\\n                          if (returnDescription.length() > 0) {\\n                            jsdocBuilder.recordReturnDescription(\\n                                returnDescription);\\n                          }\\n\\n                          token = returnDescriptionInfo.token;\\n                        } else {\\n                          token = eatTokensUntilEOL(token);\\n                        }\\n                        continue retry;\\n\\n                      case THIS:\\n                        if (!jsdocBuilder.recordThisType(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                        }\\n                        break;\\n\\n                      case TYPE:\\n                        if (!jsdocBuilder.recordType(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                        }\\n                        break;\\n\\n                      case TYPEDEF:\\n                        if (!jsdocBuilder.recordTypedef(type)) {\\n                          parser.addTypeWarning(\\n                              \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                        }\\n                        break;\\n                    }\\n\\n                  token = eatTokensUntilEOL();\\n                  }\\n                  continue retry;\\n              }\\n            }\\n          }\\n          break;\\n\\n        case EOC:\\n          if (hasParsedFileOverviewDocInfo()) {\\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\\n          }\\n          checkExtendedTypes(extendedTypes);\\n          return true;\\n\\n        case EOF:\\n          \/\/ discard any accumulated information\\n          jsdocBuilder.build(null);\\n          parser.addParserWarning(\\\"msg.unexpected.eof\\\",\\n              stream.getLineno(), stream.getCharno());\\n          checkExtendedTypes(extendedTypes);\\n          return false;\\n\\n        case EOL:\\n          if (state == State.SEARCHING_NEWLINE) {\\n            state = State.SEARCHING_ANNOTATION;\\n          }\\n          token = next();\\n          continue retry;\\n\\n        default:\\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\\n            token = next();\\n            continue retry;\\n          } else {\\n            state = State.SEARCHING_NEWLINE;\\n            token = eatTokensUntilEOL();\\n            continue retry;\\n          }\\n      }\\n\\n      \/\/ next token\\n      token = next();\\n    }\\n  }\", \"javadoc_start_line\": 161, \"annotations_start_line\": 169, \"method_start_line\": 169, \"end_line\": 913}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseAndRecordTypeNode\", \"content\": \"  \/**\\n   * Looks for a type expression at the current token and if found,\\n   * returns it. Note that this method consumes input.\\n   *\\n   * @param token The current token.\\n   * @param lineno The line of the type expression.\\n   * @param startCharno The starting character position of the type expression.\\n   * @return The type expression found or null if none.\\n   *\/\\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\\n      int startCharno) {\\n    return parseAndRecordTypeNode(token, lineno, startCharno,\\n        token == JsDocToken.LC, false);\\n  }\", \"javadoc_start_line\": 1049, \"annotations_start_line\": 1058, \"method_start_line\": 1059, \"end_line\": 1062}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseAndRecordTypeNode\", \"content\": \"  \/**\\n   * Looks for a parameter type expression at the current token and if found,\\n   * returns it. Note that this method consumes input.\\n   *\\n   * @param token The current token.\\n   * @param lineno The line of the type expression.\\n   * @param startCharno The starting character position of the type expression.\\n   * @param matchingLC Whether the type expression starts with a \\\"{\\\".\\n   * @param onlyParseSimpleNames If true, only simple type names are parsed\\n   *     (via a call to parseTypeNameAnnotation instead of\\n   *     parseTypeExpressionAnnotation).\\n   * @return The type expression found or null if none.\\n   *\/\\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\\n                                      int startCharno,\\n                                      boolean matchingLC,\\n                                      boolean onlyParseSimpleNames) {\\n    Node typeNode = null;\\n\\n    if (onlyParseSimpleNames) {\\n      typeNode = parseTypeNameAnnotation(token);\\n    } else {\\n      typeNode = parseTypeExpressionAnnotation(token);\\n    }\\n\\n    if (typeNode != null && !matchingLC) {\\n      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\\n    }\\n\\n    int endCharno = stream.getCharno();\\n\\n    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\\n        matchingLC);\\n\\n    return typeNode;\\n  }\", \"javadoc_start_line\": 1105, \"annotations_start_line\": 1118, \"method_start_line\": 1121, \"end_line\": 1140}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseTypeExpressionAnnotation\", \"content\": \"  \/**\\n   * TypeExpressionAnnotation := TypeExpression |\\n   *     '{' TopLevelTypeExpression '}'\\n   *\/\\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\\n    if (token == JsDocToken.LC) {\\n      skipEOLs();\\n      Node typeNode = parseTopLevelTypeExpression(next());\\n      if (typeNode != null) {\\n        skipEOLs();\\n        if (!match(JsDocToken.RC)) {\\n          reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rc\\\");\\n        } else {\\n          next();\\n        }\\n      }\\n\\n      return typeNode;\\n    } else {\\n      return parseTypeExpression(token);\\n    }\\n  }\", \"javadoc_start_line\": 1494, \"annotations_start_line\": 1498, \"method_start_line\": 1498, \"end_line\": 1515}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseTypeExpression\", \"content\": \"  \/**\\n   * TypeExpression := BasicTypeExpression\\n   *     | '?' BasicTypeExpression\\n   *     | '!' BasicTypeExpression\\n   *     | BasicTypeExpression '?'\\n   *     | BasicTypeExpression '!'\\n   *     | '?'\\n   *\/\\n  private Node parseTypeExpression(JsDocToken token) {\\n    if (token == JsDocToken.QMARK) {\\n      \/\/ A QMARK could mean that a type is nullable, or that it's unknown.\\n      \/\/ We use look-ahead 1 to determine whether it's unknown. Otherwise,\\n      \/\/ we assume it means nullable. There are 5 cases:\\n      \/\/ {?} - right curly\\n      \/\/ {?=} - equals\\n      \/\/ {function(?, number)} - comma\\n      \/\/ {function(number, ?)} - right paren\\n      \/\/ {function(): ?|number} - pipe\\n      \/\/ I'm not a big fan of using look-ahead for this, but it makes\\n      \/\/ the type language a lot nicer.\\n      token = next();\\n      if (token == JsDocToken.COMMA ||\\n          token == JsDocToken.EQUALS ||\\n          token == JsDocToken.RC ||\\n          token == JsDocToken.RP ||\\n          token == JsDocToken.PIPE) {\\n        restoreLookAhead(token);\\n        return newNode(Token.QMARK);\\n      }\\n\\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\\n    } else if (token == JsDocToken.BANG) {\\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\\n    } else {\\n      Node basicTypeExpr = parseBasicTypeExpression(token);\\n      if (basicTypeExpr != null) {\\n        if (match(JsDocToken.QMARK)) {\\n          next();\\n          return wrapNode(Token.QMARK, basicTypeExpr);\\n        } else if (match(JsDocToken.BANG)) {\\n          next();\\n          return wrapNode(Token.BANG, basicTypeExpr);\\n        }\\n      }\\n\\n      return basicTypeExpr;\\n    }\\n  }\", \"javadoc_start_line\": 1632, \"annotations_start_line\": 1640, \"method_start_line\": 1640, \"end_line\": 1679}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseBasicTypeExpression\", \"content\": \"  \/**\\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\\n   *     | FunctionType | UnionType | RecordType | ArrayType\\n   *\/\\n  private Node parseBasicTypeExpression(JsDocToken token) {\\n    if (token == JsDocToken.STAR) {\\n      return newNode(Token.STAR);\\n    } else if (token == JsDocToken.LB) {\\n      skipEOLs();\\n      return parseArrayType(next());\\n    } else if (token == JsDocToken.LC) {\\n      skipEOLs();\\n      return parseRecordType(next());\\n    } else if (token == JsDocToken.LP) {\\n      skipEOLs();\\n      return parseUnionType(next());\\n    } else if (token == JsDocToken.STRING) {\\n      String string = stream.getString();\\n      if (\\\"function\\\".equals(string)) {\\n        skipEOLs();\\n        return parseFunctionType(next());\\n      } else if (\\\"null\\\".equals(string) || \\\"undefined\\\".equals(string)) {\\n        return newStringNode(string);\\n      } else {\\n        return parseTypeName(token);\\n      }\\n    }\\n\\n    return reportGenericTypeSyntaxWarning();\\n  }\", \"javadoc_start_line\": 1681, \"annotations_start_line\": 1685, \"method_start_line\": 1685, \"end_line\": 1710}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseFunctionType\", \"content\": \"  \/**\\n   * FunctionType := 'function' FunctionSignatureType\\n   * FunctionSignatureType :=\\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\\n   *\/\\n  private Node parseFunctionType(JsDocToken token) {\\n    \/\/ NOTE(nicksantos): We're not implementing generics at the moment, so\\n    \/\/ just throw out TypeParameters.\\n    if (token != JsDocToken.LP) {\\n      return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.lp\\\");\\n    }\\n\\n    Node functionType = newNode(Token.FUNCTION);\\n    Node parameters = null;\\n    skipEOLs();\\n    if (!match(JsDocToken.RP)) {\\n      token = next();\\n\\n      boolean hasParams = true;\\n      if (token == JsDocToken.STRING) {\\n        String tokenStr = stream.getString();\\n        boolean isThis = \\\"this\\\".equals(tokenStr);\\n        boolean isNew = \\\"new\\\".equals(tokenStr);\\n        if (isThis || isNew) {\\n          if (match(JsDocToken.COLON)) {\\n            next();\\n            skipEOLs();\\n            Node contextType = wrapNode(\\n                isThis ? Token.THIS : Token.NEW,\\n                parseTypeName(next()));\\n            if (contextType == null) {\\n              return null;\\n            }\\n\\n            functionType.addChildToFront(contextType);\\n          } else {\\n            return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.colon\\\");\\n          }\\n\\n          if (match(JsDocToken.COMMA)) {\\n            next();\\n            skipEOLs();\\n            token = next();\\n          } else {\\n            hasParams = false;\\n          }\\n        }\\n      }\\n\\n      if (hasParams) {\\n        parameters = parseParametersType(token);\\n        if (parameters == null) {\\n          return null;\\n        }\\n      }\\n    }\\n\\n    if (parameters != null) {\\n      functionType.addChildToBack(parameters);\\n    }\\n\\n    skipEOLs();\\n    if (!match(JsDocToken.RP)) {\\n      return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rp\\\");\\n    }\\n\\n    skipEOLs();\\n    Node resultType = parseResultType(next());\\n    if (resultType == null) {\\n      return null;\\n    } else {\\n      functionType.addChildToBack(resultType);\\n    }\\n    return functionType;\\n  }\", \"javadoc_start_line\": 1752, \"annotations_start_line\": 1757, \"method_start_line\": 1757, \"end_line\": 1826}"}]},{"name":"Closure","version":73,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.CodePrinterTest\", \"methodName\": \"testUnicode\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"expected:<var x=\\\"[\\\\u007f]\\\"> but was:<var x=\\\"[\\u007f]\\\">\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"strEscape\", \"content\": \"  \/** Helper to escape javascript string as well as regular expression *\/\\n  static String strEscape(String s, char quote,\\n                          String doublequoteEscape,\\n                          String singlequoteEscape,\\n                          String backslashEscape,\\n                          CharsetEncoder outputCharsetEncoder) {\\n    StringBuilder sb = new StringBuilder(s.length() + 2);\\n    sb.append(quote);\\n    for (int i = 0; i < s.length(); i++) {\\n      char c = s.charAt(i);\\n      switch (c) {\\n        case '\\\\0': sb.append(\\\"\\\\\\\\0\\\"); break;\\n        case '\\\\n': sb.append(\\\"\\\\\\\\n\\\"); break;\\n        case '\\\\r': sb.append(\\\"\\\\\\\\r\\\"); break;\\n        case '\\\\t': sb.append(\\\"\\\\\\\\t\\\"); break;\\n        case '\\\\\\\\': sb.append(backslashEscape); break;\\n        case '\\\\\\\"': sb.append(doublequoteEscape); break;\\n        case '\\\\'': sb.append(singlequoteEscape); break;\\n        case '>':                       \/\/ Break --> into --\\\\> or ]]> into ]]\\\\>\\n          if (i >= 2 &&\\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\\n            sb.append(\\\"\\\\\\\\>\\\");\\n          } else {\\n            sb.append(c);\\n          }\\n          break;\\n        case '<':\\n          \/\/ Break <\/script into <\\\\\/script\\n          final String END_SCRIPT = \\\"\/script\\\";\\n\\n          \/\/ Break <!-- into <\\\\!--\\n          final String START_COMMENT = \\\"!--\\\";\\n\\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\\n                              END_SCRIPT.length())) {\\n            sb.append(\\\"<\\\\\\\\\\\");\\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\\n                                     START_COMMENT.length())) {\\n            sb.append(\\\"<\\\\\\\\\\\");\\n          } else {\\n            sb.append(c);\\n          }\\n          break;\\n        default:\\n          \/\/ If we're given an outputCharsetEncoder, then check if the\\n          \/\/  character can be represented in this character set.\\n          if (outputCharsetEncoder != null) {\\n            if (outputCharsetEncoder.canEncode(c)) {\\n              sb.append(c);\\n            } else {\\n              \/\/ Unicode-escape the character.\\n              appendHexJavaScriptRepresentation(sb, c);\\n            }\\n          } else {\\n            \/\/ No charsetEncoder provided - pass straight latin characters\\n            \/\/ through, and escape the rest.  Doing the explicit character\\n            \/\/ check is measurably faster than using the CharsetEncoder.\\n            if (c > 0x1f && c <= 0x7f) {\\n              sb.append(c);\\n            } else {\\n              \/\/ Other characters can be misinterpreted by some js parsers,\\n              \/\/ or perhaps mangled by proxies along the way,\\n              \/\/ so we play it safe and unicode escape them.\\n              appendHexJavaScriptRepresentation(sb, c);\\n            }\\n          }\\n      }\\n    }\\n    sb.append(quote);\\n    return sb.toString();\\n  }\", \"javadoc_start_line\": 987, \"annotations_start_line\": 988, \"method_start_line\": 992, \"end_line\": 1058}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodePrinter.java\", \"method_name\": \"CodePrinter\", \"content\": \"class CodePrinter {\", \"javadoc_start_line\": 35, \"annotations_start_line\": 35, \"method_start_line\": 35, \"end_line\": 35}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodePrinter.java\", \"method_name\": \"<clinit>\", \"content\": \"class CodePrinter {\", \"javadoc_start_line\": 35, \"annotations_start_line\": 35, \"method_start_line\": 35, \"end_line\": 35}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodePrinter.java\", \"method_name\": \"toSource\", \"content\": \"  \/**\\n   * Converts a tree to js code\\n   *\/\\n  private static String toSource(Node root, Format outputFormat,\\n                                 boolean lineBreak,  int lineLengthThreshold,\\n                                 SourceMap sourceMap,\\n                                 SourceMap.DetailLevel sourceMapDetailLevel,\\n                                 Charset outputCharset,\\n                                 boolean tagAsStrict) {\\n    Preconditions.checkState(sourceMapDetailLevel != null);\\n\\n    boolean createSourceMap = (sourceMap != null);\\n    MappedCodePrinter mcp =\\n        outputFormat == Format.COMPACT\\n        ? new CompactCodePrinter(\\n            lineBreak, lineLengthThreshold,\\n            createSourceMap, sourceMapDetailLevel)\\n        : new PrettyCodePrinter(\\n            lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\\n    CodeGenerator cg =\\n        outputFormat == Format.TYPED\\n        ? new TypedCodeGenerator(mcp, outputCharset)\\n        : new CodeGenerator(mcp, outputCharset);\\n\\n    if (tagAsStrict) {\\n      cg.tagAsStrict();\\n    }\\n\\n    cg.add(root);\\n    mcp.endFile();\\n\\n    String code = mcp.getCode();\\n\\n    if (createSourceMap) {\\n      mcp.generateSourceMap(sourceMap);\\n    }\\n\\n    return code;\\n  }\", \"javadoc_start_line\": 606, \"annotations_start_line\": 609, \"method_start_line\": 614, \"end_line\": 644}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"add\", \"content\": \"  void add(Node n) {\\n    add(n, Context.OTHER);\\n  }\", \"javadoc_start_line\": 78, \"annotations_start_line\": 78, \"method_start_line\": 78, \"end_line\": 80}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"add\", \"content\": \"  void add(Node n, Context context) {\\n    if (!cc.continueProcessing()) {\\n      return;\\n    }\\n\\n    int type = n.getType();\\n    String opstr = NodeUtil.opToStr(type);\\n    int childCount = n.getChildCount();\\n    Node first = n.getFirstChild();\\n    Node last = n.getLastChild();\\n\\n    \/\/ Handle all binary operators\\n    if (opstr != null && first != last) {\\n      Preconditions.checkState(\\n          childCount == 2,\\n          \\\"Bad binary operator \\\\\\\"%s\\\\\\\": expected 2 arguments but got %s\\\",\\n          opstr, childCount);\\n      int p = NodeUtil.precedence(type);\\n      addLeftExpr(first, p, context);\\n      cc.addOp(opstr, true);\\n\\n      \/\/ For right-hand-side of operations, only pass context if it's\\n      \/\/ the IN_FOR_INIT_CLAUSE one.\\n      Context rhsContext = getContextForNoInOperator(context);\\n\\n      \/\/ Handle associativity.\\n      \/\/ e.g. if the parse tree is a * (b * c),\\n      \/\/ we can simply generate a * b * c.\\n      if (last.getType() == type &&\\n          NodeUtil.isAssociative(type)) {\\n        addExpr(last, p, rhsContext);\\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\\n        \/\/ Assignments are the only right-associative binary operators\\n        addExpr(last, p, rhsContext);\\n      } else {\\n        addExpr(last, p + 1, rhsContext);\\n      }\\n      return;\\n    }\\n\\n    cc.startSourceMapping(n);\\n\\n    switch (type) {\\n      case Token.TRY: {\\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\\n                !first.getNext().hasMoreThanOneChild());\\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\\n\\n        add(\\\"try\\\");\\n        add(first, Context.PRESERVE_BLOCK);\\n\\n        \/\/ second child contains the catch block, or nothing if there\\n        \/\/ isn't a catch block\\n        Node catchblock = first.getNext().getFirstChild();\\n        if (catchblock != null) {\\n          add(catchblock);\\n        }\\n\\n        if (childCount == 3) {\\n          add(\\\"finally\\\");\\n          add(last, Context.PRESERVE_BLOCK);\\n        }\\n        break;\\n      }\\n\\n      case Token.CATCH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"catch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        add(last, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.THROW:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"throw\\\");\\n        add(first);\\n\\n        \/\/ Must have a ';' after a throw statement, otherwise safari can't\\n        \/\/ parse this.\\n        cc.endStatement(true);\\n        break;\\n\\n      case Token.RETURN:\\n        add(\\\"return\\\");\\n        if (childCount == 1) {\\n          add(first);\\n        } else {\\n          Preconditions.checkState(childCount == 0);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.VAR:\\n        if (first != null) {\\n          add(\\\"var \\\");\\n          addList(first, false, getContextForNoInOperator(context));\\n        }\\n        break;\\n\\n      case Token.LABEL_NAME:\\n        Preconditions.checkState(!n.getString().isEmpty());\\n        addIdentifier(n.getString());\\n        break;\\n\\n      case Token.NAME:\\n        if (first == null || first.getType() == Token.EMPTY) {\\n          addIdentifier(n.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          addIdentifier(n.getString());\\n          cc.addOp(\\\"=\\\", true);\\n          if (first.getType() == Token.COMMA) {\\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\\n          } else {\\n            \/\/ Add expression, consider nearby code at lowest level of\\n            \/\/ precedence.\\n            addExpr(first, 0, getContextForNoInOperator(context));\\n          }\\n        }\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        add(\\\"[\\\");\\n        addArrayList(first);\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.LP:\\n        add(\\\"(\\\");\\n        addList(first);\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.COMMA:\\n        Preconditions.checkState(childCount == 2);\\n        addList(first, false, context);\\n        break;\\n\\n      case Token.NUMBER:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addNumber(n.getDouble());\\n        break;\\n\\n      case Token.TYPEOF:\\n      case Token.VOID:\\n      case Token.NOT:\\n      case Token.BITNOT:\\n      case Token.POS: {\\n        \/\/ All of these unary operators are right-associative\\n        Preconditions.checkState(childCount == 1);\\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n        addExpr(first, NodeUtil.precedence(type));\\n        break;\\n      }\\n\\n      case Token.NEG: {\\n        Preconditions.checkState(childCount == 1);\\n\\n        \/\/ It's important to our sanity checker that the code\\n        \/\/ we print produces the same AST as the code we parse back.\\n        \/\/ NEG is a weird case because Rhino parses \\\"- -2\\\" as \\\"2\\\".\\n        if (n.getFirstChild().getType() == Token.NUMBER) {\\n          cc.addNumber(-n.getFirstChild().getDouble());\\n        } else {\\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n          addExpr(first, NodeUtil.precedence(type));\\n        }\\n\\n        break;\\n      }\\n\\n      case Token.HOOK: {\\n        Preconditions.checkState(childCount == 3);\\n        int p = NodeUtil.precedence(type);\\n        addLeftExpr(first, p + 1, context);\\n        cc.addOp(\\\"?\\\", true);\\n        addExpr(first.getNext(), 1);\\n        cc.addOp(\\\":\\\", true);\\n        addExpr(last, 1);\\n        break;\\n      }\\n\\n      case Token.REGEXP:\\n        if (first.getType() != Token.STRING ||\\n            last.getType() != Token.STRING) {\\n          throw new Error(\\\"Expected children to be strings\\\");\\n        }\\n\\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\\n\\n        \/\/ I only use one .add because whitespace matters\\n        if (childCount == 2) {\\n          add(regexp + last.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          add(regexp);\\n        }\\n        break;\\n\\n      case Token.GET_REF:\\n        add(first);\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        Preconditions.checkState(childCount == 1);\\n        add(first);\\n        add(\\\".\\\");\\n        add((String) n.getProp(Node.NAME_PROP));\\n        break;\\n\\n      case Token.FUNCTION:\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        Preconditions.checkState(childCount == 3);\\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\\n        if (funcNeedsParens) {\\n          add(\\\"(\\\");\\n        }\\n\\n        add(\\\"function\\\");\\n        add(first);\\n\\n        add(first.getNext());\\n        add(last, Context.PRESERVE_BLOCK);\\n        cc.endFunction(context == Context.STATEMENT);\\n\\n        if (funcNeedsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.GET:\\n      case Token.SET:\\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\\n        Preconditions.checkState(childCount == 1);\\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\\n\\n        \/\/ Get methods are unnamed\\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\\n        if (type == Token.GET) {\\n          \/\/ Get methods have no parameters.\\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\\n          add(\\\"get \\\");\\n        } else {\\n          \/\/ Set methods have one parameter.\\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\\n          add(\\\"set \\\");\\n        }\\n\\n        \/\/ The name is on the GET or SET node.\\n        String name = n.getString();\\n        Node fn = first;\\n        Node parameters = fn.getChildAtIndex(1);\\n        Node body = fn.getLastChild();\\n\\n        \/\/ Add the property name.\\n        if (!n.isQuotedString() &&\\n            TokenStream.isJSIdentifier(name) &&\\n            \/\/ do not encode literally any non-literal characters that were\\n            \/\/ unicode escaped.\\n            NodeUtil.isLatin(name)) {\\n          add(name);\\n        } else {\\n          \/\/ Determine if the string is a simple number.\\n          double d = getSimpleNumber(name);\\n          if (!Double.isNaN(d)) {\\n            cc.addNumber(d);\\n          } else {\\n            add(jsString(n.getString(), outputCharsetEncoder));\\n          }\\n        }\\n\\n        add(parameters);\\n        add(body, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.SCRIPT:\\n      case Token.BLOCK: {\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\\n        if (preserveBlock) {\\n          cc.beginBlock();\\n        }\\n\\n        boolean preferLineBreaks =\\n            type == Token.SCRIPT ||\\n            (type == Token.BLOCK &&\\n                !preserveBlock &&\\n                n.getParent() != null &&\\n                n.getParent().getType() == Token.SCRIPT);\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          add(c, Context.STATEMENT);\\n\\n          \/\/ VAR doesn't include ';' since it gets used in expressions\\n          if (c.getType() == Token.VAR) {\\n            cc.endStatement();\\n          }\\n\\n          if (c.getType() == Token.FUNCTION) {\\n            cc.maybeLineBreak();\\n          }\\n\\n          \/\/ Prefer to break lines in between top-level statements\\n          \/\/ because top level statements are more homogeneous.\\n          if (preferLineBreaks) {\\n            cc.notePreferredLineBreak();\\n          }\\n        }\\n        if (preserveBlock) {\\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\\n        }\\n        break;\\n      }\\n\\n      case Token.FOR:\\n        if (childCount == 4) {\\n          add(\\\"for(\\\");\\n          if (first.getType() == Token.VAR) {\\n            add(first, Context.IN_FOR_INIT_CLAUSE);\\n          } else {\\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\\n          }\\n          add(\\\";\\\");\\n          add(first.getNext());\\n          add(\\\";\\\");\\n          add(first.getNext().getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          Preconditions.checkState(childCount == 3);\\n          add(\\\"for(\\\");\\n          add(first);\\n          add(\\\"in\\\");\\n          add(first.getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        }\\n        break;\\n\\n      case Token.DO:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"do\\\");\\n        addNonEmptyStatement(first, Context.OTHER, false);\\n        add(\\\"while(\\\");\\n        add(last);\\n        add(\\\")\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.WHILE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"while(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.EMPTY:\\n        Preconditions.checkState(childCount == 0);\\n        break;\\n\\n      case Token.GETPROP: {\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount);\\n        Preconditions.checkState(\\n            last.getType() == Token.STRING,\\n            \\\"Bad GETPROP: RHS should be STRING\\\");\\n        boolean needsParens = (first.getType() == Token.NUMBER);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        add(\\\".\\\");\\n        addIdentifier(last.getString());\\n        break;\\n      }\\n\\n      case Token.GETELEM:\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount);\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        add(\\\"[\\\");\\n        add(first.getNext());\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.WITH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"with(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.INC:\\n      case Token.DEC: {\\n        Preconditions.checkState(childCount == 1);\\n        String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\";\\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\\n        \/\/ A non-zero post-prop value indicates a post inc\/dec, default of zero\\n        \/\/ is a pre-inc\/dec.\\n        if (postProp != 0) {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n          cc.addOp(o, false);\\n        } else {\\n          cc.addOp(o, false);\\n          add(first);\\n        }\\n        break;\\n      }\\n\\n      case Token.CALL:\\n        \/\/ We have two special cases here:\\n        \/\/ 1) If the left hand side of the call is a direct reference to eval,\\n        \/\/ then it must have a DIRECT_EVAL annotation. If it does not, then\\n        \/\/ that means it was originally an indirect call to eval, and that\\n        \/\/ indirectness must be preserved.\\n        \/\/ 2) If the left hand side of the call is a property reference,\\n        \/\/ then the call must not a FREE_CALL annotation. If it does, then\\n        \/\/ that means it was originally an call without an explicit this and\\n        \/\/ that must be preserved.\\n        if (isIndirectEval(first)\\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\\n          add(\\\"(0,\\\");\\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\\n          add(\\\")\\\");\\n        } else {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n        }\\n        add(\\\"(\\\");\\n        addList(first.getNext());\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.IF:\\n        boolean hasElse = childCount == 3;\\n        boolean ambiguousElseClause =\\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\\n        if (ambiguousElseClause) {\\n          cc.beginBlock();\\n        }\\n\\n        add(\\\"if(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n\\n        if (hasElse) {\\n          addNonEmptyStatement(\\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\\n          add(\\\"else\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\\n          Preconditions.checkState(childCount == 2);\\n        }\\n\\n        if (ambiguousElseClause) {\\n          cc.endBlock();\\n        }\\n        break;\\n\\n      case Token.NULL:\\n      case Token.THIS:\\n      case Token.FALSE:\\n      case Token.TRUE:\\n        Preconditions.checkState(childCount == 0);\\n        add(Node.tokenToName(type));\\n        break;\\n\\n      case Token.CONTINUE:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"continue\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.DEBUGGER:\\n        Preconditions.checkState(childCount == 0);\\n        add(\\\"debugger\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.BREAK:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"break\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.EXPR_VOID:\\n        throw new Error(\\\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\\\");\\n\\n      case Token.EXPR_RESULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(first, Context.START_OF_EXPR);\\n        cc.endStatement();\\n        break;\\n\\n      case Token.NEW:\\n        add(\\\"new \\\");\\n        int precedence = NodeUtil.precedence(type);\\n\\n        \/\/ If the first child contains a CALL, then claim higher precedence\\n        \/\/ to force parentheses. Otherwise, when parsed, NEW will bind to the\\n        \/\/ first viable parentheses (don't traverse into functions).\\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\\n          precedence = NodeUtil.precedence(first.getType()) + 1;\\n        }\\n        addExpr(first, precedence);\\n\\n        \/\/ '()' is optional when no arguments are present\\n        Node next = first.getNext();\\n        if (next != null) {\\n          add(\\\"(\\\");\\n          addList(next);\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.STRING:\\n        if (childCount !=\\n            ((n.getParent() != null &&\\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\\n          throw new IllegalStateException(\\n              \\\"Unexpected String children: \\\" + n.getParent().toStringTree());\\n        }\\n        add(jsString(n.getString(), outputCharsetEncoder));\\n        break;\\n\\n      case Token.DELPROP:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"delete \\\");\\n        add(first);\\n        break;\\n\\n      case Token.OBJECTLIT: {\\n        boolean needsParens = (context == Context.START_OF_EXPR);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        add(\\\"{\\\");\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          if (c != first) {\\n            cc.listSeparator();\\n          }\\n\\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\\n            add(c);\\n          } else {\\n            Preconditions.checkState(c.getType() == Token.STRING);\\n            String key = c.getString();\\n            \/\/ Object literal property names don't have to be quoted if they\\n            \/\/ are not JavaScript keywords\\n            if (!c.isQuotedString() &&\\n                !TokenStream.isKeyword(key) &&\\n                TokenStream.isJSIdentifier(key) &&\\n                \/\/ do not encode literally any non-literal characters that\\n                \/\/ were unicode escaped.\\n                NodeUtil.isLatin(key)) {\\n              add(key);\\n            } else {\\n              \/\/ Determine if the string is a simple number.\\n              double d = getSimpleNumber(key);\\n              if (!Double.isNaN(d)) {\\n                cc.addNumber(d);\\n              } else {\\n                addExpr(c, 1);\\n              }\\n            }\\n            add(\\\":\\\");\\n            addExpr(c.getFirstChild(), 1);\\n          }\\n        }\\n        add(\\\"}\\\");\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n      }\\n\\n      case Token.SWITCH:\\n        add(\\\"switch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        cc.beginBlock();\\n        addAllSiblings(first.getNext());\\n        cc.endBlock(context == Context.STATEMENT);\\n        break;\\n\\n      case Token.CASE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"case \\\");\\n        add(first);\\n        addCaseBody(last);\\n        break;\\n\\n      case Token.DEFAULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"default\\\");\\n        addCaseBody(first);\\n        break;\\n\\n      case Token.LABEL:\\n        Preconditions.checkState(childCount == 2);\\n        if (first.getType() != Token.LABEL_NAME) {\\n          throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n        }\\n        add(first);\\n        add(\\\":\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), true);\\n        break;\\n\\n      \/\/ This node is auto generated in anonymous functions and should just get\\n      \/\/ ignored for our purposes.\\n      case Token.SETNAME:\\n        break;\\n\\n      default:\\n        throw new Error(\\\"Unknown type \\\" + type + \\\"\\\\n\\\" + n.toStringTree());\\n    }\\n\\n    cc.endSourceMapping(n);\\n  }\", \"javadoc_start_line\": 82, \"annotations_start_line\": 82, \"method_start_line\": 82, \"end_line\": 731}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"add\", \"content\": \"  void add(Node n, Context context) {\\n    if (!cc.continueProcessing()) {\\n      return;\\n    }\\n\\n    int type = n.getType();\\n    String opstr = NodeUtil.opToStr(type);\\n    int childCount = n.getChildCount();\\n    Node first = n.getFirstChild();\\n    Node last = n.getLastChild();\\n\\n    \/\/ Handle all binary operators\\n    if (opstr != null && first != last) {\\n      Preconditions.checkState(\\n          childCount == 2,\\n          \\\"Bad binary operator \\\\\\\"%s\\\\\\\": expected 2 arguments but got %s\\\",\\n          opstr, childCount);\\n      int p = NodeUtil.precedence(type);\\n      addLeftExpr(first, p, context);\\n      cc.addOp(opstr, true);\\n\\n      \/\/ For right-hand-side of operations, only pass context if it's\\n      \/\/ the IN_FOR_INIT_CLAUSE one.\\n      Context rhsContext = getContextForNoInOperator(context);\\n\\n      \/\/ Handle associativity.\\n      \/\/ e.g. if the parse tree is a * (b * c),\\n      \/\/ we can simply generate a * b * c.\\n      if (last.getType() == type &&\\n          NodeUtil.isAssociative(type)) {\\n        addExpr(last, p, rhsContext);\\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\\n        \/\/ Assignments are the only right-associative binary operators\\n        addExpr(last, p, rhsContext);\\n      } else {\\n        addExpr(last, p + 1, rhsContext);\\n      }\\n      return;\\n    }\\n\\n    cc.startSourceMapping(n);\\n\\n    switch (type) {\\n      case Token.TRY: {\\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\\n                !first.getNext().hasMoreThanOneChild());\\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\\n\\n        add(\\\"try\\\");\\n        add(first, Context.PRESERVE_BLOCK);\\n\\n        \/\/ second child contains the catch block, or nothing if there\\n        \/\/ isn't a catch block\\n        Node catchblock = first.getNext().getFirstChild();\\n        if (catchblock != null) {\\n          add(catchblock);\\n        }\\n\\n        if (childCount == 3) {\\n          add(\\\"finally\\\");\\n          add(last, Context.PRESERVE_BLOCK);\\n        }\\n        break;\\n      }\\n\\n      case Token.CATCH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"catch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        add(last, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.THROW:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"throw\\\");\\n        add(first);\\n\\n        \/\/ Must have a ';' after a throw statement, otherwise safari can't\\n        \/\/ parse this.\\n        cc.endStatement(true);\\n        break;\\n\\n      case Token.RETURN:\\n        add(\\\"return\\\");\\n        if (childCount == 1) {\\n          add(first);\\n        } else {\\n          Preconditions.checkState(childCount == 0);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.VAR:\\n        if (first != null) {\\n          add(\\\"var \\\");\\n          addList(first, false, getContextForNoInOperator(context));\\n        }\\n        break;\\n\\n      case Token.LABEL_NAME:\\n        Preconditions.checkState(!n.getString().isEmpty());\\n        addIdentifier(n.getString());\\n        break;\\n\\n      case Token.NAME:\\n        if (first == null || first.getType() == Token.EMPTY) {\\n          addIdentifier(n.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          addIdentifier(n.getString());\\n          cc.addOp(\\\"=\\\", true);\\n          if (first.getType() == Token.COMMA) {\\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\\n          } else {\\n            \/\/ Add expression, consider nearby code at lowest level of\\n            \/\/ precedence.\\n            addExpr(first, 0, getContextForNoInOperator(context));\\n          }\\n        }\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        add(\\\"[\\\");\\n        addArrayList(first);\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.LP:\\n        add(\\\"(\\\");\\n        addList(first);\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.COMMA:\\n        Preconditions.checkState(childCount == 2);\\n        addList(first, false, context);\\n        break;\\n\\n      case Token.NUMBER:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addNumber(n.getDouble());\\n        break;\\n\\n      case Token.TYPEOF:\\n      case Token.VOID:\\n      case Token.NOT:\\n      case Token.BITNOT:\\n      case Token.POS: {\\n        \/\/ All of these unary operators are right-associative\\n        Preconditions.checkState(childCount == 1);\\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n        addExpr(first, NodeUtil.precedence(type));\\n        break;\\n      }\\n\\n      case Token.NEG: {\\n        Preconditions.checkState(childCount == 1);\\n\\n        \/\/ It's important to our sanity checker that the code\\n        \/\/ we print produces the same AST as the code we parse back.\\n        \/\/ NEG is a weird case because Rhino parses \\\"- -2\\\" as \\\"2\\\".\\n        if (n.getFirstChild().getType() == Token.NUMBER) {\\n          cc.addNumber(-n.getFirstChild().getDouble());\\n        } else {\\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n          addExpr(first, NodeUtil.precedence(type));\\n        }\\n\\n        break;\\n      }\\n\\n      case Token.HOOK: {\\n        Preconditions.checkState(childCount == 3);\\n        int p = NodeUtil.precedence(type);\\n        addLeftExpr(first, p + 1, context);\\n        cc.addOp(\\\"?\\\", true);\\n        addExpr(first.getNext(), 1);\\n        cc.addOp(\\\":\\\", true);\\n        addExpr(last, 1);\\n        break;\\n      }\\n\\n      case Token.REGEXP:\\n        if (first.getType() != Token.STRING ||\\n            last.getType() != Token.STRING) {\\n          throw new Error(\\\"Expected children to be strings\\\");\\n        }\\n\\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\\n\\n        \/\/ I only use one .add because whitespace matters\\n        if (childCount == 2) {\\n          add(regexp + last.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          add(regexp);\\n        }\\n        break;\\n\\n      case Token.GET_REF:\\n        add(first);\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        Preconditions.checkState(childCount == 1);\\n        add(first);\\n        add(\\\".\\\");\\n        add((String) n.getProp(Node.NAME_PROP));\\n        break;\\n\\n      case Token.FUNCTION:\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        Preconditions.checkState(childCount == 3);\\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\\n        if (funcNeedsParens) {\\n          add(\\\"(\\\");\\n        }\\n\\n        add(\\\"function\\\");\\n        add(first);\\n\\n        add(first.getNext());\\n        add(last, Context.PRESERVE_BLOCK);\\n        cc.endFunction(context == Context.STATEMENT);\\n\\n        if (funcNeedsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.GET:\\n      case Token.SET:\\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\\n        Preconditions.checkState(childCount == 1);\\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\\n\\n        \/\/ Get methods are unnamed\\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\\n        if (type == Token.GET) {\\n          \/\/ Get methods have no parameters.\\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\\n          add(\\\"get \\\");\\n        } else {\\n          \/\/ Set methods have one parameter.\\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\\n          add(\\\"set \\\");\\n        }\\n\\n        \/\/ The name is on the GET or SET node.\\n        String name = n.getString();\\n        Node fn = first;\\n        Node parameters = fn.getChildAtIndex(1);\\n        Node body = fn.getLastChild();\\n\\n        \/\/ Add the property name.\\n        if (!n.isQuotedString() &&\\n            TokenStream.isJSIdentifier(name) &&\\n            \/\/ do not encode literally any non-literal characters that were\\n            \/\/ unicode escaped.\\n            NodeUtil.isLatin(name)) {\\n          add(name);\\n        } else {\\n          \/\/ Determine if the string is a simple number.\\n          double d = getSimpleNumber(name);\\n          if (!Double.isNaN(d)) {\\n            cc.addNumber(d);\\n          } else {\\n            add(jsString(n.getString(), outputCharsetEncoder));\\n          }\\n        }\\n\\n        add(parameters);\\n        add(body, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.SCRIPT:\\n      case Token.BLOCK: {\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\\n        if (preserveBlock) {\\n          cc.beginBlock();\\n        }\\n\\n        boolean preferLineBreaks =\\n            type == Token.SCRIPT ||\\n            (type == Token.BLOCK &&\\n                !preserveBlock &&\\n                n.getParent() != null &&\\n                n.getParent().getType() == Token.SCRIPT);\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          add(c, Context.STATEMENT);\\n\\n          \/\/ VAR doesn't include ';' since it gets used in expressions\\n          if (c.getType() == Token.VAR) {\\n            cc.endStatement();\\n          }\\n\\n          if (c.getType() == Token.FUNCTION) {\\n            cc.maybeLineBreak();\\n          }\\n\\n          \/\/ Prefer to break lines in between top-level statements\\n          \/\/ because top level statements are more homogeneous.\\n          if (preferLineBreaks) {\\n            cc.notePreferredLineBreak();\\n          }\\n        }\\n        if (preserveBlock) {\\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\\n        }\\n        break;\\n      }\\n\\n      case Token.FOR:\\n        if (childCount == 4) {\\n          add(\\\"for(\\\");\\n          if (first.getType() == Token.VAR) {\\n            add(first, Context.IN_FOR_INIT_CLAUSE);\\n          } else {\\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\\n          }\\n          add(\\\";\\\");\\n          add(first.getNext());\\n          add(\\\";\\\");\\n          add(first.getNext().getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          Preconditions.checkState(childCount == 3);\\n          add(\\\"for(\\\");\\n          add(first);\\n          add(\\\"in\\\");\\n          add(first.getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        }\\n        break;\\n\\n      case Token.DO:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"do\\\");\\n        addNonEmptyStatement(first, Context.OTHER, false);\\n        add(\\\"while(\\\");\\n        add(last);\\n        add(\\\")\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.WHILE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"while(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.EMPTY:\\n        Preconditions.checkState(childCount == 0);\\n        break;\\n\\n      case Token.GETPROP: {\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount);\\n        Preconditions.checkState(\\n            last.getType() == Token.STRING,\\n            \\\"Bad GETPROP: RHS should be STRING\\\");\\n        boolean needsParens = (first.getType() == Token.NUMBER);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        add(\\\".\\\");\\n        addIdentifier(last.getString());\\n        break;\\n      }\\n\\n      case Token.GETELEM:\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount);\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        add(\\\"[\\\");\\n        add(first.getNext());\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.WITH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"with(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.INC:\\n      case Token.DEC: {\\n        Preconditions.checkState(childCount == 1);\\n        String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\";\\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\\n        \/\/ A non-zero post-prop value indicates a post inc\/dec, default of zero\\n        \/\/ is a pre-inc\/dec.\\n        if (postProp != 0) {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n          cc.addOp(o, false);\\n        } else {\\n          cc.addOp(o, false);\\n          add(first);\\n        }\\n        break;\\n      }\\n\\n      case Token.CALL:\\n        \/\/ We have two special cases here:\\n        \/\/ 1) If the left hand side of the call is a direct reference to eval,\\n        \/\/ then it must have a DIRECT_EVAL annotation. If it does not, then\\n        \/\/ that means it was originally an indirect call to eval, and that\\n        \/\/ indirectness must be preserved.\\n        \/\/ 2) If the left hand side of the call is a property reference,\\n        \/\/ then the call must not a FREE_CALL annotation. If it does, then\\n        \/\/ that means it was originally an call without an explicit this and\\n        \/\/ that must be preserved.\\n        if (isIndirectEval(first)\\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\\n          add(\\\"(0,\\\");\\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\\n          add(\\\")\\\");\\n        } else {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n        }\\n        add(\\\"(\\\");\\n        addList(first.getNext());\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.IF:\\n        boolean hasElse = childCount == 3;\\n        boolean ambiguousElseClause =\\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\\n        if (ambiguousElseClause) {\\n          cc.beginBlock();\\n        }\\n\\n        add(\\\"if(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n\\n        if (hasElse) {\\n          addNonEmptyStatement(\\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\\n          add(\\\"else\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\\n          Preconditions.checkState(childCount == 2);\\n        }\\n\\n        if (ambiguousElseClause) {\\n          cc.endBlock();\\n        }\\n        break;\\n\\n      case Token.NULL:\\n      case Token.THIS:\\n      case Token.FALSE:\\n      case Token.TRUE:\\n        Preconditions.checkState(childCount == 0);\\n        add(Node.tokenToName(type));\\n        break;\\n\\n      case Token.CONTINUE:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"continue\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.DEBUGGER:\\n        Preconditions.checkState(childCount == 0);\\n        add(\\\"debugger\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.BREAK:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"break\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.EXPR_VOID:\\n        throw new Error(\\\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\\\");\\n\\n      case Token.EXPR_RESULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(first, Context.START_OF_EXPR);\\n        cc.endStatement();\\n        break;\\n\\n      case Token.NEW:\\n        add(\\\"new \\\");\\n        int precedence = NodeUtil.precedence(type);\\n\\n        \/\/ If the first child contains a CALL, then claim higher precedence\\n        \/\/ to force parentheses. Otherwise, when parsed, NEW will bind to the\\n        \/\/ first viable parentheses (don't traverse into functions).\\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\\n          precedence = NodeUtil.precedence(first.getType()) + 1;\\n        }\\n        addExpr(first, precedence);\\n\\n        \/\/ '()' is optional when no arguments are present\\n        Node next = first.getNext();\\n        if (next != null) {\\n          add(\\\"(\\\");\\n          addList(next);\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.STRING:\\n        if (childCount !=\\n            ((n.getParent() != null &&\\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\\n          throw new IllegalStateException(\\n              \\\"Unexpected String children: \\\" + n.getParent().toStringTree());\\n        }\\n        add(jsString(n.getString(), outputCharsetEncoder));\\n        break;\\n\\n      case Token.DELPROP:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"delete \\\");\\n        add(first);\\n        break;\\n\\n      case Token.OBJECTLIT: {\\n        boolean needsParens = (context == Context.START_OF_EXPR);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        add(\\\"{\\\");\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          if (c != first) {\\n            cc.listSeparator();\\n          }\\n\\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\\n            add(c);\\n          } else {\\n            Preconditions.checkState(c.getType() == Token.STRING);\\n            String key = c.getString();\\n            \/\/ Object literal property names don't have to be quoted if they\\n            \/\/ are not JavaScript keywords\\n            if (!c.isQuotedString() &&\\n                !TokenStream.isKeyword(key) &&\\n                TokenStream.isJSIdentifier(key) &&\\n                \/\/ do not encode literally any non-literal characters that\\n                \/\/ were unicode escaped.\\n                NodeUtil.isLatin(key)) {\\n              add(key);\\n            } else {\\n              \/\/ Determine if the string is a simple number.\\n              double d = getSimpleNumber(key);\\n              if (!Double.isNaN(d)) {\\n                cc.addNumber(d);\\n              } else {\\n                addExpr(c, 1);\\n              }\\n            }\\n            add(\\\":\\\");\\n            addExpr(c.getFirstChild(), 1);\\n          }\\n        }\\n        add(\\\"}\\\");\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n      }\\n\\n      case Token.SWITCH:\\n        add(\\\"switch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        cc.beginBlock();\\n        addAllSiblings(first.getNext());\\n        cc.endBlock(context == Context.STATEMENT);\\n        break;\\n\\n      case Token.CASE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"case \\\");\\n        add(first);\\n        addCaseBody(last);\\n        break;\\n\\n      case Token.DEFAULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"default\\\");\\n        addCaseBody(first);\\n        break;\\n\\n      case Token.LABEL:\\n        Preconditions.checkState(childCount == 2);\\n        if (first.getType() != Token.LABEL_NAME) {\\n          throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n        }\\n        add(first);\\n        add(\\\":\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), true);\\n        break;\\n\\n      \/\/ This node is auto generated in anonymous functions and should just get\\n      \/\/ ignored for our purposes.\\n      case Token.SETNAME:\\n        break;\\n\\n      default:\\n        throw new Error(\\\"Unknown type \\\" + type + \\\"\\\\n\\\" + n.toStringTree());\\n    }\\n\\n    cc.endSourceMapping(n);\\n  }\", \"javadoc_start_line\": 82, \"annotations_start_line\": 82, \"method_start_line\": 82, \"end_line\": 731}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"addList\", \"content\": \"  void addList(Node firstInList, boolean isArrayOrFunctionArgument,\\n               Context lhsContext) {\\n    for (Node n = firstInList; n != null; n = n.getNext()) {\\n      boolean isFirst = n == firstInList;\\n      if (isFirst) {\\n        addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);\\n      } else {\\n        cc.listSeparator();\\n        addExpr(n, isArrayOrFunctionArgument ? 1 : 0);\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 890, \"annotations_start_line\": 890, \"method_start_line\": 891, \"end_line\": 901}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"addLeftExpr\", \"content\": \"  \/**\\n   * Adds a node at the left-hand side of an expression. Unlike\\n   * {@link #addExpr(Node,int)}, this preserves information about the context.\\n   *\\n   * The left side of an expression is special because in the JavaScript\\n   * grammar, certain tokens may be parsed differently when they are at\\n   * the beginning of a statement. For example, \\\"{}\\\" is parsed as a block,\\n   * but \\\"{'x': 'y'}\\\" is parsed as an object literal.\\n   *\/\\n  void addLeftExpr(Node n, int minPrecedence, Context context) {\\n    addExpr(n, minPrecedence, context);\\n  }\", \"javadoc_start_line\": 853, \"annotations_start_line\": 862, \"method_start_line\": 862, \"end_line\": 864}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"addExpr\", \"content\": \"  private void addExpr(Node n, int minPrecedence, Context context) {\\n    if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\\n        (n.getType() == Token.IN))){\\n      add(\\\"(\\\");\\n      add(n, clearContextForNoInOperator(context));\\n      add(\\\")\\\");\\n    } else {\\n      add(n, context);\\n    }\\n  }\", \"javadoc_start_line\": 870, \"annotations_start_line\": 870, \"method_start_line\": 870, \"end_line\": 880}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"add\", \"content\": \"  void add(Node n, Context context) {\\n    if (!cc.continueProcessing()) {\\n      return;\\n    }\\n\\n    int type = n.getType();\\n    String opstr = NodeUtil.opToStr(type);\\n    int childCount = n.getChildCount();\\n    Node first = n.getFirstChild();\\n    Node last = n.getLastChild();\\n\\n    \/\/ Handle all binary operators\\n    if (opstr != null && first != last) {\\n      Preconditions.checkState(\\n          childCount == 2,\\n          \\\"Bad binary operator \\\\\\\"%s\\\\\\\": expected 2 arguments but got %s\\\",\\n          opstr, childCount);\\n      int p = NodeUtil.precedence(type);\\n      addLeftExpr(first, p, context);\\n      cc.addOp(opstr, true);\\n\\n      \/\/ For right-hand-side of operations, only pass context if it's\\n      \/\/ the IN_FOR_INIT_CLAUSE one.\\n      Context rhsContext = getContextForNoInOperator(context);\\n\\n      \/\/ Handle associativity.\\n      \/\/ e.g. if the parse tree is a * (b * c),\\n      \/\/ we can simply generate a * b * c.\\n      if (last.getType() == type &&\\n          NodeUtil.isAssociative(type)) {\\n        addExpr(last, p, rhsContext);\\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\\n        \/\/ Assignments are the only right-associative binary operators\\n        addExpr(last, p, rhsContext);\\n      } else {\\n        addExpr(last, p + 1, rhsContext);\\n      }\\n      return;\\n    }\\n\\n    cc.startSourceMapping(n);\\n\\n    switch (type) {\\n      case Token.TRY: {\\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\\n                !first.getNext().hasMoreThanOneChild());\\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\\n\\n        add(\\\"try\\\");\\n        add(first, Context.PRESERVE_BLOCK);\\n\\n        \/\/ second child contains the catch block, or nothing if there\\n        \/\/ isn't a catch block\\n        Node catchblock = first.getNext().getFirstChild();\\n        if (catchblock != null) {\\n          add(catchblock);\\n        }\\n\\n        if (childCount == 3) {\\n          add(\\\"finally\\\");\\n          add(last, Context.PRESERVE_BLOCK);\\n        }\\n        break;\\n      }\\n\\n      case Token.CATCH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"catch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        add(last, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.THROW:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"throw\\\");\\n        add(first);\\n\\n        \/\/ Must have a ';' after a throw statement, otherwise safari can't\\n        \/\/ parse this.\\n        cc.endStatement(true);\\n        break;\\n\\n      case Token.RETURN:\\n        add(\\\"return\\\");\\n        if (childCount == 1) {\\n          add(first);\\n        } else {\\n          Preconditions.checkState(childCount == 0);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.VAR:\\n        if (first != null) {\\n          add(\\\"var \\\");\\n          addList(first, false, getContextForNoInOperator(context));\\n        }\\n        break;\\n\\n      case Token.LABEL_NAME:\\n        Preconditions.checkState(!n.getString().isEmpty());\\n        addIdentifier(n.getString());\\n        break;\\n\\n      case Token.NAME:\\n        if (first == null || first.getType() == Token.EMPTY) {\\n          addIdentifier(n.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          addIdentifier(n.getString());\\n          cc.addOp(\\\"=\\\", true);\\n          if (first.getType() == Token.COMMA) {\\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\\n          } else {\\n            \/\/ Add expression, consider nearby code at lowest level of\\n            \/\/ precedence.\\n            addExpr(first, 0, getContextForNoInOperator(context));\\n          }\\n        }\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        add(\\\"[\\\");\\n        addArrayList(first);\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.LP:\\n        add(\\\"(\\\");\\n        addList(first);\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.COMMA:\\n        Preconditions.checkState(childCount == 2);\\n        addList(first, false, context);\\n        break;\\n\\n      case Token.NUMBER:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addNumber(n.getDouble());\\n        break;\\n\\n      case Token.TYPEOF:\\n      case Token.VOID:\\n      case Token.NOT:\\n      case Token.BITNOT:\\n      case Token.POS: {\\n        \/\/ All of these unary operators are right-associative\\n        Preconditions.checkState(childCount == 1);\\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n        addExpr(first, NodeUtil.precedence(type));\\n        break;\\n      }\\n\\n      case Token.NEG: {\\n        Preconditions.checkState(childCount == 1);\\n\\n        \/\/ It's important to our sanity checker that the code\\n        \/\/ we print produces the same AST as the code we parse back.\\n        \/\/ NEG is a weird case because Rhino parses \\\"- -2\\\" as \\\"2\\\".\\n        if (n.getFirstChild().getType() == Token.NUMBER) {\\n          cc.addNumber(-n.getFirstChild().getDouble());\\n        } else {\\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n          addExpr(first, NodeUtil.precedence(type));\\n        }\\n\\n        break;\\n      }\\n\\n      case Token.HOOK: {\\n        Preconditions.checkState(childCount == 3);\\n        int p = NodeUtil.precedence(type);\\n        addLeftExpr(first, p + 1, context);\\n        cc.addOp(\\\"?\\\", true);\\n        addExpr(first.getNext(), 1);\\n        cc.addOp(\\\":\\\", true);\\n        addExpr(last, 1);\\n        break;\\n      }\\n\\n      case Token.REGEXP:\\n        if (first.getType() != Token.STRING ||\\n            last.getType() != Token.STRING) {\\n          throw new Error(\\\"Expected children to be strings\\\");\\n        }\\n\\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\\n\\n        \/\/ I only use one .add because whitespace matters\\n        if (childCount == 2) {\\n          add(regexp + last.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          add(regexp);\\n        }\\n        break;\\n\\n      case Token.GET_REF:\\n        add(first);\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        Preconditions.checkState(childCount == 1);\\n        add(first);\\n        add(\\\".\\\");\\n        add((String) n.getProp(Node.NAME_PROP));\\n        break;\\n\\n      case Token.FUNCTION:\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        Preconditions.checkState(childCount == 3);\\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\\n        if (funcNeedsParens) {\\n          add(\\\"(\\\");\\n        }\\n\\n        add(\\\"function\\\");\\n        add(first);\\n\\n        add(first.getNext());\\n        add(last, Context.PRESERVE_BLOCK);\\n        cc.endFunction(context == Context.STATEMENT);\\n\\n        if (funcNeedsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.GET:\\n      case Token.SET:\\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\\n        Preconditions.checkState(childCount == 1);\\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\\n\\n        \/\/ Get methods are unnamed\\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\\n        if (type == Token.GET) {\\n          \/\/ Get methods have no parameters.\\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\\n          add(\\\"get \\\");\\n        } else {\\n          \/\/ Set methods have one parameter.\\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\\n          add(\\\"set \\\");\\n        }\\n\\n        \/\/ The name is on the GET or SET node.\\n        String name = n.getString();\\n        Node fn = first;\\n        Node parameters = fn.getChildAtIndex(1);\\n        Node body = fn.getLastChild();\\n\\n        \/\/ Add the property name.\\n        if (!n.isQuotedString() &&\\n            TokenStream.isJSIdentifier(name) &&\\n            \/\/ do not encode literally any non-literal characters that were\\n            \/\/ unicode escaped.\\n            NodeUtil.isLatin(name)) {\\n          add(name);\\n        } else {\\n          \/\/ Determine if the string is a simple number.\\n          double d = getSimpleNumber(name);\\n          if (!Double.isNaN(d)) {\\n            cc.addNumber(d);\\n          } else {\\n            add(jsString(n.getString(), outputCharsetEncoder));\\n          }\\n        }\\n\\n        add(parameters);\\n        add(body, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.SCRIPT:\\n      case Token.BLOCK: {\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\\n        if (preserveBlock) {\\n          cc.beginBlock();\\n        }\\n\\n        boolean preferLineBreaks =\\n            type == Token.SCRIPT ||\\n            (type == Token.BLOCK &&\\n                !preserveBlock &&\\n                n.getParent() != null &&\\n                n.getParent().getType() == Token.SCRIPT);\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          add(c, Context.STATEMENT);\\n\\n          \/\/ VAR doesn't include ';' since it gets used in expressions\\n          if (c.getType() == Token.VAR) {\\n            cc.endStatement();\\n          }\\n\\n          if (c.getType() == Token.FUNCTION) {\\n            cc.maybeLineBreak();\\n          }\\n\\n          \/\/ Prefer to break lines in between top-level statements\\n          \/\/ because top level statements are more homogeneous.\\n          if (preferLineBreaks) {\\n            cc.notePreferredLineBreak();\\n          }\\n        }\\n        if (preserveBlock) {\\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\\n        }\\n        break;\\n      }\\n\\n      case Token.FOR:\\n        if (childCount == 4) {\\n          add(\\\"for(\\\");\\n          if (first.getType() == Token.VAR) {\\n            add(first, Context.IN_FOR_INIT_CLAUSE);\\n          } else {\\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\\n          }\\n          add(\\\";\\\");\\n          add(first.getNext());\\n          add(\\\";\\\");\\n          add(first.getNext().getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          Preconditions.checkState(childCount == 3);\\n          add(\\\"for(\\\");\\n          add(first);\\n          add(\\\"in\\\");\\n          add(first.getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        }\\n        break;\\n\\n      case Token.DO:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"do\\\");\\n        addNonEmptyStatement(first, Context.OTHER, false);\\n        add(\\\"while(\\\");\\n        add(last);\\n        add(\\\")\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.WHILE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"while(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.EMPTY:\\n        Preconditions.checkState(childCount == 0);\\n        break;\\n\\n      case Token.GETPROP: {\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount);\\n        Preconditions.checkState(\\n            last.getType() == Token.STRING,\\n            \\\"Bad GETPROP: RHS should be STRING\\\");\\n        boolean needsParens = (first.getType() == Token.NUMBER);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        add(\\\".\\\");\\n        addIdentifier(last.getString());\\n        break;\\n      }\\n\\n      case Token.GETELEM:\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount);\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        add(\\\"[\\\");\\n        add(first.getNext());\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.WITH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"with(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.INC:\\n      case Token.DEC: {\\n        Preconditions.checkState(childCount == 1);\\n        String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\";\\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\\n        \/\/ A non-zero post-prop value indicates a post inc\/dec, default of zero\\n        \/\/ is a pre-inc\/dec.\\n        if (postProp != 0) {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n          cc.addOp(o, false);\\n        } else {\\n          cc.addOp(o, false);\\n          add(first);\\n        }\\n        break;\\n      }\\n\\n      case Token.CALL:\\n        \/\/ We have two special cases here:\\n        \/\/ 1) If the left hand side of the call is a direct reference to eval,\\n        \/\/ then it must have a DIRECT_EVAL annotation. If it does not, then\\n        \/\/ that means it was originally an indirect call to eval, and that\\n        \/\/ indirectness must be preserved.\\n        \/\/ 2) If the left hand side of the call is a property reference,\\n        \/\/ then the call must not a FREE_CALL annotation. If it does, then\\n        \/\/ that means it was originally an call without an explicit this and\\n        \/\/ that must be preserved.\\n        if (isIndirectEval(first)\\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\\n          add(\\\"(0,\\\");\\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\\n          add(\\\")\\\");\\n        } else {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n        }\\n        add(\\\"(\\\");\\n        addList(first.getNext());\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.IF:\\n        boolean hasElse = childCount == 3;\\n        boolean ambiguousElseClause =\\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\\n        if (ambiguousElseClause) {\\n          cc.beginBlock();\\n        }\\n\\n        add(\\\"if(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n\\n        if (hasElse) {\\n          addNonEmptyStatement(\\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\\n          add(\\\"else\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\\n          Preconditions.checkState(childCount == 2);\\n        }\\n\\n        if (ambiguousElseClause) {\\n          cc.endBlock();\\n        }\\n        break;\\n\\n      case Token.NULL:\\n      case Token.THIS:\\n      case Token.FALSE:\\n      case Token.TRUE:\\n        Preconditions.checkState(childCount == 0);\\n        add(Node.tokenToName(type));\\n        break;\\n\\n      case Token.CONTINUE:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"continue\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.DEBUGGER:\\n        Preconditions.checkState(childCount == 0);\\n        add(\\\"debugger\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.BREAK:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"break\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.EXPR_VOID:\\n        throw new Error(\\\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\\\");\\n\\n      case Token.EXPR_RESULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(first, Context.START_OF_EXPR);\\n        cc.endStatement();\\n        break;\\n\\n      case Token.NEW:\\n        add(\\\"new \\\");\\n        int precedence = NodeUtil.precedence(type);\\n\\n        \/\/ If the first child contains a CALL, then claim higher precedence\\n        \/\/ to force parentheses. Otherwise, when parsed, NEW will bind to the\\n        \/\/ first viable parentheses (don't traverse into functions).\\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\\n          precedence = NodeUtil.precedence(first.getType()) + 1;\\n        }\\n        addExpr(first, precedence);\\n\\n        \/\/ '()' is optional when no arguments are present\\n        Node next = first.getNext();\\n        if (next != null) {\\n          add(\\\"(\\\");\\n          addList(next);\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.STRING:\\n        if (childCount !=\\n            ((n.getParent() != null &&\\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\\n          throw new IllegalStateException(\\n              \\\"Unexpected String children: \\\" + n.getParent().toStringTree());\\n        }\\n        add(jsString(n.getString(), outputCharsetEncoder));\\n        break;\\n\\n      case Token.DELPROP:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"delete \\\");\\n        add(first);\\n        break;\\n\\n      case Token.OBJECTLIT: {\\n        boolean needsParens = (context == Context.START_OF_EXPR);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        add(\\\"{\\\");\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          if (c != first) {\\n            cc.listSeparator();\\n          }\\n\\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\\n            add(c);\\n          } else {\\n            Preconditions.checkState(c.getType() == Token.STRING);\\n            String key = c.getString();\\n            \/\/ Object literal property names don't have to be quoted if they\\n            \/\/ are not JavaScript keywords\\n            if (!c.isQuotedString() &&\\n                !TokenStream.isKeyword(key) &&\\n                TokenStream.isJSIdentifier(key) &&\\n                \/\/ do not encode literally any non-literal characters that\\n                \/\/ were unicode escaped.\\n                NodeUtil.isLatin(key)) {\\n              add(key);\\n            } else {\\n              \/\/ Determine if the string is a simple number.\\n              double d = getSimpleNumber(key);\\n              if (!Double.isNaN(d)) {\\n                cc.addNumber(d);\\n              } else {\\n                addExpr(c, 1);\\n              }\\n            }\\n            add(\\\":\\\");\\n            addExpr(c.getFirstChild(), 1);\\n          }\\n        }\\n        add(\\\"}\\\");\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n      }\\n\\n      case Token.SWITCH:\\n        add(\\\"switch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        cc.beginBlock();\\n        addAllSiblings(first.getNext());\\n        cc.endBlock(context == Context.STATEMENT);\\n        break;\\n\\n      case Token.CASE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"case \\\");\\n        add(first);\\n        addCaseBody(last);\\n        break;\\n\\n      case Token.DEFAULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"default\\\");\\n        addCaseBody(first);\\n        break;\\n\\n      case Token.LABEL:\\n        Preconditions.checkState(childCount == 2);\\n        if (first.getType() != Token.LABEL_NAME) {\\n          throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n        }\\n        add(first);\\n        add(\\\":\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), true);\\n        break;\\n\\n      \/\/ This node is auto generated in anonymous functions and should just get\\n      \/\/ ignored for our purposes.\\n      case Token.SETNAME:\\n        break;\\n\\n      default:\\n        throw new Error(\\\"Unknown type \\\" + type + \\\"\\\\n\\\" + n.toStringTree());\\n    }\\n\\n    cc.endSourceMapping(n);\\n  }\", \"javadoc_start_line\": 82, \"annotations_start_line\": 82, \"method_start_line\": 82, \"end_line\": 731}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"addExpr\", \"content\": \"  private void addExpr(Node n, int minPrecedence, Context context) {\\n    if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\\n        (n.getType() == Token.IN))){\\n      add(\\\"(\\\");\\n      add(n, clearContextForNoInOperator(context));\\n      add(\\\")\\\");\\n    } else {\\n      add(n, context);\\n    }\\n  }\", \"javadoc_start_line\": 870, \"annotations_start_line\": 870, \"method_start_line\": 870, \"end_line\": 880}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"add\", \"content\": \"  void add(Node n, Context context) {\\n    if (!cc.continueProcessing()) {\\n      return;\\n    }\\n\\n    int type = n.getType();\\n    String opstr = NodeUtil.opToStr(type);\\n    int childCount = n.getChildCount();\\n    Node first = n.getFirstChild();\\n    Node last = n.getLastChild();\\n\\n    \/\/ Handle all binary operators\\n    if (opstr != null && first != last) {\\n      Preconditions.checkState(\\n          childCount == 2,\\n          \\\"Bad binary operator \\\\\\\"%s\\\\\\\": expected 2 arguments but got %s\\\",\\n          opstr, childCount);\\n      int p = NodeUtil.precedence(type);\\n      addLeftExpr(first, p, context);\\n      cc.addOp(opstr, true);\\n\\n      \/\/ For right-hand-side of operations, only pass context if it's\\n      \/\/ the IN_FOR_INIT_CLAUSE one.\\n      Context rhsContext = getContextForNoInOperator(context);\\n\\n      \/\/ Handle associativity.\\n      \/\/ e.g. if the parse tree is a * (b * c),\\n      \/\/ we can simply generate a * b * c.\\n      if (last.getType() == type &&\\n          NodeUtil.isAssociative(type)) {\\n        addExpr(last, p, rhsContext);\\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\\n        \/\/ Assignments are the only right-associative binary operators\\n        addExpr(last, p, rhsContext);\\n      } else {\\n        addExpr(last, p + 1, rhsContext);\\n      }\\n      return;\\n    }\\n\\n    cc.startSourceMapping(n);\\n\\n    switch (type) {\\n      case Token.TRY: {\\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\\n                !first.getNext().hasMoreThanOneChild());\\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\\n\\n        add(\\\"try\\\");\\n        add(first, Context.PRESERVE_BLOCK);\\n\\n        \/\/ second child contains the catch block, or nothing if there\\n        \/\/ isn't a catch block\\n        Node catchblock = first.getNext().getFirstChild();\\n        if (catchblock != null) {\\n          add(catchblock);\\n        }\\n\\n        if (childCount == 3) {\\n          add(\\\"finally\\\");\\n          add(last, Context.PRESERVE_BLOCK);\\n        }\\n        break;\\n      }\\n\\n      case Token.CATCH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"catch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        add(last, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.THROW:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"throw\\\");\\n        add(first);\\n\\n        \/\/ Must have a ';' after a throw statement, otherwise safari can't\\n        \/\/ parse this.\\n        cc.endStatement(true);\\n        break;\\n\\n      case Token.RETURN:\\n        add(\\\"return\\\");\\n        if (childCount == 1) {\\n          add(first);\\n        } else {\\n          Preconditions.checkState(childCount == 0);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.VAR:\\n        if (first != null) {\\n          add(\\\"var \\\");\\n          addList(first, false, getContextForNoInOperator(context));\\n        }\\n        break;\\n\\n      case Token.LABEL_NAME:\\n        Preconditions.checkState(!n.getString().isEmpty());\\n        addIdentifier(n.getString());\\n        break;\\n\\n      case Token.NAME:\\n        if (first == null || first.getType() == Token.EMPTY) {\\n          addIdentifier(n.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          addIdentifier(n.getString());\\n          cc.addOp(\\\"=\\\", true);\\n          if (first.getType() == Token.COMMA) {\\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\\n          } else {\\n            \/\/ Add expression, consider nearby code at lowest level of\\n            \/\/ precedence.\\n            addExpr(first, 0, getContextForNoInOperator(context));\\n          }\\n        }\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        add(\\\"[\\\");\\n        addArrayList(first);\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.LP:\\n        add(\\\"(\\\");\\n        addList(first);\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.COMMA:\\n        Preconditions.checkState(childCount == 2);\\n        addList(first, false, context);\\n        break;\\n\\n      case Token.NUMBER:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addNumber(n.getDouble());\\n        break;\\n\\n      case Token.TYPEOF:\\n      case Token.VOID:\\n      case Token.NOT:\\n      case Token.BITNOT:\\n      case Token.POS: {\\n        \/\/ All of these unary operators are right-associative\\n        Preconditions.checkState(childCount == 1);\\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n        addExpr(first, NodeUtil.precedence(type));\\n        break;\\n      }\\n\\n      case Token.NEG: {\\n        Preconditions.checkState(childCount == 1);\\n\\n        \/\/ It's important to our sanity checker that the code\\n        \/\/ we print produces the same AST as the code we parse back.\\n        \/\/ NEG is a weird case because Rhino parses \\\"- -2\\\" as \\\"2\\\".\\n        if (n.getFirstChild().getType() == Token.NUMBER) {\\n          cc.addNumber(-n.getFirstChild().getDouble());\\n        } else {\\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n          addExpr(first, NodeUtil.precedence(type));\\n        }\\n\\n        break;\\n      }\\n\\n      case Token.HOOK: {\\n        Preconditions.checkState(childCount == 3);\\n        int p = NodeUtil.precedence(type);\\n        addLeftExpr(first, p + 1, context);\\n        cc.addOp(\\\"?\\\", true);\\n        addExpr(first.getNext(), 1);\\n        cc.addOp(\\\":\\\", true);\\n        addExpr(last, 1);\\n        break;\\n      }\\n\\n      case Token.REGEXP:\\n        if (first.getType() != Token.STRING ||\\n            last.getType() != Token.STRING) {\\n          throw new Error(\\\"Expected children to be strings\\\");\\n        }\\n\\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\\n\\n        \/\/ I only use one .add because whitespace matters\\n        if (childCount == 2) {\\n          add(regexp + last.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          add(regexp);\\n        }\\n        break;\\n\\n      case Token.GET_REF:\\n        add(first);\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        Preconditions.checkState(childCount == 1);\\n        add(first);\\n        add(\\\".\\\");\\n        add((String) n.getProp(Node.NAME_PROP));\\n        break;\\n\\n      case Token.FUNCTION:\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        Preconditions.checkState(childCount == 3);\\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\\n        if (funcNeedsParens) {\\n          add(\\\"(\\\");\\n        }\\n\\n        add(\\\"function\\\");\\n        add(first);\\n\\n        add(first.getNext());\\n        add(last, Context.PRESERVE_BLOCK);\\n        cc.endFunction(context == Context.STATEMENT);\\n\\n        if (funcNeedsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.GET:\\n      case Token.SET:\\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\\n        Preconditions.checkState(childCount == 1);\\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\\n\\n        \/\/ Get methods are unnamed\\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\\n        if (type == Token.GET) {\\n          \/\/ Get methods have no parameters.\\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\\n          add(\\\"get \\\");\\n        } else {\\n          \/\/ Set methods have one parameter.\\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\\n          add(\\\"set \\\");\\n        }\\n\\n        \/\/ The name is on the GET or SET node.\\n        String name = n.getString();\\n        Node fn = first;\\n        Node parameters = fn.getChildAtIndex(1);\\n        Node body = fn.getLastChild();\\n\\n        \/\/ Add the property name.\\n        if (!n.isQuotedString() &&\\n            TokenStream.isJSIdentifier(name) &&\\n            \/\/ do not encode literally any non-literal characters that were\\n            \/\/ unicode escaped.\\n            NodeUtil.isLatin(name)) {\\n          add(name);\\n        } else {\\n          \/\/ Determine if the string is a simple number.\\n          double d = getSimpleNumber(name);\\n          if (!Double.isNaN(d)) {\\n            cc.addNumber(d);\\n          } else {\\n            add(jsString(n.getString(), outputCharsetEncoder));\\n          }\\n        }\\n\\n        add(parameters);\\n        add(body, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.SCRIPT:\\n      case Token.BLOCK: {\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\\n        if (preserveBlock) {\\n          cc.beginBlock();\\n        }\\n\\n        boolean preferLineBreaks =\\n            type == Token.SCRIPT ||\\n            (type == Token.BLOCK &&\\n                !preserveBlock &&\\n                n.getParent() != null &&\\n                n.getParent().getType() == Token.SCRIPT);\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          add(c, Context.STATEMENT);\\n\\n          \/\/ VAR doesn't include ';' since it gets used in expressions\\n          if (c.getType() == Token.VAR) {\\n            cc.endStatement();\\n          }\\n\\n          if (c.getType() == Token.FUNCTION) {\\n            cc.maybeLineBreak();\\n          }\\n\\n          \/\/ Prefer to break lines in between top-level statements\\n          \/\/ because top level statements are more homogeneous.\\n          if (preferLineBreaks) {\\n            cc.notePreferredLineBreak();\\n          }\\n        }\\n        if (preserveBlock) {\\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\\n        }\\n        break;\\n      }\\n\\n      case Token.FOR:\\n        if (childCount == 4) {\\n          add(\\\"for(\\\");\\n          if (first.getType() == Token.VAR) {\\n            add(first, Context.IN_FOR_INIT_CLAUSE);\\n          } else {\\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\\n          }\\n          add(\\\";\\\");\\n          add(first.getNext());\\n          add(\\\";\\\");\\n          add(first.getNext().getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          Preconditions.checkState(childCount == 3);\\n          add(\\\"for(\\\");\\n          add(first);\\n          add(\\\"in\\\");\\n          add(first.getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        }\\n        break;\\n\\n      case Token.DO:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"do\\\");\\n        addNonEmptyStatement(first, Context.OTHER, false);\\n        add(\\\"while(\\\");\\n        add(last);\\n        add(\\\")\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.WHILE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"while(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.EMPTY:\\n        Preconditions.checkState(childCount == 0);\\n        break;\\n\\n      case Token.GETPROP: {\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount);\\n        Preconditions.checkState(\\n            last.getType() == Token.STRING,\\n            \\\"Bad GETPROP: RHS should be STRING\\\");\\n        boolean needsParens = (first.getType() == Token.NUMBER);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        add(\\\".\\\");\\n        addIdentifier(last.getString());\\n        break;\\n      }\\n\\n      case Token.GETELEM:\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount);\\n        addLeftExpr(first, NodeUtil.precedence(type), context);\\n        add(\\\"[\\\");\\n        add(first.getNext());\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.WITH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"with(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.INC:\\n      case Token.DEC: {\\n        Preconditions.checkState(childCount == 1);\\n        String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\";\\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\\n        \/\/ A non-zero post-prop value indicates a post inc\/dec, default of zero\\n        \/\/ is a pre-inc\/dec.\\n        if (postProp != 0) {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n          cc.addOp(o, false);\\n        } else {\\n          cc.addOp(o, false);\\n          add(first);\\n        }\\n        break;\\n      }\\n\\n      case Token.CALL:\\n        \/\/ We have two special cases here:\\n        \/\/ 1) If the left hand side of the call is a direct reference to eval,\\n        \/\/ then it must have a DIRECT_EVAL annotation. If it does not, then\\n        \/\/ that means it was originally an indirect call to eval, and that\\n        \/\/ indirectness must be preserved.\\n        \/\/ 2) If the left hand side of the call is a property reference,\\n        \/\/ then the call must not a FREE_CALL annotation. If it does, then\\n        \/\/ that means it was originally an call without an explicit this and\\n        \/\/ that must be preserved.\\n        if (isIndirectEval(first)\\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\\n          add(\\\"(0,\\\");\\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\\n          add(\\\")\\\");\\n        } else {\\n          addLeftExpr(first, NodeUtil.precedence(type), context);\\n        }\\n        add(\\\"(\\\");\\n        addList(first.getNext());\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.IF:\\n        boolean hasElse = childCount == 3;\\n        boolean ambiguousElseClause =\\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\\n        if (ambiguousElseClause) {\\n          cc.beginBlock();\\n        }\\n\\n        add(\\\"if(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n\\n        if (hasElse) {\\n          addNonEmptyStatement(\\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\\n          add(\\\"else\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\\n          Preconditions.checkState(childCount == 2);\\n        }\\n\\n        if (ambiguousElseClause) {\\n          cc.endBlock();\\n        }\\n        break;\\n\\n      case Token.NULL:\\n      case Token.THIS:\\n      case Token.FALSE:\\n      case Token.TRUE:\\n        Preconditions.checkState(childCount == 0);\\n        add(Node.tokenToName(type));\\n        break;\\n\\n      case Token.CONTINUE:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"continue\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.DEBUGGER:\\n        Preconditions.checkState(childCount == 0);\\n        add(\\\"debugger\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.BREAK:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"break\\\");\\n        if (childCount == 1) {\\n          if (first.getType() != Token.LABEL_NAME) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.EXPR_VOID:\\n        throw new Error(\\\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\\\");\\n\\n      case Token.EXPR_RESULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(first, Context.START_OF_EXPR);\\n        cc.endStatement();\\n        break;\\n\\n      case Token.NEW:\\n        add(\\\"new \\\");\\n        int precedence = NodeUtil.precedence(type);\\n\\n        \/\/ If the first child contains a CALL, then claim higher precedence\\n        \/\/ to force parentheses. Otherwise, when parsed, NEW will bind to the\\n        \/\/ first viable parentheses (don't traverse into functions).\\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\\n          precedence = NodeUtil.precedence(first.getType()) + 1;\\n        }\\n        addExpr(first, precedence);\\n\\n        \/\/ '()' is optional when no arguments are present\\n        Node next = first.getNext();\\n        if (next != null) {\\n          add(\\\"(\\\");\\n          addList(next);\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.STRING:\\n        if (childCount !=\\n            ((n.getParent() != null &&\\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\\n          throw new IllegalStateException(\\n              \\\"Unexpected String children: \\\" + n.getParent().toStringTree());\\n        }\\n        add(jsString(n.getString(), outputCharsetEncoder));\\n        break;\\n\\n      case Token.DELPROP:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"delete \\\");\\n        add(first);\\n        break;\\n\\n      case Token.OBJECTLIT: {\\n        boolean needsParens = (context == Context.START_OF_EXPR);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        add(\\\"{\\\");\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          if (c != first) {\\n            cc.listSeparator();\\n          }\\n\\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\\n            add(c);\\n          } else {\\n            Preconditions.checkState(c.getType() == Token.STRING);\\n            String key = c.getString();\\n            \/\/ Object literal property names don't have to be quoted if they\\n            \/\/ are not JavaScript keywords\\n            if (!c.isQuotedString() &&\\n                !TokenStream.isKeyword(key) &&\\n                TokenStream.isJSIdentifier(key) &&\\n                \/\/ do not encode literally any non-literal characters that\\n                \/\/ were unicode escaped.\\n                NodeUtil.isLatin(key)) {\\n              add(key);\\n            } else {\\n              \/\/ Determine if the string is a simple number.\\n              double d = getSimpleNumber(key);\\n              if (!Double.isNaN(d)) {\\n                cc.addNumber(d);\\n              } else {\\n                addExpr(c, 1);\\n              }\\n            }\\n            add(\\\":\\\");\\n            addExpr(c.getFirstChild(), 1);\\n          }\\n        }\\n        add(\\\"}\\\");\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n      }\\n\\n      case Token.SWITCH:\\n        add(\\\"switch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        cc.beginBlock();\\n        addAllSiblings(first.getNext());\\n        cc.endBlock(context == Context.STATEMENT);\\n        break;\\n\\n      case Token.CASE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"case \\\");\\n        add(first);\\n        addCaseBody(last);\\n        break;\\n\\n      case Token.DEFAULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"default\\\");\\n        addCaseBody(first);\\n        break;\\n\\n      case Token.LABEL:\\n        Preconditions.checkState(childCount == 2);\\n        if (first.getType() != Token.LABEL_NAME) {\\n          throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n        }\\n        add(first);\\n        add(\\\":\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), true);\\n        break;\\n\\n      \/\/ This node is auto generated in anonymous functions and should just get\\n      \/\/ ignored for our purposes.\\n      case Token.SETNAME:\\n        break;\\n\\n      default:\\n        throw new Error(\\\"Unknown type \\\" + type + \\\"\\\\n\\\" + n.toStringTree());\\n    }\\n\\n    cc.endSourceMapping(n);\\n  }\", \"javadoc_start_line\": 82, \"annotations_start_line\": 82, \"method_start_line\": 82, \"end_line\": 731}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"jsString\", \"content\": \"  \/** Outputs a js string, using the optimal (single\/double) quote character *\/\\n  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {\\n    int singleq = 0, doubleq = 0;\\n\\n    \/\/ could count the quotes and pick the optimal quote character\\n    for (int i = 0; i < s.length(); i++) {\\n      switch (s.charAt(i)) {\\n        case '\\\"': doubleq++; break;\\n        case '\\\\'': singleq++; break;\\n      }\\n    }\\n\\n    String doublequote, singlequote;\\n    char quote;\\n    if (singleq < doubleq) {\\n      \/\/ more double quotes so escape the single quotes\\n      quote = '\\\\'';\\n      doublequote = \\\"\\\\\\\"\\\";\\n      singlequote = \\\"\\\\\\\\\\\\'\\\";\\n    } else {\\n      \/\/ more single quotes so escape the doubles\\n      quote = '\\\\\\\"';\\n      doublequote = \\\"\\\\\\\\\\\\\\\"\\\";\\n      singlequote = \\\"\\\\'\\\";\\n    }\\n\\n    return strEscape(s, quote, doublequote, singlequote, \\\"\\\\\\\\\\\\\\\\\\\",\\n        outputCharsetEncoder);\\n  }\", \"javadoc_start_line\": 938, \"annotations_start_line\": 939, \"method_start_line\": 939, \"end_line\": 966}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"strEscape\", \"content\": \"  \/** Helper to escape javascript string as well as regular expression *\/\\n  static String strEscape(String s, char quote,\\n                          String doublequoteEscape,\\n                          String singlequoteEscape,\\n                          String backslashEscape,\\n                          CharsetEncoder outputCharsetEncoder) {\\n    StringBuilder sb = new StringBuilder(s.length() + 2);\\n    sb.append(quote);\\n    for (int i = 0; i < s.length(); i++) {\\n      char c = s.charAt(i);\\n      switch (c) {\\n        case '\\\\0': sb.append(\\\"\\\\\\\\0\\\"); break;\\n        case '\\\\n': sb.append(\\\"\\\\\\\\n\\\"); break;\\n        case '\\\\r': sb.append(\\\"\\\\\\\\r\\\"); break;\\n        case '\\\\t': sb.append(\\\"\\\\\\\\t\\\"); break;\\n        case '\\\\\\\\': sb.append(backslashEscape); break;\\n        case '\\\\\\\"': sb.append(doublequoteEscape); break;\\n        case '\\\\'': sb.append(singlequoteEscape); break;\\n        case '>':                       \/\/ Break --> into --\\\\> or ]]> into ]]\\\\>\\n          if (i >= 2 &&\\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\\n            sb.append(\\\"\\\\\\\\>\\\");\\n          } else {\\n            sb.append(c);\\n          }\\n          break;\\n        case '<':\\n          \/\/ Break <\/script into <\\\\\/script\\n          final String END_SCRIPT = \\\"\/script\\\";\\n\\n          \/\/ Break <!-- into <\\\\!--\\n          final String START_COMMENT = \\\"!--\\\";\\n\\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\\n                              END_SCRIPT.length())) {\\n            sb.append(\\\"<\\\\\\\\\\\");\\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\\n                                     START_COMMENT.length())) {\\n            sb.append(\\\"<\\\\\\\\\\\");\\n          } else {\\n            sb.append(c);\\n          }\\n          break;\\n        default:\\n          \/\/ If we're given an outputCharsetEncoder, then check if the\\n          \/\/  character can be represented in this character set.\\n          if (outputCharsetEncoder != null) {\\n            if (outputCharsetEncoder.canEncode(c)) {\\n              sb.append(c);\\n            } else {\\n              \/\/ Unicode-escape the character.\\n              appendHexJavaScriptRepresentation(sb, c);\\n            }\\n          } else {\\n            \/\/ No charsetEncoder provided - pass straight latin characters\\n            \/\/ through, and escape the rest.  Doing the explicit character\\n            \/\/ check is measurably faster than using the CharsetEncoder.\\n            if (c > 0x1f && c <= 0x7f) {\\n              sb.append(c);\\n            } else {\\n              \/\/ Other characters can be misinterpreted by some js parsers,\\n              \/\/ or perhaps mangled by proxies along the way,\\n              \/\/ so we play it safe and unicode escape them.\\n              appendHexJavaScriptRepresentation(sb, c);\\n            }\\n          }\\n      }\\n    }\\n    sb.append(quote);\\n    return sb.toString();\\n  }\", \"javadoc_start_line\": 987, \"annotations_start_line\": 988, \"method_start_line\": 992, \"end_line\": 1058}"}]},{"name":"Closure","version":79,"tour_id":3,"test":"{\"className\": \" com.google.javascript.jscomp.VarCheckTest\", \"methodName\": \"testPropReferenceInExterns1\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"compiler.reportCodeChange() should have been called\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/VarCheck.java\", \"method_name\": \"createSynthesizedExternVar\", \"content\": \"  \/**\\n   * Create a new variable in a synthetic script. This will prevent\\n   * subsequent compiler passes from crashing.\\n   *\/\\n  private void createSynthesizedExternVar(String varName) {\\n    Node nameNode = Node.newString(Token.NAME, varName);\\n\\n    \/\/ Mark the variable as constant if it matches the coding convention\\n    \/\/ for constant vars.\\n    \/\/ NOTE(nicksantos): honestly, i'm not sure how much this matters.\\n    \/\/ AFAIK, all people who use the CONST coding convention also\\n    \/\/ compile with undeclaredVars as errors. We have some test\\n    \/\/ cases for this configuration though, and it makes them happier.\\n    if (compiler.getCodingConvention().isConstant(varName)) {\\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\\n    }\\n\\n    getSynthesizedExternsRoot().addChildToBack(\\n        new Node(Token.VAR, nameNode));\\n    varsToDeclareInExterns.remove(varName);\\n  }\", \"javadoc_start_line\": 201, \"annotations_start_line\": 205, \"method_start_line\": 205, \"end_line\": 221}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/VarCheck.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    \/\/ Don't run externs-checking in sanity check mode. Normalization will\\n    \/\/ remove duplicate VAR declarations, which will make\\n    \/\/ externs look like they have assigns.\\n    if (!sanityCheck) {\\n      NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\\n    }\\n\\n    NodeTraversal.traverseRoots(\\n        compiler, Lists.newArrayList(externs, root), this);\\n    for (String varName : varsToDeclareInExterns) {\\n      createSynthesizedExternVar(varName);\\n    }\\n  }\", \"javadoc_start_line\": 97, \"annotations_start_line\": 96, \"method_start_line\": 97, \"end_line\": 110}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  \/**\\n   * Traverses a list of node trees.\\n   *\/\\n  public static void traverseRoots(\\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverseRoots(roots);\\n  }\", \"javadoc_start_line\": 425, \"annotations_start_line\": 428, \"method_start_line\": 429, \"end_line\": 432}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  public void traverseRoots(List<Node> roots) {\\n    if (roots.isEmpty()) {\\n      return;\\n    }\\n\\n    try {\\n      Node scopeRoot = roots.get(0).getParent();\\n      Preconditions.checkState(scopeRoot != null);\\n\\n      sourceName = \\\"\\\";\\n      curNode = scopeRoot;\\n      pushScope(scopeRoot);\\n\\n      for (Node root : roots) {\\n        Preconditions.checkState(root.getParent() == scopeRoot);\\n        traverseBranch(root, scopeRoot);\\n      }\\n\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 260, \"annotations_start_line\": 260, \"method_start_line\": 260, \"end_line\": 282}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/VarCheck.java\", \"method_name\": \"visit\", \"content\": \"  public void visit(NodeTraversal t, Node n, Node parent) {\\n    if (n.getType() != Token.NAME) {\\n      return;\\n    }\\n\\n    String varName = n.getString();\\n\\n    \/\/ Only a function can have an empty name.\\n    if (varName.isEmpty()) {\\n      Preconditions.checkState(NodeUtil.isFunction(parent));\\n\\n      \/\/ A function declaration with an empty name passes Rhino,\\n      \/\/ but is supposed to be a syntax error according to the spec.\\n      if (!NodeUtil.isFunctionExpression(parent)) {\\n        t.report(n, INVALID_FUNCTION_DECL);\\n      }\\n      return;\\n    }\\n\\n    \/\/ Check if this is a declaration for a var that has been declared\\n    \/\/ elsewhere. If so, mark it as a duplicate.\\n    if ((parent.getType() == Token.VAR ||\\n         NodeUtil.isFunctionDeclaration(parent)) &&\\n        varsToDeclareInExterns.contains(varName)) {\\n      createSynthesizedExternVar(varName);\\n\\n      n.addSuppression(\\\"duplicate\\\");\\n    }\\n\\n    \/\/ Check that the var has been declared.\\n    Scope scope = t.getScope();\\n    Scope.Var var = scope.getVar(varName);\\n    if (var == null) {\\n      if (NodeUtil.isFunctionExpression(parent)) {\\n        \/\/ e.g. [ function foo() {} ], it's okay if \\\"foo\\\" isn't defined in the\\n        \/\/ current scope.\\n      } else {\\n        \/\/ The extern checks are stricter, don't report a second error.\\n        if (!strictExternCheck || !t.getInput().isExtern()) {\\n          t.report(n, UNDEFINED_VAR_ERROR, varName);\\n        }\\n\\n        if (sanityCheck) {\\n          throw new IllegalStateException(\\\"Unexpected variable \\\" + varName);\\n        } else {\\n          createSynthesizedExternVar(varName);\\n          scope.getGlobalScope().declare(varName, n,\\n              null, getSynthesizedExternsInput());\\n        }\\n      }\\n      return;\\n    }\\n\\n    CompilerInput currInput = t.getInput();\\n    CompilerInput varInput = var.input;\\n    if (currInput == varInput || currInput == null || varInput == null) {\\n      \/\/ The variable was defined in the same file. This is fine.\\n      return;\\n    }\\n\\n    \/\/ Check module dependencies.\\n    JSModule currModule = currInput.getModule();\\n    JSModule varModule = varInput.getModule();\\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\\n    if (varModule != currModule && varModule != null && currModule != null) {\\n      if (moduleGraph.dependsOn(currModule, varModule)) {\\n        \/\/ The module dependency was properly declared.\\n      } else {\\n        if (!sanityCheck && scope.isGlobal()) {\\n          if (moduleGraph.dependsOn(varModule, currModule)) {\\n            \/\/ The variable reference violates a declared module dependency.\\n            t.report(n, VIOLATED_MODULE_DEP_ERROR,\\n                     currModule.getName(), varModule.getName(), varName);\\n          } else {\\n            \/\/ The variable reference is between two modules that have no\\n            \/\/ dependency relationship. This should probably be considered an\\n            \/\/ error, but just issue a warning for now.\\n            t.report(n, MISSING_MODULE_DEP_ERROR,\\n                     currModule.getName(), varModule.getName(), varName);\\n          }\\n        } else {\\n          t.report(n, STRICT_MODULE_DEP_ERROR,\\n                   currModule.getName(), varModule.getName(), varName);\\n        }\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 112, \"method_start_line\": 113, \"end_line\": 199}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/VarCheck.java\", \"method_name\": \"createSynthesizedExternVar\", \"content\": \"  \/**\\n   * Create a new variable in a synthetic script. This will prevent\\n   * subsequent compiler passes from crashing.\\n   *\/\\n  private void createSynthesizedExternVar(String varName) {\\n    Node nameNode = Node.newString(Token.NAME, varName);\\n\\n    \/\/ Mark the variable as constant if it matches the coding convention\\n    \/\/ for constant vars.\\n    \/\/ NOTE(nicksantos): honestly, i'm not sure how much this matters.\\n    \/\/ AFAIK, all people who use the CONST coding convention also\\n    \/\/ compile with undeclaredVars as errors. We have some test\\n    \/\/ cases for this configuration though, and it makes them happier.\\n    if (compiler.getCodingConvention().isConstant(varName)) {\\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\\n    }\\n\\n    getSynthesizedExternsRoot().addChildToBack(\\n        new Node(Token.VAR, nameNode));\\n    varsToDeclareInExterns.remove(varName);\\n  }\", \"javadoc_start_line\": 201, \"annotations_start_line\": 205, \"method_start_line\": 205, \"end_line\": 221}"}]},{"name":"Closure","version":81,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.parsing.ParserTest\", \"methodName\": \"testUnnamedFunctionStatement\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"processFunctionNode\", \"content\": \"    Node processFunctionNode(FunctionNode functionNode) {\\n      Name name = functionNode.getFunctionName();\\n      Boolean isUnnamedFunction = false;\\n      if (name == null) {\\n        name = new Name();\\n        name.setIdentifier(\\\"\\\");\\n        isUnnamedFunction = true;\\n      }\\n      Node node = newNode(Token.FUNCTION);\\n      Node newName = transform(name);\\n      if (isUnnamedFunction) {\\n        \/\/ Old Rhino tagged the empty name node with the line number of the\\n        \/\/ declaration.\\n        newName.setLineno(functionNode.getLineno());\\n        \/\/ TODO(bowdidge) Mark line number of paren correctly.\\n        \/\/ Same problem as below - the left paren might not be on the\\n        \/\/ same line as the function keyword.\\n        int lpColumn = functionNode.getAbsolutePosition() +\\n            functionNode.getLp();\\n        newName.setCharno(position2charno(lpColumn));\\n      }\\n\\n      node.addChildToBack(newName);\\n      Node lp = newNode(Token.LP);\\n      \/\/ The left paren's complicated because it's not represented by an\\n      \/\/ AstNode, so there's nothing that has the actual line number that it\\n      \/\/ appeared on.  We know the paren has to appear on the same line as the\\n      \/\/ function name (or else a semicolon will be inserted.)  If there's no\\n      \/\/ function name, assume the paren was on the same line as the function.\\n      \/\/ TODO(bowdidge): Mark line number of paren correctly.\\n      Name fnName = functionNode.getFunctionName();\\n      if (fnName != null) {\\n        lp.setLineno(fnName.getLineno());\\n      } else {\\n        lp.setLineno(functionNode.getLineno());\\n      }\\n      int lparenCharno = functionNode.getLp() +\\n          functionNode.getAbsolutePosition();\\n\\n      lp.setCharno(position2charno(lparenCharno));\\n      for (AstNode param : functionNode.getParams()) {\\n        lp.addChildToBack(transform(param));\\n      }\\n      node.addChildToBack(lp);\\n\\n      Node bodyNode = transform(functionNode.getBody());\\n      parseDirectives(bodyNode);\\n      node.addChildToBack(bodyNode);\\n     return node;\\n    }\", \"javadoc_start_line\": 513, \"annotations_start_line\": 512, \"method_start_line\": 513, \"end_line\": 562}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/ParserRunner.java\", \"method_name\": \"parse\", \"content\": \"  \/**\\n   * Parses the JavaScript text given by a reader.\\n   *\\n   * @param sourceName The filename.\\n   * @param sourceString Source code from the file.\\n   * @param errorReporter An error.\\n   * @param logger A logger.\\n   * @return The AST of the given text.\\n   * @throws IOException\\n   *\/\\n  public static Node parse(String sourceName,\\n                           String sourceString,\\n                           Config config,\\n                           ErrorReporter errorReporter,\\n                           Logger logger) throws IOException {\\n    Context cx = Context.enter();\\n    cx.setErrorReporter(errorReporter);\\n    cx.setLanguageVersion(Context.VERSION_1_5);\\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\\n    compilerEnv.initFromContext(cx);\\n    compilerEnv.setRecordingComments(true);\\n    compilerEnv.setRecordingLocalJsDocComments(true);\\n    compilerEnv.setWarnTrailingComma(true);\\n    if (config.isIdeMode) {\\n      compilerEnv.setReservedKeywordAsIdentifier(true);\\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\\n    }\\n\\n    Parser p = new Parser(compilerEnv, errorReporter);\\n    AstRoot astRoot = null;\\n    try {\\n      astRoot = p.parse(sourceString, sourceName, 1);\\n    } catch (EvaluatorException e) {\\n      logger.info(\\\"Error parsing \\\" + sourceName + \\\": \\\" + e.getMessage());\\n    } finally {\\n      Context.exit();\\n    }\\n    Node root = null;\\n    if (astRoot != null) {\\n      root = IRFactory.transformTree(\\n          astRoot, sourceString, config, errorReporter);\\n      root.setIsSyntheticBlock(true);\\n    }\\n    return root;\\n  }\", \"javadoc_start_line\": 83, \"annotations_start_line\": 93, \"method_start_line\": 97, \"end_line\": 127}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"transformTree\", \"content\": \"  public static Node transformTree(AstRoot node,\\n                                   String sourceString,\\n                                   Config config,\\n                                   ErrorReporter errorReporter) {\\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\\n        config, errorReporter);\\n    Node irNode = irFactory.transform(node);\\n\\n    if (node.getComments() != null) {\\n      for (Comment comment : node.getComments()) {\\n        if (comment.getCommentType() == JSDOC && !comment.isParsed()) {\\n          irFactory.handlePossibleFileOverviewJsDoc(comment);\\n        }\\n      }\\n    }\\n\\n    irFactory.setFileOverviewJsDoc(irNode);\\n\\n    return irNode;\\n  }\", \"javadoc_start_line\": 124, \"annotations_start_line\": 124, \"method_start_line\": 127, \"end_line\": 143}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/IRFactory.java\", \"method_name\": \"createExprStatement\", \"content\": \"    Node createExprStatement(Node expr, int lineno, int charno)\\n    {\\n        int type;\\n        if (parser.insideFunction()) {\\n            type = Token.EXPR_VOID;\\n        } else {\\n            type = Token.EXPR_RESULT;\\n        }\\n        return new Node(type, expr, lineno, charno);\\n    }\", \"javadoc_start_line\": 124, \"annotations_start_line\": 124, \"method_start_line\": 125, \"end_line\": 133}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"transform\", \"content\": \"  private Node transform(AstNode node) {\\n    JSDocInfo jsDocInfo = handleJsDoc(node);\\n    Node irNode = justTransform(node);\\n    if (jsDocInfo != null) {\\n      irNode.setJSDocInfo(jsDocInfo);\\n    }\\n\\n    \/\/ If we have a named function, set the position to that of the name.\\n    if (irNode.getType() == Token.FUNCTION &&\\n        irNode.getFirstChild().getLineno() != -1) {\\n      irNode.setLineno(irNode.getFirstChild().getLineno());\\n      irNode.setCharno(irNode.getFirstChild().getCharno());\\n    } else {\\n      if (irNode.getLineno() == -1) {\\n        \/\/ If we didn't already set the line, then set it now.  This avoids\\n        \/\/ cases like ParenthesizedExpression where we just return a previous\\n        \/\/ node, but don't want the new node to get its parent's line number.\\n        int lineno = node.getLineno();\\n        irNode.setLineno(lineno);\\n        int charno = position2charno(node.getAbsolutePosition());\\n        irNode.setCharno(charno);\\n      }\\n    }\\n    return irNode;\\n  }\", \"javadoc_start_line\": 205, \"annotations_start_line\": 205, \"method_start_line\": 205, \"end_line\": 229}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/IRFactory.java\", \"method_name\": \"createContinue\", \"content\": \"    \/**\\n     * Continue (possibly labeled)\\n     *\/\\n    Node createContinue(String label, int lineno, int charno)\\n    {\\n        Node result = new Node(Token.CONTINUE, lineno, charno);\\n        if (label == null) {\\n            return result;\\n        } else {\\n            Node name = Node.newString(Token.NAME, label, lineno, charno);\\n            result.addChildToBack(name);\\n            return result;\\n        }\\n    }\", \"javadoc_start_line\": 262, \"annotations_start_line\": 265, \"method_start_line\": 266, \"end_line\": 275}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"justTransform\", \"content\": \"  private Node justTransform(AstNode node) {\\n    return transformDispatcher.process(node);\\n  }\", \"javadoc_start_line\": 273, \"annotations_start_line\": 273, \"method_start_line\": 273, \"end_line\": 275}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/TypeSafeDispatcher.java\", \"method_name\": \"process\", \"content\": \"  public T process(AstNode node) {\\n    switch (node.getType()) {\\n      case Token.ADD:\\n      case Token.AND:\\n      case Token.BITAND:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.COMMA:\\n      case Token.DIV:\\n      case Token.EQ:\\n      case Token.GE:\\n      case Token.GT:\\n      case Token.IN:\\n      case Token.INSTANCEOF:\\n      case Token.LE:\\n      case Token.LSH:\\n      case Token.LT:\\n      case Token.MOD:\\n      case Token.MUL:\\n      case Token.NE:\\n      case Token.OR:\\n      case Token.RSH:\\n      case Token.SHEQ:\\n      case Token.SHNE:\\n      case Token.SUB:\\n      case Token.URSH:\\n        return processInfixExpression((InfixExpression) node);\\n      case Token.ARRAYLIT:\\n        return processArrayLiteral((ArrayLiteral) node);\\n      case Token.ASSIGN:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_MUL:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_URSH:\\n        return processAssignment((Assignment) node);\\n      case Token.BITNOT:\\n      case Token.DEC:\\n      case Token.DELPROP:\\n      case Token.INC:\\n      case Token.NEG:\\n      case Token.NOT:\\n      case Token.POS:\\n      case Token.TYPEOF:\\n      case Token.VOID:\\n        return processUnaryExpression((UnaryExpression) node);\\n      case Token.BLOCK:\\n        if (node instanceof Block) {\\n          return processBlock((Block) node);\\n        } else  if (node instanceof Scope) {\\n          return processScope((Scope) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.BREAK:\\n        return processBreakStatement((BreakStatement) node);\\n      case Token.CALL:\\n        return processFunctionCall((FunctionCall) node);\\n      case Token.CASE:\\n      case Token.DEFAULT:\\n        return processSwitchCase((SwitchCase) node);\\n      case Token.CATCH:\\n      case Token.FINALLY:\\n        return processCatchClause((CatchClause) node);\\n      case Token.COLON:\\n        return processObjectProperty((ObjectProperty) node);\\n      case Token.CONTINUE:\\n        return processContinueStatement((ContinueStatement) node);\\n      case Token.DO:\\n        return processDoLoop((DoLoop) node);\\n      case Token.EMPTY:\\n        return processEmptyExpression((EmptyExpression) node);\\n      case Token.EXPR_RESULT:\\n      case Token.EXPR_VOID:\\n        if (node instanceof ExpressionStatement) {\\n          return processExpressionStatement((ExpressionStatement) node);\\n        } else  if (node instanceof LabeledStatement) {\\n          return processLabeledStatement((LabeledStatement) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.DEBUGGER:\\n      case Token.FALSE:\\n      case Token.NULL:\\n      case Token.THIS:\\n      case Token.TRUE:\\n        return processKeywordLiteral((KeywordLiteral) node);\\n      case Token.FOR:\\n        if (node instanceof ForInLoop) {\\n          return processForInLoop((ForInLoop) node);\\n        } else  if (node instanceof ForLoop) {\\n          return processForLoop((ForLoop) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.FUNCTION:\\n        return processFunctionNode((FunctionNode) node);\\n      case Token.GETELEM:\\n        return processElementGet((ElementGet) node);\\n      case Token.GETPROP:\\n        return processPropertyGet((PropertyGet) node);\\n      case Token.HOOK:\\n        return processConditionalExpression((ConditionalExpression) node);\\n      case Token.IF:\\n        return processIfStatement((IfStatement) node);\\n      case Token.LABEL:\\n        return processLabel((Label) node);\\n      case Token.LP:\\n        return processParenthesizedExpression((ParenthesizedExpression) node);\\n      case Token.NAME:\\n        return processName((Name) node);\\n      case Token.NEW:\\n        return processNewExpression((NewExpression) node);\\n      case Token.NUMBER:\\n        return processNumberLiteral((NumberLiteral) node);\\n      case Token.OBJECTLIT:\\n        return processObjectLiteral((ObjectLiteral) node);\\n      case Token.REGEXP:\\n        return processRegExpLiteral((RegExpLiteral) node);\\n      case Token.RETURN:\\n        return processReturnStatement((ReturnStatement) node);\\n      case Token.SCRIPT:\\n        return processAstRoot((AstRoot) node);\\n      case Token.STRING:\\n        return processStringLiteral((StringLiteral) node);\\n      case Token.SWITCH:\\n        return processSwitchStatement((SwitchStatement) node);\\n      case Token.THROW:\\n        return processThrowStatement((ThrowStatement) node);\\n      case Token.TRY:\\n        return processTryStatement((TryStatement) node);\\n      case Token.CONST:\\n      case Token.VAR:\\n        if (node instanceof VariableDeclaration) {\\n          return processVariableDeclaration((VariableDeclaration) node);\\n        } else  if (node instanceof VariableInitializer) {\\n          return processVariableInitializer((VariableInitializer) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.WHILE:\\n        return processWhileLoop((WhileLoop) node);\\n      case Token.WITH:\\n        return processWithStatement((WithStatement) node);\\n    }\\n    return processIllegalToken(node);\\n  }\", \"javadoc_start_line\": 118, \"annotations_start_line\": 118, \"method_start_line\": 118, \"end_line\": 282}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/IRFactory.java\", \"method_name\": \"createLeaf\", \"content\": \"    \/**\\n     * Leaf\\n     *\/\\n    Node createLeaf(int nodeType)\\n    {\\n        return new Node(nodeType);\\n    }\", \"javadoc_start_line\": 71, \"annotations_start_line\": 74, \"method_start_line\": 75, \"end_line\": 77}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"<obinit>\", \"content\": \"public class IRFactory {\", \"javadoc_start_line\": 77, \"annotations_start_line\": 77, \"method_start_line\": 77, \"end_line\": 77}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"transform\", \"content\": \"  private Node transform(AstNode node) {\\n    JSDocInfo jsDocInfo = handleJsDoc(node);\\n    Node irNode = justTransform(node);\\n    if (jsDocInfo != null) {\\n      irNode.setJSDocInfo(jsDocInfo);\\n    }\\n\\n    \/\/ If we have a named function, set the position to that of the name.\\n    if (irNode.getType() == Token.FUNCTION &&\\n        irNode.getFirstChild().getLineno() != -1) {\\n      irNode.setLineno(irNode.getFirstChild().getLineno());\\n      irNode.setCharno(irNode.getFirstChild().getCharno());\\n    } else {\\n      if (irNode.getLineno() == -1) {\\n        \/\/ If we didn't already set the line, then set it now.  This avoids\\n        \/\/ cases like ParenthesizedExpression where we just return a previous\\n        \/\/ node, but don't want the new node to get its parent's line number.\\n        int lineno = node.getLineno();\\n        irNode.setLineno(lineno);\\n        int charno = position2charno(node.getAbsolutePosition());\\n        irNode.setCharno(charno);\\n      }\\n    }\\n    return irNode;\\n  }\", \"javadoc_start_line\": 205, \"annotations_start_line\": 205, \"method_start_line\": 205, \"end_line\": 229}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/IRFactory.java\", \"method_name\": \"createContinue\", \"content\": \"    \/**\\n     * Continue (possibly labeled)\\n     *\/\\n    Node createContinue(String label, int lineno, int charno)\\n    {\\n        Node result = new Node(Token.CONTINUE, lineno, charno);\\n        if (label == null) {\\n            return result;\\n        } else {\\n            Node name = Node.newString(Token.NAME, label, lineno, charno);\\n            result.addChildToBack(name);\\n            return result;\\n        }\\n    }\", \"javadoc_start_line\": 262, \"annotations_start_line\": 265, \"method_start_line\": 266, \"end_line\": 275}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"justTransform\", \"content\": \"  private Node justTransform(AstNode node) {\\n    return transformDispatcher.process(node);\\n  }\", \"javadoc_start_line\": 273, \"annotations_start_line\": 273, \"method_start_line\": 273, \"end_line\": 275}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/TypeSafeDispatcher.java\", \"method_name\": \"process\", \"content\": \"  public T process(AstNode node) {\\n    switch (node.getType()) {\\n      case Token.ADD:\\n      case Token.AND:\\n      case Token.BITAND:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.COMMA:\\n      case Token.DIV:\\n      case Token.EQ:\\n      case Token.GE:\\n      case Token.GT:\\n      case Token.IN:\\n      case Token.INSTANCEOF:\\n      case Token.LE:\\n      case Token.LSH:\\n      case Token.LT:\\n      case Token.MOD:\\n      case Token.MUL:\\n      case Token.NE:\\n      case Token.OR:\\n      case Token.RSH:\\n      case Token.SHEQ:\\n      case Token.SHNE:\\n      case Token.SUB:\\n      case Token.URSH:\\n        return processInfixExpression((InfixExpression) node);\\n      case Token.ARRAYLIT:\\n        return processArrayLiteral((ArrayLiteral) node);\\n      case Token.ASSIGN:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_MUL:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_URSH:\\n        return processAssignment((Assignment) node);\\n      case Token.BITNOT:\\n      case Token.DEC:\\n      case Token.DELPROP:\\n      case Token.INC:\\n      case Token.NEG:\\n      case Token.NOT:\\n      case Token.POS:\\n      case Token.TYPEOF:\\n      case Token.VOID:\\n        return processUnaryExpression((UnaryExpression) node);\\n      case Token.BLOCK:\\n        if (node instanceof Block) {\\n          return processBlock((Block) node);\\n        } else  if (node instanceof Scope) {\\n          return processScope((Scope) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.BREAK:\\n        return processBreakStatement((BreakStatement) node);\\n      case Token.CALL:\\n        return processFunctionCall((FunctionCall) node);\\n      case Token.CASE:\\n      case Token.DEFAULT:\\n        return processSwitchCase((SwitchCase) node);\\n      case Token.CATCH:\\n      case Token.FINALLY:\\n        return processCatchClause((CatchClause) node);\\n      case Token.COLON:\\n        return processObjectProperty((ObjectProperty) node);\\n      case Token.CONTINUE:\\n        return processContinueStatement((ContinueStatement) node);\\n      case Token.DO:\\n        return processDoLoop((DoLoop) node);\\n      case Token.EMPTY:\\n        return processEmptyExpression((EmptyExpression) node);\\n      case Token.EXPR_RESULT:\\n      case Token.EXPR_VOID:\\n        if (node instanceof ExpressionStatement) {\\n          return processExpressionStatement((ExpressionStatement) node);\\n        } else  if (node instanceof LabeledStatement) {\\n          return processLabeledStatement((LabeledStatement) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.DEBUGGER:\\n      case Token.FALSE:\\n      case Token.NULL:\\n      case Token.THIS:\\n      case Token.TRUE:\\n        return processKeywordLiteral((KeywordLiteral) node);\\n      case Token.FOR:\\n        if (node instanceof ForInLoop) {\\n          return processForInLoop((ForInLoop) node);\\n        } else  if (node instanceof ForLoop) {\\n          return processForLoop((ForLoop) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.FUNCTION:\\n        return processFunctionNode((FunctionNode) node);\\n      case Token.GETELEM:\\n        return processElementGet((ElementGet) node);\\n      case Token.GETPROP:\\n        return processPropertyGet((PropertyGet) node);\\n      case Token.HOOK:\\n        return processConditionalExpression((ConditionalExpression) node);\\n      case Token.IF:\\n        return processIfStatement((IfStatement) node);\\n      case Token.LABEL:\\n        return processLabel((Label) node);\\n      case Token.LP:\\n        return processParenthesizedExpression((ParenthesizedExpression) node);\\n      case Token.NAME:\\n        return processName((Name) node);\\n      case Token.NEW:\\n        return processNewExpression((NewExpression) node);\\n      case Token.NUMBER:\\n        return processNumberLiteral((NumberLiteral) node);\\n      case Token.OBJECTLIT:\\n        return processObjectLiteral((ObjectLiteral) node);\\n      case Token.REGEXP:\\n        return processRegExpLiteral((RegExpLiteral) node);\\n      case Token.RETURN:\\n        return processReturnStatement((ReturnStatement) node);\\n      case Token.SCRIPT:\\n        return processAstRoot((AstRoot) node);\\n      case Token.STRING:\\n        return processStringLiteral((StringLiteral) node);\\n      case Token.SWITCH:\\n        return processSwitchStatement((SwitchStatement) node);\\n      case Token.THROW:\\n        return processThrowStatement((ThrowStatement) node);\\n      case Token.TRY:\\n        return processTryStatement((TryStatement) node);\\n      case Token.CONST:\\n      case Token.VAR:\\n        if (node instanceof VariableDeclaration) {\\n          return processVariableDeclaration((VariableDeclaration) node);\\n        } else  if (node instanceof VariableInitializer) {\\n          return processVariableInitializer((VariableInitializer) node);\\n        } else {\\n          throw new IllegalStateException(\\\"Unexpected node type.  class: \\\" +\\n                                          node.getClass() +\\n                                          \\\" type: \\\" +\\n                                          Token.typeToName(node.getType()));\\n        }\\n      case Token.WHILE:\\n        return processWhileLoop((WhileLoop) node);\\n      case Token.WITH:\\n        return processWithStatement((WithStatement) node);\\n    }\\n    return processIllegalToken(node);\\n  }\", \"javadoc_start_line\": 118, \"annotations_start_line\": 118, \"method_start_line\": 118, \"end_line\": 282}"}]},{"name":"Closure","version":82,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeCheckTest\", \"methodName\": \"testIssue301\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected a warning\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/JSType.java\", \"method_name\": \"isEmptyType\", \"content\": \"  public final boolean isEmptyType() {\\n    return isNoType() || isNoObjectType() || isNoResolvedType();\\n  }\", \"javadoc_start_line\": 162, \"annotations_start_line\": 162, \"method_start_line\": 162, \"end_line\": 164}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 347, \"annotations_start_line\": 348, \"method_start_line\": 348, \"end_line\": 365}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Main entry point for this phase of processing. This follows the pattern for\\n   * JSCompiler phases.\\n   *\\n   * @param externsRoot The root of the externs parse tree.\\n   * @param jsRoot The root of the input parse tree to be checked.\\n   *\/\\n  public void process(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkNotNull(scopeCreator);\\n    Preconditions.checkNotNull(topScope);\\n\\n    Node externsAndJs = jsRoot.getParent();\\n    Preconditions.checkState(externsAndJs != null);\\n    Preconditions.checkState(\\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\\n\\n    if (externsRoot != null) {\\n      check(externsRoot, true);\\n    }\\n    check(jsRoot, false);\\n  }\", \"javadoc_start_line\": 325, \"annotations_start_line\": 332, \"method_start_line\": 332, \"end_line\": 345}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"check\", \"content\": \"  public void check(Node node, boolean externs) {\\n    Preconditions.checkNotNull(node);\\n\\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\\n    inExterns = externs;\\n    t.traverseWithScope(node, topScope);\\n    if (externs) {\\n      inferJSDocInfo.process(node, null);\\n    } else {\\n      inferJSDocInfo.process(null, node);\\n    }\\n  }\", \"javadoc_start_line\": 368, \"annotations_start_line\": 368, \"method_start_line\": 368, \"end_line\": 379}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseWithScope\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively with a scope, starting with the given\\n   * root. This should only be used in the global scope. Otherwise, use\\n   * {@link #traverseAtScope}.\\n   *\/\\n  void traverseWithScope(Node root, Scope s) {\\n    Preconditions.checkState(s.isGlobal());\\n\\n    sourceName = \\\"\\\";\\n    curNode = root;\\n    pushScope(s);\\n    traverseBranch(root, null);\\n    popScope();\\n  }\", \"javadoc_start_line\": 301, \"annotations_start_line\": 306, \"method_start_line\": 306, \"end_line\": 314}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visit\", \"content\": \"  \/**\\n   * This is the meat of the type checking.  It is basically one big switch,\\n   * with each case representing one type of parse tree node.  The individual\\n   * cases are usually pretty straightforward.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of the node n.\\n   *\/\\n  public void visit(NodeTraversal t, Node n, Node parent) {\\n    JSType childType;\\n    JSType leftType, rightType;\\n    Node left, right;\\n    \/\/ To be explicitly set to false if the node is not typeable.\\n    boolean typeable = true;\\n\\n    switch (n.getType()) {\\n      case Token.NAME:\\n        typeable = visitName(t, n, parent);\\n        break;\\n\\n      case Token.LP:\\n        \/\/ If this is under a FUNCTION node, it is a parameter list and can be\\n        \/\/ ignored here.\\n        if (parent.getType() != Token.FUNCTION) {\\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        } else {\\n          typeable = false;\\n        }\\n        break;\\n\\n      case Token.COMMA:\\n        ensureTyped(t, n, getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.THIS:\\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        ensureTyped(t, n);\\n        break;\\n\\n      case Token.GET_REF:\\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        break;\\n\\n      case Token.NULL:\\n        ensureTyped(t, n, NULL_TYPE);\\n        break;\\n\\n      case Token.NUMBER:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\\n          ensureTyped(t, n, NUMBER_TYPE);\\n        }\\n        break;\\n\\n      case Token.STRING:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\\n          ensureTyped(t, n, STRING_TYPE);\\n        }\\n        break;\\n\\n      case Token.GET:\\n      case Token.SET:\\n        \/\/ Object literal keys are handled with OBJECTLIT\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        ensureTyped(t, n, ARRAY_TYPE);\\n        break;\\n\\n      case Token.REGEXP:\\n        ensureTyped(t, n, REGEXP_TYPE);\\n        break;\\n\\n      case Token.GETPROP:\\n        visitGetProp(t, n, parent);\\n        typeable = !(parent.getType() == Token.ASSIGN &&\\n                     parent.getFirstChild() == n);\\n        break;\\n\\n      case Token.GETELEM:\\n        visitGetElem(t, n);\\n        \/\/ The type of GETELEM is always unknown, so no point counting that.\\n        \/\/ If that unknown leaks elsewhere (say by an assignment to another\\n        \/\/ variable), then it will be counted.\\n        typeable = false;\\n        break;\\n\\n      case Token.VAR:\\n        visitVar(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.NEW:\\n        visitNew(t, n);\\n        typeable = true;\\n        break;\\n\\n      case Token.CALL:\\n        visitCall(t, n);\\n        typeable = !NodeUtil.isExpressionNode(parent);\\n        break;\\n\\n      case Token.RETURN:\\n        visitReturn(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.DEC:\\n      case Token.INC:\\n        left = n.getFirstChild();\\n        validator.expectNumber(\\n            t, left, getJSType(left), \\\"increment\/decrement\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.NOT:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.VOID:\\n        ensureTyped(t, n, VOID_TYPE);\\n        break;\\n\\n      case Token.TYPEOF:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.BITNOT:\\n        childType = getJSType(n.getFirstChild());\\n        if (!childType.matchesInt32Context()) {\\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\\n              childType.toString());\\n        }\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        left = n.getFirstChild();\\n        validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.EQ:\\n      case Token.NE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        TernaryValue result =\\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\\n        if (result != TernaryValue.UNKNOWN) {\\n          if (n.getType() == Token.NE) {\\n            result = result.not();\\n          }\\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\\n              rightType.toString(), result.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.SHEQ:\\n      case Token.SHNE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\\n                rightTypeRestricted)) {\\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\\n              rightType.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n        if (rightType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, leftType, \\\"left side of numeric comparison\\\");\\n        } else if (leftType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, rightType, \\\"right side of numeric comparison\\\");\\n        } else if (leftType.matchesNumberContext() &&\\n                   rightType.matchesNumberContext()) {\\n          \/\/ OK.\\n        } else {\\n          \/\/ Whether the comparison is numeric will be determined at runtime\\n          \/\/ each time the expression is evaluated. Regardless, both operands\\n          \/\/ should match a string context.\\n          String message = \\\"left side of comparison\\\";\\n          validator.expectString(t, n, leftType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, leftType, message, getNativeType(STRING_TYPE));\\n          message = \\\"right side of comparison\\\";\\n          validator.expectString(t, n, rightType, message);\\n          validator.expectNotNullOrUndefined(\\n              t, n, rightType, message, getNativeType(STRING_TYPE));\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.IN:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right);\\n        validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\");\\n        validator.expectString(t, left, leftType, \\\"left side of 'in'\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.INSTANCEOF:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\\n\\n        validator.expectAnyObject(\\n            t, left, leftType, \\\"deterministic instanceof yields false\\\");\\n        validator.expectActualObject(\\n            t, right, rightType, \\\"instanceof requires an object\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.ASSIGN:\\n        visitAssign(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_MUL:\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.BITAND:\\n      case Token.SUB:\\n      case Token.ADD:\\n      case Token.MUL:\\n        visitBinaryOperator(n.getType(), t, n);\\n        break;\\n\\n      case Token.DELPROP:\\n        if (!isReference(n.getFirstChild())) {\\n          report(t, n, BAD_DELETE);\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.CASE:\\n        JSType switchType = getJSType(parent.getFirstChild());\\n        JSType caseType = getJSType(n.getFirstChild());\\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\\n        typeable = false;\\n        break;\\n\\n      case Token.WITH: {\\n        Node child = n.getFirstChild();\\n        childType = getJSType(child);\\n        validator.expectObject(\\n            t, child, childType, \\\"with requires an object\\\");\\n        typeable = false;\\n        break;\\n      }\\n\\n      case Token.FUNCTION:\\n        visitFunction(t, n);\\n        break;\\n\\n      \/\/ These nodes have no interesting type behavior.\\n      case Token.LABEL:\\n      case Token.LABEL_NAME:\\n      case Token.SWITCH:\\n      case Token.BREAK:\\n      case Token.CATCH:\\n      case Token.TRY:\\n      case Token.SCRIPT:\\n      case Token.EXPR_RESULT:\\n      case Token.BLOCK:\\n      case Token.EMPTY:\\n      case Token.DEFAULT:\\n      case Token.CONTINUE:\\n      case Token.DEBUGGER:\\n      case Token.THROW:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes require data flow analysis.\\n      case Token.DO:\\n      case Token.FOR:\\n      case Token.IF:\\n      case Token.WHILE:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes are typed during the type inference.\\n      case Token.AND:\\n      case Token.HOOK:\\n      case Token.OBJECTLIT:\\n      case Token.OR:\\n        if (n.getJSType() != null) { \/\/ If we didn't run type inference.\\n          ensureTyped(t, n);\\n        } else {\\n          \/\/ If this is an enum, then give that type to the objectlit as well.\\n          if ((n.getType() == Token.OBJECTLIT)\\n              && (parent.getJSType() instanceof EnumType)) {\\n            ensureTyped(t, n, parent.getJSType());\\n          } else {\\n            ensureTyped(t, n);\\n          }\\n        }\\n        if (n.getType() == Token.OBJECTLIT) {\\n          for (Node key : n.children()) {\\n            visitObjLitKey(t, key, n);\\n          }\\n        }\\n        break;\\n\\n      default:\\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\\n        ensureTyped(t, n);\\n        break;\\n    }\\n\\n    \/\/ Don't count externs since the user's code may not even use that part.\\n    typeable = typeable && !inExterns;\\n\\n    if (typeable) {\\n      doPercentTypedAccounting(t, n);\\n    }\\n\\n    checkNoTypeCheckSection(n, false);\\n  }\", \"javadoc_start_line\": 437, \"annotations_start_line\": 447, \"method_start_line\": 447, \"end_line\": 801}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitGetProp\", \"content\": \"  \/**\\n   * Visits a GETPROP node.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of <code>n<\/code>\\n   *\/\\n  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\\n    \/\/ GETPROP nodes have an assigned type on their node by the scope creator\\n    \/\/ if this is an enum declaration. The only namespaced enum declarations\\n    \/\/ that we allow are of the form object.name = ...;\\n    if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {\\n      return;\\n    }\\n\\n    \/\/ obj.prop or obj.method()\\n    \/\/ Lots of types can appear on the left, a call to a void function can\\n    \/\/ never be on the left. getPropertyType will decide what is acceptable\\n    \/\/ and what isn't.\\n    Node property = n.getLastChild();\\n    Node objNode = n.getFirstChild();\\n    JSType childType = getJSType(objNode);\\n\\n    \/\/ TODO(user): remove in favor of flagging every property access on\\n    \/\/ non-object.\\n    if (!validator.expectNotNullOrUndefined(t, n, childType,\\n            childType + \\\" has no properties\\\", getNativeType(OBJECT_TYPE))) {\\n      ensureTyped(t, n);\\n      return;\\n    }\\n\\n    checkPropertyAccess(childType, property.getString(), t, n);\\n    ensureTyped(t, n);\\n  }\", \"javadoc_start_line\": 1223, \"annotations_start_line\": 1231, \"method_start_line\": 1231, \"end_line\": 1257}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"checkPropertyAccess\", \"content\": \"  \/**\\n   * Make sure that the access of this property is ok.\\n   *\/\\n  private void checkPropertyAccess(JSType childType, String propName,\\n      NodeTraversal t, Node n) {\\n    ObjectType objectType = childType.dereference();\\n    if (objectType != null) {\\n      JSType propType = getJSType(n);\\n      if ((!objectType.hasProperty(propName) ||\\n           objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&\\n          propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\\n        if (objectType instanceof EnumType) {\\n          report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\\n        } else if (!objectType.isEmptyType() &&\\n            reportMissingProperties && !isPropertyTest(n)) {\\n          if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\\n            report(t, n, INEXISTENT_PROPERTY, propName,\\n                validator.getReadableJSTypeName(n.getFirstChild(), true));\\n          }\\n        }\\n      }\\n    } else {\\n      \/\/ TODO(nicksantos): might want to flag the access on a non object when\\n      \/\/ it's impossible to get a property from this type.\\n    }\\n  }\", \"javadoc_start_line\": 1259, \"annotations_start_line\": 1262, \"method_start_line\": 1263, \"end_line\": 1284}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/JSTypeRegistry.java\", \"method_name\": \"canPropertyBeDefined\", \"content\": \"  \/**\\n   * Returns whether the given property can possibly be set on the given type.\\n   *\/\\n  public boolean canPropertyBeDefined(JSType type, String propertyName) {\\n    if (typesIndexedByProperty.containsKey(propertyName)) {\\n      for (JSType alt :\\n               typesIndexedByProperty.get(propertyName).getAlternates()) {\\n        if (!alt.getGreatestSubtype(type).isEmptyType()) {\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\", \"javadoc_start_line\": 655, \"annotations_start_line\": 658, \"method_start_line\": 658, \"end_line\": 668}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/JSType.java\", \"method_name\": \"isEmptyType\", \"content\": \"  public final boolean isEmptyType() {\\n    return isNoType() || isNoObjectType() || isNoResolvedType();\\n  }\", \"javadoc_start_line\": 162, \"annotations_start_line\": 162, \"method_start_line\": 162, \"end_line\": 164}"}]},{"name":"Closure","version":87,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest\", \"methodName\": \"testIssue291\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeSubstituteAlternateSyntax.java\", \"method_name\": \"isFoldableExpressBlock\", \"content\": \"  \/**\\n   * @return Whether the node is a block with a single statement that is\\n   *     an expression.\\n   *\/\\n  private boolean isFoldableExpressBlock(Node n) {\\n    if (n.getType() == Token.BLOCK) {\\n      if (n.hasOneChild()) {\\n        Node maybeExpr = n.getFirstChild();\\n          \/\/ IE has a bug where event handlers behave differently when\\n          \/\/ their return value is used vs. when their return value is in\\n          \/\/ an EXPR_RESULT. It's pretty freaking weird. See:\\n          \/\/ http:\/\/code.google.com\/p\/closure-compiler\/issues\/detail?id=291\\n          \/\/ We try to detect this case, and not fold EXPR_RESULTs\\n          \/\/ into other expressions.\\n\\n            \/\/ We only have to worry about methods with an implicit 'this'\\n            \/\/ param, or this doesn't happen.\\n\\n          return NodeUtil.isExpressionNode(maybeExpr);\\n      }\\n    }\\n\\n    return false;\\n  }\", \"javadoc_start_line\": 515, \"annotations_start_line\": 519, \"method_start_line\": 519, \"end_line\": 538}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    NodeTraversal t = new NodeTraversal(compiler, this);\\n\\n    beginTraversal(t);\\n    t.traverse(root);\\n    endTraversal(t);\\n  }\", \"javadoc_start_line\": 55, \"annotations_start_line\": 54, \"method_start_line\": 55, \"end_line\": 61}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 241, \"annotations_start_line\": 244, \"method_start_line\": 244, \"end_line\": 254}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 434, \"annotations_start_line\": 437, \"method_start_line\": 438, \"end_line\": 465}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"visit\", \"content\": \"  public void visit(NodeTraversal t, Node n, Node parent) {\\n    Node currentVersionOfNode = n;\\n    boolean somethingChanged = false;\\n\\n    do {\\n      somethingChanged = false;\\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\\n        Node newVersionOfNode =\\n            optimization.optimizeSubtree(currentVersionOfNode);\\n\\n        if (newVersionOfNode != currentVersionOfNode) {\\n          somethingChanged = true;\\n\\n          currentVersionOfNode = newVersionOfNode;\\n        }\\n\\n        if (currentVersionOfNode == null) {\\n          return;\\n        }\\n      }\\n    } while(somethingChanged);\\n  }\", \"javadoc_start_line\": 64, \"annotations_start_line\": 63, \"method_start_line\": 64, \"end_line\": 85}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeSubstituteAlternateSyntax.java\", \"method_name\": \"optimizeSubtree\", \"content\": \"  \/**\\n   * Tries apply our various peephole minimizations on the passed in node.\\n   *\/\\n  @Override\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  public Node optimizeSubtree(Node node) {\\n    switch(node.getType()) {\\n      case Token.RETURN:\\n        return tryReduceReturn(node);\\n\\n      case Token.NOT:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return tryMinimizeNot(node);\\n\\n      case Token.IF:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return tryMinimizeIf(node);\\n\\n      case Token.EXPR_RESULT:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return node;\\n\\n      case Token.HOOK:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return node;\\n\\n      case Token.WHILE:\\n      case Token.DO:\\n        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\\n        return node;\\n\\n      case Token.FOR:\\n        if (!NodeUtil.isForIn(node)) {\\n          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\\n        }\\n        return node;\\n\\n      case Token.NEW:\\n        node = tryFoldStandardConstructors(node);\\n        if (node.getType() != Token.CALL) {\\n          return node;\\n        }\\n        \/\/ Fall through on purpose because tryFoldStandardConstructors() may\\n        \/\/ convert a NEW node into a CALL node\\n      case Token.CALL:\\n        return tryFoldLiteralConstructor(node);\\n\\n      default:\\n        return node; \/\/Nothing changed\\n    }\\n  }\", \"javadoc_start_line\": 53, \"annotations_start_line\": 56, \"method_start_line\": 58, \"end_line\": 103}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeSubstituteAlternateSyntax.java\", \"method_name\": \"tryMinimizeIf\", \"content\": \"  \/**\\n   * Try turning IF nodes into smaller HOOKs\\n   *\\n   * Returns the replacement for n or the original if no replacement was\\n   * necessary.\\n   *\/\\n  private Node tryMinimizeIf(Node n) {\\n\\n    Node parent = n.getParent();\\n\\n    Node cond = n.getFirstChild();\\n\\n    \/* If the condition is a literal, we'll let other\\n     * optimizations try to remove useless code.\\n     *\/\\n    if (NodeUtil.isLiteralValue(cond, true)) {\\n      return n;\\n    }\\n\\n    Node thenBranch = cond.getNext();\\n    Node elseBranch = thenBranch.getNext();\\n\\n    if (elseBranch == null) {\\n      if (isFoldableExpressBlock(thenBranch)) {\\n        Node expr = getBlockExpression(thenBranch);\\n        if (isPropertyAssignmentInExpression(expr)) {\\n          \/\/ Keep opportunities for CollapseProperties such as\\n          \/\/ a.longIdentifier || a.longIdentifier = ... -> var a = ...;\\n          return n;\\n        }\\n\\n        if (cond.getType() == Token.NOT) {\\n          \/\/ if(!x)bar(); -> x||bar();\\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\\n                  OR_PRECEDENCE)) {\\n            \/\/ It's not okay to add two sets of parentheses.\\n            return n;\\n          }\\n\\n          Node or = new Node(Token.OR, cond.removeFirstChild(),\\n          expr.removeFirstChild()).copyInformationFrom(n);\\n          Node newExpr = NodeUtil.newExpr(or);\\n          parent.replaceChild(n, newExpr);\\n          reportCodeChange();\\n\\n          return newExpr;\\n        }\\n\\n        \/\/ if(x)foo(); -> x&&foo();\\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) ||\\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\\n                AND_PRECEDENCE)) {\\n          \/\/ One additional set of parentheses isn't worth it.\\n          return n;\\n        }\\n\\n        n.removeChild(cond);\\n        Node and = new Node(Token.AND, cond, expr.removeFirstChild())\\n                       .copyInformationFrom(n);\\n        Node newExpr = NodeUtil.newExpr(and);\\n        parent.replaceChild(n, newExpr);\\n        reportCodeChange();\\n\\n        return newExpr;\\n      }\\n\\n      return n;\\n    }\\n\\n    \/* TODO(dcc) This modifies the siblings of n, which is undesirable for a\\n     * peephole optimization. This should probably get moved to another pass.\\n     *\/\\n    tryRemoveRepeatedStatements(n);\\n\\n    \/\/ if(!x)foo();else bar(); -> if(x)bar();else foo();\\n    \/\/ An additional set of curly braces isn't worth it.\\n    if (cond.getType() == Token.NOT && !consumesDanglingElse(elseBranch)) {\\n      n.replaceChild(cond, cond.removeFirstChild());\\n      n.removeChild(thenBranch);\\n      n.addChildToBack(thenBranch);\\n      reportCodeChange();\\n      return n;\\n    }\\n\\n    \/\/ if(x)return 1;else return 2; -> return x?1:2;\\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\\n      Node thenExpr = getBlockReturnExpression(thenBranch);\\n      Node elseExpr = getBlockReturnExpression(elseBranch);\\n      n.removeChild(cond);\\n      thenExpr.detachFromParent();\\n      elseExpr.detachFromParent();\\n\\n      \/\/ note - we ignore any cases with \\\"return;\\\", technically this\\n      \/\/ can be converted to \\\"return undefined;\\\" or some variant, but\\n      \/\/ that does not help code size.\\n      Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\\n                          .copyInformationFrom(n);\\n      Node returnNode = new Node(Token.RETURN, hookNode);\\n      parent.replaceChild(n, returnNode);\\n      reportCodeChange();\\n      return returnNode;\\n    }\\n\\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\\n\\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\\n      if (thenOp.getType() == elseOp.getType()) {\\n        \/\/ if(x)a=1;else a=2; -> a=x?1:2;\\n        if (NodeUtil.isAssignmentOp(thenOp)) {\\n          Node lhs = thenOp.getFirstChild();\\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\\n              \/\/ if LHS has side effects, don't proceed [since the optimization\\n              \/\/ evaluates LHS before cond]\\n              \/\/ NOTE - there are some circumstances where we can\\n              \/\/ proceed even if there are side effects...\\n              !mayEffectMutableState(lhs)) {\\n\\n            n.removeChild(cond);\\n            Node assignName = thenOp.removeFirstChild();\\n            Node thenExpr = thenOp.removeFirstChild();\\n            Node elseExpr = elseOp.getLastChild();\\n            elseOp.removeChild(elseExpr);\\n\\n            Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\\n                                .copyInformationFrom(n);\\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\\n                              .copyInformationFrom(thenOp);\\n            Node expr = NodeUtil.newExpr(assign);\\n            parent.replaceChild(n, expr);\\n            reportCodeChange();\\n\\n            return expr;\\n          }\\n        } else if (NodeUtil.isCall(thenOp)) {\\n          \/\/ if(x)foo();else bar(); -> x?foo():bar()\\n          n.removeChild(cond);\\n          thenOp.detachFromParent();\\n          elseOp.detachFromParent();\\n          Node hookNode = new Node(Token.HOOK, cond, thenOp, elseOp)\\n                              .copyInformationFrom(n);\\n          Node expr = NodeUtil.newExpr(hookNode);\\n          parent.replaceChild(n, expr);\\n          reportCodeChange();\\n\\n          return expr;\\n        }\\n      }\\n      return n;\\n    }\\n\\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\\n\\n    \/\/ if(x)var y=1;else y=2  ->  var y=x?1:2\\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\\n        NodeUtil.isAssign(getBlockExpression(elseBranch).getFirstChild())) {\\n\\n      Node var = getBlockVar(thenBranch);\\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\\n\\n      Node name1 = var.getFirstChild();\\n      Node maybeName2 = elseAssign.getFirstChild();\\n\\n      if (name1.hasChildren()\\n          && maybeName2.getType() == Token.NAME\\n          && name1.getString().equals(maybeName2.getString())) {\\n        Node thenExpr = name1.removeChildren();\\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\\n        cond.detachFromParent();\\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\\n                            .copyInformationFrom(n);\\n        var.detachFromParent();\\n        name1.addChildrenToBack(hookNode);\\n        parent.replaceChild(n, var);\\n        reportCodeChange();\\n        return var;\\n      }\\n\\n    \/\/ if(x)y=1;else var y=2  ->  var y=x?1:2\\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\\n        NodeUtil.isAssign(getBlockExpression(thenBranch).getFirstChild())) {\\n\\n      Node var = getBlockVar(elseBranch);\\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\\n\\n      Node maybeName1 = thenAssign.getFirstChild();\\n      Node name2 = var.getFirstChild();\\n\\n      if (name2.hasChildren()\\n          && maybeName1.getType() == Token.NAME\\n          && maybeName1.getString().equals(name2.getString())) {\\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\\n        Node elseExpr = name2.removeChildren();\\n        cond.detachFromParent();\\n        Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\\n                            .copyInformationFrom(n);\\n        var.detachFromParent();\\n        name2.addChildrenToBack(hookNode);\\n        parent.replaceChild(n, var);\\n        reportCodeChange();\\n\\n        return var;\\n      }\\n    }\\n\\n    return n;\\n  }\", \"javadoc_start_line\": 252, \"annotations_start_line\": 258, \"method_start_line\": 258, \"end_line\": 462}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeSubstituteAlternateSyntax.java\", \"method_name\": \"isFoldableExpressBlock\", \"content\": \"  \/**\\n   * @return Whether the node is a block with a single statement that is\\n   *     an expression.\\n   *\/\\n  private boolean isFoldableExpressBlock(Node n) {\\n    if (n.getType() == Token.BLOCK) {\\n      if (n.hasOneChild()) {\\n        Node maybeExpr = n.getFirstChild();\\n          \/\/ IE has a bug where event handlers behave differently when\\n          \/\/ their return value is used vs. when their return value is in\\n          \/\/ an EXPR_RESULT. It's pretty freaking weird. See:\\n          \/\/ http:\/\/code.google.com\/p\/closure-compiler\/issues\/detail?id=291\\n          \/\/ We try to detect this case, and not fold EXPR_RESULTs\\n          \/\/ into other expressions.\\n\\n            \/\/ We only have to worry about methods with an implicit 'this'\\n            \/\/ param, or this doesn't happen.\\n\\n          return NodeUtil.isExpressionNode(maybeExpr);\\n      }\\n    }\\n\\n    return false;\\n  }\", \"javadoc_start_line\": 515, \"annotations_start_line\": 519, \"method_start_line\": 519, \"end_line\": 538}"}]},{"name":"Closure","version":90,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeCheckTest\", \"methodName\": \"testBackwardsTypedefUse8\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"unexpected warnings(s):\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/FunctionTypeBuilder.java\", \"method_name\": \"apply\", \"content\": \"    public boolean apply(JSType type) {\\n      \/\/ TODO(user): Doing an instanceof check here is too\\n      \/\/ restrictive as (Date,Error) is, for instance, an object type\\n      \/\/ even though its implementation is a UnionType. Would need to\\n      \/\/ create interfaces JSType, ObjectType, FunctionType etc and have\\n      \/\/ separate implementation instead of the class hierarchy, so that\\n      \/\/ union types can also be object types, etc.\\n      if (!type.isSubtype(\\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\\n        return false;\\n      }\\n      return true;\\n    }\", \"javadoc_start_line\": 177, \"annotations_start_line\": 176, \"method_start_line\": 177, \"end_line\": 190}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 345, \"annotations_start_line\": 346, \"method_start_line\": 346, \"end_line\": 363}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/MemoizedScopeCreator.java\", \"method_name\": \"createScope\", \"content\": \"  public Scope createScope(Node n, Scope parent) {\\n    Scope scope = scopes.get(n);\\n    if (scope == null) {\\n      scope = delegate.createScope(n, parent);\\n      scopes.put(n, scope);\\n    } else {\\n      Preconditions.checkState(parent == scope.getParent());\\n    }\\n    return scope;\\n  }\", \"javadoc_start_line\": 50, \"annotations_start_line\": 49, \"method_start_line\": 50, \"end_line\": 59}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypedScopeCreator.java\", \"method_name\": \"createScope\", \"content\": \"  \/**\\n   * Creates a scope with all types declared. Declares newly discovered types\\n   * and type properties in the type registry.\\n   *\/\\n  public Scope createScope(Node root, Scope parent) {\\n    \/\/ Constructing the global scope is very different than constructing\\n    \/\/ inner scopes, because only global scopes can contain named classes that\\n    \/\/ show up in the type registry.\\n    Scope newScope = null;\\n    AbstractScopeBuilder scopeBuilder = null;\\n    if (parent == null) {\\n      \/\/ Find all the classes in the global scope.\\n      newScope = createInitialScope(root);\\n\\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\\n      scopeBuilder = globalScopeBuilder;\\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\\n    } else {\\n      newScope = new Scope(parent, root);\\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\\n      scopeBuilder = localScopeBuilder;\\n      localScopeBuilder.build();\\n    }\\n\\n    scopeBuilder.resolveStubDeclarations();\\n    scopeBuilder.resolveTypes();\\n\\n    \/\/ Gather the properties in each function that we found in the\\n    \/\/ global scope, if that function has a @this type that we can\\n    \/\/ build properties on.\\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\\n      JSType type = functionNode.getJSType();\\n      if (type != null && type instanceof FunctionType) {\\n        FunctionType fnType = (FunctionType) type;\\n        ObjectType fnThisType = fnType.getTypeOfThis();\\n        if (!fnThisType.isUnknownType()) {\\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\\n              scopeBuilder.new CollectProperties(fnThisType));\\n        }\\n      }\\n    }\\n\\n    if (parent == null) {\\n      codingConvention.defineDelegateProxyPrototypeProperties(\\n          typeRegistry, newScope, delegateProxyPrototypes);\\n    }\\n    return newScope;\\n  }\", \"javadoc_start_line\": 165, \"annotations_start_line\": 169, \"method_start_line\": 169, \"end_line\": 212}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/JSType.java\", \"method_name\": \"resolve\", \"content\": \"  \/**\\n   * Resolve this type in the given scope.\\n   *\\n   * The returned value must be equal to {@code this}, as defined by\\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\\n   * may modify the internal state of {@code this}, as long as it does\\n   * so in a way that preserves Object equality.\\n   *\\n   * For efficiency, we should only resolve a type once per compilation job.\\n   * For incremental compilations, one compilation job may need the\\n   * artifacts from a previous generation, so we will eventually need\\n   * a generational flag instead of a boolean one.\\n   *\/\\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\\n    if (resolved) {\\n      \/\/ TODO(nicksantos): Check to see if resolve() looped back on itself.\\n      \/\/ Preconditions.checkNotNull(resolveResult);\\n      if (resolveResult == null) {\\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\\n      }\\n      return resolveResult;\\n    }\\n    resolved = true;\\n    resolveResult = resolveInternal(t, scope);\\n    resolveResult.setResolvedTypeInternal(resolveResult);\\n    return resolveResult;\\n  }\", \"javadoc_start_line\": 871, \"annotations_start_line\": 884, \"method_start_line\": 884, \"end_line\": 897}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/FunctionType.java\", \"method_name\": \"resolveInternal\", \"content\": \"  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\\n    setResolvedTypeInternal(this);\\n\\n    call = (ArrowType) safeResolve(call, t, scope);\\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\\n\\n    \/\/ Warning about typeOfThis if it doesn't resolve to an ObjectType\\n    \/\/ is handled further upstream.\\n    \/\/\\n    \/\/ TODO(nicksantos): Handle this correctly if we have a UnionType.\\n    \/\/\\n    \/\/ TODO(nicksantos): In ES3, the runtime coerces \\\"null\\\" to the global\\n    \/\/ activation object. In ES5, it leaves it as null. Just punt on this\\n    \/\/ issue for now by coercing out null. This is complicated by the\\n    \/\/ fact that when most people write @this {Foo}, they really don't\\n    \/\/ mean \\\"nullable Foo\\\". For certain tags (like @extends) we de-nullify\\n    \/\/ the name for them.\\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\\n    if (maybeTypeOfThis instanceof ObjectType) {\\n      typeOfThis = (ObjectType) maybeTypeOfThis;\\n    }\\n\\n    boolean changed = false;\\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\\n        ImmutableList.builder();\\n    for (ObjectType iface : implementedInterfaces) {\\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\\n      resolvedInterfaces.add(resolvedIface);\\n      changed |= (resolvedIface != iface);\\n    }\\n    if (changed) {\\n      implementedInterfaces = resolvedInterfaces.build();\\n    }\\n\\n    if (subTypes != null) {\\n      for (int i = 0; i < subTypes.size(); i++) {\\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\\n      }\\n    }\\n\\n    return super.resolveInternal(t, scope);\\n  }\", \"javadoc_start_line\": 862, \"annotations_start_line\": 861, \"method_start_line\": 862, \"end_line\": 903}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/JSType.java\", \"method_name\": \"safeResolve\", \"content\": \"  \/**\\n   * A null-safe resolve.\\n   * @see #resolve\\n   *\/\\n  static final JSType safeResolve(\\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\\n    return type == null ? null : type.resolve(t, scope);\\n  }\", \"javadoc_start_line\": 920, \"annotations_start_line\": 924, \"method_start_line\": 925, \"end_line\": 927}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/JSType.java\", \"method_name\": \"resolve\", \"content\": \"  \/**\\n   * Resolve this type in the given scope.\\n   *\\n   * The returned value must be equal to {@code this}, as defined by\\n   * {@link #isEquivalentTo}. It may or may not be the same object. This method\\n   * may modify the internal state of {@code this}, as long as it does\\n   * so in a way that preserves Object equality.\\n   *\\n   * For efficiency, we should only resolve a type once per compilation job.\\n   * For incremental compilations, one compilation job may need the\\n   * artifacts from a previous generation, so we will eventually need\\n   * a generational flag instead of a boolean one.\\n   *\/\\n  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\\n    if (resolved) {\\n      \/\/ TODO(nicksantos): Check to see if resolve() looped back on itself.\\n      \/\/ Preconditions.checkNotNull(resolveResult);\\n      if (resolveResult == null) {\\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\\n      }\\n      return resolveResult;\\n    }\\n    resolved = true;\\n    resolveResult = resolveInternal(t, scope);\\n    resolveResult.setResolvedTypeInternal(resolveResult);\\n    return resolveResult;\\n  }\", \"javadoc_start_line\": 871, \"annotations_start_line\": 884, \"method_start_line\": 884, \"end_line\": 897}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/NamedType.java\", \"method_name\": \"resolveInternal\", \"content\": \"  \/**\\n   * Resolve the referenced type within the enclosing scope.\\n   *\/\\n  @Override\\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\\n    \/\/ TODO(user): Investigate whether it is really necessary to keep two\\n    \/\/ different mechanisms for resolving named types, and if so, which order\\n    \/\/ makes more sense. Now, resolution via registry is first in order to\\n    \/\/ avoid triggering the warnings built into the resolution via properties.\\n    boolean resolved = resolveViaRegistry(t, enclosing);\\n    if (detectImplicitPrototypeCycle()) {\\n      handleTypeCycle(t);\\n    }\\n\\n    if (resolved) {\\n      super.resolveInternal(t, enclosing);\\n      return registry.isLastGeneration() ?\\n          getReferencedType() : this;\\n    }\\n\\n    resolveViaProperties(t, enclosing);\\n    if (detectImplicitPrototypeCycle()) {\\n      handleTypeCycle(t);\\n    }\\n\\n    super.resolveInternal(t, enclosing);\\n    return registry.isLastGeneration() ?\\n        getReferencedType() : this;\\n  }\", \"javadoc_start_line\": 181, \"annotations_start_line\": 184, \"method_start_line\": 185, \"end_line\": 209}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/NamedType.java\", \"method_name\": \"resolveViaRegistry\", \"content\": \"  \/**\\n   * Resolves a named type by looking it up in the registry.\\n   * @return True if we resolved successfully.\\n   *\/\\n  private boolean resolveViaRegistry(\\n      ErrorReporter t, StaticScope<JSType> enclosing) {\\n    JSType type = registry.getType(reference);\\n    if (type != null) {\\n      setReferencedAndResolvedType(type, t, enclosing);\\n      return true;\\n    }\\n    return false;\\n  }\", \"javadoc_start_line\": 211, \"annotations_start_line\": 215, \"method_start_line\": 216, \"end_line\": 223}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/rhino\/jstype\/NamedType.java\", \"method_name\": \"setReferencedAndResolvedType\", \"content\": \"  private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\\n      StaticScope<JSType> enclosing) {\\n    if (validator != null) {\\n      validator.apply(type);\\n    }\\n    setReferencedType(type);\\n    checkEnumElementCycle(t);\\n    setResolvedTypeInternal(getReferencedType());\\n  }\", \"javadoc_start_line\": 295, \"annotations_start_line\": 295, \"method_start_line\": 296, \"end_line\": 303}"}]},{"name":"Closure","version":96,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.TypeCheckTest\", \"methodName\": \"testFunctionArguments16\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected a warning\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitParameterList\", \"content\": \"  \/**\\n   * Visits the parameters of a CALL or a NEW node.\\n   *\/\\n  private void visitParameterList(NodeTraversal t, Node call,\\n      FunctionType functionType) {\\n    Iterator<Node> arguments = call.children().iterator();\\n    arguments.next(); \/\/ skip the function name\\n\\n    Iterator<Node> parameters = functionType.getParameters().iterator();\\n    int ordinal = 0;\\n    Node parameter = null;\\n    Node argument = null;\\n    while (arguments.hasNext() &&\\n           parameters.hasNext()) {\\n      \/\/ If there are no parameters left in the list, then the while loop\\n      \/\/ above implies that this must be a var_args function.\\n        parameter = parameters.next();\\n      argument = arguments.next();\\n      ordinal++;\\n\\n      validator.expectArgumentMatchesParameter(t, argument,\\n          getJSType(argument), getJSType(parameter), call, ordinal);\\n    }\\n\\n    int numArgs = call.getChildCount() - 1;\\n    int minArgs = functionType.getMinArguments();\\n    int maxArgs = functionType.getMaxArguments();\\n    if (minArgs > numArgs || maxArgs < numArgs) {\\n      report(t, call, WRONG_ARGUMENT_COUNT,\\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\\n              String.valueOf(numArgs), String.valueOf(minArgs),\\n              maxArgs != Integer.MAX_VALUE ?\\n              \\\" and no more than \\\" + maxArgs + \\\" argument(s)\\\" : \\\"\\\");\\n    }\\n  }\", \"javadoc_start_line\": 1396, \"annotations_start_line\": 1399, \"method_start_line\": 1400, \"end_line\": 1430}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"processForTesting\", \"content\": \"  \/** Main entry point of this phase for testing code. *\/\\n  public Scope processForTesting(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkState(scopeCreator == null);\\n    Preconditions.checkState(topScope == null);\\n\\n    Preconditions.checkState(jsRoot.getParent() != null);\\n    Node externsAndJsRoot = jsRoot.getParent();\\n\\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\\n\\n    TypeInferencePass inference = new TypeInferencePass(compiler,\\n        reverseInterpreter, topScope, scopeCreator);\\n\\n    inference.process(externsRoot, jsRoot);\\n    process(externsRoot, jsRoot);\\n\\n    return topScope;\\n  }\", \"javadoc_start_line\": 345, \"annotations_start_line\": 346, \"method_start_line\": 346, \"end_line\": 363}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Main entry point for this phase of processing. This follows the pattern for\\n   * JSCompiler phases.\\n   *\\n   * @param externsRoot The root of the externs parse tree.\\n   * @param jsRoot The root of the input parse tree to be checked.\\n   *\/\\n  public void process(Node externsRoot, Node jsRoot) {\\n    Preconditions.checkNotNull(scopeCreator);\\n    Preconditions.checkNotNull(topScope);\\n\\n    Node externsAndJs = jsRoot.getParent();\\n    Preconditions.checkState(externsAndJs != null);\\n    Preconditions.checkState(\\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\\n\\n    if (externsRoot != null) {\\n      check(externsRoot, true);\\n    }\\n    check(jsRoot, false);\\n  }\", \"javadoc_start_line\": 323, \"annotations_start_line\": 330, \"method_start_line\": 330, \"end_line\": 343}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"check\", \"content\": \"  public void check(Node node, boolean externs) {\\n    Preconditions.checkNotNull(node);\\n\\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\\n    inExterns = externs;\\n    t.traverseWithScope(node, topScope);\\n    if (externs) {\\n      inferJSDocInfo.process(node, null);\\n    } else {\\n      inferJSDocInfo.process(null, node);\\n    }\\n  }\", \"javadoc_start_line\": 366, \"annotations_start_line\": 366, \"method_start_line\": 366, \"end_line\": 377}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseWithScope\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively with a scope, starting with the given\\n   * root. This should only be used in the global scope. Otherwise, use\\n   * {@link #traverseAtScope}.\\n   *\/\\n  void traverseWithScope(Node root, Scope s) {\\n    Preconditions.checkState(s.isGlobal());\\n\\n    sourceName = \\\"\\\";\\n    curNode = root;\\n    pushScope(s);\\n    traverseBranch(root, null);\\n    popScope();\\n  }\", \"javadoc_start_line\": 305, \"annotations_start_line\": 310, \"method_start_line\": 310, \"end_line\": 318}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visit\", \"content\": \"  \/**\\n   * This is the meat of the type checking.  It is basically one big switch,\\n   * with each case representing one type of parse tree node.  The individual\\n   * cases are usually pretty straightforward.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   * @param parent The parent of the node n.\\n   *\/\\n  public void visit(NodeTraversal t, Node n, Node parent) {\\n    JSType childType;\\n    JSType leftType, rightType;\\n    Node left, right;\\n    \/\/ To be explicitly set to false if the node is not typeable.\\n    boolean typeable = true;\\n\\n    switch (n.getType()) {\\n      case Token.NAME:\\n        typeable = visitName(t, n, parent);\\n        break;\\n\\n      case Token.LP:\\n        \/\/ If this is under a FUNCTION node, it is a parameter list and can be\\n        \/\/ ignored here.\\n        if (parent.getType() != Token.FUNCTION) {\\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        } else {\\n          typeable = false;\\n        }\\n        break;\\n\\n      case Token.COMMA:\\n        ensureTyped(t, n, getJSType(n.getLastChild()));\\n        break;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.THIS:\\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\\n        break;\\n\\n      case Token.REF_SPECIAL:\\n        ensureTyped(t, n);\\n        break;\\n\\n      case Token.GET_REF:\\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\\n        break;\\n\\n      case Token.NULL:\\n        ensureTyped(t, n, NULL_TYPE);\\n        break;\\n\\n      case Token.NUMBER:\\n        if (n.getParent().getType() != Token.OBJECTLIT) {\\n          ensureTyped(t, n, NUMBER_TYPE);\\n        } else {\\n          typeable = false;\\n        }\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        ensureTyped(t, n, ARRAY_TYPE);\\n        break;\\n\\n      case Token.STRING:\\n        if (n.getParent().getType() != Token.OBJECTLIT) {\\n          ensureTyped(t, n, STRING_TYPE);\\n        } else {\\n          typeable = false;\\n        }\\n        break;\\n\\n      case Token.REGEXP:\\n        ensureTyped(t, n, REGEXP_TYPE);\\n        break;\\n\\n      case Token.GETPROP:\\n        visitGetProp(t, n, parent);\\n        typeable = !(parent.getType() == Token.ASSIGN &&\\n                     parent.getFirstChild() == n);\\n        break;\\n\\n      case Token.GETELEM:\\n        visitGetElem(t, n);\\n        \/\/ The type of GETELEM is always unknown, so no point counting that.\\n        \/\/ If that unknown leaks elsewhere (say by an assignment to another\\n        \/\/ variable), then it will be counted.\\n        typeable = false;\\n        break;\\n\\n      case Token.VAR:\\n        visitVar(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.NEW:\\n        visitNew(t, n);\\n        typeable = true;\\n        break;\\n\\n      case Token.CALL:\\n        visitCall(t, n);\\n        typeable = !NodeUtil.isExpressionNode(parent);\\n        break;\\n\\n      case Token.RETURN:\\n        visitReturn(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.DEC:\\n      case Token.INC:\\n        left = n.getFirstChild();\\n        validator.expectNumber(\\n            t, left, getJSType(left), \\\"increment\/decrement\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.NOT:\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.VOID:\\n        ensureTyped(t, n, VOID_TYPE);\\n        break;\\n\\n      case Token.TYPEOF:\\n        ensureTyped(t, n, STRING_TYPE);\\n        break;\\n\\n      case Token.BITNOT:\\n        childType = getJSType(n.getFirstChild());\\n        if (!childType.matchesInt32Context()) {\\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\\n              childType.toString());\\n        }\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.POS:\\n      case Token.NEG:\\n        left = n.getFirstChild();\\n        validator.expectNumber(t, left, getJSType(left), \\\"sign operator\\\");\\n        ensureTyped(t, n, NUMBER_TYPE);\\n        break;\\n\\n      case Token.EQ:\\n      case Token.NE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        TernaryValue result =\\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\\n        if (result != TernaryValue.UNKNOWN) {\\n          if (n.getType() == Token.NE) {\\n            result = result.not();\\n          }\\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\\n              rightType.toString(), result.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.SHEQ:\\n      case Token.SHNE: {\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n\\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\\n                rightTypeRestricted)) {\\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\\n              rightType.toString());\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n      }\\n\\n      case Token.LT:\\n      case Token.LE:\\n      case Token.GT:\\n      case Token.GE:\\n        leftType = getJSType(n.getFirstChild());\\n        rightType = getJSType(n.getLastChild());\\n        if (rightType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, leftType, \\\"left side of numeric comparison\\\");\\n        } else if (leftType.isNumber()) {\\n          validator.expectNumber(\\n              t, n, rightType, \\\"right side of numeric comparison\\\");\\n        } else if (leftType.matchesNumberContext() &&\\n                   rightType.matchesNumberContext()) {\\n          \/\/ OK.\\n        } else {\\n          \/\/ Whether the comparison is numeric will be determined at runtime\\n          \/\/ each time the expression is evaluated. Regardless, both operands\\n          \/\/ should match a string context.\\n          String message = \\\"left side of comparison\\\";\\n          validator.expectString(t, n, leftType, message);\\n          validator.expectNotVoid(\\n              t, n, leftType, message, getNativeType(STRING_TYPE));\\n          message = \\\"right side of comparison\\\";\\n          validator.expectString(t, n, rightType, message);\\n          validator.expectNotVoid(\\n              t, n, rightType, message, getNativeType(STRING_TYPE));\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.IN:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right);\\n        validator.expectObject(t, n, rightType, \\\"'in' requires an object\\\");\\n        validator.expectString(t, left, leftType, \\\"left side of 'in'\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.INSTANCEOF:\\n        left = n.getFirstChild();\\n        right = n.getLastChild();\\n        leftType = getJSType(left);\\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\\n\\n        validator.expectAnyObject(\\n            t, left, leftType, \\\"deterministic instanceof yields false\\\");\\n        validator.expectActualObject(\\n            t, right, rightType, \\\"instanceof requires an object\\\");\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.ASSIGN:\\n        visitAssign(t, n);\\n        typeable = false;\\n        break;\\n\\n      case Token.ASSIGN_LSH:\\n      case Token.ASSIGN_RSH:\\n      case Token.ASSIGN_URSH:\\n      case Token.ASSIGN_DIV:\\n      case Token.ASSIGN_MOD:\\n      case Token.ASSIGN_BITOR:\\n      case Token.ASSIGN_BITXOR:\\n      case Token.ASSIGN_BITAND:\\n      case Token.ASSIGN_SUB:\\n      case Token.ASSIGN_ADD:\\n      case Token.ASSIGN_MUL:\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n      case Token.DIV:\\n      case Token.MOD:\\n      case Token.BITOR:\\n      case Token.BITXOR:\\n      case Token.BITAND:\\n      case Token.SUB:\\n      case Token.ADD:\\n      case Token.MUL:\\n        visitBinaryOperator(n.getType(), t, n);\\n        break;\\n\\n      case Token.DELPROP:\\n        if (!isReference(n.getFirstChild())) {\\n          report(t, n, BAD_DELETE);\\n        }\\n        ensureTyped(t, n, BOOLEAN_TYPE);\\n        break;\\n\\n      case Token.CASE:\\n        JSType switchType = getJSType(parent.getFirstChild());\\n        JSType caseType = getJSType(n.getFirstChild());\\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\\n        typeable = false;\\n        break;\\n\\n      case Token.WITH: {\\n        Node child = n.getFirstChild();\\n        childType = getJSType(child);\\n        validator.expectObject(\\n            t, child, childType, \\\"with requires an object\\\");\\n        typeable = false;\\n        break;\\n      }\\n\\n      case Token.FUNCTION:\\n        visitFunction(t, n);\\n        break;\\n\\n      \/\/ These nodes have no interesting type behavior.\\n      case Token.LABEL:\\n      case Token.LABEL_NAME:\\n      case Token.SWITCH:\\n      case Token.BREAK:\\n      case Token.CATCH:\\n      case Token.TRY:\\n      case Token.SCRIPT:\\n      case Token.EXPR_RESULT:\\n      case Token.BLOCK:\\n      case Token.EMPTY:\\n      case Token.DEFAULT:\\n      case Token.CONTINUE:\\n      case Token.DEBUGGER:\\n      case Token.THROW:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes require data flow analysis.\\n      case Token.DO:\\n      case Token.FOR:\\n      case Token.IF:\\n      case Token.WHILE:\\n        typeable = false;\\n        break;\\n\\n      \/\/ These nodes are typed during the type inference.\\n      case Token.AND:\\n      case Token.HOOK:\\n      case Token.OBJECTLIT:\\n      case Token.OR:\\n        if (n.getJSType() != null) { \/\/ If we didn't run type inference.\\n          ensureTyped(t, n);\\n        } else {\\n          \/\/ If this is an enum, then give that type to the objectlit as well.\\n          if ((n.getType() == Token.OBJECTLIT)\\n              && (parent.getJSType() instanceof EnumType)) {\\n            ensureTyped(t, n, parent.getJSType());\\n          } else {\\n            ensureTyped(t, n);\\n          }\\n        }\\n        break;\\n\\n      default:\\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\\n        ensureTyped(t, n);\\n        break;\\n    }\\n\\n    \/\/ Don't count externs since the user's code may not even use that part.\\n    typeable = typeable && !inExterns;\\n\\n    if (typeable) {\\n      doPercentTypedAccounting(t, n);\\n    }\\n\\n    checkNoTypeCheckSection(n, false);\\n  }\", \"javadoc_start_line\": 435, \"annotations_start_line\": 445, \"method_start_line\": 445, \"end_line\": 791}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitCall\", \"content\": \"  \/**\\n   * Visits a CALL node.\\n   *\\n   * @param t The node traversal object that supplies context, such as the\\n   * scope chain to use in name lookups as well as error reporting.\\n   * @param n The node being visited.\\n   *\/\\n  private void visitCall(NodeTraversal t, Node n) {\\n    Node child = n.getFirstChild();\\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\\n\\n    if (!childType.canBeCalled()) {\\n      report(t, n, NOT_CALLABLE, childType.toString());\\n      ensureTyped(t, n);\\n      return;\\n    }\\n\\n    \/\/ A couple of types can be called as if they were functions.\\n    \/\/ If it is a function type, then validate parameters.\\n    if (childType instanceof FunctionType) {\\n      FunctionType functionType = (FunctionType) childType;\\n\\n      \/\/ Non-native constructors should never be called directly.\\n      if (functionType.isConstructor() &&\\n          !functionType.isNativeObjectType()) {\\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\\n      }\\n\\n      visitParameterList(t, n, functionType);\\n      ensureTyped(t, n, functionType.getReturnType());\\n    } else {\\n      ensureTyped(t, n);\\n    }\\n\\n    \/\/ TODO: Add something to check for calls of RegExp objects, which is not\\n    \/\/ supported by IE.  Either say something about the return type or warn\\n    \/\/ about the non-portability of the call or both.\\n  }\", \"javadoc_start_line\": 1357, \"annotations_start_line\": 1364, \"method_start_line\": 1364, \"end_line\": 1394}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/TypeCheck.java\", \"method_name\": \"visitParameterList\", \"content\": \"  \/**\\n   * Visits the parameters of a CALL or a NEW node.\\n   *\/\\n  private void visitParameterList(NodeTraversal t, Node call,\\n      FunctionType functionType) {\\n    Iterator<Node> arguments = call.children().iterator();\\n    arguments.next(); \/\/ skip the function name\\n\\n    Iterator<Node> parameters = functionType.getParameters().iterator();\\n    int ordinal = 0;\\n    Node parameter = null;\\n    Node argument = null;\\n    while (arguments.hasNext() &&\\n           parameters.hasNext()) {\\n      \/\/ If there are no parameters left in the list, then the while loop\\n      \/\/ above implies that this must be a var_args function.\\n        parameter = parameters.next();\\n      argument = arguments.next();\\n      ordinal++;\\n\\n      validator.expectArgumentMatchesParameter(t, argument,\\n          getJSType(argument), getJSType(parameter), call, ordinal);\\n    }\\n\\n    int numArgs = call.getChildCount() - 1;\\n    int minArgs = functionType.getMinArguments();\\n    int maxArgs = functionType.getMaxArguments();\\n    if (minArgs > numArgs || maxArgs < numArgs) {\\n      report(t, call, WRONG_ARGUMENT_COUNT,\\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\\n              String.valueOf(numArgs), String.valueOf(minArgs),\\n              maxArgs != Integer.MAX_VALUE ?\\n              \\\" and no more than \\\" + maxArgs + \\\" argument(s)\\\" : \\\"\\\");\\n    }\\n  }\", \"javadoc_start_line\": 1396, \"annotations_start_line\": 1399, \"method_start_line\": 1400, \"end_line\": 1430}"}]},{"name":"Closure","version":97,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.PeepholeFoldConstantsTest\", \"methodName\": \"testFoldBitShifts\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"tryFoldShift\", \"content\": \"  \/**\\n   * Try to fold shift operations\\n   *\/\\n  private Node tryFoldShift(Node n, Node left, Node right) {\\n    if (left.getType() == Token.NUMBER &&\\n        right.getType() == Token.NUMBER) {\\n\\n      double result;\\n      double lval = left.getDouble();\\n      double rval = right.getDouble();\\n\\n      \/\/ check ranges.  We do not do anything that would clip the double to\\n      \/\/ a 32-bit range, since the user likely does not intend that.\\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\\n        return n;\\n      }\\n\\n      \/\/ only the lower 5 bits are used when shifting, so don't do anything\\n      \/\/ if the shift amount is outside [0,32)\\n      if (!(rval >= 0 && rval < 32)) {\\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\\n        return n;\\n      }\\n\\n      \/\/ Convert the numbers to ints\\n      int lvalInt = (int) lval;\\n      if (lvalInt != lval) {\\n        error(FRACTIONAL_BITWISE_OPERAND, left);\\n        return n;\\n      }\\n\\n      int rvalInt = (int) rval;\\n      if (rvalInt != rval) {\\n        error(FRACTIONAL_BITWISE_OPERAND, right);\\n        return n;\\n      }\\n\\n      switch (n.getType()) {\\n        case Token.LSH:\\n          result = lvalInt << rvalInt;\\n          break;\\n        case Token.RSH:\\n          result = lvalInt >> rvalInt;\\n          break;\\n        case Token.URSH:\\n          \/\/ JavaScript handles zero shifts on signed numbers differently than\\n          \/\/ Java as an Java int can not represent the unsigned 32-bit number\\n          \/\/ where JavaScript can so use a long here.\\n          result = lvalInt >>> rvalInt;\\n          break;\\n        default:\\n          throw new AssertionError(\\\"Unknown shift operator: \\\" +\\n              Node.tokenToName(n.getType()));\\n      }\\n\\n      Node newNumber = Node.newNumber(result);\\n      n.getParent().replaceChild(n, newNumber);\\n      reportCodeChange();\\n\\n      return newNumber;\\n    }\\n\\n    return n;\\n  }\", \"javadoc_start_line\": 649, \"annotations_start_line\": 652, \"method_start_line\": 652, \"end_line\": 713}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    NodeTraversal t = new NodeTraversal(compiler, this);\\n    \\n    beginTraversal(t);\\n    t.traverse(root);\\n    endTraversal(t);\\n  }\", \"javadoc_start_line\": 55, \"annotations_start_line\": 54, \"method_start_line\": 55, \"end_line\": 61}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 245, \"annotations_start_line\": 248, \"method_start_line\": 248, \"end_line\": 258}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) return;\\n\\n    switch (type) {\\n      case Token.CATCH:\\n        Preconditions.checkState(n.getChildCount() == 3);\\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\\n        \/\/ the first child is the catch var and the third child\\n        \/\/ is the code block\\n        traverseBranch(n.getFirstChild(), n);\\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\\n        break;\\n\\n      case Token.FUNCTION:\\n        traverseFunction(n, parent);\\n        break;\\n\\n      default:\\n        for (Node child = n.getFirstChild(); child != null; ) {\\n          \/\/ child could be replaced, in which case our child node\\n          \/\/ would no longer point to the true next\\n          Node next = child.getNext();\\n          traverseBranch(child, n);\\n          child = next;\\n        }\\n        break;\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 438, \"annotations_start_line\": 441, \"method_start_line\": 442, \"end_line\": 478}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"visit\", \"content\": \"  public void visit(NodeTraversal t, Node n, Node parent) {\\n    Node currentVersionOfNode = n;\\n    \\n    boolean somethingChanged = false;\\n    \\n    do {\\n      somethingChanged = false;\\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\\n        Node newVersionOfNode = \\n            optimization.optimizeSubtree(currentVersionOfNode);\\n        \\n        if (newVersionOfNode != currentVersionOfNode) {\\n          somethingChanged = true;\\n          \\n          currentVersionOfNode = newVersionOfNode;\\n        }\\n        \\n        if (currentVersionOfNode == null) {\\n          return;\\n        }\\n      }\\n    } while(somethingChanged);\\n  }\", \"javadoc_start_line\": 64, \"annotations_start_line\": 63, \"method_start_line\": 64, \"end_line\": 86}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"optimizeSubtree\", \"content\": \"  Node optimizeSubtree(Node subtree) {\\n    switch(subtree.getType()) {\\n      case Token.CALL:\\n        return tryFoldKnownMethods(subtree);\\n\\n      case Token.TYPEOF:\\n        return tryFoldTypeof(subtree);\\n\\n      case Token.NOT:\\n      case Token.NEG:\\n      case Token.BITNOT:\\n        return tryFoldUnaryOperator(subtree);\\n\\n      default:\\n        return tryFoldBinaryOperator(subtree);\\n    }\\n  }\", \"javadoc_start_line\": 70, \"annotations_start_line\": 69, \"method_start_line\": 70, \"end_line\": 86}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"tryFoldBinaryOperator\", \"content\": \"  private Node tryFoldBinaryOperator(Node subtree) {\\n    Node left = subtree.getFirstChild();\\n\\n    if (left == null) {\\n      return subtree;\\n    }\\n\\n    Node right = left.getNext();\\n\\n    if (right == null) {\\n      return subtree;\\n    }\\n\\n    \/\/ If we've reached here, node is truly a binary operator.\\n    switch(subtree.getType()) {\\n      case Token.GETPROP:\\n        return tryFoldGetProp(subtree, left, right);\\n\\n      case Token.GETELEM:\\n        return tryFoldGetElem(subtree, left, right);\\n\\n      case Token.INSTANCEOF:\\n        return tryFoldInstanceof(subtree, left, right);\\n\\n      case Token.AND:\\n      case Token.OR:\\n        return tryFoldAndOr(subtree, left, right);\\n\\n      case Token.BITAND:\\n      case Token.BITOR:\\n        return tryFoldBitAndOr(subtree, left, right);\\n\\n      case Token.LSH:\\n      case Token.RSH:\\n      case Token.URSH:\\n        return tryFoldShift(subtree, left, right);\\n\\n      case Token.ASSIGN:\\n        return tryFoldAssign(subtree, left, right);\\n\\n      case Token.ADD:\\n        return tryFoldAdd(subtree, left, right);\\n\\n      case Token.SUB:\\n      case Token.MUL:\\n      case Token.DIV:\\n        return tryFoldArithmetic(subtree, left, right);\\n\\n      case Token.LT:\\n      case Token.GT:\\n      case Token.LE:\\n      case Token.GE:\\n      case Token.EQ:\\n      case Token.NE:\\n      case Token.SHEQ:\\n      case Token.SHNE:\\n        return tryFoldComparison(subtree, left, right);\\n\\n      default:\\n        return subtree;\\n    }\\n  }\", \"javadoc_start_line\": 88, \"annotations_start_line\": 88, \"method_start_line\": 88, \"end_line\": 149}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeFoldConstants.java\", \"method_name\": \"tryFoldShift\", \"content\": \"  \/**\\n   * Try to fold shift operations\\n   *\/\\n  private Node tryFoldShift(Node n, Node left, Node right) {\\n    if (left.getType() == Token.NUMBER &&\\n        right.getType() == Token.NUMBER) {\\n\\n      double result;\\n      double lval = left.getDouble();\\n      double rval = right.getDouble();\\n\\n      \/\/ check ranges.  We do not do anything that would clip the double to\\n      \/\/ a 32-bit range, since the user likely does not intend that.\\n      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\\n        return n;\\n      }\\n\\n      \/\/ only the lower 5 bits are used when shifting, so don't do anything\\n      \/\/ if the shift amount is outside [0,32)\\n      if (!(rval >= 0 && rval < 32)) {\\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\\n        return n;\\n      }\\n\\n      \/\/ Convert the numbers to ints\\n      int lvalInt = (int) lval;\\n      if (lvalInt != lval) {\\n        error(FRACTIONAL_BITWISE_OPERAND, left);\\n        return n;\\n      }\\n\\n      int rvalInt = (int) rval;\\n      if (rvalInt != rval) {\\n        error(FRACTIONAL_BITWISE_OPERAND, right);\\n        return n;\\n      }\\n\\n      switch (n.getType()) {\\n        case Token.LSH:\\n          result = lvalInt << rvalInt;\\n          break;\\n        case Token.RSH:\\n          result = lvalInt >> rvalInt;\\n          break;\\n        case Token.URSH:\\n          \/\/ JavaScript handles zero shifts on signed numbers differently than\\n          \/\/ Java as an Java int can not represent the unsigned 32-bit number\\n          \/\/ where JavaScript can so use a long here.\\n          result = lvalInt >>> rvalInt;\\n          break;\\n        default:\\n          throw new AssertionError(\\\"Unknown shift operator: \\\" +\\n              Node.tokenToName(n.getType()));\\n      }\\n\\n      Node newNumber = Node.newNumber(result);\\n      n.getParent().replaceChild(n, newNumber);\\n      reportCodeChange();\\n\\n      return newNumber;\\n    }\\n\\n    return n;\\n  }\", \"javadoc_start_line\": 649, \"annotations_start_line\": 652, \"method_start_line\": 652, \"end_line\": 713}"}]},{"name":"Closure","version":98,"tour_id":1,"test":"{\"className\": \" com.google.javascript.jscomp.InlineVariablesTest\", \"methodName\": \"testNoInlineAliasesInLoop\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"isAssignedOnceInLifetime\", \"content\": \"    \/**\\n     * @return Whether the variable is only assigned a value once for its\\n     *     lifetime.\\n     *\/\\n    boolean isAssignedOnceInLifetime() {\\n      Reference ref = getOneAndOnlyAssignment();\\n      if (ref == null) {\\n        return false;\\n      }\\n\\n      \/\/ Make sure this assignment is not in a loop.\\n\\n      return true;\\n    }\", \"javadoc_start_line\": 350, \"annotations_start_line\": 354, \"method_start_line\": 354, \"end_line\": 363}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/InlineVariables.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\\n        compiler, new InliningBehavior(), getFilterForMode());\\n    callback.process(externs, root);\\n  }\", \"javadoc_start_line\": 84, \"annotations_start_line\": 83, \"method_start_line\": 84, \"end_line\": 88}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Convenience method for running this pass over a tree with this\\n   * class as a callback.\\n   *\/\\n  public void process(Node externs, Node root) {\\n    NodeTraversal.traverse(compiler, root, this);\\n  }\", \"javadoc_start_line\": 95, \"annotations_start_line\": 99, \"method_start_line\": 99, \"end_line\": 101}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a node recursively.\\n   *\/\\n  public static void traverse(\\n      AbstractCompiler compiler, Node root, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverse(root);\\n  }\", \"javadoc_start_line\": 420, \"annotations_start_line\": 423, \"method_start_line\": 424, \"end_line\": 427}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 245, \"annotations_start_line\": 248, \"method_start_line\": 248, \"end_line\": 258}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"popScope\", \"content\": \"  \/** Pops back to the previous scope (e.g. when leaving a function). *\/\\n  private void popScope() {\\n    if (scopeCallback != null) {\\n      scopeCallback.exitScope(this);\\n    }\\n    if (scopeRoots.isEmpty()) {\\n      scopes.pop();\\n    } else {\\n      scopeRoots.pop();\\n    }\\n    cfgs.pop();\\n  }\", \"javadoc_start_line\": 554, \"annotations_start_line\": 555, \"method_start_line\": 555, \"end_line\": 565}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"exitScope\", \"content\": \"  \/**\\n   * Updates block statck and invokes any additional behavior.\\n   *\/\\n  public void exitScope(NodeTraversal t) {\\n    blockStack.pop();\\n    behavior.afterExitScope(t, referenceMap);\\n  }\", \"javadoc_start_line\": 137, \"annotations_start_line\": 140, \"method_start_line\": 140, \"end_line\": 143}"}]},{"name":"Closure","version":108,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.ScopedAliasesTest\", \"methodName\": \"testIssue1144\", \"error\": \"java.lang.IllegalStateException\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ScopedAliases.java\", \"method_name\": \"visit\", \"content\": \"    public void visit(NodeTraversal t, Node n, Node parent) {\\n      if (isCallToScopeMethod(n)) {\\n        validateScopeCall(t, n, n.getParent());\\n      }\\n\\n      if (t.getScopeDepth() < 2) {\\n        return;\\n      }\\n\\n      int type = n.getType();\\n      Var aliasVar = null;\\n      if (type == Token.NAME) {\\n        String name = n.getString();\\n        Var lexicalVar = t.getScope().getVar(n.getString());\\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\\n          aliasVar = lexicalVar;\\n        }\\n      }\\n\\n      \/\/ Validate the top-level of the goog.scope block.\\n      if (t.getScopeDepth() == 2) {\\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\\n          if (aliasVar.getNode() == n) {\\n            aliasDefinitionsInOrder.add(n);\\n\\n            \/\/ Return early, to ensure that we don't record a definition\\n            \/\/ twice.\\n            return;\\n          } else {\\n            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\\n          }\\n        }\\n\\n        if (type == Token.RETURN) {\\n          report(t, n, GOOG_SCOPE_USES_RETURN);\\n        } else if (type == Token.THIS) {\\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\\n        } else if (type == Token.THROW) {\\n          report(t, n, GOOG_SCOPE_USES_THROW);\\n        }\\n      }\\n\\n      \/\/ Validate all descendent scopes of the goog.scope block.\\n      if (t.getScopeDepth() >= 2) {\\n        \/\/ Check if this name points to an alias.\\n        if (aliasVar != null) {\\n          \/\/ Note, to support the transitive case, it's important we don't\\n          \/\/ clone aliasedNode here.  For example,\\n          \/\/ var g = goog; var d = g.dom; d.createElement('DIV');\\n          \/\/ The node in aliasedNode (which is \\\"g\\\") will be replaced in the\\n          \/\/ changes pass above with \\\"goog\\\".  If we cloned here, we'd end up\\n          \/\/ with <code>g.dom.createElement('DIV')<\/code>.\\n          aliasUsages.add(new AliasedNode(aliasVar, n));\\n        }\\n\\n        \/\/ When we inject declarations, we duplicate jsdoc. Make sure\\n        \/\/ we only process that jsdoc once.\\n        JSDocInfo info = n.getJSDocInfo();\\n        if (info != null) {\\n          for (Node node : info.getTypeNodes()) {\\n            fixTypeNode(node);\\n          }\\n        }\\n\\n        \/\/ TODO(robbyw): Error for goog.scope not at root.\\n      }\\n    }\", \"javadoc_start_line\": 523, \"annotations_start_line\": 522, \"method_start_line\": 523, \"end_line\": 589}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ScopedAliases.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    hotSwapScript(root, null);\\n  }\", \"javadoc_start_line\": 127, \"annotations_start_line\": 126, \"method_start_line\": 127, \"end_line\": 129}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ScopedAliases.java\", \"method_name\": \"hotSwapScript\", \"content\": \"  public void hotSwapScript(Node root, Node originalRoot) {\\n    Traversal traversal = new Traversal();\\n    NodeTraversal.traverse(compiler, root, traversal);\\n\\n    if (!traversal.hasErrors()) {\\n\\n      \/\/ Apply the aliases.\\n      List<AliasUsage> aliasWorkQueue =\\n          Lists.newArrayList(traversal.getAliasUsages());\\n      while (!aliasWorkQueue.isEmpty()) {\\n        List<AliasUsage> newQueue = Lists.newArrayList();\\n        for (AliasUsage aliasUsage : aliasWorkQueue) {\\n          if (aliasUsage.referencesOtherAlias()) {\\n            newQueue.add(aliasUsage);\\n          } else {\\n            aliasUsage.applyAlias();\\n          }\\n        }\\n\\n        \/\/ Prevent an infinite loop.\\n        if (newQueue.size() == aliasWorkQueue.size()) {\\n          Var cycleVar = newQueue.get(0).aliasVar;\\n          compiler.report(JSError.make(\\n              cycleVar.getNode(), GOOG_SCOPE_ALIAS_CYCLE, cycleVar.getName()));\\n          break;\\n        } else {\\n          aliasWorkQueue = newQueue;\\n        }\\n      }\\n\\n      \/\/ Remove the alias definitions.\\n      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {\\n        if (aliasDefinition.getParent().isVar() &&\\n            aliasDefinition.getParent().hasOneChild()) {\\n          aliasDefinition.getParent().detachFromParent();\\n        } else {\\n          aliasDefinition.detachFromParent();\\n        }\\n      }\\n\\n      \/\/ Collapse the scopes.\\n      for (Node scopeCall : traversal.getScopeCalls()) {\\n        Node expressionWithScopeCall = scopeCall.getParent();\\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\\n        scopeClosureBlock.detachFromParent();\\n        expressionWithScopeCall.getParent().replaceChild(\\n            expressionWithScopeCall,\\n            scopeClosureBlock);\\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\\n      }\\n\\n      if (traversal.getAliasUsages().size() > 0 ||\\n          traversal.getAliasDefinitionsInOrder().size() > 0 ||\\n          traversal.getScopeCalls().size() > 0) {\\n        compiler.reportCodeChange();\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 132, \"annotations_start_line\": 131, \"method_start_line\": 132, \"end_line\": 189}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a node recursively.\\n   *\/\\n  public static void traverse(\\n      AbstractCompiler compiler, Node root, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverse(root);\\n  }\", \"javadoc_start_line\": 488, \"annotations_start_line\": 491, \"method_start_line\": 492, \"end_line\": 495}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      inputId = NodeUtil.getInputId(root);\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      \/\/ null parent ensures that the shallow callbacks will traverse root\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 277, \"annotations_start_line\": 280, \"method_start_line\": 280, \"end_line\": 292}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 512, \"annotations_start_line\": 515, \"method_start_line\": 515, \"end_line\": 541}"}]},{"name":"Closure","version":109,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.parsing.JsDocInfoParserTest\", \"methodName\": \"testStructuralConstructor2\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"extra warning: Bad type annotation. type not recognized due to syntax error\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseContextTypeExpression\", \"content\": \"  \/**\\n   * ContextTypeExpression := BasicTypeExpression | '?'\\n   * For expressions on the right hand side of a this: or new:\\n   *\/\\n  private Node parseContextTypeExpression(JsDocToken token) {\\n          return parseTypeName(token);\\n  }\", \"javadoc_start_line\": 1903, \"annotations_start_line\": 1907, \"method_start_line\": 1907, \"end_line\": 1909}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parse\", \"content\": \"  \/**\\n   * Parses a {@link JSDocInfo} object. This parsing method reads all tokens\\n   * returned by the {@link JsDocTokenStream#getJsDocToken()} method until the\\n   * {@link JsDocToken#EOC} is returned.\\n   *\\n   * @return {@code true} if JSDoc information was correctly parsed,\\n   *     {@code false} otherwise\\n   *\/\\n  boolean parse() {\\n    state = State.SEARCHING_ANNOTATION;\\n    skipEOLs();\\n\\n    JsDocToken token = next();\\n\\n    \/\/ Always record that we have a comment.\\n    if (jsdocBuilder.shouldParseDocumentation()) {\\n      ExtractionInfo blockInfo = extractBlockComment(token);\\n      token = blockInfo.token;\\n      if (!blockInfo.string.isEmpty()) {\\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\\n      }\\n    } else {\\n      if (token != JsDocToken.ANNOTATION &&\\n          token != JsDocToken.EOC) {\\n        \/\/ Mark that there was a description, but don't bother marking\\n        \/\/ what it was.\\n        jsdocBuilder.recordBlockDescription(\\\"\\\");\\n      }\\n    }\\n\\n    return parseHelperLoop(token, Lists.<ExtendedTypeInfo>newArrayList());\\n  }\", \"javadoc_start_line\": 208, \"annotations_start_line\": 216, \"method_start_line\": 216, \"end_line\": 239}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseHelperLoop\", \"content\": \"  private boolean parseHelperLoop(JsDocToken token,\\n                                  List<ExtendedTypeInfo> extendedTypes) {\\n    while (true) {\\n      switch (token) {\\n        case ANNOTATION:\\n          if (state == State.SEARCHING_ANNOTATION) {\\n            state = State.SEARCHING_NEWLINE;\\n            token = parseAnnotation(token, extendedTypes);\\n          } else {\\n            token = next();\\n          }\\n          break;\\n\\n        case EOC:\\n          if (hasParsedFileOverviewDocInfo()) {\\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\\n          }\\n          checkExtendedTypes(extendedTypes);\\n          return true;\\n\\n        case EOF:\\n          \/\/ discard any accumulated information\\n          jsdocBuilder.build(null);\\n          parser.addParserWarning(\\\"msg.unexpected.eof\\\",\\n              stream.getLineno(), stream.getCharno());\\n          checkExtendedTypes(extendedTypes);\\n          return false;\\n\\n        case EOL:\\n          if (state == State.SEARCHING_NEWLINE) {\\n            state = State.SEARCHING_ANNOTATION;\\n          }\\n          token = next();\\n          break;\\n\\n        default:\\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\\n            token = next();\\n          } else {\\n            state = State.SEARCHING_NEWLINE;\\n            token = eatTokensUntilEOL();\\n          }\\n          break;\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 241, \"annotations_start_line\": 241, \"method_start_line\": 242, \"end_line\": 286}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseAnnotation\", \"content\": \"  private JsDocToken parseAnnotation(JsDocToken token,\\n      List<ExtendedTypeInfo> extendedTypes) {\\n    \/\/ JSTypes are represented as Rhino AST nodes, and then resolved later.\\n    JSTypeExpression type;\\n    int lineno = stream.getLineno();\\n    int charno = stream.getCharno();\\n\\n    String annotationName = stream.getString();\\n    Annotation annotation = annotationNames.get(annotationName);\\n    if (annotation == null) {\\n      parser.addParserWarning(\\\"msg.bad.jsdoc.tag\\\", annotationName,\\n          stream.getLineno(), stream.getCharno());\\n    } else {\\n      \/\/ Mark the beginning of the annotation.\\n      jsdocBuilder.markAnnotation(annotationName, lineno, charno);\\n\\n      switch (annotation) {\\n        case NG_INJECT:\\n          if (jsdocBuilder.isNgInjectRecorded()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.nginject.extra\\\",\\n              stream.getLineno(), stream.getCharno());\\n          } else {\\n            jsdocBuilder.recordNgInject(true);\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case JAGGER_INJECT:\\n          if (jsdocBuilder.isJaggerInjectRecorded()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.jaggerInject.extra\\\",\\n              stream.getLineno(), stream.getCharno());\\n          } else {\\n            jsdocBuilder.recordJaggerInject(true);\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case JAGGER_MODULE:\\n          if (jsdocBuilder.isJaggerModuleRecorded()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.jaggerModule.extra\\\",\\n              stream.getLineno(), stream.getCharno());\\n          } else {\\n            jsdocBuilder.recordJaggerModule(true);\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case JAGGER_PROVIDE:\\n          if (jsdocBuilder.isJaggerProvideRecorded()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.jaggerProvide.extra\\\",\\n              stream.getLineno(), stream.getCharno());\\n          } else {\\n            jsdocBuilder.recordJaggerProvide(true);\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case AUTHOR:\\n          if (jsdocBuilder.shouldParseDocumentation()) {\\n            ExtractionInfo authorInfo = extractSingleLineBlock();\\n            String author = authorInfo.string;\\n\\n            if (author.length() == 0) {\\n              parser.addParserWarning(\\\"msg.jsdoc.authormissing\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            } else {\\n              jsdocBuilder.addAuthor(author);\\n            }\\n            token = authorInfo.token;\\n          } else {\\n            token = eatUntilEOLIfNotAnnotation();\\n          }\\n          return token;\\n\\n        case CONSISTENTIDGENERATOR:\\n          if (!jsdocBuilder.recordConsistentIdGenerator()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.consistidgen\\\",\\n              stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case STRUCT:\\n          if (!jsdocBuilder.recordStruct()) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                                  stream.getLineno(),\\n                                  stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case DICT:\\n          if (!jsdocBuilder.recordDict()) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                                  stream.getLineno(),\\n                                  stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case CONSTRUCTOR:\\n          if (!jsdocBuilder.recordConstructor()) {\\n            if (jsdocBuilder.isInterfaceRecorded()) {\\n              parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            } else {\\n              parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            }\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case DEPRECATED:\\n          if (!jsdocBuilder.recordDeprecated()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.deprecated\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n\\n          \/\/ Find the reason\/description, if any.\\n          ExtractionInfo reasonInfo =\\n              extractMultilineTextualBlock(token);\\n\\n          String reason = reasonInfo.string;\\n\\n          if (reason.length() > 0) {\\n            jsdocBuilder.recordDeprecationReason(reason);\\n          }\\n\\n          token = reasonInfo.token;\\n          return token;\\n\\n        case INTERFACE:\\n          if (!jsdocBuilder.recordInterface()) {\\n            if (jsdocBuilder.isConstructorRecorded()) {\\n              parser.addTypeWarning(\\\"msg.jsdoc.interface.constructor\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            } else {\\n              parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            }\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case DESC:\\n          if (jsdocBuilder.isDescriptionRecorded()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.desc.extra\\\",\\n                stream.getLineno(), stream.getCharno());\\n            return eatUntilEOLIfNotAnnotation();\\n          } else {\\n            ExtractionInfo descriptionInfo =\\n                extractMultilineTextualBlock(token);\\n\\n            String description = descriptionInfo.string;\\n\\n            jsdocBuilder.recordDescription(description);\\n            token = descriptionInfo.token;\\n            return token;\\n          }\\n\\n        case FILE_OVERVIEW:\\n          String fileOverview = \\\"\\\";\\n          if (jsdocBuilder.shouldParseDocumentation()) {\\n            ExtractionInfo fileOverviewInfo =\\n                extractMultilineTextualBlock(token,\\n                    WhitespaceOption.TRIM);\\n\\n            fileOverview = fileOverviewInfo.string;\\n\\n            token = fileOverviewInfo.token;\\n          } else {\\n            token = eatTokensUntilEOL(token);\\n          }\\n\\n          if (!jsdocBuilder.recordFileOverview(fileOverview)) {\\n            parser.addParserWarning(\\\"msg.jsdoc.fileoverview.extra\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return token;\\n\\n        case LICENSE:\\n        case PRESERVE:\\n          ExtractionInfo preserveInfo =\\n              extractMultilineTextualBlock(token,\\n                                           WhitespaceOption.PRESERVE);\\n\\n          String preserve = preserveInfo.string;\\n\\n          if (preserve.length() > 0) {\\n            if (fileLevelJsDocBuilder != null) {\\n              fileLevelJsDocBuilder.append(preserve);\\n            }\\n          }\\n\\n          token = preserveInfo.token;\\n          return token;\\n\\n        case ENUM:\\n          token = next();\\n          lineno = stream.getLineno();\\n          charno = stream.getCharno();\\n\\n          type = null;\\n          if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\\n            type = createJSTypeExpression(\\n                parseAndRecordTypeNode(token));\\n          }\\n\\n          if (type == null) {\\n            type = createJSTypeExpression(newStringNode(\\\"number\\\"));\\n          }\\n          if (!jsdocBuilder.recordEnumParameterType(type)) {\\n            parser.addTypeWarning(\\n                \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n          }\\n          token = eatUntilEOLIfNotAnnotation(token);\\n          return token;\\n\\n        case EXPORT:\\n          if (!jsdocBuilder.recordExport()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.export\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case EXPOSE:\\n          if (!jsdocBuilder.recordExpose()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.expose\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case EXTERNS:\\n          if (!jsdocBuilder.recordExterns()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.externs\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case JAVA_DISPATCH:\\n          if (!jsdocBuilder.recordJavaDispatch()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.javadispatch\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case EXTENDS:\\n        case IMPLEMENTS:\\n          skipEOLs();\\n          token = next();\\n          lineno = stream.getLineno();\\n          charno = stream.getCharno();\\n          boolean matchingRc = false;\\n\\n          if (token == JsDocToken.LC) {\\n            token = next();\\n            matchingRc = true;\\n          }\\n\\n          if (token == JsDocToken.STRING) {\\n            Node typeNode = parseAndRecordTypeNameNode(\\n                token, lineno, charno, matchingRc);\\n\\n            lineno = stream.getLineno();\\n            charno = stream.getCharno();\\n\\n            typeNode = wrapNode(Token.BANG, typeNode);\\n            type = createJSTypeExpression(typeNode);\\n\\n            if (annotation == Annotation.EXTENDS) {\\n              \/\/ record the extended type, check later\\n              extendedTypes.add(new ExtendedTypeInfo(\\n                  type, stream.getLineno(), stream.getCharno()));\\n            } else {\\n              Preconditions.checkState(\\n                  annotation == Annotation.IMPLEMENTS);\\n              if (!jsdocBuilder.recordImplementedInterface(type)) {\\n                parser.addTypeWarning(\\\"msg.jsdoc.implements.duplicate\\\",\\n                    lineno, charno);\\n              }\\n            }\\n            token = next();\\n            if (matchingRc) {\\n              if (token != JsDocToken.RC) {\\n                parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\",\\n                    stream.getLineno(), stream.getCharno());\\n              } else {\\n                token = next();\\n              }\\n            } else if (token != JsDocToken.EOL &&\\n                token != JsDocToken.EOF && token != JsDocToken.EOC) {\\n              parser.addTypeWarning(\\\"msg.end.annotation.expected\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            }\\n          } else {\\n            parser.addTypeWarning(\\\"msg.no.type.name\\\", lineno, charno);\\n          }\\n          token = eatUntilEOLIfNotAnnotation(token);\\n          return token;\\n\\n        case HIDDEN:\\n          if (!jsdocBuilder.recordHiddenness()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.hidden\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case LENDS:\\n          skipEOLs();\\n\\n          matchingRc = false;\\n          if (match(JsDocToken.LC)) {\\n            token = next();\\n            matchingRc = true;\\n          }\\n\\n          if (match(JsDocToken.STRING)) {\\n            token = next();\\n            if (!jsdocBuilder.recordLends(stream.getString())) {\\n              parser.addTypeWarning(\\\"msg.jsdoc.lends.incompatible\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            }\\n          } else {\\n            parser.addTypeWarning(\\\"msg.jsdoc.lends.missing\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n\\n          if (matchingRc && !match(JsDocToken.RC)) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.missing.rc\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case MEANING:\\n          ExtractionInfo meaningInfo =\\n              extractMultilineTextualBlock(token);\\n          String meaning = meaningInfo.string;\\n          token = meaningInfo.token;\\n          if (!jsdocBuilder.recordMeaning(meaning)) {\\n            parser.addParserWarning(\\\"msg.jsdoc.meaning.extra\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return token;\\n\\n        case NO_ALIAS:\\n          if (!jsdocBuilder.recordNoAlias()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.noalias\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case NO_COMPILE:\\n          if (!jsdocBuilder.recordNoCompile()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.nocompile\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case NO_TYPE_CHECK:\\n          if (!jsdocBuilder.recordNoTypeCheck()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.nocheck\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case NOT_IMPLEMENTED:\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case INHERIT_DOC:\\n        case OVERRIDE:\\n          if (!jsdocBuilder.recordOverride()) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.override\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case THROWS: {\\n          skipEOLs();\\n          token = next();\\n          lineno = stream.getLineno();\\n          charno = stream.getCharno();\\n          type = null;\\n\\n          if (token == JsDocToken.LC) {\\n            type = createJSTypeExpression(\\n                parseAndRecordTypeNode(token));\\n\\n            if (type == null) {\\n              \/\/ parsing error reported during recursive descent\\n              \/\/ recovering parsing\\n              return eatUntilEOLIfNotAnnotation();\\n            }\\n          }\\n\\n          \/\/ *Update* the token to that after the type annotation.\\n          token = current();\\n\\n          \/\/ Save the throw type.\\n          jsdocBuilder.recordThrowType(type);\\n\\n          boolean isAnnotationNext = lookAheadForAnnotation();\\n\\n          \/\/ Find the throw's description (if applicable).\\n          if (jsdocBuilder.shouldParseDocumentation() && !isAnnotationNext) {\\n            ExtractionInfo descriptionInfo =\\n                extractMultilineTextualBlock(token);\\n\\n            String description = descriptionInfo.string;\\n\\n            if (description.length() > 0) {\\n              jsdocBuilder.recordThrowDescription(type, description);\\n            }\\n\\n            token = descriptionInfo.token;\\n          } else {\\n            token = eatUntilEOLIfNotAnnotation();\\n          }\\n          return token;\\n        }\\n\\n        case PARAM:\\n          skipEOLs();\\n          token = next();\\n          lineno = stream.getLineno();\\n          charno = stream.getCharno();\\n          type = null;\\n\\n          if (token == JsDocToken.LC) {\\n            type = createJSTypeExpression(\\n                parseAndRecordParamTypeNode(token));\\n\\n            if (type == null) {\\n              \/\/ parsing error reported during recursive descent\\n              \/\/ recovering parsing\\n              return eatUntilEOLIfNotAnnotation();\\n            }\\n            skipEOLs();\\n            token = next();\\n            lineno = stream.getLineno();\\n            charno = stream.getCharno();\\n          }\\n\\n          String name = null;\\n          boolean isBracketedParam = JsDocToken.LB == token;\\n          if (isBracketedParam) {\\n            token = next();\\n          }\\n\\n          if (JsDocToken.STRING != token) {\\n            parser.addTypeWarning(\\\"msg.missing.variable.name\\\",\\n                lineno, charno);\\n          } else {\\n            name = stream.getString();\\n\\n            if (isBracketedParam) {\\n              token = next();\\n\\n              \/\/ Throw out JsDocToolkit's \\\"default\\\" parameter\\n              \/\/ annotation.  It makes no sense under our type\\n              \/\/ system.\\n              if (JsDocToken.EQUALS == token) {\\n                token = next();\\n                if (JsDocToken.STRING == token) {\\n                  token = next();\\n                }\\n              }\\n\\n              if (JsDocToken.RB != token) {\\n                reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rb\\\");\\n              } else if (type != null) {\\n                \/\/ Make the type expression optional, if it isn't\\n                \/\/ already.\\n                type = JSTypeExpression.makeOptionalArg(type);\\n              }\\n            }\\n\\n            \/\/ If the param name has a DOT in it, just throw it out\\n            \/\/ quietly. We do not handle the JsDocToolkit method\\n            \/\/ for handling properties of params.\\n            if (name.indexOf('.') > -1) {\\n              name = null;\\n            } else if (!jsdocBuilder.recordParameter(name, type)) {\\n              if (jsdocBuilder.hasParameter(name)) {\\n                parser.addTypeWarning(\\\"msg.dup.variable.name\\\", name,\\n                    lineno, charno);\\n              } else {\\n                parser.addTypeWarning(\\\"msg.jsdoc.incompat.type\\\", name,\\n                    lineno, charno);\\n              }\\n            }\\n          }\\n\\n          if (name == null) {\\n            token = eatUntilEOLIfNotAnnotation(token);\\n            return token;\\n          }\\n\\n          jsdocBuilder.markName(name, sourceFile, lineno, charno);\\n\\n          \/\/ Find the parameter's description (if applicable).\\n          if (jsdocBuilder.shouldParseDocumentation()\\n              && token != JsDocToken.ANNOTATION) {\\n            ExtractionInfo paramDescriptionInfo =\\n                extractMultilineTextualBlock(token);\\n\\n            String paramDescription = paramDescriptionInfo.string;\\n\\n            if (paramDescription.length() > 0) {\\n              jsdocBuilder.recordParameterDescription(name,\\n                  paramDescription);\\n            }\\n\\n            token = paramDescriptionInfo.token;\\n          } else if (token != JsDocToken.EOC && token != JsDocToken.EOF) {\\n            token = eatUntilEOLIfNotAnnotation();\\n          }\\n          return token;\\n\\n        case PRESERVE_TRY:\\n          if (!jsdocBuilder.recordPreserveTry()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.preservertry\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case NO_SHADOW:\\n          if (!jsdocBuilder.recordNoShadow()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.noshadow\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case NO_SIDE_EFFECTS:\\n          if (!jsdocBuilder.recordNoSideEffects()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.nosideeffects\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case MODIFIES:\\n          token = parseModifiesTag(next());\\n          return token;\\n\\n        case IMPLICIT_CAST:\\n          if (!jsdocBuilder.recordImplicitCast()) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.implicitcast\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case SEE:\\n          if (jsdocBuilder.shouldParseDocumentation()) {\\n            ExtractionInfo referenceInfo = extractSingleLineBlock();\\n            String reference = referenceInfo.string;\\n\\n            if (reference.length() == 0) {\\n              parser.addParserWarning(\\\"msg.jsdoc.seemissing\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            } else {\\n              jsdocBuilder.addReference(reference);\\n            }\\n\\n            token = referenceInfo.token;\\n          } else {\\n            token = eatUntilEOLIfNotAnnotation();\\n          }\\n          return token;\\n\\n        case STABLEIDGENERATOR:\\n          if (!jsdocBuilder.recordStableIdGenerator()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.stableidgen\\\",\\n              stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case SUPPRESS:\\n          token = parseSuppressTag(next());\\n          return token;\\n\\n        case TEMPLATE: {\\n          ExtractionInfo templateInfo = extractSingleLineBlock();\\n          List<String> names = Lists.newArrayList(\\n              Splitter.on(',')\\n                  .trimResults()\\n                  .split(templateInfo.string));\\n\\n          if (names.size() == 0 || names.get(0).length() == 0) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.templatemissing\\\",\\n                  stream.getLineno(), stream.getCharno());\\n          } else if (!jsdocBuilder.recordTemplateTypeNames(names)) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.template.at.most.once\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n\\n          token = templateInfo.token;\\n          return token;\\n        }\\n\\n        case IDGENERATOR:\\n          token = parseIdGeneratorTag(next());\\n          return token;\\n\\n        case WIZACTION:\\n          if (!jsdocBuilder.recordWizaction()) {\\n            parser.addParserWarning(\\\"msg.jsdoc.wizaction\\\",\\n              stream.getLineno(), stream.getCharno());\\n          }\\n          return eatUntilEOLIfNotAnnotation();\\n\\n        case DISPOSES: {\\n          ExtractionInfo templateInfo = extractSingleLineBlock();\\n          List<String> names = Lists.newArrayList(\\n              Splitter.on(',')\\n                  .trimResults()\\n                  .split(templateInfo.string));\\n\\n          if (names.size() == 0 || names.get(0).length() == 0) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.disposeparameter.missing\\\",\\n                  stream.getLineno(), stream.getCharno());\\n          } else if (!jsdocBuilder.recordDisposesParameter(names)) {\\n            parser.addTypeWarning(\\\"msg.jsdoc.disposeparameter.error\\\",\\n                stream.getLineno(), stream.getCharno());\\n          }\\n\\n          token = templateInfo.token;\\n          return token;\\n        }\\n\\n        case VERSION:\\n          ExtractionInfo versionInfo = extractSingleLineBlock();\\n          String version = versionInfo.string;\\n\\n          if (version.length() == 0) {\\n            parser.addParserWarning(\\\"msg.jsdoc.versionmissing\\\",\\n                  stream.getLineno(), stream.getCharno());\\n          } else {\\n            if (!jsdocBuilder.recordVersion(version)) {\\n               parser.addParserWarning(\\\"msg.jsdoc.extraversion\\\",\\n                  stream.getLineno(), stream.getCharno());\\n            }\\n          }\\n\\n          token = versionInfo.token;\\n          return token;\\n\\n        case CONSTANT:\\n        case DEFINE:\\n        case RETURN:\\n        case PRIVATE:\\n        case PROTECTED:\\n        case PUBLIC:\\n        case THIS:\\n        case TYPE:\\n        case TYPEDEF:\\n          lineno = stream.getLineno();\\n          charno = stream.getCharno();\\n\\n          Node typeNode = null;\\n          boolean hasType = lookAheadForType();\\n          boolean isAlternateTypeAnnotation =\\n              (annotation == Annotation.PRIVATE ||\\n               annotation == Annotation.PROTECTED ||\\n               annotation == Annotation.PUBLIC ||\\n               annotation == Annotation.CONSTANT);\\n          boolean canSkipTypeAnnotation =\\n              (isAlternateTypeAnnotation ||\\n               annotation == Annotation.RETURN);\\n          type = null;\\n          if (hasType || !canSkipTypeAnnotation) {\\n            skipEOLs();\\n            token = next();\\n            typeNode = parseAndRecordTypeNode(token);\\n\\n            if (annotation == Annotation.THIS) {\\n              typeNode = wrapNode(Token.BANG, typeNode);\\n            }\\n            type = createJSTypeExpression(typeNode);\\n          }\\n\\n          \/\/ The error was reported during recursive descent\\n          \/\/ recovering parsing\\n          boolean hasError = type == null && !canSkipTypeAnnotation;\\n          if (!hasError) {\\n            \/\/ Record types for @type.\\n            \/\/ If the @private, @protected, or @public annotations\\n            \/\/ have a type attached, pretend that they actually wrote:\\n            \/\/ @type {type}\\\\n@private\\n            \/\/ This will have some weird behavior in some cases\\n            \/\/ (for example, @private can now be used as a type-cast),\\n            \/\/ but should be mostly OK.\\n            if ((type != null && isAlternateTypeAnnotation)\\n                || annotation == Annotation.TYPE) {\\n              if (!jsdocBuilder.recordType(type)) {\\n                parser.addTypeWarning(\\n                    \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n              }\\n            }\\n\\n            switch (annotation) {\\n              case CONSTANT:\\n                if (!jsdocBuilder.recordConstancy()) {\\n                  parser.addParserWarning(\\\"msg.jsdoc.const\\\",\\n                      stream.getLineno(), stream.getCharno());\\n                }\\n                break;\\n\\n              case DEFINE:\\n                if (!jsdocBuilder.recordDefineType(type)) {\\n                  parser.addParserWarning(\\\"msg.jsdoc.define\\\",\\n                      lineno, charno);\\n                }\\n                return recordDescription(token);\\n\\n              case PRIVATE:\\n                if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\\n                  parser.addParserWarning(\\n                      \\\"msg.jsdoc.visibility.private\\\",\\n                      lineno, charno);\\n                }\\n                return recordDescription(token);\\n\\n              case PROTECTED:\\n                if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\\n                  parser.addParserWarning(\\n                      \\\"msg.jsdoc.visibility.protected\\\",\\n                      lineno, charno);\\n                }\\n                return recordDescription(token);\\n\\n              case PUBLIC:\\n                if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\\n                  parser.addParserWarning(\\n                      \\\"msg.jsdoc.visibility.public\\\",\\n                      lineno, charno);\\n                }\\n                return recordDescription(token);\\n\\n              case RETURN:\\n                if (type == null) {\\n                  type = createJSTypeExpression(newNode(Token.QMARK));\\n                }\\n\\n                if (!jsdocBuilder.recordReturnType(type)) {\\n                  parser.addTypeWarning(\\n                      \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                  break;\\n                }\\n\\n                \/\/ TODO(johnlenz): The extractMultilineTextualBlock method\\n                \/\/ and friends look directly at the stream, regardless of\\n                \/\/ last token read, so we don't want to read the first\\n                \/\/ \\\"STRING\\\" out of the stream.\\n\\n                boolean isAnnotationNext = lookAheadForAnnotation();\\n\\n                \/\/ Find the return's description (if applicable).\\n                if (jsdocBuilder.shouldParseDocumentation()\\n                    && !isAnnotationNext) {\\n                  ExtractionInfo returnDescriptionInfo =\\n                      extractMultilineTextualBlock(token);\\n\\n                  String returnDescription =\\n                      returnDescriptionInfo.string;\\n\\n                  if (returnDescription.length() > 0) {\\n                    jsdocBuilder.recordReturnDescription(\\n                        returnDescription);\\n                  }\\n\\n                  token = returnDescriptionInfo.token;\\n                } else {\\n                  token = eatUntilEOLIfNotAnnotation();\\n                }\\n                return token;\\n\\n              case THIS:\\n                if (!jsdocBuilder.recordThisType(type)) {\\n                  parser.addTypeWarning(\\n                      \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                }\\n                break;\\n\\n              case TYPEDEF:\\n                if (!jsdocBuilder.recordTypedef(type)) {\\n                  parser.addTypeWarning(\\n                      \\\"msg.jsdoc.incompat.type\\\", lineno, charno);\\n                }\\n                break;\\n            }\\n          }\\n\\n          return eatUntilEOLIfNotAnnotation();\\n      }\\n    }\\n\\n    return next();\\n  }\", \"javadoc_start_line\": 288, \"annotations_start_line\": 288, \"method_start_line\": 289, \"end_line\": 1076}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseAndRecordTypeNode\", \"content\": \"  \/**\\n   * Looks for a type expression at the current token and if found,\\n   * returns it. Note that this method consumes input.\\n   *\\n   * @param token The current token.\\n   * @return The type expression found or null if none.\\n   *\/\\n  Node parseAndRecordTypeNode(JsDocToken token) {\\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\\n        token == JsDocToken.LC, false);\\n  }\", \"javadoc_start_line\": 1262, \"annotations_start_line\": 1269, \"method_start_line\": 1269, \"end_line\": 1272}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseAndRecordTypeNode\", \"content\": \"  \/**\\n   * Looks for a parameter type expression at the current token and if found,\\n   * returns it. Note that this method consumes input.\\n   *\\n   * @param token The current token.\\n   * @param lineno The line of the type expression.\\n   * @param startCharno The starting character position of the type expression.\\n   * @param matchingLC Whether the type expression starts with a \\\"{\\\".\\n   * @param onlyParseSimpleNames If true, only simple type names are parsed\\n   *     (via a call to parseTypeNameAnnotation instead of\\n   *     parseTypeExpressionAnnotation).\\n   * @return The type expression found or null if none.\\n   *\/\\n  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\\n                                      int startCharno,\\n                                      boolean matchingLC,\\n                                      boolean onlyParseSimpleNames) {\\n    Node typeNode = null;\\n\\n    if (onlyParseSimpleNames) {\\n      typeNode = parseTypeNameAnnotation(token);\\n    } else {\\n      typeNode = parseTypeExpressionAnnotation(token);\\n    }\\n\\n    recordTypeNode(lineno, startCharno, typeNode, matchingLC);\\n    return typeNode;\\n  }\", \"javadoc_start_line\": 1312, \"annotations_start_line\": 1325, \"method_start_line\": 1328, \"end_line\": 1339}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseTypeExpressionAnnotation\", \"content\": \"  \/**\\n   * TypeExpressionAnnotation := TypeExpression |\\n   *     '{' TopLevelTypeExpression '}'\\n   *\/\\n  private Node parseTypeExpressionAnnotation(JsDocToken token) {\\n    if (token == JsDocToken.LC) {\\n      skipEOLs();\\n      Node typeNode = parseTopLevelTypeExpression(next());\\n      if (typeNode != null) {\\n        skipEOLs();\\n        if (!match(JsDocToken.RC)) {\\n          reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rc\\\");\\n        } else {\\n          next();\\n        }\\n      }\\n\\n      return typeNode;\\n    } else {\\n      return parseTypeExpression(token);\\n    }\\n  }\", \"javadoc_start_line\": 1710, \"annotations_start_line\": 1714, \"method_start_line\": 1714, \"end_line\": 1731}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseTopLevelTypeExpression\", \"content\": \"  \/**\\n   * TopLevelTypeExpression := TypeExpression\\n   *     | TypeUnionList\\n   *\\n   * We made this rule up, for the sake of backwards compatibility.\\n   *\/\\n  private Node parseTopLevelTypeExpression(JsDocToken token) {\\n    Node typeExpr = parseTypeExpression(token);\\n    if (typeExpr != null) {\\n      \/\/ top-level unions are allowed\\n      if (match(JsDocToken.PIPE)) {\\n        next();\\n        if (match(JsDocToken.PIPE)) {\\n          \/\/ We support double pipes for backwards-compatibility.\\n          next();\\n        }\\n        skipEOLs();\\n        token = next();\\n        return parseUnionTypeWithAlternate(token, typeExpr);\\n      }\\n    }\\n    return typeExpr;\\n  }\", \"javadoc_start_line\": 1801, \"annotations_start_line\": 1807, \"method_start_line\": 1807, \"end_line\": 1823}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseTypeExpression\", \"content\": \"  \/**\\n   * TypeExpression := BasicTypeExpression\\n   *     | '?' BasicTypeExpression\\n   *     | '!' BasicTypeExpression\\n   *     | BasicTypeExpression '?'\\n   *     | BasicTypeExpression '!'\\n   *     | '?'\\n   *\/\\n  private Node parseTypeExpression(JsDocToken token) {\\n    if (token == JsDocToken.QMARK) {\\n      \/\/ A QMARK could mean that a type is nullable, or that it's unknown.\\n      \/\/ We use look-ahead 1 to determine whether it's unknown. Otherwise,\\n      \/\/ we assume it means nullable. There are 8 cases:\\n      \/\/ {?} - right curly\\n      \/\/ {?=} - equals\\n      \/\/ {function(?, number)} - comma\\n      \/\/ {function(number, ?)} - right paren\\n      \/\/ {function(number, ...[?])} - right bracket\\n      \/\/ {function(): ?|number} - pipe\\n      \/\/ {Array.<?>} - greater than\\n      \/\/ \/** ? *\/ - EOC (inline types)\\n      \/\/ I'm not a big fan of using look-ahead for this, but it makes\\n      \/\/ the type language a lot nicer.\\n      token = next();\\n      if (token == JsDocToken.COMMA ||\\n          token == JsDocToken.EQUALS ||\\n          token == JsDocToken.RB ||\\n          token == JsDocToken.RC ||\\n          token == JsDocToken.RP ||\\n          token == JsDocToken.PIPE ||\\n          token == JsDocToken.GT ||\\n          token == JsDocToken.EOC) {\\n        restoreLookAhead(token);\\n        return newNode(Token.QMARK);\\n      }\\n\\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\\n    } else if (token == JsDocToken.BANG) {\\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\\n    } else {\\n      Node basicTypeExpr = parseBasicTypeExpression(token);\\n      if (basicTypeExpr != null) {\\n        if (match(JsDocToken.QMARK)) {\\n          next();\\n          return wrapNode(Token.QMARK, basicTypeExpr);\\n        } else if (match(JsDocToken.BANG)) {\\n          next();\\n          return wrapNode(Token.BANG, basicTypeExpr);\\n        }\\n      }\\n\\n      return basicTypeExpr;\\n    }\\n  }\", \"javadoc_start_line\": 1848, \"annotations_start_line\": 1856, \"method_start_line\": 1856, \"end_line\": 1901}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseBasicTypeExpression\", \"content\": \"  \/**\\n   * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\\n   *     | FunctionType | UnionType | RecordType | ArrayType\\n   *\/\\n  private Node parseBasicTypeExpression(JsDocToken token) {\\n    if (token == JsDocToken.STAR) {\\n      return newNode(Token.STAR);\\n    } else if (token == JsDocToken.LB) {\\n      skipEOLs();\\n      return parseArrayType(next());\\n    } else if (token == JsDocToken.LC) {\\n      skipEOLs();\\n      return parseRecordType(next());\\n    } else if (token == JsDocToken.LP) {\\n      skipEOLs();\\n      return parseUnionType(next());\\n    } else if (token == JsDocToken.STRING) {\\n      String string = stream.getString();\\n      if (\\\"function\\\".equals(string)) {\\n        skipEOLs();\\n        return parseFunctionType(next());\\n      } else if (\\\"null\\\".equals(string) || \\\"undefined\\\".equals(string)) {\\n        return newStringNode(string);\\n      } else {\\n        return parseTypeName(token);\\n      }\\n    }\\n\\n    restoreLookAhead(token);\\n    return reportGenericTypeSyntaxWarning();\\n  }\", \"javadoc_start_line\": 1911, \"annotations_start_line\": 1915, \"method_start_line\": 1915, \"end_line\": 1941}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseFunctionType\", \"content\": \"  \/**\\n   * FunctionType := 'function' FunctionSignatureType\\n   * FunctionSignatureType :=\\n   *    TypeParameters '(' 'this' ':' TypeName, ParametersType ')' ResultType\\n   *\/\\n  private Node parseFunctionType(JsDocToken token) {\\n    \/\/ NOTE(nicksantos): We're not implementing generics at the moment, so\\n    \/\/ just throw out TypeParameters.\\n    if (token != JsDocToken.LP) {\\n      restoreLookAhead(token);\\n      return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.lp\\\");\\n    }\\n\\n    Node functionType = newNode(Token.FUNCTION);\\n    Node parameters = null;\\n    skipEOLs();\\n    if (!match(JsDocToken.RP)) {\\n      token = next();\\n\\n      boolean hasParams = true;\\n      if (token == JsDocToken.STRING) {\\n        String tokenStr = stream.getString();\\n        boolean isThis = \\\"this\\\".equals(tokenStr);\\n        boolean isNew = \\\"new\\\".equals(tokenStr);\\n        if (isThis || isNew) {\\n          if (match(JsDocToken.COLON)) {\\n            next();\\n            skipEOLs();\\n            Node contextType = wrapNode(\\n                isThis ? Token.THIS : Token.NEW,\\n                parseContextTypeExpression(next()));\\n            if (contextType == null) {\\n              return null;\\n            }\\n\\n            functionType.addChildToFront(contextType);\\n          } else {\\n            return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.colon\\\");\\n          }\\n\\n          if (match(JsDocToken.COMMA)) {\\n            next();\\n            skipEOLs();\\n            token = next();\\n          } else {\\n            hasParams = false;\\n          }\\n        }\\n      }\\n\\n      if (hasParams) {\\n        parameters = parseParametersType(token);\\n        if (parameters == null) {\\n          return null;\\n        }\\n      }\\n    }\\n\\n    if (parameters != null) {\\n      functionType.addChildToBack(parameters);\\n    }\\n\\n    skipEOLs();\\n    if (!match(JsDocToken.RP)) {\\n      return reportTypeSyntaxWarning(\\\"msg.jsdoc.missing.rp\\\");\\n    }\\n\\n    skipEOLs();\\n    Node resultType = parseResultType(next());\\n    if (resultType == null) {\\n      return null;\\n    } else {\\n      functionType.addChildToBack(resultType);\\n    }\\n    return functionType;\\n  }\", \"javadoc_start_line\": 1984, \"annotations_start_line\": 1989, \"method_start_line\": 1989, \"end_line\": 2059}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/JsDocInfoParser.java\", \"method_name\": \"parseContextTypeExpression\", \"content\": \"  \/**\\n   * ContextTypeExpression := BasicTypeExpression | '?'\\n   * For expressions on the right hand side of a this: or new:\\n   *\/\\n  private Node parseContextTypeExpression(JsDocToken token) {\\n          return parseTypeName(token);\\n  }\", \"javadoc_start_line\": 1903, \"annotations_start_line\": 1907, \"method_start_line\": 1907, \"end_line\": 1909}"}]},{"name":"Closure","version":120,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.InlineVariablesTest\", \"methodName\": \"testExternalIssue1053\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"isAssignedOnceInLifetime\", \"content\": \"    \/**\\n     * @return Whether the variable is only assigned a value once for its\\n     *     lifetime.\\n     *\/\\n    boolean isAssignedOnceInLifetime() {\\n      Reference ref = getOneAndOnlyAssignment();\\n      if (ref == null) {\\n        return false;\\n      }\\n\\n      \/\/ Make sure this assignment is not in a loop.\\n      for (BasicBlock block = ref.getBasicBlock();\\n           block != null; block = block.getParent()) {\\n        if (block.isFunction) {\\n          break;\\n        } else if (block.isLoop) {\\n          return false;\\n        }\\n      }\\n\\n      return true;\\n    }\", \"javadoc_start_line\": 417, \"annotations_start_line\": 421, \"method_start_line\": 421, \"end_line\": 438}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/InlineVariables.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\\n        compiler, new InliningBehavior(), getFilterForMode());\\n    callback.process(externs, root);\\n  }\", \"javadoc_start_line\": 83, \"annotations_start_line\": 82, \"method_start_line\": 83, \"end_line\": 87}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"process\", \"content\": \"  \/**\\n   * Convenience method for running this pass over a tree with this\\n   * class as a callback.\\n   *\/\\n  @Override\\n  public void process(Node externs, Node root) {\\n    NodeTraversal.traverseRoots(\\n        compiler, Lists.newArrayList(externs, root), this);\\n  }\", \"javadoc_start_line\": 104, \"annotations_start_line\": 108, \"method_start_line\": 109, \"end_line\": 112}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  \/**\\n   * Traverses a list of node trees.\\n   *\/\\n  public static void traverseRoots(\\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverseRoots(roots);\\n  }\", \"javadoc_start_line\": 497, \"annotations_start_line\": 500, \"method_start_line\": 501, \"end_line\": 504}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseRoots\", \"content\": \"  public void traverseRoots(List<Node> roots) {\\n    if (roots.isEmpty()) {\\n      return;\\n    }\\n\\n    try {\\n      Node scopeRoot = roots.get(0).getParent();\\n      Preconditions.checkState(scopeRoot != null);\\n\\n      inputId = NodeUtil.getInputId(scopeRoot);\\n      sourceName = \\\"\\\";\\n      curNode = scopeRoot;\\n      pushScope(scopeRoot);\\n\\n      for (Node root : roots) {\\n        Preconditions.checkState(root.getParent() == scopeRoot);\\n        traverseBranch(root, scopeRoot);\\n      }\\n\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 298, \"annotations_start_line\": 298, \"method_start_line\": 298, \"end_line\": 321}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"popScope\", \"content\": \"  \/** Pops back to the previous scope (e.g. when leaving a function). *\/\\n  private void popScope() {\\n    if (scopeCallback != null) {\\n      scopeCallback.exitScope(this);\\n    }\\n    if (scopeRoots.isEmpty()) {\\n      scopes.pop();\\n    } else {\\n      scopeRoots.pop();\\n    }\\n    cfgs.pop();\\n    if (hasScope()) {\\n      compiler.setScope(getScopeRoot());\\n    }\\n  }\", \"javadoc_start_line\": 615, \"annotations_start_line\": 616, \"method_start_line\": 616, \"end_line\": 629}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ReferenceCollectingCallback.java\", \"method_name\": \"exitScope\", \"content\": \"  \/**\\n   * Updates block stack and invokes any additional behavior.\\n   *\/\\n  @Override\\n  public void exitScope(NodeTraversal t) {\\n    blockStack.pop();\\n    if (t.getScope().isGlobal()) {\\n      \/\/ Update global scope reference lists when we are done with it.\\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\\n    } else {\\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\\n    }\\n  }\", \"javadoc_start_line\": 176, \"annotations_start_line\": 179, \"method_start_line\": 180, \"end_line\": 189}"}]},{"name":"Closure","version":122,"tour_id":1,"test":"{\"className\": \" com.google.javascript.jscomp.parsing.ParserTest\", \"methodName\": \"testSuspiciousBlockCommentWarning3\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"handleBlockComment\", \"content\": \"  \/**\\n   * Check to see if the given block comment looks like it should be JSDoc.\\n   *\/\\n  private void handleBlockComment(Comment comment) {\\n    if (comment.getValue().indexOf(\\\"\/* @\\\") != -1 || comment.getValue().indexOf(\\\"\\\\n * @\\\") != -1) {\\n      errorReporter.warning(\\n          SUSPICIOUS_COMMENT_WARNING,\\n          sourceName,\\n          comment.getLineno(), \\\"\\\", 0);\\n    }\\n  }\", \"javadoc_start_line\": 248, \"annotations_start_line\": 251, \"method_start_line\": 251, \"end_line\": 258}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/ParserRunner.java\", \"method_name\": \"parse\", \"content\": \"  \/**\\n   * Parses the JavaScript text given by a reader.\\n   *\\n   * @param sourceString Source code from the file.\\n   * @param errorReporter An error.\\n   * @param logger A logger.\\n   * @return The AST of the given text.\\n   * @throws IOException\\n   *\/\\n  public static ParseResult parse(StaticSourceFile sourceFile,\\n                                  String sourceString,\\n                                  Config config,\\n                                  ErrorReporter errorReporter,\\n                                  Logger logger) throws IOException {\\n    Context cx = Context.enter();\\n    cx.setErrorReporter(errorReporter);\\n    cx.setLanguageVersion(Context.VERSION_1_5);\\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\\n    compilerEnv.initFromContext(cx);\\n    compilerEnv.setRecordingComments(true);\\n    compilerEnv.setRecordingLocalJsDocComments(true);\\n\\n    \/\/ ES5 specifically allows trailing commas\\n    compilerEnv.setWarnTrailingComma(\\n        config.languageMode == LanguageMode.ECMASCRIPT3);\\n\\n    compilerEnv.setReservedKeywordAsIdentifier(true);\\n\\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\\n    compilerEnv.setIdeMode(config.isIdeMode);\\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\\n\\n    Parser p = new Parser(compilerEnv, errorReporter);\\n    AstRoot astRoot = null;\\n    try {\\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\\n    } catch (EvaluatorException e) {\\n      logger.info(\\n          \\\"Error parsing \\\" + sourceFile.getName() + \\\": \\\" + e.getMessage());\\n    } finally {\\n      Context.exit();\\n    }\\n    Node root = null;\\n    if (astRoot != null) {\\n      root = IRFactory.transformTree(\\n          astRoot, sourceFile, sourceString, config, errorReporter);\\n      root.setIsSyntheticBlock(true);\\n    }\\n    return new ParseResult(root, astRoot);\\n  }\", \"javadoc_start_line\": 98, \"annotations_start_line\": 107, \"method_start_line\": 111, \"end_line\": 147}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"transformTree\", \"content\": \"  public static Node transformTree(AstRoot node,\\n                                   StaticSourceFile sourceFile,\\n                                   String sourceString,\\n                                   Config config,\\n                                   ErrorReporter errorReporter) {\\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\\n        config, errorReporter);\\n    Node irNode = irFactory.transform(node);\\n\\n    if (node.getComments() != null) {\\n      for (Comment comment : node.getComments()) {\\n        if (comment.getCommentType() == CommentType.JSDOC &&\\n            !irFactory.parsedComments.contains(comment)) {\\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\\n          irFactory.handleBlockComment(comment);\\n        }\\n      }\\n    }\\n\\n    irFactory.setFileOverviewJsDoc(irNode);\\n\\n    return irNode;\\n  }\", \"javadoc_start_line\": 186, \"annotations_start_line\": 186, \"method_start_line\": 190, \"end_line\": 209}"},{"step":"{\"file_path\": \"\/lib\/rhino\/src\/org\/mozilla\/javascript\/IRFactory.java\", \"method_name\": \"transformArrayComp\", \"content\": \"    private Node transformArrayComp(ArrayComprehension node) {\\n        \/\/ An array comprehension expression such as\\n        \/\/\\n        \/\/   [expr for (x in foo) for each ([y, z] in bar) if (cond)]\\n        \/\/\\n        \/\/ is rewritten approximately as\\n        \/\/\\n        \/\/ new Scope(ARRAYCOMP) {\\n        \/\/   new Node(BLOCK) {\\n        \/\/     let tmp1 = new Array;\\n        \/\/     for (let x in foo) {\\n        \/\/       for each (let tmp2 in bar) {\\n        \/\/         if (cond) {\\n        \/\/           tmp1.push([y, z] = tmp2, expr);\\n        \/\/         }\\n        \/\/       }\\n        \/\/     }\\n        \/\/   }\\n        \/\/   createName(tmp1)\\n        \/\/ }\\n\\n        int lineno = node.getLineno();\\n        Scope scopeNode = createScopeNode(Token.ARRAYCOMP, lineno);\\n        String arrayName = currentScriptOrFn.getNextTempName();\\n        pushScope(scopeNode);\\n        try {\\n            defineSymbol(Token.LET, arrayName, false);\\n            Node block = new Node(Token.BLOCK, lineno);\\n            Node newArray = createCallOrNew(Token.NEW, createName(\\\"Array\\\"));\\n            Node init = new Node(Token.EXPR_VOID,\\n                                 createAssignment(Token.ASSIGN,\\n                                                  createName(arrayName),\\n                                                  newArray),\\n                                 lineno);\\n            block.addChildToBack(init);\\n            block.addChildToBack(arrayCompTransformHelper(node, arrayName));\\n            scopeNode.addChildToBack(block);\\n            scopeNode.addChildToBack(createName(arrayName));\\n            return scopeNode;\\n        } finally {\\n            popScope();\\n        }\\n    }\", \"javadoc_start_line\": 183, \"annotations_start_line\": 183, \"method_start_line\": 183, \"end_line\": 225}"},{"step":"{\"file_path\": \"\/lib\/rhino\/src\/org\/mozilla\/javascript\/IRFactory.java\", \"method_name\": \"arrayCompTransformHelper\", \"content\": \"    private Node arrayCompTransformHelper(ArrayComprehension node,\\n                                          String arrayName) {\\n        decompiler.addToken(Token.LB);\\n        int lineno = node.getLineno();\\n        Node expr = transform(node.getResult());\\n\\n        List<ArrayComprehensionLoop> loops = node.getLoops();\\n        int numLoops = loops.size();\\n\\n        \/\/ Walk through loops, collecting and defining their iterator symbols.\\n        Node[] iterators = new Node[numLoops];\\n        Node[] iteratedObjs = new Node[numLoops];\\n\\n        for (int i = 0; i < numLoops; i++) {\\n            ArrayComprehensionLoop acl = loops.get(i);\\n            decompiler.addName(\\\" \\\");\\n            decompiler.addToken(Token.FOR);\\n            if (acl.isForEach()) {\\n                decompiler.addName(\\\"each \\\");\\n            }\\n            decompiler.addToken(Token.LP);\\n\\n            AstNode iter = acl.getIterator();\\n            String name = null;\\n            if (iter.getType() == Token.NAME) {\\n                name = iter.getString();\\n                decompiler.addName(name);\\n            } else {\\n                \/\/ destructuring assignment\\n                decompile(iter);\\n                name = currentScriptOrFn.getNextTempName();\\n                defineSymbol(Token.LP, name, false);\\n                expr = createBinary(Token.COMMA,\\n                                    createAssignment(Token.ASSIGN,\\n                                                     iter,\\n                                                     createName(name)),\\n                                    expr);\\n            }\\n            Node init = createName(name);\\n            \/\/ Define as a let since we want the scope of the variable to\\n            \/\/ be restricted to the array comprehension\\n            defineSymbol(Token.LET, name, false);\\n            iterators[i] = init;\\n\\n            decompiler.addToken(Token.IN);\\n            iteratedObjs[i] = transform(acl.getIteratedObject());\\n            decompiler.addToken(Token.RP);\\n        }\\n\\n        \/\/ generate code for tmpArray.push(body)\\n        Node call = createCallOrNew(Token.CALL,\\n                                    createPropertyGet(createName(arrayName),\\n                                                      null,\\n                                                      \\\"push\\\", 0));\\n\\n        Node body = new Node(Token.EXPR_VOID, call, lineno);\\n\\n        if (node.getFilter() != null) {\\n            decompiler.addName(\\\" \\\");\\n            decompiler.addToken(Token.IF);\\n            decompiler.addToken(Token.LP);\\n            body = createIf(transform(node.getFilter()), body, null, lineno);\\n            decompiler.addToken(Token.RP);\\n        }\\n\\n        \/\/ Now walk loops in reverse to build up the body statement.\\n        int pushed = 0;\\n        try {\\n            for (int i = numLoops-1; i >= 0; i--) {\\n                ArrayComprehensionLoop acl = loops.get(i);\\n                Scope loop = createLoopNode(null,  \/\/ no label\\n                                            acl.getLineno());\\n                pushScope(loop);\\n                pushed++;\\n                body = createForIn(Token.LET,\\n                                   loop,\\n                                   iterators[i],\\n                                   iteratedObjs[i],\\n                                   body,\\n                                   acl.isForEach());\\n            }\\n        } finally {\\n            for (int i = 0; i < pushed; i++) {\\n                popScope();\\n            }\\n        }\\n\\n        decompiler.addToken(Token.RB);\\n\\n        \/\/ Now that we've accumulated any destructuring forms,\\n        \/\/ add expr to the call node; it's pushed on each iteration.\\n        call.addChildToBack(expr);\\n        return body;\\n    }\", \"javadoc_start_line\": 227, \"annotations_start_line\": 227, \"method_start_line\": 228, \"end_line\": 320}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/parsing\/IRFactory.java\", \"method_name\": \"handleBlockComment\", \"content\": \"  \/**\\n   * Check to see if the given block comment looks like it should be JSDoc.\\n   *\/\\n  private void handleBlockComment(Comment comment) {\\n    if (comment.getValue().indexOf(\\\"\/* @\\\") != -1 || comment.getValue().indexOf(\\\"\\\\n * @\\\") != -1) {\\n      errorReporter.warning(\\n          SUSPICIOUS_COMMENT_WARNING,\\n          sourceName,\\n          comment.getLineno(), \\\"\\\", 0);\\n    }\\n  }\", \"javadoc_start_line\": 248, \"annotations_start_line\": 251, \"method_start_line\": 251, \"end_line\": 258}"}]},{"name":"Closure","version":123,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.CodePrinterTest\", \"methodName\": \"testPrintInOperatorInForLoop\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"expected:<for(a=c?0:[(0 in d)];;)foo()> but was:<for(a=c?0:[0 in d];;)foo()>\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"add\", \"content\": \"  void add(Node n, Context context) {\\n    if (!cc.continueProcessing()) {\\n      return;\\n    }\\n\\n    int type = n.getType();\\n    String opstr = NodeUtil.opToStr(type);\\n    int childCount = n.getChildCount();\\n    Node first = n.getFirstChild();\\n    Node last = n.getLastChild();\\n\\n    \/\/ Handle all binary operators\\n    if (opstr != null && first != last) {\\n      Preconditions.checkState(\\n          childCount == 2,\\n          \\\"Bad binary operator \\\\\\\"%s\\\\\\\": expected 2 arguments but got %s\\\",\\n          opstr, childCount);\\n      int p = NodeUtil.precedence(type);\\n\\n      \/\/ For right-hand-side of operations, only pass context if it's\\n      \/\/ the IN_FOR_INIT_CLAUSE one.\\n      Context rhsContext = getContextForNoInOperator(context);\\n\\n      \/\/ Handle associativity.\\n      \/\/ e.g. if the parse tree is a * (b * c),\\n      \/\/ we can simply generate a * b * c.\\n      if (last.getType() == type &&\\n          NodeUtil.isAssociative(type)) {\\n        addExpr(first, p, context);\\n        cc.addOp(opstr, true);\\n        addExpr(last, p, rhsContext);\\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\\n        \/\/ Assignments are the only right-associative binary operators\\n        addExpr(first, p, context);\\n        cc.addOp(opstr, true);\\n        addExpr(last, p, rhsContext);\\n      } else {\\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\\n      }\\n      return;\\n    }\\n\\n    cc.startSourceMapping(n);\\n\\n    switch (type) {\\n      case Token.TRY: {\\n        Preconditions.checkState(first.getNext().isBlock() &&\\n                !first.getNext().hasMoreThanOneChild());\\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\\n\\n        add(\\\"try\\\");\\n        add(first, Context.PRESERVE_BLOCK);\\n\\n        \/\/ second child contains the catch block, or nothing if there\\n        \/\/ isn't a catch block\\n        Node catchblock = first.getNext().getFirstChild();\\n        if (catchblock != null) {\\n          add(catchblock);\\n        }\\n\\n        if (childCount == 3) {\\n          add(\\\"finally\\\");\\n          add(last, Context.PRESERVE_BLOCK);\\n        }\\n        break;\\n      }\\n\\n      case Token.CATCH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"catch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        add(last, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.THROW:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"throw\\\");\\n        add(first);\\n\\n        \/\/ Must have a ';' after a throw statement, otherwise safari can't\\n        \/\/ parse this.\\n        cc.endStatement(true);\\n        break;\\n\\n      case Token.RETURN:\\n        add(\\\"return\\\");\\n        if (childCount == 1) {\\n          add(first);\\n        } else {\\n          Preconditions.checkState(childCount == 0);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.VAR:\\n        if (first != null) {\\n          add(\\\"var \\\");\\n          addList(first, false, getContextForNoInOperator(context));\\n        }\\n        break;\\n\\n      case Token.LABEL_NAME:\\n        Preconditions.checkState(!n.getString().isEmpty());\\n        addIdentifier(n.getString());\\n        break;\\n\\n      case Token.NAME:\\n        if (first == null || first.isEmpty()) {\\n          addIdentifier(n.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          addIdentifier(n.getString());\\n          cc.addOp(\\\"=\\\", true);\\n          if (first.isComma()) {\\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\\n          } else {\\n            \/\/ Add expression, consider nearby code at lowest level of\\n            \/\/ precedence.\\n            addExpr(first, 0, getContextForNoInOperator(context));\\n          }\\n        }\\n        break;\\n\\n      case Token.ARRAYLIT:\\n        add(\\\"[\\\");\\n        addArrayList(first);\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.PARAM_LIST:\\n        add(\\\"(\\\");\\n        addList(first);\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.COMMA:\\n        Preconditions.checkState(childCount == 2);\\n        unrollBinaryOperator(n, Token.COMMA, \\\",\\\", context,\\n            getContextForNoInOperator(context), 0, 0);\\n        break;\\n\\n      case Token.NUMBER:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addNumber(n.getDouble());\\n        break;\\n\\n      case Token.TYPEOF:\\n      case Token.VOID:\\n      case Token.NOT:\\n      case Token.BITNOT:\\n      case Token.POS: {\\n        \/\/ All of these unary operators are right-associative\\n        Preconditions.checkState(childCount == 1);\\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\\n        break;\\n      }\\n\\n      case Token.NEG: {\\n        Preconditions.checkState(childCount == 1);\\n\\n        \/\/ It's important to our sanity checker that the code\\n        \/\/ we print produces the same AST as the code we parse back.\\n        \/\/ NEG is a weird case because Rhino parses \\\"- -2\\\" as \\\"2\\\".\\n        if (n.getFirstChild().isNumber()) {\\n          cc.addNumber(-n.getFirstChild().getDouble());\\n        } else {\\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\\n        }\\n\\n        break;\\n      }\\n\\n      case Token.HOOK: {\\n        Preconditions.checkState(childCount == 3);\\n        int p = NodeUtil.precedence(type);\\n        Context rhsContext = Context.OTHER;\\n        addExpr(first, p + 1, context);\\n        cc.addOp(\\\"?\\\", true);\\n        addExpr(first.getNext(), 1, rhsContext);\\n        cc.addOp(\\\":\\\", true);\\n        addExpr(last, 1, rhsContext);\\n        break;\\n      }\\n\\n      case Token.REGEXP:\\n        if (!first.isString() ||\\n            !last.isString()) {\\n          throw new Error(\\\"Expected children to be strings\\\");\\n        }\\n\\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\\n\\n        \/\/ I only use one .add because whitespace matters\\n        if (childCount == 2) {\\n          add(regexp + last.getString());\\n        } else {\\n          Preconditions.checkState(childCount == 1);\\n          add(regexp);\\n        }\\n        break;\\n\\n      case Token.FUNCTION:\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        Preconditions.checkState(childCount == 3);\\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\\n        if (funcNeedsParens) {\\n          add(\\\"(\\\");\\n        }\\n\\n        add(\\\"function\\\");\\n        add(first);\\n\\n        add(first.getNext());\\n        add(last, Context.PRESERVE_BLOCK);\\n        cc.endFunction(context == Context.STATEMENT);\\n\\n        if (funcNeedsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.GETTER_DEF:\\n      case Token.SETTER_DEF:\\n        Preconditions.checkState(n.getParent().isObjectLit());\\n        Preconditions.checkState(childCount == 1);\\n        Preconditions.checkState(first.isFunction());\\n\\n        \/\/ Get methods are unnamed\\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\\n        if (type == Token.GETTER_DEF) {\\n          \/\/ Get methods have no parameters.\\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\\n          add(\\\"get \\\");\\n        } else {\\n          \/\/ Set methods have one parameter.\\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\\n          add(\\\"set \\\");\\n        }\\n\\n        \/\/ The name is on the GET or SET node.\\n        String name = n.getString();\\n        Node fn = first;\\n        Node parameters = fn.getChildAtIndex(1);\\n        Node body = fn.getLastChild();\\n\\n        \/\/ Add the property name.\\n        if (!n.isQuotedString() &&\\n            TokenStream.isJSIdentifier(name) &&\\n            \/\/ do not encode literally any non-literal characters that were\\n            \/\/ Unicode escaped.\\n            NodeUtil.isLatin(name)) {\\n          add(name);\\n        } else {\\n          \/\/ Determine if the string is a simple number.\\n          double d = getSimpleNumber(name);\\n          if (!Double.isNaN(d)) {\\n            cc.addNumber(d);\\n          } else {\\n            addJsString(n);\\n          }\\n        }\\n\\n        add(parameters);\\n        add(body, Context.PRESERVE_BLOCK);\\n        break;\\n\\n      case Token.SCRIPT:\\n      case Token.BLOCK: {\\n        if (n.getClass() != Node.class) {\\n          throw new Error(\\\"Unexpected Node subclass.\\\");\\n        }\\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\\n        if (preserveBlock) {\\n          cc.beginBlock();\\n        }\\n\\n        boolean preferLineBreaks =\\n            type == Token.SCRIPT ||\\n            (type == Token.BLOCK &&\\n                !preserveBlock &&\\n                n.getParent() != null &&\\n                n.getParent().isScript());\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          add(c, Context.STATEMENT);\\n\\n          \/\/ VAR doesn't include ';' since it gets used in expressions\\n          if (c.isVar()) {\\n            cc.endStatement();\\n          }\\n\\n          if (c.isFunction()) {\\n            cc.maybeLineBreak();\\n          }\\n\\n          \/\/ Prefer to break lines in between top-level statements\\n          \/\/ because top-level statements are more homogeneous.\\n          if (preferLineBreaks) {\\n            cc.notePreferredLineBreak();\\n          }\\n        }\\n        if (preserveBlock) {\\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\\n        }\\n        break;\\n      }\\n\\n      case Token.FOR:\\n        if (childCount == 4) {\\n          add(\\\"for(\\\");\\n          if (first.isVar()) {\\n            add(first, Context.IN_FOR_INIT_CLAUSE);\\n          } else {\\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\\n          }\\n          add(\\\";\\\");\\n          add(first.getNext());\\n          add(\\\";\\\");\\n          add(first.getNext().getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          Preconditions.checkState(childCount == 3);\\n          add(\\\"for(\\\");\\n          add(first);\\n          add(\\\"in\\\");\\n          add(first.getNext());\\n          add(\\\")\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        }\\n        break;\\n\\n      case Token.DO:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"do\\\");\\n        addNonEmptyStatement(first, Context.OTHER, false);\\n        add(\\\"while(\\\");\\n        add(last);\\n        add(\\\")\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.WHILE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"while(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.EMPTY:\\n        Preconditions.checkState(childCount == 0);\\n        break;\\n\\n      case Token.GETPROP: {\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETPROP: expected 2 children, but got %s\\\", childCount);\\n        Preconditions.checkState(\\n            last.isString(),\\n            \\\"Bad GETPROP: RHS should be STRING\\\");\\n        boolean needsParens = (first.isNumber());\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        addExpr(first, NodeUtil.precedence(type), context);\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        if (this.languageMode == LanguageMode.ECMASCRIPT3\\n            && TokenStream.isKeyword(last.getString())) {\\n          \/\/ Check for ECMASCRIPT3 keywords.\\n          add(\\\"[\\\");\\n          add(last);\\n          add(\\\"]\\\");\\n        } else {\\n          add(\\\".\\\");\\n          addIdentifier(last.getString());\\n        }\\n        break;\\n      }\\n\\n      case Token.GETELEM:\\n        Preconditions.checkState(\\n            childCount == 2,\\n            \\\"Bad GETELEM: expected 2 children but got %s\\\", childCount);\\n        addExpr(first, NodeUtil.precedence(type), context);\\n        add(\\\"[\\\");\\n        add(first.getNext());\\n        add(\\\"]\\\");\\n        break;\\n\\n      case Token.WITH:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"with(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), false);\\n        break;\\n\\n      case Token.INC:\\n      case Token.DEC: {\\n        Preconditions.checkState(childCount == 1);\\n        String o = type == Token.INC ? \\\"++\\\" : \\\"--\\\";\\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\\n        \/\/ A non-zero post-prop value indicates a post inc\/dec, default of zero\\n        \/\/ is a pre-inc\/dec.\\n        if (postProp != 0) {\\n          addExpr(first, NodeUtil.precedence(type), context);\\n          cc.addOp(o, false);\\n        } else {\\n          cc.addOp(o, false);\\n          add(first);\\n        }\\n        break;\\n      }\\n\\n      case Token.CALL:\\n        \/\/ We have two special cases here:\\n        \/\/ 1) If the left hand side of the call is a direct reference to eval,\\n        \/\/ then it must have a DIRECT_EVAL annotation. If it does not, then\\n        \/\/ that means it was originally an indirect call to eval, and that\\n        \/\/ indirectness must be preserved.\\n        \/\/ 2) If the left hand side of the call is a property reference,\\n        \/\/ then the call must not a FREE_CALL annotation. If it does, then\\n        \/\/ that means it was originally an call without an explicit this and\\n        \/\/ that must be preserved.\\n        if (isIndirectEval(first)\\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\\n          add(\\\"(0,\\\");\\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\\n          add(\\\")\\\");\\n        } else {\\n          addExpr(first, NodeUtil.precedence(type), context);\\n        }\\n        add(\\\"(\\\");\\n        addList(first.getNext());\\n        add(\\\")\\\");\\n        break;\\n\\n      case Token.IF:\\n        boolean hasElse = childCount == 3;\\n        boolean ambiguousElseClause =\\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\\n        if (ambiguousElseClause) {\\n          cc.beginBlock();\\n        }\\n\\n        add(\\\"if(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n\\n        if (hasElse) {\\n          addNonEmptyStatement(\\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\\n          add(\\\"else\\\");\\n          addNonEmptyStatement(\\n              last, getContextForNonEmptyExpression(context), false);\\n        } else {\\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\\n          Preconditions.checkState(childCount == 2);\\n        }\\n\\n        if (ambiguousElseClause) {\\n          cc.endBlock();\\n        }\\n        break;\\n\\n      case Token.NULL:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addConstant(\\\"null\\\");\\n        break;\\n\\n      case Token.THIS:\\n        Preconditions.checkState(childCount == 0);\\n        add(\\\"this\\\");\\n        break;\\n\\n      case Token.FALSE:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addConstant(\\\"false\\\");\\n        break;\\n\\n      case Token.TRUE:\\n        Preconditions.checkState(childCount == 0);\\n        cc.addConstant(\\\"true\\\");\\n        break;\\n\\n      case Token.CONTINUE:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"continue\\\");\\n        if (childCount == 1) {\\n          if (!first.isLabelName()) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.DEBUGGER:\\n        Preconditions.checkState(childCount == 0);\\n        add(\\\"debugger\\\");\\n        cc.endStatement();\\n        break;\\n\\n      case Token.BREAK:\\n        Preconditions.checkState(childCount <= 1);\\n        add(\\\"break\\\");\\n        if (childCount == 1) {\\n          if (!first.isLabelName()) {\\n            throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n          }\\n          add(\\\" \\\");\\n          add(first);\\n        }\\n        cc.endStatement();\\n        break;\\n\\n      case Token.EXPR_RESULT:\\n        Preconditions.checkState(childCount == 1);\\n        add(first, Context.START_OF_EXPR);\\n        cc.endStatement();\\n        break;\\n\\n      case Token.NEW:\\n        add(\\\"new \\\");\\n        int precedence = NodeUtil.precedence(type);\\n\\n        \/\/ If the first child contains a CALL, then claim higher precedence\\n        \/\/ to force parentheses. Otherwise, when parsed, NEW will bind to the\\n        \/\/ first viable parentheses (don't traverse into functions).\\n        if (NodeUtil.containsType(\\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\\n          precedence = NodeUtil.precedence(first.getType()) + 1;\\n        }\\n        addExpr(first, precedence, Context.OTHER);\\n\\n        \/\/ '()' is optional when no arguments are present\\n        Node next = first.getNext();\\n        if (next != null) {\\n          add(\\\"(\\\");\\n          addList(next);\\n          add(\\\")\\\");\\n        }\\n        break;\\n\\n      case Token.STRING_KEY:\\n        Preconditions.checkState(\\n            childCount == 1, \\\"Object lit key must have 1 child\\\");\\n        addJsString(n);\\n        break;\\n\\n      case Token.STRING:\\n        Preconditions.checkState(\\n            childCount == 0, \\\"A string may not have children\\\");\\n        addJsString(n);\\n        break;\\n\\n      case Token.DELPROP:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"delete \\\");\\n        add(first);\\n        break;\\n\\n      case Token.OBJECTLIT: {\\n        boolean needsParens = (context == Context.START_OF_EXPR);\\n        if (needsParens) {\\n          add(\\\"(\\\");\\n        }\\n        add(\\\"{\\\");\\n        for (Node c = first; c != null; c = c.getNext()) {\\n          if (c != first) {\\n            cc.listSeparator();\\n          }\\n\\n          if (c.isGetterDef() || c.isSetterDef()) {\\n            add(c);\\n          } else {\\n            Preconditions.checkState(c.isStringKey());\\n            String key = c.getString();\\n            \/\/ Object literal property names don't have to be quoted if they\\n            \/\/ are not JavaScript keywords\\n            if (!c.isQuotedString()\\n                && !(languageMode == LanguageMode.ECMASCRIPT3\\n                    && TokenStream.isKeyword(key))\\n                && TokenStream.isJSIdentifier(key)\\n                \/\/ do not encode literally any non-literal characters that\\n                \/\/ were Unicode escaped.\\n                && NodeUtil.isLatin(key)) {\\n              add(key);\\n            } else {\\n              \/\/ Determine if the string is a simple number.\\n              double d = getSimpleNumber(key);\\n              if (!Double.isNaN(d)) {\\n                cc.addNumber(d);\\n              } else {\\n                addExpr(c, 1, Context.OTHER);\\n              }\\n            }\\n            add(\\\":\\\");\\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\\n          }\\n        }\\n        add(\\\"}\\\");\\n        if (needsParens) {\\n          add(\\\")\\\");\\n        }\\n        break;\\n      }\\n\\n      case Token.SWITCH:\\n        add(\\\"switch(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        cc.beginBlock();\\n        addAllSiblings(first.getNext());\\n        cc.endBlock(context == Context.STATEMENT);\\n        break;\\n\\n      case Token.CASE:\\n        Preconditions.checkState(childCount == 2);\\n        add(\\\"case \\\");\\n        add(first);\\n        addCaseBody(last);\\n        break;\\n\\n      case Token.DEFAULT_CASE:\\n        Preconditions.checkState(childCount == 1);\\n        add(\\\"default\\\");\\n        addCaseBody(first);\\n        break;\\n\\n      case Token.LABEL:\\n        Preconditions.checkState(childCount == 2);\\n        if (!first.isLabelName()) {\\n          throw new Error(\\\"Unexpected token type. Should be LABEL_NAME.\\\");\\n        }\\n        add(first);\\n        add(\\\":\\\");\\n        addNonEmptyStatement(\\n            last, getContextForNonEmptyExpression(context), true);\\n        break;\\n\\n      case Token.CAST:\\n        add(\\\"(\\\");\\n        add(first);\\n        add(\\\")\\\");\\n        break;\\n\\n      default:\\n        throw new Error(\\\"Unknown type \\\" + type + \\\"\\\\n\\\" + n.toStringTree());\\n    }\\n\\n    cc.endSourceMapping(n);\\n  }\", \"javadoc_start_line\": 107, \"annotations_start_line\": 107, \"method_start_line\": 107, \"end_line\": 771}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodePrinter.java\", \"method_name\": \"CodePrinter\", \"content\": \"class CodePrinter {\", \"javadoc_start_line\": 36, \"annotations_start_line\": 36, \"method_start_line\": 36, \"end_line\": 36}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodePrinter.java\", \"method_name\": \"<clinit>\", \"content\": \"class CodePrinter {\", \"javadoc_start_line\": 36, \"annotations_start_line\": 36, \"method_start_line\": 36, \"end_line\": 36}"},{"step":"{\"file_path\": \"\/lib\/rhino\/toolsrc\/org\/mozilla\/javascript\/tools\/idswitch\/CodePrinter.java\", \"method_name\": \"ensure_area\", \"content\": \"    private int ensure_area(int area_size) {\\n        int begin = offset;\\n        int end = begin + area_size;\\n        if (end > buffer.length) {\\n            int new_capacity = buffer.length * 2;\\n            if (end > new_capacity) { new_capacity = end; }\\n            char[] tmp = new char[new_capacity];\\n            System.arraycopy(buffer, 0, tmp, 0, begin);\\n            buffer = tmp;\\n        }\\n        return begin;\\n    }\", \"javadoc_start_line\": 34, \"annotations_start_line\": 34, \"method_start_line\": 34, \"end_line\": 45}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodePrinter.java\", \"method_name\": \"toSource\", \"content\": \"  \/**\\n   * Converts a tree to JS code\\n   *\/\\n  private static String toSource(Node root, Format outputFormat,\\n      CompilerOptions options, JSTypeRegistry registry,\\n      SourceMap sourceMap,  boolean tagAsStrict) {\\n    Preconditions.checkState(options.sourceMapDetailLevel != null);\\n\\n    boolean createSourceMap = (sourceMap != null);\\n    MappedCodePrinter mcp =\\n        outputFormat == Format.COMPACT\\n        ? new CompactCodePrinter(\\n            options.lineBreak,\\n            options.preferLineBreakAtEndOfFile,\\n            options.lineLengthThreshold,\\n            createSourceMap,\\n            options.sourceMapDetailLevel)\\n        : new PrettyCodePrinter(\\n            options.lineLengthThreshold,\\n            createSourceMap,\\n            options.sourceMapDetailLevel);\\n    CodeGenerator cg =\\n        outputFormat == Format.TYPED\\n        ? new TypedCodeGenerator(mcp, options, registry)\\n        : new CodeGenerator(mcp, options);\\n\\n    if (tagAsStrict) {\\n      cg.tagAsStrict();\\n    }\\n\\n    cg.add(root);\\n    mcp.endFile();\\n\\n    String code = mcp.getCode();\\n\\n    if (createSourceMap) {\\n      mcp.generateSourceMap(sourceMap);\\n    }\\n\\n    return code;\\n  }\", \"javadoc_start_line\": 651, \"annotations_start_line\": 654, \"method_start_line\": 656, \"end_line\": 691}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CodeGenerator.java\", \"method_name\": \"add\", \"content\": \"  void add(Node n) {\\n    add(n, Context.OTHER);\\n  }\", \"javadoc_start_line\": 103, \"annotations_start_line\": 103, \"method_start_line\": 103, \"end_line\": 105}"},{"step":"{\"file_path\": \"\/lib\/rhino\/src\/org\/mozilla\/javascript\/CodeGenerator.java\", \"method_name\": \"generateFunctionICode\", \"content\": \"    private void generateFunctionICode()\\n    {\\n        itsInFunctionFlag = true;\\n\\n        FunctionNode theFunction = (FunctionNode)scriptOrFn;\\n\\n        itsData.itsFunctionType = theFunction.getFunctionType();\\n        itsData.itsNeedsActivation = theFunction.requiresActivation();\\n        if (theFunction.getFunctionName() != null) {\\n            itsData.itsName = theFunction.getName();\\n        }\\n        if (theFunction.isGenerator()) {\\n          addIcode(Icode_GENERATOR);\\n          addUint16(theFunction.getBaseLineno() & 0xFFFF);\\n        }\\n\\n        generateICodeFromTree(theFunction.getLastChild());\\n    }\", \"javadoc_start_line\": 88, \"annotations_start_line\": 88, \"method_start_line\": 89, \"end_line\": 105}"}]},{"name":"Closure","version":124,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.ExploitAssignsTest\", \"methodName\": \"testIssue1017\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ExploitAssigns.java\", \"method_name\": \"isSafeReplacement\", \"content\": \"  \/**\\n   * Checks name referenced in node to determine if it might have\\n   * changed.\\n   * @return Whether the replacement can be made.\\n   *\/\\n  private boolean isSafeReplacement(Node node, Node replacement) {\\n    \/\/ No checks are needed for simple names.\\n    if (node.isName()) {\\n      return true;\\n    }\\n    Preconditions.checkArgument(node.isGetProp());\\n\\n      node = node.getFirstChild();\\n    if (node.isName()\\n        && isNameAssignedTo(node.getString(), replacement)) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\", \"javadoc_start_line\": 201, \"annotations_start_line\": 206, \"method_start_line\": 206, \"end_line\": 220}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    compiler.addChangeHandler(handler);\\n    beginTraversal();\\n    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\\n        @Override\\n        public void visit(AbstractCompiler compiler, Node root) {\\n          if (root.isFunction()) {\\n            root = root.getLastChild();\\n          }\\n          do {\\n            handler.reset();\\n            NodeTraversal.traverse(compiler, root, new PeepCallback());\\n          } while (retraverseOnChange && handler.hasCodeChanged());\\n        }\\n      });\\n    endTraversal();\\n    compiler.removeChangeHandler(handler);\\n  }\", \"javadoc_start_line\": 60, \"annotations_start_line\": 59, \"method_start_line\": 60, \"end_line\": 77}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"\", \"content\": \"    NodeTraversal.traverseChangedFunctions(compiler, new FunctionCallback() {\", \"javadoc_start_line\": 63, \"annotations_start_line\": 63, \"method_start_line\": 63, \"end_line\": 63}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseChangedFunctions\", \"content\": \"  \/**\\n   * Traversal for passes that work only on changed functions.\\n   * Suppose a loopable pass P1 uses this traversal.\\n   * Then, if a function doesn't change between two runs of P1, it won't look at\\n   * the function the second time.\\n   * (We're assuming that P1 runs to a fixpoint, o\/w we may miss optimizations.)\\n   *\\n   * Most changes are reported with calls to Compiler.reportCodeChange(), which\\n   * doesn't know which scope changed. We keep track of the current scope by\\n   * calling Compiler.setScope inside pushScope and popScope.\\n   * The automatic tracking can be wrong in rare cases when a pass changes scope\\n   * w\/out causing a call to pushScope or popScope. It's very hard to find the\\n   * places where this happens unless a bug is triggered.\\n   * Passes that do cross-scope modifications call\\n   * Compiler.reportChangeToEnclosingScope(Node n).\\n   *\/\\n  public static void traverseChangedFunctions(\\n      AbstractCompiler compiler, FunctionCallback callback) {\\n    final AbstractCompiler comp = compiler;\\n    final FunctionCallback cb = callback;\\n    final Node jsRoot = comp.getJsRoot();\\n    NodeTraversal t = new NodeTraversal(comp, new AbstractPreOrderCallback() {\\n        @Override\\n        public final boolean shouldTraverse(NodeTraversal t, Node n, Node p) {\\n          if ((n == jsRoot || n.isFunction()) && comp.hasScopeChanged(n)) {\\n            cb.visit(comp, n);\\n          }\\n          return true;\\n        }\\n      });\\n    t.traverse(jsRoot);\\n  }\", \"javadoc_start_line\": 455, \"annotations_start_line\": 471, \"method_start_line\": 472, \"end_line\": 486}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      inputId = NodeUtil.getInputId(root);\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      \/\/ null parent ensures that the shallow callbacks will traverse root\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 277, \"annotations_start_line\": 280, \"method_start_line\": 280, \"end_line\": 292}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 512, \"annotations_start_line\": 515, \"method_start_line\": 515, \"end_line\": 541}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a node recursively.\\n   *\/\\n  public static void traverse(\\n      AbstractCompiler compiler, Node root, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverse(root);\\n  }\", \"javadoc_start_line\": 488, \"annotations_start_line\": 491, \"method_start_line\": 492, \"end_line\": 495}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      inputId = NodeUtil.getInputId(root);\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      \/\/ null parent ensures that the shallow callbacks will traverse root\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 277, \"annotations_start_line\": 280, \"method_start_line\": 280, \"end_line\": 292}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 512, \"annotations_start_line\": 515, \"method_start_line\": 515, \"end_line\": 541}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 512, \"annotations_start_line\": 515, \"method_start_line\": 515, \"end_line\": 541}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ExploitAssigns.java\", \"method_name\": \"optimizeSubtree\", \"content\": \"  Node optimizeSubtree(Node subtree) {\\n    for (Node child = subtree.getFirstChild(); child != null;) {\\n      Node next = child.getNext();\\n      if (NodeUtil.isExprAssign(child)) {\\n        collapseAssign(child.getFirstChild(), child, subtree);\\n      }\\n      child = next;\\n    }\\n    return subtree;\\n  }\", \"javadoc_start_line\": 32, \"annotations_start_line\": 31, \"method_start_line\": 32, \"end_line\": 41}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ExploitAssigns.java\", \"method_name\": \"collapseAssign\", \"content\": \"  \/**\\n   * Try to collapse the given assign into subsequent expressions.\\n   *\/\\n  private void collapseAssign(Node assign, Node expr,\\n      Node exprParent) {\\n    Node leftValue = assign.getFirstChild();\\n    Node rightValue = leftValue.getNext();\\n    if (isCollapsibleValue(leftValue, true) &&\\n        collapseAssignEqualTo(expr, exprParent, leftValue)) {\\n      reportCodeChange();\\n    } else if (isCollapsibleValue(rightValue, false) &&\\n        collapseAssignEqualTo(expr, exprParent, rightValue)) {\\n      reportCodeChange();\\n    } else if (rightValue.isAssign()) {\\n      \/\/ Recursively deal with nested assigns.\\n      collapseAssign(rightValue, expr, exprParent);\\n    }\\n  }\", \"javadoc_start_line\": 43, \"annotations_start_line\": 46, \"method_start_line\": 47, \"end_line\": 60}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ExploitAssigns.java\", \"method_name\": \"collapseAssignEqualTo\", \"content\": \"  \/**\\n   * Collapse the given assign expression into the expression directly\\n   * following it, if possible.\\n   *\\n   * @param expr The expression that may be moved.\\n   * @param exprParent The parent of {@code expr}.\\n   * @param value The value of this expression, expressed as a node. Each\\n   *     expression may have multiple values, so this function may be called\\n   *     multiple times for the same expression. For example,\\n   *     <code>\\n   *     a = true;\\n   *     <\/code>\\n   *     is equal to the name \\\"a\\\" and the boolean \\\"true\\\".\\n   * @return Whether the expression was collapsed successfully.\\n   *\/\\n  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\\n      Node value) {\\n    Node assign = expr.getFirstChild();\\n    Node parent = exprParent;\\n    Node next = expr.getNext();\\n    while (next != null) {\\n      switch (next.getType()) {\\n        case Token.AND:\\n        case Token.OR:\\n        case Token.HOOK:\\n        case Token.IF:\\n        case Token.RETURN:\\n        case Token.EXPR_RESULT:\\n          \/\/ Dive down the left side\\n          parent = next;\\n          next = next.getFirstChild();\\n          break;\\n\\n        case Token.VAR:\\n          if (next.getFirstChild().hasChildren()) {\\n            parent = next.getFirstChild();\\n            next = parent.getFirstChild();\\n            break;\\n          }\\n          return false;\\n\\n        case Token.GETPROP:\\n        case Token.NAME:\\n          if (next.isQualifiedName()) {\\n            String nextName = next.getQualifiedName();\\n            if (value.isQualifiedName() &&\\n                nextName.equals(value.getQualifiedName())) {\\n              \/\/ If the previous expression evaluates to value of a\\n              \/\/ qualified name, and that qualified name is used again\\n              \/\/ shortly, then we can exploit the assign here.\\n\\n              \/\/ Verify the assignment doesn't change its own value.\\n              if (!isSafeReplacement(next, assign)) {\\n                return false;\\n              }\\n\\n              exprParent.removeChild(expr);\\n              expr.removeChild(assign);\\n              parent.replaceChild(next, assign);\\n              return true;\\n            }\\n          }\\n          return false;\\n\\n        case Token.ASSIGN:\\n          \/\/ Assigns are really tricky. In lots of cases, we want to inline\\n          \/\/ into the right side of the assign. But the left side of the\\n          \/\/ assign is evaluated first, and it may have convoluted logic:\\n          \/\/   a = null;\\n          \/\/   (a = b).c = null;\\n          \/\/ We don't want to exploit the first assign. Similarly:\\n          \/\/   a.b = null;\\n          \/\/   a.b.c = null;\\n          \/\/ We don't want to exploit the first assign either.\\n          \/\/\\n          \/\/ To protect against this, we simply only inline when the left side\\n          \/\/ is guaranteed to evaluate to the same L-value no matter what.\\n          Node leftSide = next.getFirstChild();\\n          if (leftSide.isName() ||\\n              leftSide.isGetProp() &&\\n              leftSide.getFirstChild().isThis()) {\\n            \/\/ Dive down the right side of the assign.\\n            parent = next;\\n            next = leftSide.getNext();\\n            break;\\n          } else {\\n            return false;\\n          }\\n\\n        default:\\n          if (NodeUtil.isImmutableValue(next)\\n              && next.isEquivalentTo(value)) {\\n            \/\/ If the r-value of the expr assign is an immutable value,\\n            \/\/ and the value is used again shortly, then we can exploit\\n            \/\/ the assign here.\\n            exprParent.removeChild(expr);\\n            expr.removeChild(assign);\\n            parent.replaceChild(next, assign);\\n            return true;\\n          }\\n          \/\/ Return without inlining a thing\\n          return false;\\n      }\\n    }\\n\\n    return false;\\n  }\", \"javadoc_start_line\": 93, \"annotations_start_line\": 108, \"method_start_line\": 109, \"end_line\": 199}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/ExploitAssigns.java\", \"method_name\": \"isSafeReplacement\", \"content\": \"  \/**\\n   * Checks name referenced in node to determine if it might have\\n   * changed.\\n   * @return Whether the replacement can be made.\\n   *\/\\n  private boolean isSafeReplacement(Node node, Node replacement) {\\n    \/\/ No checks are needed for simple names.\\n    if (node.isName()) {\\n      return true;\\n    }\\n    Preconditions.checkArgument(node.isGetProp());\\n\\n      node = node.getFirstChild();\\n    if (node.isName()\\n        && isNameAssignedTo(node.getString(), replacement)) {\\n      return false;\\n    }\\n\\n    return true;\\n  }\", \"javadoc_start_line\": 201, \"annotations_start_line\": 206, \"method_start_line\": 206, \"end_line\": 220}"}]},{"name":"Closure","version":126,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.MinimizeExitPointsTest\", \"methodName\": \"testDontRemoveBreakInTryFinally\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/MinimizeExitPoints.java\", \"method_name\": \"tryMinimizeExits\", \"content\": \"  \/**\\n   * Attempts to minimize the number of explicit exit points in a control\\n   * structure to take advantage of the implied exit at the end of the\\n   * structure.  This is accomplished by removing redundant statements, and\\n   * moving statements following a qualifying IF node into that node.\\n   * For example:\\n   *\\n   * function () {\\n   *   if (x) return;\\n   *   else blah();\\n   *   foo();\\n   * }\\n   *\\n   * becomes:\\n   *\\n   * function () {\\n   *  if (x) ;\\n   *  else {\\n   *    blah();\\n   *    foo();\\n   *  }\\n   *\\n   * @param n The execution node of a parent to inspect.\\n   * @param exitType The type of exit to look for.\\n   * @param labelName If parent is a label the name of the label to look for,\\n   *   null otherwise.\\n   * @nullable labelName non-null only for breaks within labels.\\n   *\/\\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\\n\\n    \/\/ Just an 'exit'.\\n    if (matchingExitNode(n, exitType, labelName)) {\\n      NodeUtil.removeChild(n.getParent(), n);\\n      compiler.reportCodeChange();\\n      return;\\n    }\\n\\n    \/\/ Just an 'if'.\\n    if (n.isIf()) {\\n      Node ifBlock = n.getFirstChild().getNext();\\n      tryMinimizeExits(ifBlock, exitType, labelName);\\n      Node elseBlock = ifBlock.getNext();\\n      if (elseBlock != null) {\\n        tryMinimizeExits(elseBlock, exitType, labelName);\\n      }\\n      return;\\n    }\\n\\n    \/\/ Just a 'try\/catch\/finally'.\\n    if (n.isTry()) {\\n      Node tryBlock = n.getFirstChild();\\n      tryMinimizeExits(tryBlock, exitType, labelName);\\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\\n        Preconditions.checkState(allCatchNodes.hasOneChild());\\n        Node catchNode = allCatchNodes.getFirstChild();\\n        Node catchCodeBlock = catchNode.getLastChild();\\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\\n      }\\n      \/* Don't try to minimize the exits of finally blocks, as this\\n       * can cause problems if it changes the completion type of the finally\\n       * block. See ECMA 262 Sections 8.9 & 12.14\\n       *\/\\n      if (NodeUtil.hasFinally(n)) {\\n        Node finallyBlock = n.getLastChild();\\n        tryMinimizeExits(finallyBlock, exitType, labelName);\\n      }\\n    }\\n\\n    \/\/ Just a 'label'.\\n    if (n.isLabel()) {\\n      Node labelBlock = n.getLastChild();\\n      tryMinimizeExits(labelBlock, exitType, labelName);\\n    }\\n\\n    \/\/ TODO(johnlenz): The last case of SWITCH statement?\\n\\n    \/\/ The rest assumes a block with at least one child, bail on anything else.\\n    if (!n.isBlock() || n.getLastChild() == null) {\\n      return;\\n    }\\n\\n    \/\/ Multiple if-exits can be converted in a single pass.\\n    \/\/ Convert \\\"if (blah) break;  if (blah2) break; other_stmt;\\\" to\\n    \/\/ become \\\"if (blah); else { if (blah2); else { other_stmt; } }\\\"\\n    \/\/ which will get converted to \\\"if (!blah && !blah2) { other_stmt; }\\\".\\n    for (Node c : n.children()) {\\n\\n      \/\/ An 'if' block to process below.\\n      if (c.isIf()) {\\n        Node ifTree = c;\\n        Node trueBlock, falseBlock;\\n\\n        \/\/ First, the true condition block.\\n        trueBlock = ifTree.getFirstChild().getNext();\\n        falseBlock = trueBlock.getNext();\\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\\n            ifTree, exitType, labelName);\\n\\n        \/\/ Now the else block.\\n        \/\/ The if blocks may have changed, get them again.\\n        trueBlock = ifTree.getFirstChild().getNext();\\n        falseBlock = trueBlock.getNext();\\n        if (falseBlock != null) {\\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\\n              ifTree, exitType, labelName);\\n        }\\n      }\\n\\n      if (c == n.getLastChild()) {\\n        break;\\n      }\\n    }\\n\\n    \/\/ Now try to minimize the exits of the last child, if it is removed\\n    \/\/ look at what has become the last child.\\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\\n      tryMinimizeExits(c, exitType, labelName);\\n      \/\/ If the node is still the last child, we are done.\\n      if (c == n.getLastChild()) {\\n        break;\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 78, \"annotations_start_line\": 106, \"method_start_line\": 106, \"end_line\": 201}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a node recursively.\\n   *\/\\n  public static void traverse(\\n      AbstractCompiler compiler, Node root, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverse(root);\\n  }\", \"javadoc_start_line\": 483, \"annotations_start_line\": 486, \"method_start_line\": 487, \"end_line\": 490}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      inputId = NodeUtil.getInputId(root);\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      \/\/ null parent ensures that the shallow callbacks will traverse root\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 278, \"annotations_start_line\": 281, \"method_start_line\": 281, \"end_line\": 293}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 507, \"annotations_start_line\": 510, \"method_start_line\": 510, \"end_line\": 536}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 507, \"annotations_start_line\": 510, \"method_start_line\": 510, \"end_line\": 536}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 507, \"annotations_start_line\": 510, \"method_start_line\": 510, \"end_line\": 536}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/MinimizeExitPoints.java\", \"method_name\": \"visit\", \"content\": \"  public void visit(NodeTraversal t, Node n, Node parent) {\\n    switch (n.getType()) {\\n      case Token.LABEL:\\n        tryMinimizeExits(\\n            n.getLastChild(), Token.BREAK, n.getFirstChild().getString());\\n        break;\\n\\n      case Token.FOR:\\n      case Token.WHILE:\\n        tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\\n        break;\\n\\n      case Token.DO:\\n        tryMinimizeExits(NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\\n\\n        Node cond = NodeUtil.getConditionExpression(n);\\n        if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {\\n          \/\/ Normally, we wouldn't be able to optimize BREAKs inside a loop\\n          \/\/ but as we know the condition will always false, we can treat them\\n          \/\/ as we would a CONTINUE.\\n          tryMinimizeExits(n.getFirstChild(), Token.BREAK, null);\\n        }\\n        break;\\n\\n      case Token.FUNCTION:\\n        tryMinimizeExits(n.getLastChild(), Token.RETURN, null);\\n        break;\\n    }\\n  }\", \"javadoc_start_line\": 48, \"annotations_start_line\": 47, \"method_start_line\": 48, \"end_line\": 76}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/MinimizeExitPoints.java\", \"method_name\": \"tryMinimizeExits\", \"content\": \"  \/**\\n   * Attempts to minimize the number of explicit exit points in a control\\n   * structure to take advantage of the implied exit at the end of the\\n   * structure.  This is accomplished by removing redundant statements, and\\n   * moving statements following a qualifying IF node into that node.\\n   * For example:\\n   *\\n   * function () {\\n   *   if (x) return;\\n   *   else blah();\\n   *   foo();\\n   * }\\n   *\\n   * becomes:\\n   *\\n   * function () {\\n   *  if (x) ;\\n   *  else {\\n   *    blah();\\n   *    foo();\\n   *  }\\n   *\\n   * @param n The execution node of a parent to inspect.\\n   * @param exitType The type of exit to look for.\\n   * @param labelName If parent is a label the name of the label to look for,\\n   *   null otherwise.\\n   * @nullable labelName non-null only for breaks within labels.\\n   *\/\\n  void tryMinimizeExits(Node n, int exitType, String labelName) {\\n\\n    \/\/ Just an 'exit'.\\n    if (matchingExitNode(n, exitType, labelName)) {\\n      NodeUtil.removeChild(n.getParent(), n);\\n      compiler.reportCodeChange();\\n      return;\\n    }\\n\\n    \/\/ Just an 'if'.\\n    if (n.isIf()) {\\n      Node ifBlock = n.getFirstChild().getNext();\\n      tryMinimizeExits(ifBlock, exitType, labelName);\\n      Node elseBlock = ifBlock.getNext();\\n      if (elseBlock != null) {\\n        tryMinimizeExits(elseBlock, exitType, labelName);\\n      }\\n      return;\\n    }\\n\\n    \/\/ Just a 'try\/catch\/finally'.\\n    if (n.isTry()) {\\n      Node tryBlock = n.getFirstChild();\\n      tryMinimizeExits(tryBlock, exitType, labelName);\\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\\n        Preconditions.checkState(allCatchNodes.hasOneChild());\\n        Node catchNode = allCatchNodes.getFirstChild();\\n        Node catchCodeBlock = catchNode.getLastChild();\\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\\n      }\\n      \/* Don't try to minimize the exits of finally blocks, as this\\n       * can cause problems if it changes the completion type of the finally\\n       * block. See ECMA 262 Sections 8.9 & 12.14\\n       *\/\\n      if (NodeUtil.hasFinally(n)) {\\n        Node finallyBlock = n.getLastChild();\\n        tryMinimizeExits(finallyBlock, exitType, labelName);\\n      }\\n    }\\n\\n    \/\/ Just a 'label'.\\n    if (n.isLabel()) {\\n      Node labelBlock = n.getLastChild();\\n      tryMinimizeExits(labelBlock, exitType, labelName);\\n    }\\n\\n    \/\/ TODO(johnlenz): The last case of SWITCH statement?\\n\\n    \/\/ The rest assumes a block with at least one child, bail on anything else.\\n    if (!n.isBlock() || n.getLastChild() == null) {\\n      return;\\n    }\\n\\n    \/\/ Multiple if-exits can be converted in a single pass.\\n    \/\/ Convert \\\"if (blah) break;  if (blah2) break; other_stmt;\\\" to\\n    \/\/ become \\\"if (blah); else { if (blah2); else { other_stmt; } }\\\"\\n    \/\/ which will get converted to \\\"if (!blah && !blah2) { other_stmt; }\\\".\\n    for (Node c : n.children()) {\\n\\n      \/\/ An 'if' block to process below.\\n      if (c.isIf()) {\\n        Node ifTree = c;\\n        Node trueBlock, falseBlock;\\n\\n        \/\/ First, the true condition block.\\n        trueBlock = ifTree.getFirstChild().getNext();\\n        falseBlock = trueBlock.getNext();\\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\\n            ifTree, exitType, labelName);\\n\\n        \/\/ Now the else block.\\n        \/\/ The if blocks may have changed, get them again.\\n        trueBlock = ifTree.getFirstChild().getNext();\\n        falseBlock = trueBlock.getNext();\\n        if (falseBlock != null) {\\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\\n              ifTree, exitType, labelName);\\n        }\\n      }\\n\\n      if (c == n.getLastChild()) {\\n        break;\\n      }\\n    }\\n\\n    \/\/ Now try to minimize the exits of the last child, if it is removed\\n    \/\/ look at what has become the last child.\\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\\n      tryMinimizeExits(c, exitType, labelName);\\n      \/\/ If the node is still the last child, we are done.\\n      if (c == n.getLastChild()) {\\n        break;\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 78, \"annotations_start_line\": 106, \"method_start_line\": 106, \"end_line\": 201}"}]},{"name":"Closure","version":129,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.IntegrationTest\", \"methodName\": \"testIssue937\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PrepareAst.java\", \"method_name\": \"annotateCalls\", \"content\": \"    \/**\\n     * There are two types of calls we are interested in calls without explicit\\n     * \\\"this\\\" values (what we are call \\\"free\\\" calls) and direct call to eval.\\n     *\/\\n    private void annotateCalls(Node n) {\\n      Preconditions.checkState(n.isCall());\\n\\n      \/\/ Keep track of of the \\\"this\\\" context of a call.  A call without an\\n      \/\/ explicit \\\"this\\\" is a free call.\\n      Node first = n.getFirstChild();\\n\\n      \/\/ ignore cast nodes.\\n\\n      if (!NodeUtil.isGet(first)) {\\n        n.putBooleanProp(Node.FREE_CALL, true);\\n      }\\n\\n      \/\/ Keep track of the context in which eval is called. It is important\\n      \/\/ to distinguish between \\\"(0, eval)()\\\" and \\\"eval()\\\".\\n      if (first.isName() &&\\n          \\\"eval\\\".equals(first.getString())) {\\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\\n      }\\n    }\", \"javadoc_start_line\": 154, \"annotations_start_line\": 158, \"method_start_line\": 158, \"end_line\": 177}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"parseInputs\", \"content\": \"  \/**\\n   * Parses the externs and main inputs.\\n   *\\n   * @return A synthetic root node whose two children are the externs root\\n   *     and the main root\\n   *\/\\n  Node parseInputs() {\\n    boolean devMode = options.devMode != DevMode.OFF;\\n\\n    \/\/ If old roots exist (we are parsing a second time), detach each of the\\n    \/\/ individual file parse trees.\\n    if (externsRoot != null) {\\n      externsRoot.detachChildren();\\n    }\\n    if (jsRoot != null) {\\n      jsRoot.detachChildren();\\n    }\\n\\n    \/\/ Parse main JS sources.\\n    jsRoot = IR.block();\\n    jsRoot.setIsSyntheticBlock(true);\\n\\n    externsRoot = IR.block();\\n    externsRoot.setIsSyntheticBlock(true);\\n\\n    externAndJsRoot = IR.block(externsRoot, jsRoot);\\n    externAndJsRoot.setIsSyntheticBlock(true);\\n\\n    if (options.tracer.isOn()) {\\n      tracker = new PerformanceTracker(jsRoot, options.tracer);\\n      addChangeHandler(tracker.getCodeChangeHandler());\\n    }\\n\\n    Tracer tracer = newTracer(PARSING_PASS_NAME);\\n\\n    try {\\n      \/\/ Parse externs sources.\\n      for (CompilerInput input : externs) {\\n        Node n = input.getAstRoot(this);\\n        if (hasErrors()) {\\n          return null;\\n        }\\n        externsRoot.addChildToBack(n);\\n      }\\n\\n      \/\/ Modules inferred in ProcessCommonJS pass.\\n      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\\n        processAMDAndCommonJSModules();\\n      }\\n\\n      hoistExterns(externsRoot);\\n\\n      \/\/ Check if the sources need to be re-ordered.\\n      boolean staleInputs = false;\\n      if (options.dependencyOptions.needsManagement()) {\\n        for (CompilerInput input : inputs) {\\n          \/\/ Forward-declare all the provided types, so that they\\n          \/\/ are not flagged even if they are dropped from the process.\\n          for (String provide : input.getProvides()) {\\n            getTypeRegistry().forwardDeclareType(provide);\\n          }\\n        }\\n\\n        try {\\n          inputs =\\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\\n              .manageDependencies(options.dependencyOptions, inputs);\\n          staleInputs = true;\\n        } catch (CircularDependencyException e) {\\n          report(JSError.make(\\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\\n        } catch (MissingProvideException e) {\\n          report(JSError.make(\\n              MISSING_ENTRY_ERROR, e.getMessage()));\\n        } catch (JSModuleGraph.MissingModuleException e) {\\n          report(JSError.make(\\n              MISSING_MODULE_ERROR, e.getMessage()));\\n        }\\n\\n        \/\/ If in IDE mode, we ignore the error and keep going.\\n        if (hasErrors()) {\\n          return null;\\n        }\\n      }\\n\\n      hoistNoCompileFiles();\\n\\n      if (staleInputs) {\\n        repartitionInputs();\\n      }\\n\\n      \/\/ Build the AST.\\n      for (CompilerInput input : inputs) {\\n        Node n = input.getAstRoot(this);\\n        if (n == null) {\\n          continue;\\n        }\\n\\n        if (devMode) {\\n          runSanityCheck();\\n          if (hasErrors()) {\\n            return null;\\n          }\\n        }\\n\\n        if (options.sourceMapOutputPath != null ||\\n            options.nameReferenceReportPath != null) {\\n\\n          \/\/ Annotate the nodes in the tree with information from the\\n          \/\/ input file. This information is used to construct the SourceMap.\\n          SourceInformationAnnotator sia =\\n              new SourceInformationAnnotator(\\n                  input.getName(), options.devMode != DevMode.OFF);\\n          NodeTraversal.traverse(this, n, sia);\\n        }\\n\\n        jsRoot.addChildToBack(n);\\n      }\\n\\n      if (hasErrors()) {\\n        return null;\\n      }\\n      return externAndJsRoot;\\n    } finally {\\n      stopTracer(tracer, PARSING_PASS_NAME);\\n    }\\n  }\", \"javadoc_start_line\": 1294, \"annotations_start_line\": 1300, \"method_start_line\": 1300, \"end_line\": 1420}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"hoistExterns\", \"content\": \"  \/**\\n   * Hoists inputs with the @externs annotation into the externs list.\\n   *\/\\n  private void hoistExterns(Node externsRoot) {\\n    boolean staleInputs = false;\\n    for (CompilerInput input : inputs) {\\n      if (options.dependencyOptions.needsManagement()) {\\n        \/\/ If we're doing scanning dependency info anyway, use that\\n        \/\/ information to skip sources that obviously aren't externs.\\n        if (!input.getProvides().isEmpty() || !input.getRequires().isEmpty()) {\\n          continue;\\n        }\\n      }\\n\\n      Node n = input.getAstRoot(this);\\n\\n      \/\/ Inputs can have a null AST on a parse error.\\n      if (n == null) {\\n        continue;\\n      }\\n\\n      JSDocInfo info = n.getJSDocInfo();\\n      if (info != null && info.isExterns()) {\\n        \/\/ If the input file is explicitly marked as an externs file, then\\n        \/\/ assume the programmer made a mistake and throw it into\\n        \/\/ the externs pile anyways.\\n        externsRoot.addChildToBack(n);\\n        input.setIsExtern(true);\\n\\n        input.getModule().remove(input);\\n\\n        externs.add(input);\\n        staleInputs = true;\\n      }\\n    }\\n\\n    if (staleInputs) {\\n      repartitionInputs();\\n    }\\n  }\", \"javadoc_start_line\": 1422, \"annotations_start_line\": 1425, \"method_start_line\": 1425, \"end_line\": 1461}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/CompilerInput.java\", \"method_name\": \"getAstRoot\", \"content\": \"  public Node getAstRoot(AbstractCompiler compiler) {\\n    Node root = ast.getAstRoot(compiler);\\n    \/\/ The root maybe null if the AST can not be created.\\n    if (root != null) {\\n      Preconditions.checkState(root.isScript());\\n      Preconditions.checkNotNull(root.getInputId());\\n    }\\n    return root;\\n  }\", \"javadoc_start_line\": 115, \"annotations_start_line\": 114, \"method_start_line\": 115, \"end_line\": 123}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/JsAst.java\", \"method_name\": \"getAstRoot\", \"content\": \"  public Node getAstRoot(AbstractCompiler compiler) {\\n    if (root == null) {\\n      parse(compiler);\\n      root.setInputId(inputId);\\n    }\\n    return root;\\n  }\", \"javadoc_start_line\": 50, \"annotations_start_line\": 49, \"method_start_line\": 50, \"end_line\": 56}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/JsAst.java\", \"method_name\": \"parse\", \"content\": \"  private void parse(AbstractCompiler compiler) {\\n    try {\\n      logger_.fine(\\\"Parsing: \\\" + sourceFile.getName());\\n      ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\\n          compiler.getParserConfig(),\\n          compiler.getDefaultErrorReporter(),\\n          logger_);\\n      root = result.ast;\\n      compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\\n    } catch (IOException e) {\\n      compiler.report(\\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\\n    }\\n\\n    if (root == null || compiler.hasHaltingErrors()) {\\n      \/\/ There was a parse error or IOException, so use a dummy block.\\n      root = IR.script();\\n    } else {\\n      compiler.prepareAst(root);\\n    }\\n\\n    \/\/ Set the source name so that the compiler passes can track\\n    \/\/ the source file and module.\\n    root.setStaticSourceFile(sourceFile);\\n  }\", \"javadoc_start_line\": 83, \"annotations_start_line\": 83, \"method_start_line\": 83, \"end_line\": 107}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/Compiler.java\", \"method_name\": \"prepareAst\", \"content\": \"  void prepareAst(Node root) {\\n    CompilerPass pass = new PrepareAst(this);\\n    pass.process(null, root);\\n  }\", \"javadoc_start_line\": 1961, \"annotations_start_line\": 1960, \"method_start_line\": 1961, \"end_line\": 1964}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PrepareAst.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    if (checkOnly) {\\n      normalizeNodeTypes(root);\\n    } else {\\n      \/\/ Don't perform \\\"PrepareAnnotations\\\" when doing checks as\\n      \/\/ they currently aren't valid during sanity checks.  In particular,\\n      \/\/ they DIRECT_EVAL shouldn't be applied after inlining has been\\n      \/\/ performed.\\n      if (externs != null) {\\n        NodeTraversal.traverse(\\n            compiler, externs, new PrepareAnnotations());\\n      }\\n      if (root != null) {\\n        NodeTraversal.traverse(\\n            compiler, root, new PrepareAnnotations());\\n      }\\n    }\\n  }\", \"javadoc_start_line\": 55, \"annotations_start_line\": 54, \"method_start_line\": 55, \"end_line\": 72}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a node recursively.\\n   *\/\\n  public static void traverse(\\n      AbstractCompiler compiler, Node root, Callback cb) {\\n    NodeTraversal t = new NodeTraversal(compiler, cb);\\n    t.traverse(root);\\n  }\", \"javadoc_start_line\": 484, \"annotations_start_line\": 487, \"method_start_line\": 488, \"end_line\": 491}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverse\", \"content\": \"  \/**\\n   * Traverses a parse tree recursively.\\n   *\/\\n  public void traverse(Node root) {\\n    try {\\n      inputId = NodeUtil.getInputId(root);\\n      sourceName = \\\"\\\";\\n      curNode = root;\\n      pushScope(root);\\n      \/\/ null parent ensures that the shallow callbacks will traverse root\\n      traverseBranch(root, null);\\n      popScope();\\n    } catch (Exception unexpectedException) {\\n      throwUnexpectedException(unexpectedException);\\n    }\\n  }\", \"javadoc_start_line\": 279, \"annotations_start_line\": 282, \"method_start_line\": 282, \"end_line\": 294}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 508, \"annotations_start_line\": 511, \"method_start_line\": 511, \"end_line\": 537}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 508, \"annotations_start_line\": 511, \"method_start_line\": 511, \"end_line\": 537}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/NodeTraversal.java\", \"method_name\": \"traverseBranch\", \"content\": \"  \/**\\n   * Traverses a branch.\\n   *\/\\n  private void traverseBranch(Node n, Node parent) {\\n    int type = n.getType();\\n    if (type == Token.SCRIPT) {\\n      inputId = n.getInputId();\\n      sourceName = getSourceName(n);\\n    }\\n\\n    curNode = n;\\n    if (!callback.shouldTraverse(this, n, parent)) {\\n      return;\\n    }\\n\\n    if (type == Token.FUNCTION) {\\n      traverseFunction(n, parent);\\n    } else {\\n      for (Node child = n.getFirstChild(); child != null; ) {\\n        \/\/ child could be replaced, in which case our child node\\n        \/\/ would no longer point to the true next\\n        Node next = child.getNext();\\n        traverseBranch(child, n);\\n        child = next;\\n      }\\n    }\\n\\n    curNode = n;\\n    callback.visit(this, n, parent);\\n  }\", \"javadoc_start_line\": 508, \"annotations_start_line\": 511, \"method_start_line\": 511, \"end_line\": 537}"}]},{"name":"Closure","version":132,"tour_id":0,"test":"{\"className\": \" com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntaxTest\", \"methodName\": \"testIssue925\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeSubstituteAlternateSyntax.java\", \"method_name\": \"tryMinimizeIf\", \"content\": \"  \/**\\n   * Try turning IF nodes into smaller HOOKs\\n   *\\n   * Returns the replacement for n or the original if no replacement was\\n   * necessary.\\n   *\/\\n  private Node tryMinimizeIf(Node n) {\\n\\n    Node parent = n.getParent();\\n\\n    Node cond = n.getFirstChild();\\n\\n    \/* If the condition is a literal, we'll let other\\n     * optimizations try to remove useless code.\\n     *\/\\n    if (NodeUtil.isLiteralValue(cond, true)) {\\n      return n;\\n    }\\n\\n    Node thenBranch = cond.getNext();\\n    Node elseBranch = thenBranch.getNext();\\n\\n    if (elseBranch == null) {\\n      if (isFoldableExpressBlock(thenBranch)) {\\n        Node expr = getBlockExpression(thenBranch);\\n        if (!late && isPropertyAssignmentInExpression(expr)) {\\n          \/\/ Keep opportunities for CollapseProperties such as\\n          \/\/ a.longIdentifier || a.longIdentifier = ... -> var a = ...;\\n          \/\/ until CollapseProperties has been run.\\n          return n;\\n        }\\n\\n        if (cond.isNot()) {\\n          \/\/ if(!x)bar(); -> x||bar();\\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\\n                  OR_PRECEDENCE)) {\\n            \/\/ It's not okay to add two sets of parentheses.\\n            return n;\\n          }\\n\\n          Node or = IR.or(\\n              cond.removeFirstChild(),\\n              expr.removeFirstChild()).srcref(n);\\n          Node newExpr = NodeUtil.newExpr(or);\\n          parent.replaceChild(n, newExpr);\\n          reportCodeChange();\\n\\n          return newExpr;\\n        }\\n\\n        \/\/ if(x)foo(); -> x&&foo();\\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\\n                AND_PRECEDENCE)) {\\n          \/\/ One additional set of parentheses is worth the change even if\\n          \/\/ there is no immediate code size win. However, two extra pair of\\n          \/\/ {}, we would have to think twice. (unless we know for sure the\\n          \/\/ we can further optimize its parent.\\n          return n;\\n        }\\n\\n        n.removeChild(cond);\\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\\n        Node newExpr = NodeUtil.newExpr(and);\\n        parent.replaceChild(n, newExpr);\\n        reportCodeChange();\\n\\n        return newExpr;\\n      } else {\\n\\n        \/\/ Try to combine two IF-ELSE\\n        if (NodeUtil.isStatementBlock(thenBranch) &&\\n            thenBranch.hasOneChild()) {\\n          Node innerIf = thenBranch.getFirstChild();\\n\\n          if (innerIf.isIf()) {\\n            Node innerCond = innerIf.getFirstChild();\\n            Node innerThenBranch = innerCond.getNext();\\n            Node innerElseBranch = innerThenBranch.getNext();\\n\\n            if (innerElseBranch == null &&\\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\\n              n.detachChildren();\\n              n.addChildToBack(\\n                  IR.and(\\n                      cond,\\n                      innerCond.detachFromParent())\\n                      .srcref(cond));\\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\\n              reportCodeChange();\\n              \/\/ Not worth trying to fold the current IF-ELSE into && because\\n              \/\/ the inner IF-ELSE wasn't able to be folded into && anyways.\\n              return n;\\n            }\\n          }\\n        }\\n      }\\n\\n      return n;\\n    }\\n\\n    \/* TODO(dcc) This modifies the siblings of n, which is undesirable for a\\n     * peephole optimization. This should probably get moved to another pass.\\n     *\/\\n    tryRemoveRepeatedStatements(n);\\n\\n    \/\/ if(!x)foo();else bar(); -> if(x)bar();else foo();\\n    \/\/ An additional set of curly braces isn't worth it.\\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\\n      n.replaceChild(cond, cond.removeFirstChild());\\n      n.removeChild(thenBranch);\\n      n.addChildToBack(thenBranch);\\n      reportCodeChange();\\n      return n;\\n    }\\n\\n    \/\/ if(x)return 1;else return 2; -> return x?1:2;\\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\\n      Node thenExpr = getBlockReturnExpression(thenBranch);\\n      Node elseExpr = getBlockReturnExpression(elseBranch);\\n      n.removeChild(cond);\\n      thenExpr.detachFromParent();\\n      elseExpr.detachFromParent();\\n\\n      \/\/ note - we ignore any cases with \\\"return;\\\", technically this\\n      \/\/ can be converted to \\\"return undefined;\\\" or some variant, but\\n      \/\/ that does not help code size.\\n      Node returnNode = IR.returnNode(\\n                            IR.hook(cond, thenExpr, elseExpr)\\n                                .srcref(n));\\n      parent.replaceChild(n, returnNode);\\n      reportCodeChange();\\n      return returnNode;\\n    }\\n\\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\\n\\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\\n      if (thenOp.getType() == elseOp.getType()) {\\n        \/\/ if(x)a=1;else a=2; -> a=x?1:2;\\n        if (NodeUtil.isAssignmentOp(thenOp)) {\\n          Node lhs = thenOp.getFirstChild();\\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\\n              \/\/ if LHS has side effects, don't proceed [since the optimization\\n              \/\/ evaluates LHS before cond]\\n              \/\/ NOTE - there are some circumstances where we can\\n              \/\/ proceed even if there are side effects...\\n              !mayEffectMutableState(lhs)) {\\n\\n            n.removeChild(cond);\\n            Node assignName = thenOp.removeFirstChild();\\n            Node thenExpr = thenOp.removeFirstChild();\\n            Node elseExpr = elseOp.getLastChild();\\n            elseOp.removeChild(elseExpr);\\n\\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\\n                              .srcref(thenOp);\\n            Node expr = NodeUtil.newExpr(assign);\\n            parent.replaceChild(n, expr);\\n            reportCodeChange();\\n\\n            return expr;\\n          }\\n        }\\n      }\\n      \/\/ if(x)foo();else bar(); -> x?foo():bar()\\n      n.removeChild(cond);\\n      thenOp.detachFromParent();\\n      elseOp.detachFromParent();\\n      Node expr = IR.exprResult(\\n          IR.hook(cond, thenOp, elseOp).srcref(n));\\n      parent.replaceChild(n, expr);\\n      reportCodeChange();\\n      return expr;\\n    }\\n\\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\\n\\n    \/\/ if(x)var y=1;else y=2  ->  var y=x?1:2\\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\\n\\n      Node var = getBlockVar(thenBranch);\\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\\n\\n      Node name1 = var.getFirstChild();\\n      Node maybeName2 = elseAssign.getFirstChild();\\n\\n      if (name1.hasChildren()\\n          && maybeName2.isName()\\n          && name1.getString().equals(maybeName2.getString())) {\\n        Node thenExpr = name1.removeChildren();\\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\\n        cond.detachFromParent();\\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\\n                            .srcref(n);\\n        var.detachFromParent();\\n        name1.addChildrenToBack(hookNode);\\n        parent.replaceChild(n, var);\\n        reportCodeChange();\\n        return var;\\n      }\\n\\n    \/\/ if(x)y=1;else var y=2  ->  var y=x?1:2\\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\\n\\n      Node var = getBlockVar(elseBranch);\\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\\n\\n      Node maybeName1 = thenAssign.getFirstChild();\\n      Node name2 = var.getFirstChild();\\n\\n      if (name2.hasChildren()\\n          && maybeName1.isName()\\n          && maybeName1.getString().equals(name2.getString())) {\\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\\n        Node elseExpr = name2.removeChildren();\\n        cond.detachFromParent();\\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\\n                            .srcref(n);\\n        var.detachFromParent();\\n        name2.addChildrenToBack(hookNode);\\n        parent.replaceChild(n, var);\\n        reportCodeChange();\\n\\n        return var;\\n      }\\n    }\\n\\n    return n;\\n  }\", \"javadoc_start_line\": 630, \"annotations_start_line\": 636, \"method_start_line\": 636, \"end_line\": 868}","steps":[{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"process\", \"content\": \"  public void process(Node externs, Node root) {\\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\\n    compiler.addChangeHandler(handler);\\n    beginTraversal();\\n    traverse(root);\\n    endTraversal();\\n    compiler.removeChangeHandler(handler);\\n  }\", \"javadoc_start_line\": 111, \"annotations_start_line\": 110, \"method_start_line\": 111, \"end_line\": 118}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while (c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 120, \"annotations_start_line\": 120, \"method_start_line\": 120, \"end_line\": 145}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while (c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 120, \"annotations_start_line\": 120, \"method_start_line\": 120, \"end_line\": 145}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"traverse\", \"content\": \"  private void traverse(Node node) {\\n    \/\/ The goal here is to avoid retraversing\\n    \/\/ the entire AST to catch newly created opportunities.\\n    \/\/ So we track whether a \\\"unit of code\\\" has changed,\\n    \/\/ and revisit immediately.\\n    if (!shouldVisit(node)) {\\n      return;\\n    }\\n\\n    int visits = 0;\\n    do {\\n      Node c = node.getFirstChild();\\n      while (c != null) {\\n        Node next = c.getNext();\\n        traverse(c);\\n        c = next;\\n      }\\n\\n      visit(node);\\n      visits++;\\n\\n      Preconditions.checkState(visits < 10000, \\\"too many interations\\\");\\n    } while (shouldRetraverse(node));\\n\\n    exitNode(node);\\n  }\", \"javadoc_start_line\": 120, \"annotations_start_line\": 120, \"method_start_line\": 120, \"end_line\": 145}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeOptimizationsPass.java\", \"method_name\": \"visit\", \"content\": \"  public void visit(Node n) {\\n    Node currentVersionOfNode = n;\\n    boolean somethingChanged = false;\\n\\n    do {\\n      somethingChanged = false;\\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\\n        Node newVersionOfNode =\\n            optimization.optimizeSubtree(currentVersionOfNode);\\n\\n        if (newVersionOfNode != currentVersionOfNode) {\\n          somethingChanged = true;\\n\\n          currentVersionOfNode = newVersionOfNode;\\n        }\\n\\n        if (currentVersionOfNode == null) {\\n          return;\\n        }\\n      }\\n    } while(somethingChanged);\\n  }\", \"javadoc_start_line\": 182, \"annotations_start_line\": 182, \"method_start_line\": 182, \"end_line\": 203}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeSubstituteAlternateSyntax.java\", \"method_name\": \"optimizeSubtree\", \"content\": \"  \/**\\n   * Tries apply our various peephole minimizations on the passed in node.\\n   *\/\\n  @Override\\n  @SuppressWarnings(\\\"fallthrough\\\")\\n  public Node optimizeSubtree(Node node) {\\n    switch(node.getType()) {\\n      case Token.RETURN: {\\n        Node result = tryRemoveRedundantExit(node);\\n        if (result != node) {\\n          return result;\\n        }\\n        result = tryReplaceExitWithBreak(node);\\n        if (result != node) {\\n          return result;\\n        }\\n        return tryReduceReturn(node);\\n      }\\n\\n      case Token.THROW: {\\n        Node result = tryRemoveRedundantExit(node);\\n        if (result != node) {\\n          return result;\\n        }\\n        return tryReplaceExitWithBreak(node);\\n      }\\n\\n      \/\/ TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\\n      \/\/ with MinimizeExitPoints.\\n\\n      case Token.NOT:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return tryMinimizeNot(node);\\n\\n      case Token.IF:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return tryMinimizeIf(node);\\n\\n      case Token.EXPR_RESULT:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return node;\\n\\n      case Token.HOOK:\\n        tryMinimizeCondition(node.getFirstChild());\\n        return node;\\n\\n      case Token.WHILE:\\n      case Token.DO:\\n        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\\n        return node;\\n\\n      case Token.FOR:\\n        if (!NodeUtil.isForIn(node)) {\\n          tryJoinForCondition(node);\\n          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\\n        }\\n        return node;\\n\\n      case Token.TRUE:\\n      case Token.FALSE:\\n        return reduceTrueFalse(node);\\n\\n      case Token.NEW:\\n        node = tryFoldStandardConstructors(node);\\n        if (!node.isCall()) {\\n          return node;\\n        }\\n        \/\/ Fall through on purpose because tryFoldStandardConstructors() may\\n        \/\/ convert a NEW node into a CALL node\\n      case Token.CALL:\\n        Node result =  tryFoldLiteralConstructor(node);\\n        if (result == node) {\\n          result = tryFoldSimpleFunctionCall(node);\\n          if (result == node) {\\n            result = tryFoldImmediateCallToBoundFunction(node);\\n          }\\n        }\\n        return result;\\n\\n      case Token.COMMA:\\n        return trySplitComma(node);\\n\\n      case Token.NAME:\\n        return tryReplaceUndefined(node);\\n\\n      case Token.BLOCK:\\n        return tryReplaceIf(node);\\n\\n      case Token.ARRAYLIT:\\n        return tryMinimizeArrayLiteral(node);\\n\\n      default:\\n        return node; \/\/Nothing changed\\n    }\\n  }\", \"javadoc_start_line\": 75, \"annotations_start_line\": 78, \"method_start_line\": 80, \"end_line\": 169}"},{"step":"{\"file_path\": \"\/src\/com\/google\/javascript\/jscomp\/PeepholeSubstituteAlternateSyntax.java\", \"method_name\": \"tryMinimizeIf\", \"content\": \"  \/**\\n   * Try turning IF nodes into smaller HOOKs\\n   *\\n   * Returns the replacement for n or the original if no replacement was\\n   * necessary.\\n   *\/\\n  private Node tryMinimizeIf(Node n) {\\n\\n    Node parent = n.getParent();\\n\\n    Node cond = n.getFirstChild();\\n\\n    \/* If the condition is a literal, we'll let other\\n     * optimizations try to remove useless code.\\n     *\/\\n    if (NodeUtil.isLiteralValue(cond, true)) {\\n      return n;\\n    }\\n\\n    Node thenBranch = cond.getNext();\\n    Node elseBranch = thenBranch.getNext();\\n\\n    if (elseBranch == null) {\\n      if (isFoldableExpressBlock(thenBranch)) {\\n        Node expr = getBlockExpression(thenBranch);\\n        if (!late && isPropertyAssignmentInExpression(expr)) {\\n          \/\/ Keep opportunities for CollapseProperties such as\\n          \/\/ a.longIdentifier || a.longIdentifier = ... -> var a = ...;\\n          \/\/ until CollapseProperties has been run.\\n          return n;\\n        }\\n\\n        if (cond.isNot()) {\\n          \/\/ if(!x)bar(); -> x||bar();\\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\\n                  OR_PRECEDENCE)) {\\n            \/\/ It's not okay to add two sets of parentheses.\\n            return n;\\n          }\\n\\n          Node or = IR.or(\\n              cond.removeFirstChild(),\\n              expr.removeFirstChild()).srcref(n);\\n          Node newExpr = NodeUtil.newExpr(or);\\n          parent.replaceChild(n, newExpr);\\n          reportCodeChange();\\n\\n          return newExpr;\\n        }\\n\\n        \/\/ if(x)foo(); -> x&&foo();\\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\\n                AND_PRECEDENCE)) {\\n          \/\/ One additional set of parentheses is worth the change even if\\n          \/\/ there is no immediate code size win. However, two extra pair of\\n          \/\/ {}, we would have to think twice. (unless we know for sure the\\n          \/\/ we can further optimize its parent.\\n          return n;\\n        }\\n\\n        n.removeChild(cond);\\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\\n        Node newExpr = NodeUtil.newExpr(and);\\n        parent.replaceChild(n, newExpr);\\n        reportCodeChange();\\n\\n        return newExpr;\\n      } else {\\n\\n        \/\/ Try to combine two IF-ELSE\\n        if (NodeUtil.isStatementBlock(thenBranch) &&\\n            thenBranch.hasOneChild()) {\\n          Node innerIf = thenBranch.getFirstChild();\\n\\n          if (innerIf.isIf()) {\\n            Node innerCond = innerIf.getFirstChild();\\n            Node innerThenBranch = innerCond.getNext();\\n            Node innerElseBranch = innerThenBranch.getNext();\\n\\n            if (innerElseBranch == null &&\\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\\n              n.detachChildren();\\n              n.addChildToBack(\\n                  IR.and(\\n                      cond,\\n                      innerCond.detachFromParent())\\n                      .srcref(cond));\\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\\n              reportCodeChange();\\n              \/\/ Not worth trying to fold the current IF-ELSE into && because\\n              \/\/ the inner IF-ELSE wasn't able to be folded into && anyways.\\n              return n;\\n            }\\n          }\\n        }\\n      }\\n\\n      return n;\\n    }\\n\\n    \/* TODO(dcc) This modifies the siblings of n, which is undesirable for a\\n     * peephole optimization. This should probably get moved to another pass.\\n     *\/\\n    tryRemoveRepeatedStatements(n);\\n\\n    \/\/ if(!x)foo();else bar(); -> if(x)bar();else foo();\\n    \/\/ An additional set of curly braces isn't worth it.\\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\\n      n.replaceChild(cond, cond.removeFirstChild());\\n      n.removeChild(thenBranch);\\n      n.addChildToBack(thenBranch);\\n      reportCodeChange();\\n      return n;\\n    }\\n\\n    \/\/ if(x)return 1;else return 2; -> return x?1:2;\\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\\n      Node thenExpr = getBlockReturnExpression(thenBranch);\\n      Node elseExpr = getBlockReturnExpression(elseBranch);\\n      n.removeChild(cond);\\n      thenExpr.detachFromParent();\\n      elseExpr.detachFromParent();\\n\\n      \/\/ note - we ignore any cases with \\\"return;\\\", technically this\\n      \/\/ can be converted to \\\"return undefined;\\\" or some variant, but\\n      \/\/ that does not help code size.\\n      Node returnNode = IR.returnNode(\\n                            IR.hook(cond, thenExpr, elseExpr)\\n                                .srcref(n));\\n      parent.replaceChild(n, returnNode);\\n      reportCodeChange();\\n      return returnNode;\\n    }\\n\\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\\n\\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\\n      if (thenOp.getType() == elseOp.getType()) {\\n        \/\/ if(x)a=1;else a=2; -> a=x?1:2;\\n        if (NodeUtil.isAssignmentOp(thenOp)) {\\n          Node lhs = thenOp.getFirstChild();\\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\\n              \/\/ if LHS has side effects, don't proceed [since the optimization\\n              \/\/ evaluates LHS before cond]\\n              \/\/ NOTE - there are some circumstances where we can\\n              \/\/ proceed even if there are side effects...\\n              !mayEffectMutableState(lhs)) {\\n\\n            n.removeChild(cond);\\n            Node assignName = thenOp.removeFirstChild();\\n            Node thenExpr = thenOp.removeFirstChild();\\n            Node elseExpr = elseOp.getLastChild();\\n            elseOp.removeChild(elseExpr);\\n\\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\\n            Node assign = new Node(thenOp.getType(), assignName, hookNode)\\n                              .srcref(thenOp);\\n            Node expr = NodeUtil.newExpr(assign);\\n            parent.replaceChild(n, expr);\\n            reportCodeChange();\\n\\n            return expr;\\n          }\\n        }\\n      }\\n      \/\/ if(x)foo();else bar(); -> x?foo():bar()\\n      n.removeChild(cond);\\n      thenOp.detachFromParent();\\n      elseOp.detachFromParent();\\n      Node expr = IR.exprResult(\\n          IR.hook(cond, thenOp, elseOp).srcref(n));\\n      parent.replaceChild(n, expr);\\n      reportCodeChange();\\n      return expr;\\n    }\\n\\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\\n\\n    \/\/ if(x)var y=1;else y=2  ->  var y=x?1:2\\n    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\\n        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\\n\\n      Node var = getBlockVar(thenBranch);\\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\\n\\n      Node name1 = var.getFirstChild();\\n      Node maybeName2 = elseAssign.getFirstChild();\\n\\n      if (name1.hasChildren()\\n          && maybeName2.isName()\\n          && name1.getString().equals(maybeName2.getString())) {\\n        Node thenExpr = name1.removeChildren();\\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\\n        cond.detachFromParent();\\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\\n                            .srcref(n);\\n        var.detachFromParent();\\n        name1.addChildrenToBack(hookNode);\\n        parent.replaceChild(n, var);\\n        reportCodeChange();\\n        return var;\\n      }\\n\\n    \/\/ if(x)y=1;else var y=2  ->  var y=x?1:2\\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\\n        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\\n\\n      Node var = getBlockVar(elseBranch);\\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\\n\\n      Node maybeName1 = thenAssign.getFirstChild();\\n      Node name2 = var.getFirstChild();\\n\\n      if (name2.hasChildren()\\n          && maybeName1.isName()\\n          && maybeName1.getString().equals(name2.getString())) {\\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\\n        Node elseExpr = name2.removeChildren();\\n        cond.detachFromParent();\\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\\n                            .srcref(n);\\n        var.detachFromParent();\\n        name2.addChildrenToBack(hookNode);\\n        parent.replaceChild(n, var);\\n        reportCodeChange();\\n\\n        return var;\\n      }\\n    }\\n\\n    return n;\\n  }\", \"javadoc_start_line\": 630, \"annotations_start_line\": 636, \"method_start_line\": 636, \"end_line\": 868}"}]},{"name":"Lang","version":6,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.StringUtilsTest\", \"methodName\": \"testEscapeSurrogatePairs\", \"error\": \"java.lang.StringIndexOutOfBoundsException\", \"message\": \"String index out of range: 2\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/text\/translate\/CharSequenceTranslator.java\", \"method_name\": \"translate\", \"content\": \"    \/**\\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \\n     * tightly coupled with the abstract method of this class. \\n     *\\n     * @param input CharSequence that is being translated\\n     * @param out Writer to translate the text to\\n     * @throws IOException if and only if the Writer produces an IOException\\n     *\/\\n    public final void translate(CharSequence input, Writer out) throws IOException {\\n        if (out == null) {\\n            throw new IllegalArgumentException(\\\"The Writer must not be null\\\");\\n        }\\n        if (input == null) {\\n            return;\\n        }\\n        int pos = 0;\\n        int len = input.length();\\n        while (pos < len) {\\n            int consumed = translate(input, pos, out);\\n            if (consumed == 0) {\\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\\n                out.write(c);\\n                pos+= c.length;\\n                continue;\\n            }\\n\/\/          \/\/ contract with translators is that they have to understand codepoints \\n\/\/          \/\/ and they just took care of a surrogate pair\\n            for (int pt = 0; pt < consumed; pt++) {\\n                pos += Character.charCount(Character.codePointAt(input, pos));\\n            }\\n        }\\n    }\", \"javadoc_start_line\": 67, \"annotations_start_line\": 75, \"method_start_line\": 75, \"end_line\": 98}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/StringUtilsTest.java\", \"method_name\": \"testEscapeSurrogatePairs\", \"content\": \"    public void testEscapeSurrogatePairs() throws Exception {\\n        assertEquals(\\\"\\\\uD83D\\\\uDE30\\\", StringEscapeUtils.escapeCsv(\\\"\\\\uD83D\\\\uDE30\\\"));\\n        \/\/ Examples from https:\/\/en.wikipedia.org\/wiki\/UTF-16\\n        assertEquals(\\\"\\\\uD800\\\\uDC00\\\", StringEscapeUtils.escapeCsv(\\\"\\\\uD800\\\\uDC00\\\"));\\n        assertEquals(\\\"\\\\uD834\\\\uDD1E\\\", StringEscapeUtils.escapeCsv(\\\"\\\\uD834\\\\uDD1E\\\"));\\n        assertEquals(\\\"\\\\uDBFF\\\\uDFFD\\\", StringEscapeUtils.escapeCsv(\\\"\\\\uDBFF\\\\uDFFD\\\"));\\n        \\n    }\", \"javadoc_start_line\": 2186, \"annotations_start_line\": 2185, \"method_start_line\": 2186, \"end_line\": 2193}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/StringEscapeUtils.java\", \"method_name\": \"escapeCsv\", \"content\": \"    \/**\\n     * <p>Returns a {@code String} value for a CSV column enclosed in double quotes,\\n     * if required.<\/p>\\n     *\\n     * <p>If the value contains a comma, newline or double quote, then the\\n     *    String value is returned enclosed in double quotes.<\/p>\\n     * <\/p>\\n     *\\n     * <p>Any double quote characters in the value are escaped with another double quote.<\/p>\\n     *\\n     * <p>If the value does not contain a comma, newline or double quote, then the\\n     *    String value is returned unchanged.<\/p>\\n     * <\/p>\\n     *\\n     * see <a href=\\\"http:\/\/en.wikipedia.org\/wiki\/Comma-separated_values\\\">Wikipedia<\/a> and\\n     * <a href=\\\"http:\/\/tools.ietf.org\/html\/rfc4180\\\">RFC 4180<\/a>.\\n     *\\n     * @param input the input CSV column String, may be null\\n     * @return the input String, enclosed in double quotes if the value contains a comma,\\n     * newline or double quote, {@code null} if null string input\\n     * @since 2.4\\n     *\/\\n    public static final String escapeCsv(String input) {\\n        return ESCAPE_CSV.translate(input);\\n    }\", \"javadoc_start_line\": 533, \"annotations_start_line\": 555, \"method_start_line\": 555, \"end_line\": 557}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/text\/translate\/CharSequenceTranslator.java\", \"method_name\": \"translate\", \"content\": \"    \/**\\n     * Helper for non-Writer usage. \\n     * @param input CharSequence to be translated\\n     * @return String output of translation\\n     *\/\\n    public final String translate(CharSequence input) {\\n        if (input == null) {\\n            return null;\\n        }\\n        try {\\n            StringWriter writer = new StringWriter(input.length() * 2);\\n            translate(input, writer);\\n            return writer.toString();\\n        } catch (IOException ioe) {\\n            \/\/ this should never ever happen while writing to a StringWriter\\n            throw new RuntimeException(ioe);\\n        }\\n    }\", \"javadoc_start_line\": 48, \"annotations_start_line\": 53, \"method_start_line\": 53, \"end_line\": 65}"}]},{"name":"Lang","version":7,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.math.NumberUtilsTest\", \"methodName\": \"testCreateNumber\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"Expected NumberFormatException\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/NumberUtils.java\", \"method_name\": \"createBigDecimal\", \"content\": \"    \/**\\n     * <p>Convert a <code>String<\/code> to a <code>BigDecimal<\/code>.<\/p>\\n     * \\n     * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\\n     *\\n     * @param str  a <code>String<\/code> to convert, may be null\\n     * @return converted <code>BigDecimal<\/code> (or null if the input is null)\\n     * @throws NumberFormatException if the value cannot be converted\\n     *\/\\n    public static BigDecimal createBigDecimal(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        \/\/ handle JDK1.3.1 bug where \\\"\\\" throws IndexOutOfBoundsException\\n        if (StringUtils.isBlank(str)) {\\n            throw new NumberFormatException(\\\"A blank string is not a valid number\\\");\\n        }\\n            \/\/ this is protection for poorness in java.lang.BigDecimal.\\n            \/\/ it accepts this as a legal value, but it does not appear \\n            \/\/ to be in specification of class. OS X Java parses it to \\n            \/\/ a wrong value.\\n        return new BigDecimal(str);\\n    }\", \"javadoc_start_line\": 704, \"annotations_start_line\": 713, \"method_start_line\": 713, \"end_line\": 726}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/math\/NumberUtilsTest.java\", \"method_name\": \"testCreateNumber\", \"content\": \"    public void testCreateNumber() {\\n        \/\/ a lot of things can go wrong\\n        assertEquals(\\\"createNumber(String) 1 failed\\\", Float.valueOf(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5\\\"));\\n        assertEquals(\\\"createNumber(String) 2 failed\\\", Integer.valueOf(\\\"12345\\\"), NumberUtils.createNumber(\\\"12345\\\"));\\n        assertEquals(\\\"createNumber(String) 3 failed\\\", Double.valueOf(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5D\\\"));\\n        assertEquals(\\\"createNumber(String) 3 failed\\\", Double.valueOf(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5d\\\"));\\n        assertEquals(\\\"createNumber(String) 4 failed\\\", Float.valueOf(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5F\\\"));\\n        assertEquals(\\\"createNumber(String) 4 failed\\\", Float.valueOf(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5f\\\"));\\n        assertEquals(\\\"createNumber(String) 5 failed\\\", Long.valueOf(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\\\"\\\"\\n            + (Integer.MAX_VALUE + 1L)));\\n        assertEquals(\\\"createNumber(String) 6 failed\\\", Long.valueOf(12345), NumberUtils.createNumber(\\\"12345L\\\"));\\n        assertEquals(\\\"createNumber(String) 6 failed\\\", Long.valueOf(12345), NumberUtils.createNumber(\\\"12345l\\\"));\\n        assertEquals(\\\"createNumber(String) 7 failed\\\", Float.valueOf(\\\"-1234.5\\\"), NumberUtils.createNumber(\\\"-1234.5\\\"));\\n        assertEquals(\\\"createNumber(String) 8 failed\\\", Integer.valueOf(\\\"-12345\\\"), NumberUtils.createNumber(\\\"-12345\\\"));\\n        assertTrue(\\\"createNumber(String) 9a failed\\\", 0xFADE == NumberUtils.createNumber(\\\"0xFADE\\\").intValue());\\n        assertTrue(\\\"createNumber(String) 9b failed\\\", 0xFADE == NumberUtils.createNumber(\\\"0Xfade\\\").intValue());\\n        assertTrue(\\\"createNumber(String) 10a failed\\\", -0xFADE == NumberUtils.createNumber(\\\"-0xFADE\\\").intValue());\\n        assertTrue(\\\"createNumber(String) 10b failed\\\", -0xFADE == NumberUtils.createNumber(\\\"-0Xfade\\\").intValue());\\n        assertEquals(\\\"createNumber(String) 11 failed\\\", Double.valueOf(\\\"1.1E200\\\"), NumberUtils.createNumber(\\\"1.1E200\\\"));\\n        assertEquals(\\\"createNumber(String) 12 failed\\\", Float.valueOf(\\\"1.1E20\\\"), NumberUtils.createNumber(\\\"1.1E20\\\"));\\n        assertEquals(\\\"createNumber(String) 13 failed\\\", Double.valueOf(\\\"-1.1E200\\\"), NumberUtils.createNumber(\\\"-1.1E200\\\"));\\n        assertEquals(\\\"createNumber(String) 14 failed\\\", Double.valueOf(\\\"1.1E-200\\\"), NumberUtils.createNumber(\\\"1.1E-200\\\"));\\n        assertEquals(\\\"createNumber(null) failed\\\", null, NumberUtils.createNumber(null));\\n        assertEquals(\\\"createNumber(String) failed\\\", new BigInteger(\\\"12345678901234567890\\\"), NumberUtils\\n                .createNumber(\\\"12345678901234567890L\\\"));\\n\\n        \/\/ jdk 1.2 doesn't support this. unsure about jdk 1.2.2\\n        if (SystemUtils.isJavaVersionAtLeast(JAVA_1_3)) {\\n            assertEquals(\\\"createNumber(String) 15 failed\\\", new BigDecimal(\\\"1.1E-700\\\"), NumberUtils\\n                    .createNumber(\\\"1.1E-700F\\\"));\\n        }\\n        assertEquals(\\\"createNumber(String) 16 failed\\\", Long.valueOf(\\\"10\\\" + Integer.MAX_VALUE), NumberUtils\\n                .createNumber(\\\"10\\\" + Integer.MAX_VALUE + \\\"L\\\"));\\n        assertEquals(\\\"createNumber(String) 17 failed\\\", Long.valueOf(\\\"10\\\" + Integer.MAX_VALUE), NumberUtils\\n                .createNumber(\\\"10\\\" + Integer.MAX_VALUE));\\n        assertEquals(\\\"createNumber(String) 18 failed\\\", new BigInteger(\\\"10\\\" + Long.MAX_VALUE), NumberUtils\\n                .createNumber(\\\"10\\\" + Long.MAX_VALUE));\\n\\n        \/\/ LANG-521\\n        assertEquals(\\\"createNumber(String) LANG-521 failed\\\", Float.valueOf(\\\"2.\\\"), NumberUtils.createNumber(\\\"2.\\\"));\\n\\n        \/\/ LANG-638\\n        assertFalse(\\\"createNumber(String) succeeded\\\", checkCreateNumber(\\\"1eE\\\"));\\n\\n        \/\/ LANG-693\\n        assertEquals(\\\"createNumber(String) LANG-693 failed\\\", Double.valueOf(Double.MAX_VALUE), NumberUtils\\n                    .createNumber(\\\"\\\" + Double.MAX_VALUE));\\n        \\n        \/\/ LANG-822\\n        \/\/ ensure that the underlying negative number would create a BigDecimal\\n        final Number bigNum = NumberUtils.createNumber(\\\"-1.1E-700F\\\");\\n        assertEquals(BigDecimal.class,bigNum.getClass());\\n        assertNotNull(bigNum);\\n\\n        \/\/ Check that the code fails to create a valid number when preceeded by -- rather than -\\n        try {\\n            NumberUtils.createNumber(\\\"--1.1E-700F\\\");\\n            fail(\\\"Expected NumberFormatException\\\");\\n        } catch (NumberFormatException nfe) {\\n            \/\/ expected\\n        }\\n    }\", \"javadoc_start_line\": 185, \"annotations_start_line\": 184, \"method_start_line\": 185, \"end_line\": 246}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/NumberUtils.java\", \"method_name\": \"createNumber\", \"content\": \"    \/**\\n     * <p>Turns a string value into a java.lang.Number.<\/p>\\n     *\\n     * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code> (lower or upper case), it\\n     * will be interpreted as a hexadecimal integer - or long, if the number of digits after the 0x\\n     * prefix is more than 8.\\n     * Values with leading <code>0<\/code>'s will not be interpreted as octal.<\/p>\\n     *\\n     * <p>Then, the value is examined for a type qualifier on the end, i.e. one of\\n     * <code>'f','F','d','D','l','L'<\/code>.  If it is found, it starts \\n     * trying to create successively larger types from the type specified\\n     * until one is found that can represent the value.<\/p>\\n     *\\n     * <p>If a type specifier is not found, it will check for a decimal point\\n     * and then try successively larger types from <code>Integer<\/code> to\\n     * <code>BigInteger<\/code> and from <code>Float<\/code> to\\n     * <code>BigDecimal<\/code>.<\/p>\\n     *\\n     * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\\n     *\\n     * <p>This method does not trim the input string, i.e., strings with leading\\n     * or trailing spaces will generate NumberFormatExceptions.<\/p>\\n     *\\n     * @param str  String containing a number, may be null\\n     * @return Number created from the string (or null if the input is null)\\n     * @throws NumberFormatException if the value cannot be converted\\n     *\/\\n    public static Number createNumber(String str) throws NumberFormatException {\\n        if (str == null) {\\n            return null;\\n        }\\n        if (StringUtils.isBlank(str)) {\\n            throw new NumberFormatException(\\\"A blank string is not a valid number\\\");\\n        }  \\n        if (str.startsWith(\\\"--\\\")) {\\n            return null;\\n        }\\n        if (str.startsWith(\\\"0x\\\") || str.startsWith(\\\"-0x\\\") || str.startsWith(\\\"0X\\\") || str.startsWith(\\\"-0X\\\")) {\\n            int hexDigits = str.length() - 2; \/\/ drop 0x\\n            if (str.startsWith(\\\"-\\\")) { \/\/ drop -\\n                hexDigits--;\\n            }\\n            if (hexDigits > 8) { \/\/ too many for an int\\n                return createLong(str);\\n            }\\n            return createInteger(str);\\n        }   \\n        char lastChar = str.charAt(str.length() - 1);\\n        String mant;\\n        String dec;\\n        String exp;\\n        int decPos = str.indexOf('.');\\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\\n\\n        if (decPos > -1) {\\n\\n            if (expPos > -1) {\\n                if (expPos < decPos || expPos > str.length()) {\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n                }\\n                dec = str.substring(decPos + 1, expPos);\\n            } else {\\n                dec = str.substring(decPos + 1);\\n            }\\n            mant = str.substring(0, decPos);\\n        } else {\\n            if (expPos > -1) {\\n                if (expPos > str.length()) {\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n                }\\n                mant = str.substring(0, expPos);\\n            } else {\\n                mant = str;\\n            }\\n            dec = null;\\n        }\\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\\n            if (expPos > -1 && expPos < str.length() - 1) {\\n                exp = str.substring(expPos + 1, str.length() - 1);\\n            } else {\\n                exp = null;\\n            }\\n            \/\/Requesting a specific type..\\n            String numeric = str.substring(0, str.length() - 1);\\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\\n            switch (lastChar) {\\n                case 'l' :\\n                case 'L' :\\n                    if (dec == null\\n                        && exp == null\\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\\n                        try {\\n                            return createLong(numeric);\\n                        } catch (NumberFormatException nfe) { \/\/ NOPMD\\n                            \/\/ Too big for a long\\n                        }\\n                        return createBigInteger(numeric);\\n\\n                    }\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n                case 'f' :\\n                case 'F' :\\n                    try {\\n                        Float f = NumberUtils.createFloat(numeric);\\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\\n                            \/\/If it's too big for a float or the float value = 0 and the string\\n                            \/\/has non-zeros in it, then float does not have the precision we want\\n                            return f;\\n                        }\\n\\n                    } catch (NumberFormatException nfe) { \/\/ NOPMD\\n                        \/\/ ignore the bad number\\n                    }\\n                    \/\/$FALL-THROUGH$\\n                case 'd' :\\n                case 'D' :\\n                    try {\\n                        Double d = NumberUtils.createDouble(numeric);\\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\\n                            return d;\\n                        }\\n                    } catch (NumberFormatException nfe) { \/\/ NOPMD\\n                        \/\/ ignore the bad number\\n                    }\\n                    try {\\n                        return createBigDecimal(numeric);\\n                    } catch (NumberFormatException e) { \/\/ NOPMD\\n                        \/\/ ignore the bad number\\n                    }\\n                    \/\/$FALL-THROUGH$\\n                default :\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n\\n            }\\n        } else {\\n            \/\/User doesn't have a preference on the return type, so let's start\\n            \/\/small and go from there...\\n            if (expPos > -1 && expPos < str.length() - 1) {\\n                exp = str.substring(expPos + 1, str.length());\\n            } else {\\n                exp = null;\\n            }\\n            if (dec == null && exp == null) {\\n                \/\/Must be an int,long,bigint\\n                try {\\n                    return createInteger(str);\\n                } catch (NumberFormatException nfe) { \/\/ NOPMD\\n                    \/\/ ignore the bad number\\n                }\\n                try {\\n                    return createLong(str);\\n                } catch (NumberFormatException nfe) { \/\/ NOPMD\\n                    \/\/ ignore the bad number\\n                }\\n                return createBigInteger(str);\\n\\n            } else {\\n                \/\/Must be a float,double,BigDec\\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\\n                try {\\n                    Float f = createFloat(str);\\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\\n                        return f;\\n                    }\\n                } catch (NumberFormatException nfe) { \/\/ NOPMD\\n                    \/\/ ignore the bad number\\n                }\\n                try {\\n                    Double d = createDouble(str);\\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\\n                        return d;\\n                    }\\n                } catch (NumberFormatException nfe) { \/\/ NOPMD\\n                    \/\/ ignore the bad number\\n                }\\n\\n                return createBigDecimal(str);\\n\\n            }\\n        }\\n    }\", \"javadoc_start_line\": 418, \"annotations_start_line\": 445, \"method_start_line\": 445, \"end_line\": 598}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/NumberUtils.java\", \"method_name\": \"createBigDecimal\", \"content\": \"    \/**\\n     * <p>Convert a <code>String<\/code> to a <code>BigDecimal<\/code>.<\/p>\\n     * \\n     * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\\n     *\\n     * @param str  a <code>String<\/code> to convert, may be null\\n     * @return converted <code>BigDecimal<\/code> (or null if the input is null)\\n     * @throws NumberFormatException if the value cannot be converted\\n     *\/\\n    public static BigDecimal createBigDecimal(String str) {\\n        if (str == null) {\\n            return null;\\n        }\\n        \/\/ handle JDK1.3.1 bug where \\\"\\\" throws IndexOutOfBoundsException\\n        if (StringUtils.isBlank(str)) {\\n            throw new NumberFormatException(\\\"A blank string is not a valid number\\\");\\n        }\\n            \/\/ this is protection for poorness in java.lang.BigDecimal.\\n            \/\/ it accepts this as a legal value, but it does not appear \\n            \/\/ to be in specification of class. OS X Java parses it to \\n            \/\/ a wrong value.\\n        return new BigDecimal(str);\\n    }\", \"javadoc_start_line\": 704, \"annotations_start_line\": 713, \"method_start_line\": 713, \"end_line\": 726}"}]},{"name":"Lang","version":8,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.time.FastDateFormat_PrinterTest\", \"methodName\": \"testCalendarTimezoneRespected\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<11:03PM [CL]T> but was:<11:03PM [PS]T>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDatePrinter.java\", \"method_name\": \"appendTo\", \"content\": \"        \/**\\n         * {@inheritDoc}\\n         *\/\\n        @Override\\n        public void appendTo(StringBuffer buffer, Calendar calendar) {\\n            if (zone.useDaylightTime()\\n                    && calendar.get(Calendar.DST_OFFSET) != 0) {\\n                buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\\n            } else {\\n                buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\\n            }\\n        }\", \"javadoc_start_line\": 1129, \"annotations_start_line\": 1132, \"method_start_line\": 1133, \"end_line\": 1140}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/time\/FastDatePrinterTest.java\", \"method_name\": \"testCalendarTimezoneRespected\", \"content\": \"    public void testCalendarTimezoneRespected() {\\n        String[] availableZones = TimeZone.getAvailableIDs();\\n        TimeZone currentZone = TimeZone.getDefault();\\n        \\n        TimeZone anotherZone = null;\\n        for (String zone : availableZones) {\\n            if (!zone.equals(currentZone.getID())) {\\n                anotherZone = TimeZone.getTimeZone(zone);\\n            }\\n        }\\n        \\n        assertNotNull(\\\"Cannot find another timezone\\\", anotherZone);\\n        \\n        final String pattern = \\\"h:mma z\\\";\\n        final Calendar cal = Calendar.getInstance(anotherZone);\\n        \\n        SimpleDateFormat sdf = new SimpleDateFormat(pattern);\\n        sdf.setTimeZone(anotherZone);\\n        String expectedValue = sdf.format(cal.getTime());\\n        String actualValue = FastDateFormat.getInstance(pattern).format(cal);\\n        assertEquals(expectedValue, actualValue);\\n    }\", \"javadoc_start_line\": 266, \"annotations_start_line\": 265, \"method_start_line\": 266, \"end_line\": 287}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateFormat.java\", \"method_name\": \"format\", \"content\": \"    \/**\\n     * <p>Formats a {@code Calendar} object.<\/p>\\n     *\\n     * @param calendar  the calendar to format\\n     * @return the formatted string\\n     *\/\\n    @Override\\n    public String format(Calendar calendar) {\\n        return printer.format(calendar);\\n    }\", \"javadoc_start_line\": 412, \"annotations_start_line\": 418, \"method_start_line\": 419, \"end_line\": 421}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDatePrinter.java\", \"method_name\": \"format\", \"content\": \"    public String format(Calendar calendar) {\\n        return format(calendar, new StringBuffer(mMaxLengthEstimate)).toString();\\n    }\", \"javadoc_start_line\": 414, \"annotations_start_line\": 413, \"method_start_line\": 414, \"end_line\": 416}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDatePrinter.java\", \"method_name\": \"format\", \"content\": \"    public StringBuffer format(Calendar calendar, StringBuffer buf) {\\n        return applyRules(calendar, buf);\\n    }\", \"javadoc_start_line\": 440, \"annotations_start_line\": 439, \"method_start_line\": 440, \"end_line\": 442}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDatePrinter.java\", \"method_name\": \"applyRules\", \"content\": \"    \/**\\n     * <p>Performs the formatting by applying the rules to the\\n     * specified calendar.<\/p>\\n     *\\n     * @param calendar  the calendar to format\\n     * @param buf  the buffer to format into\\n     * @return the specified string buffer\\n     *\/\\n    protected StringBuffer applyRules(Calendar calendar, StringBuffer buf) {\\n        for (Rule rule : mRules) {\\n            rule.appendTo(buf, calendar);\\n        }\\n        return buf;\\n    }\", \"javadoc_start_line\": 444, \"annotations_start_line\": 452, \"method_start_line\": 452, \"end_line\": 457}"}]},{"name":"Lang","version":9,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.time.FastDateFormat_ParserTest\", \"methodName\": \"testLANG_832\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"Parsed dates should be equal expected:<null> but was:<Fri Jan 02 21:00:00 PST 1970>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateParser.java\", \"method_name\": \"init\", \"content\": \"    \/**\\n     * Initialize derived fields from defining fields.\\n     * This is called from constructor and from readObject (de-serialization)\\n     *\/\\n    private void init() {\\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\\n\\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\\n\\n        StringBuilder regex= new StringBuilder();\\n        List<Strategy> collector = new ArrayList<Strategy>();\\n\\n        Matcher patternMatcher= formatPattern.matcher(pattern);\\n        if(!patternMatcher.lookingAt()) {\\n            throw new IllegalArgumentException(\\\"Invalid pattern\\\");\\n        }\\n\\n        currentFormatField= patternMatcher.group();\\n        Strategy currentStrategy= getStrategy(currentFormatField);\\n        for(;;) {\\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\\n            if(!patternMatcher.lookingAt()) {\\n                nextStrategy = null;\\n                break;\\n            }\\n            String nextFormatField= patternMatcher.group();\\n            nextStrategy = getStrategy(nextFormatField);\\n            if(currentStrategy.addRegex(this, regex)) {\\n                collector.add(currentStrategy);\\n            }\\n            currentFormatField= nextFormatField;\\n            currentStrategy= nextStrategy;\\n        }\\n        if(currentStrategy.addRegex(this, regex)) {\\n            collector.add(currentStrategy);\\n        }\\n        currentFormatField= null;\\n        strategies= collector.toArray(new Strategy[collector.size()]);\\n        parsePattern= Pattern.compile(regex.toString());\\n    }\", \"javadoc_start_line\": 111, \"annotations_start_line\": 115, \"method_start_line\": 115, \"end_line\": 150}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/time\/FastDateParserTest.java\", \"method_name\": \"testLANG_832\", \"content\": \"    public void testLANG_832() throws Exception {\\n        testSdfAndFdp(\\\"'d'd\\\" ,\\\"d3\\\", false); \/\/ OK\\n        testSdfAndFdp(\\\"'d'd'\\\",\\\"d3\\\", true); \/\/ should fail (unterminated quote)\\n    }\", \"javadoc_start_line\": 346, \"annotations_start_line\": 345, \"method_start_line\": 346, \"end_line\": 349}"},{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/time\/FastDateParserTest.java\", \"method_name\": \"testSdfAndFdp\", \"content\": \"    private void testSdfAndFdp(String format, String date, boolean shouldFail)\\n            throws Exception {\\n        Date dfdp = null;\\n        Date dsdf = null;\\n        Throwable f = null;\\n        Throwable s = null;\\n\\n        try {\\n            SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);\\n            sdf.setTimeZone(NEW_YORK);\\n            dsdf = sdf.parse(date);\\n            if (shouldFail) {\\n                Assert.fail(\\\"Expected SDF failure, but got \\\" + dsdf + \\\" for [\\\"+format+\\\",\\\"+date+\\\"]\\\");\\n            }\\n        } catch (Exception e) {\\n            s = e;\\n            if (!shouldFail) {\\n                throw e;\\n            }\\n\/\/            System.out.println(\\\"sdf:\\\"+format+\\\"\/\\\"+date+\\\"=>\\\"+e);\\n        }\\n\\n        try {\\n            DateParser fdp = getInstance(format, NEW_YORK, Locale.US);\\n            dfdp = fdp.parse(date);\\n            if (shouldFail) {\\n                Assert.fail(\\\"Expected FDF failure, but got \\\" + dfdp + \\\" for [\\\"+format+\\\",\\\"+date+\\\"] using \\\"+((FastDateParser)fdp).getParsePattern());\\n            }\\n        } catch (Exception e) {\\n            f = e;\\n            if (!shouldFail) {\\n                throw e;\\n            }\\n\/\/            System.out.println(\\\"fdf:\\\"+format+\\\"\/\\\"+date+\\\"=>\\\"+e);\\n        }\\n        \/\/ SDF and FDF should produce equivalent results\\n        assertTrue(\\\"Should both or neither throw Exceptions\\\", (f==null)==(s==null));\\n        assertEquals(\\\"Parsed dates should be equal\\\", dsdf, dfdp);\\n    }\", \"javadoc_start_line\": 356, \"annotations_start_line\": 356, \"method_start_line\": 357, \"end_line\": 394}"},{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/time\/FastDateParserTest.java\", \"method_name\": \"getInstance\", \"content\": \"    \/**\\n     * Override this method in derived tests to change the construction of instances\\n     *\/\\n    protected DateParser getInstance(String format, TimeZone timeZone, Locale locale) {\\n        return new FastDateParser(format, timeZone, locale);\\n    }\", \"javadoc_start_line\": 77, \"annotations_start_line\": 80, \"method_start_line\": 80, \"end_line\": 82}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateParser.java\", \"method_name\": \"FastDateParser\", \"content\": \"    \/**\\n     * <p>Constructs a new FastDateParser.<\/p>\\n     *\\n     * @param pattern non-null {@link java.text.SimpleDateFormat} compatible\\n     *  pattern\\n     * @param timeZone non-null time zone to use\\n     * @param locale non-null locale\\n     *\/\\n    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\\n        this.pattern = pattern;\\n        this.timeZone = timeZone;\\n        this.locale = locale;\\n        init();\\n    }\", \"javadoc_start_line\": 96, \"annotations_start_line\": 104, \"method_start_line\": 104, \"end_line\": 109}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateParser.java\", \"method_name\": \"init\", \"content\": \"    \/**\\n     * Initialize derived fields from defining fields.\\n     * This is called from constructor and from readObject (de-serialization)\\n     *\/\\n    private void init() {\\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\\n\\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\\n\\n        StringBuilder regex= new StringBuilder();\\n        List<Strategy> collector = new ArrayList<Strategy>();\\n\\n        Matcher patternMatcher= formatPattern.matcher(pattern);\\n        if(!patternMatcher.lookingAt()) {\\n            throw new IllegalArgumentException(\\\"Invalid pattern\\\");\\n        }\\n\\n        currentFormatField= patternMatcher.group();\\n        Strategy currentStrategy= getStrategy(currentFormatField);\\n        for(;;) {\\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\\n            if(!patternMatcher.lookingAt()) {\\n                nextStrategy = null;\\n                break;\\n            }\\n            String nextFormatField= patternMatcher.group();\\n            nextStrategy = getStrategy(nextFormatField);\\n            if(currentStrategy.addRegex(this, regex)) {\\n                collector.add(currentStrategy);\\n            }\\n            currentFormatField= nextFormatField;\\n            currentStrategy= nextStrategy;\\n        }\\n        if(currentStrategy.addRegex(this, regex)) {\\n            collector.add(currentStrategy);\\n        }\\n        currentFormatField= null;\\n        strategies= collector.toArray(new Strategy[collector.size()]);\\n        parsePattern= Pattern.compile(regex.toString());\\n    }\", \"javadoc_start_line\": 111, \"annotations_start_line\": 115, \"method_start_line\": 115, \"end_line\": 150}"}]},{"name":"Lang","version":17,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.StringEscapeUtilsTest\", \"methodName\": \"testLang720\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"expected:<\\ud842\\udfb7[A]> but was:<\\ud842\\udfb7[?]>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/text\/translate\/CharSequenceTranslator.java\", \"method_name\": \"translate\", \"content\": \"    \/**\\n     * Translate an input onto a Writer. This is intentionally final as its algorithm is \\n     * tightly coupled with the abstract method of this class. \\n     *\\n     * @param input CharSequence that is being translated\\n     * @param out Writer to translate the text to\\n     * @throws IOException if and only if the Writer produces an IOException\\n     *\/\\n    public final void translate(CharSequence input, Writer out) throws IOException {\\n        if (out == null) {\\n            throw new IllegalArgumentException(\\\"The Writer must not be null\\\");\\n        }\\n        if (input == null) {\\n            return;\\n        }\\n        int pos = 0;\\n        int len = Character.codePointCount(input, 0, input.length());\\n        while (pos < len) {\\n            int consumed = translate(input, pos, out);\\n            if (consumed == 0) {\\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\\n                out.write(c);\\n            }\\n            else {\\n\/\/          \/\/ contract with translators is that they have to understand codepoints \\n\/\/          \/\/ and they just took care of a surrogate pair\\n            for (int pt = 0; pt < consumed; pt++) {\\n                    if (pos < len - 2) {\\n                pos += Character.charCount(Character.codePointAt(input, pos));\\n                    } else {\\n                        pos++;\\n                    }\\n                }\\n                pos--;\\n            }\\n            pos++;\\n        }\\n    }\", \"javadoc_start_line\": 67, \"annotations_start_line\": 75, \"method_start_line\": 75, \"end_line\": 104}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/StringEscapeUtilsTest.java\", \"method_name\": \"testLang720\", \"content\": \"    public void testLang720() {\\n        String input = new StringBuilder(\\\"\\\\ud842\\\\udfb7\\\").append(\\\"A\\\").toString();\\n        String escaped = StringEscapeUtils.escapeXml(input);\\n        assertEquals(input, escaped);\\n    }\", \"javadoc_start_line\": 428, \"annotations_start_line\": 428, \"method_start_line\": 428, \"end_line\": 432}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/StringEscapeUtils.java\", \"method_name\": \"escapeXml\", \"content\": \"    \/**\\n     * <p>Escapes the characters in a {@code String} using XML entities.<\/p>\\n     *\\n     * <p>For example: <tt>\\\"bread\\\" & \\\"butter\\\"<\/tt> =>\\n     * <tt>&amp;quot;bread&amp;quot; &amp;amp; &amp;quot;butter&amp;quot;<\/tt>.\\n     * <\/p>\\n     *\\n     * <p>Supports only the five basic XML entities (gt, lt, quot, amp, apos).\\n     * Does not support DTDs or external entities.<\/p>\\n     *\\n     * <p>Note that unicode characters greater than 0x7f are as of 3.0, no longer \\n     *    escaped. If you still wish this functionality, you can achieve it \\n     *    via the following: \\n     * {@code StringEscapeUtils.ESCAPE_XML.with( new UnicodeEscaper(Range.between(0x7f, Integer.MAX_VALUE)) );}<\/p>\\n     *\\n     * @param input  the {@code String} to escape, may be null\\n     * @return a new escaped {@code String}, {@code null} if null string input\\n     * @see #unescapeXml(java.lang.String)\\n     *\/\\n    public static final String escapeXml(String input) {\\n        return ESCAPE_XML.translate(input);\\n    }\", \"javadoc_start_line\": 486, \"annotations_start_line\": 505, \"method_start_line\": 505, \"end_line\": 507}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/text\/translate\/CharSequenceTranslator.java\", \"method_name\": \"translate\", \"content\": \"    \/**\\n     * Helper for non-Writer usage. \\n     * @param input CharSequence to be translated\\n     * @return String output of translation\\n     *\/\\n    public final String translate(CharSequence input) {\\n        if (input == null) {\\n            return null;\\n        }\\n        try {\\n            StringWriter writer = new StringWriter(input.length() * 2);\\n            translate(input, writer);\\n            return writer.toString();\\n        } catch (IOException ioe) {\\n            \/\/ this should never ever happen while writing to a StringWriter\\n            throw new RuntimeException(ioe);\\n        }\\n    }\", \"javadoc_start_line\": 48, \"annotations_start_line\": 53, \"method_start_line\": 53, \"end_line\": 65}"}]},{"name":"Lang","version":18,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.time.FastDateFormatTest\", \"methodName\": \"testFormat\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"expected:<AD AD AD AD 2003 [2003 03 20]03 January Jan 01 1 ...> but was:<AD AD AD AD 2003 [03 03 ]03 January Jan 01 1 ...>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateFormat.java\", \"method_name\": \"parsePattern\", \"content\": \"    \/**\\n     * <p>Returns a list of Rules given a pattern.<\/p>\\n     *\\n     * @return a {@code List} of Rule objects\\n     * @throws IllegalArgumentException if pattern is invalid\\n     *\/\\n    protected List<Rule> parsePattern() {\\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\\n        List<Rule> rules = new ArrayList<Rule>();\\n\\n        String[] ERAs = symbols.getEras();\\n        String[] months = symbols.getMonths();\\n        String[] shortMonths = symbols.getShortMonths();\\n        String[] weekdays = symbols.getWeekdays();\\n        String[] shortWeekdays = symbols.getShortWeekdays();\\n        String[] AmPmStrings = symbols.getAmPmStrings();\\n\\n        int length = mPattern.length();\\n        int[] indexRef = new int[1];\\n\\n        for (int i = 0; i < length; i++) {\\n            indexRef[0] = i;\\n            String token = parseToken(mPattern, indexRef);\\n            i = indexRef[0];\\n\\n            int tokenLen = token.length();\\n            if (tokenLen == 0) {\\n                break;\\n            }\\n\\n            Rule rule;\\n            char c = token.charAt(0);\\n\\n            switch (c) {\\n            case 'G': \/\/ era designator (text)\\n                rule = new TextField(Calendar.ERA, ERAs);\\n                break;\\n            case 'y': \/\/ year (number)\\n                if (tokenLen >= 4) {\\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\\n                } else {\\n                    rule = TwoDigitYearField.INSTANCE;\\n                }\\n                break;\\n            case 'M': \/\/ month in year (text and number)\\n                if (tokenLen >= 4) {\\n                    rule = new TextField(Calendar.MONTH, months);\\n                } else if (tokenLen == 3) {\\n                    rule = new TextField(Calendar.MONTH, shortMonths);\\n                } else if (tokenLen == 2) {\\n                    rule = TwoDigitMonthField.INSTANCE;\\n                } else {\\n                    rule = UnpaddedMonthField.INSTANCE;\\n                }\\n                break;\\n            case 'd': \/\/ day in month (number)\\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\\n                break;\\n            case 'h': \/\/ hour in am\/pm (number, 1..12)\\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\\n                break;\\n            case 'H': \/\/ hour in day (number, 0..23)\\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\\n                break;\\n            case 'm': \/\/ minute in hour (number)\\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\\n                break;\\n            case 's': \/\/ second in minute (number)\\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\\n                break;\\n            case 'S': \/\/ millisecond (number)\\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\\n                break;\\n            case 'E': \/\/ day in week (text)\\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\\n                break;\\n            case 'D': \/\/ day in year (number)\\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\\n                break;\\n            case 'F': \/\/ day of week in month (number)\\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\\n                break;\\n            case 'w': \/\/ week in year (number)\\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\\n                break;\\n            case 'W': \/\/ week in month (number)\\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\\n                break;\\n            case 'a': \/\/ am\/pm marker (text)\\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\\n                break;\\n            case 'k': \/\/ hour in day (1..24)\\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\\n                break;\\n            case 'K': \/\/ hour in am\/pm (0..11)\\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\\n                break;\\n            case 'z': \/\/ time zone (text)\\n                if (tokenLen >= 4) {\\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\\n                } else {\\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\\n                }\\n                break;\\n            case 'Z': \/\/ time zone (value)\\n                if (tokenLen == 1) {\\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\\n                } else {\\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\\n                }\\n                break;\\n            case '\\\\'': \/\/ literal text\\n                String sub = token.substring(1);\\n                if (sub.length() == 1) {\\n                    rule = new CharacterLiteral(sub.charAt(0));\\n                } else {\\n                    rule = new StringLiteral(sub);\\n                }\\n                break;\\n            default:\\n                throw new IllegalArgumentException(\\\"Illegal pattern component: \\\" + token);\\n            }\\n\\n            rules.add(rule);\\n        }\\n\\n        return rules;\\n    }\", \"javadoc_start_line\": 457, \"annotations_start_line\": 463, \"method_start_line\": 463, \"end_line\": 584}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/time\/FastDateFormatTest.java\", \"method_name\": \"testFormat\", \"content\": \"    public void testFormat() {\\n        Locale realDefaultLocale = Locale.getDefault();\\n        TimeZone realDefaultZone = TimeZone.getDefault();\\n        try {\\n            Locale.setDefault(Locale.US);\\n            TimeZone.setDefault(TimeZone.getTimeZone(\\\"America\/New_York\\\"));\\n\\n            GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\\n            GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 00, 00);\\n            Date date1 = cal1.getTime();\\n            Date date2 = cal2.getTime();\\n            long millis1 = date1.getTime();\\n            long millis2 = date2.getTime();\\n\\n            FastDateFormat fdf = FastDateFormat.getInstance(\\\"yyyy-MM-dd'T'HH:mm:ss\\\");\\n            SimpleDateFormat sdf = new SimpleDateFormat(\\\"yyyy-MM-dd'T'HH:mm:ss\\\");\\n            assertEquals(sdf.format(date1), fdf.format(date1));\\n            assertEquals(\\\"2003-01-10T15:33:20\\\", fdf.format(date1));\\n            assertEquals(\\\"2003-01-10T15:33:20\\\", fdf.format(cal1));\\n            assertEquals(\\\"2003-01-10T15:33:20\\\", fdf.format(millis1));\\n            assertEquals(\\\"2003-07-10T09:00:00\\\", fdf.format(date2));\\n            assertEquals(\\\"2003-07-10T09:00:00\\\", fdf.format(cal2));\\n            assertEquals(\\\"2003-07-10T09:00:00\\\", fdf.format(millis2));\\n\\n            fdf = FastDateFormat.getInstance(\\\"Z\\\");\\n            assertEquals(\\\"-0500\\\", fdf.format(date1));\\n            assertEquals(\\\"-0500\\\", fdf.format(cal1));\\n            assertEquals(\\\"-0500\\\", fdf.format(millis1));\\n\\n            assertEquals(\\\"-0400\\\", fdf.format(date2));\\n            assertEquals(\\\"-0400\\\", fdf.format(cal2));\\n            assertEquals(\\\"-0400\\\", fdf.format(millis2));\\n\\n            fdf = FastDateFormat.getInstance(\\\"ZZ\\\");\\n            assertEquals(\\\"-05:00\\\", fdf.format(date1));\\n            assertEquals(\\\"-05:00\\\", fdf.format(cal1));\\n            assertEquals(\\\"-05:00\\\", fdf.format(millis1));\\n\\n            assertEquals(\\\"-04:00\\\", fdf.format(date2));\\n            assertEquals(\\\"-04:00\\\", fdf.format(cal2));\\n            assertEquals(\\\"-04:00\\\", fdf.format(millis2));\\n\\n            String pattern = \\\"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\\\" +\\n                \\\" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\\\";\\n            fdf = FastDateFormat.getInstance(pattern);\\n            sdf = new SimpleDateFormat(pattern);\\n            \/\/ SDF bug fix starting with Java 7\\n            assertEquals(sdf.format(date1).replaceAll(\\\"2003 03 03 03\\\", \\\"2003 2003 03 2003\\\"), fdf.format(date1));\\n            assertEquals(sdf.format(date2).replaceAll(\\\"2003 03 03 03\\\", \\\"2003 2003 03 2003\\\"), fdf.format(date2));\\n        } finally {\\n            Locale.setDefault(realDefaultLocale);\\n            TimeZone.setDefault(realDefaultZone);\\n        }\\n    }\", \"javadoc_start_line\": 173, \"annotations_start_line\": 173, \"method_start_line\": 173, \"end_line\": 226}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateFormat.java\", \"method_name\": \"getInstance\", \"content\": \"    \/**\\n     * <p>Gets a formatter instance using the specified pattern in the\\n     * default locale.<\/p>\\n     *\\n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\\n     *  pattern\\n     * @return a pattern based date\/time formatter\\n     * @throws IllegalArgumentException if pattern is invalid\\n     *\/\\n    public static FastDateFormat getInstance(String pattern) {\\n        return cache.getInstance(pattern, null, null);\\n    }\", \"javadoc_start_line\": 149, \"annotations_start_line\": 158, \"method_start_line\": 158, \"end_line\": 160}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FormatCache.java\", \"method_name\": \"getInstance\", \"content\": \"    \/**\\n     * <p>Gets a formatter instance using the specified pattern, time zone\\n     * and locale.<\/p>\\n     * \\n     * @param pattern  {@link java.text.SimpleDateFormat} compatible\\n     *  pattern\\n     * @param timeZone  the non-null time zone\\n     * @param locale  the non-null locale\\n     * @return a pattern based date\/time formatter\\n     * @throws IllegalArgumentException if pattern is invalid\\n     *  or <code>null<\/code>\\n     *\/\\n    public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\\n        if (pattern == null) {\\n            throw new NullPointerException(\\\"pattern must not be null\\\");\\n        }\\n        if (timeZone == null) {\\n            timeZone = TimeZone.getDefault();\\n        }\\n        if (locale == null) {\\n            locale = Locale.getDefault();\\n        }\\n        MultipartKey key = new MultipartKey(pattern, timeZone, locale);\\n        F format = cInstanceCache.get(key);\\n        if (format == null) {           \\n            format = createInstance(pattern, timeZone, locale);\\n            F previousValue= cInstanceCache.putIfAbsent(key, format);\\n            if (previousValue != null) {\\n                \/\/ another thread snuck in and did the same work\\n                \/\/ we should return the instance that is in ConcurrentMap\\n                format= previousValue;              \\n            }\\n        }\\n        return format;\\n    }\", \"javadoc_start_line\": 57, \"annotations_start_line\": 69, \"method_start_line\": 69, \"end_line\": 91}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateFormat.java\", \"method_name\": \"FastDateFormat\", \"content\": \"    \/**\\n     * <p>Constructs a new FastDateFormat.<\/p>\\n     *\\n     * @param pattern  {@link java.text.SimpleDateFormat} compatible pattern\\n     * @param timeZone  non-null time zone to use\\n     * @param locale  non-null locale to use\\n     * @throws NullPointerException if pattern, timeZone, or locale is null.\\n     *\/\\n    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\\n        mPattern = pattern;\\n        mTimeZone = timeZone;\\n        mLocale = locale;\\n\\n        init();\\n    }\", \"javadoc_start_line\": 424, \"annotations_start_line\": 432, \"method_start_line\": 432, \"end_line\": 438}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateFormat.java\", \"method_name\": \"init\", \"content\": \"    \/**\\n     * <p>Initializes the instance for first use.<\/p>\\n     *\/\\n    private void init() {\\n        List<Rule> rulesList = parsePattern();\\n        mRules = rulesList.toArray(new Rule[rulesList.size()]);\\n\\n        int len = 0;\\n        for (int i=mRules.length; --i >= 0; ) {\\n            len += mRules[i].estimateLength();\\n        }\\n\\n        mMaxLengthEstimate = len;\\n    }\", \"javadoc_start_line\": 440, \"annotations_start_line\": 443, \"method_start_line\": 443, \"end_line\": 453}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/time\/FastDateFormat.java\", \"method_name\": \"parsePattern\", \"content\": \"    \/**\\n     * <p>Returns a list of Rules given a pattern.<\/p>\\n     *\\n     * @return a {@code List} of Rule objects\\n     * @throws IllegalArgumentException if pattern is invalid\\n     *\/\\n    protected List<Rule> parsePattern() {\\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\\n        List<Rule> rules = new ArrayList<Rule>();\\n\\n        String[] ERAs = symbols.getEras();\\n        String[] months = symbols.getMonths();\\n        String[] shortMonths = symbols.getShortMonths();\\n        String[] weekdays = symbols.getWeekdays();\\n        String[] shortWeekdays = symbols.getShortWeekdays();\\n        String[] AmPmStrings = symbols.getAmPmStrings();\\n\\n        int length = mPattern.length();\\n        int[] indexRef = new int[1];\\n\\n        for (int i = 0; i < length; i++) {\\n            indexRef[0] = i;\\n            String token = parseToken(mPattern, indexRef);\\n            i = indexRef[0];\\n\\n            int tokenLen = token.length();\\n            if (tokenLen == 0) {\\n                break;\\n            }\\n\\n            Rule rule;\\n            char c = token.charAt(0);\\n\\n            switch (c) {\\n            case 'G': \/\/ era designator (text)\\n                rule = new TextField(Calendar.ERA, ERAs);\\n                break;\\n            case 'y': \/\/ year (number)\\n                if (tokenLen >= 4) {\\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\\n                } else {\\n                    rule = TwoDigitYearField.INSTANCE;\\n                }\\n                break;\\n            case 'M': \/\/ month in year (text and number)\\n                if (tokenLen >= 4) {\\n                    rule = new TextField(Calendar.MONTH, months);\\n                } else if (tokenLen == 3) {\\n                    rule = new TextField(Calendar.MONTH, shortMonths);\\n                } else if (tokenLen == 2) {\\n                    rule = TwoDigitMonthField.INSTANCE;\\n                } else {\\n                    rule = UnpaddedMonthField.INSTANCE;\\n                }\\n                break;\\n            case 'd': \/\/ day in month (number)\\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\\n                break;\\n            case 'h': \/\/ hour in am\/pm (number, 1..12)\\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\\n                break;\\n            case 'H': \/\/ hour in day (number, 0..23)\\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\\n                break;\\n            case 'm': \/\/ minute in hour (number)\\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\\n                break;\\n            case 's': \/\/ second in minute (number)\\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\\n                break;\\n            case 'S': \/\/ millisecond (number)\\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\\n                break;\\n            case 'E': \/\/ day in week (text)\\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\\n                break;\\n            case 'D': \/\/ day in year (number)\\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\\n                break;\\n            case 'F': \/\/ day of week in month (number)\\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\\n                break;\\n            case 'w': \/\/ week in year (number)\\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\\n                break;\\n            case 'W': \/\/ week in month (number)\\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\\n                break;\\n            case 'a': \/\/ am\/pm marker (text)\\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\\n                break;\\n            case 'k': \/\/ hour in day (1..24)\\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\\n                break;\\n            case 'K': \/\/ hour in am\/pm (0..11)\\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\\n                break;\\n            case 'z': \/\/ time zone (text)\\n                if (tokenLen >= 4) {\\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\\n                } else {\\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\\n                }\\n                break;\\n            case 'Z': \/\/ time zone (value)\\n                if (tokenLen == 1) {\\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\\n                } else {\\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\\n                }\\n                break;\\n            case '\\\\'': \/\/ literal text\\n                String sub = token.substring(1);\\n                if (sub.length() == 1) {\\n                    rule = new CharacterLiteral(sub.charAt(0));\\n                } else {\\n                    rule = new StringLiteral(sub);\\n                }\\n                break;\\n            default:\\n                throw new IllegalArgumentException(\\\"Illegal pattern component: \\\" + token);\\n            }\\n\\n            rules.add(rule);\\n        }\\n\\n        return rules;\\n    }\", \"javadoc_start_line\": 457, \"annotations_start_line\": 463, \"method_start_line\": 463, \"end_line\": 584}"}]},{"name":"Lang","version":22,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.math.FractionTest\", \"methodName\": \"testReducedFactory_int_int\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<-1073741824> but was:<-2147483648>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/Fraction.java\", \"method_name\": \"greatestCommonDivisor\", \"content\": \"    \/**\\n     * <p>Gets the greatest common divisor of the absolute value of\\n     * two numbers, using the \\\"binary gcd\\\" method which avoids\\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\\n     * This algorithm is due to Josef Stein (1961).<\/p>\\n     *\\n     * @param u  a non-zero number\\n     * @param v  a non-zero number\\n     * @return the greatest common divisor, never zero\\n     *\/\\n    private static int greatestCommonDivisor(int u, int v) {\\n        \/\/ From Commons Math:\\n        \/\/if either operand is abs 1, return 1:\\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\\n            return 1;\\n        }\\n        \/\/ keep u and v negative, as negative integers range down to\\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\\n        \/\/ (i.e. we can't necessarily negate a negative number without\\n        \/\/ overflow)\\n        if (u>0) { u=-u; } \/\/ make u negative\\n        if (v>0) { v=-v; } \/\/ make v negative\\n        \/\/ B1. [Find power of 2]\\n        int k=0;\\n        while ((u&1)==0 && (v&1)==0 && k<31) { \/\/ while u and v are both even...\\n            u\/=2; v\/=2; k++; \/\/ cast out twos.\\n        }\\n        if (k==31) {\\n            throw new ArithmeticException(\\\"overflow: gcd is 2^31\\\");\\n        }\\n        \/\/ B2. Initialize: u and v have been divided by 2^k and at least\\n        \/\/     one is odd.\\n        int t = ((u&1)==1) ? v : -(u\/2)\/*B3*\/;\\n        \/\/ t negative: u was odd, v may be even (t replaces v)\\n        \/\/ t positive: u was even, v is odd (t replaces u)\\n        do {\\n            \/* assert u<0 && v<0; *\/\\n            \/\/ B4\/B3: cast out twos from t.\\n            while ((t&1)==0) { \/\/ while t is even..\\n                t\/=2; \/\/ cast out twos\\n            }\\n            \/\/ B5 [reset max(u,v)]\\n            if (t>0) {\\n                u = -t;\\n            } else {\\n                v = t;\\n            }\\n            \/\/ B6\/B3. at this point both u and v should be odd.\\n            t = (v - u)\/2;\\n            \/\/ |u| larger: t positive (replace u)\\n            \/\/ |v| larger: t negative (replace v)\\n        } while (t!=0);\\n        return -u*(1<<k); \/\/ gcd is u*2^k\\n    }\", \"javadoc_start_line\": 571, \"annotations_start_line\": 581, \"method_start_line\": 581, \"end_line\": 624}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/math\/FractionTest.java\", \"method_name\": \"testReducedFactory_int_int\", \"content\": \"    public void testReducedFactory_int_int() {\\n        Fraction f = null;\\n        \\n        \/\/ zero\\n        f = Fraction.getReducedFraction(0, 1);\\n        assertEquals(0, f.getNumerator());\\n        assertEquals(1, f.getDenominator());\\n        \\n        \/\/ normal\\n        f = Fraction.getReducedFraction(1, 1);\\n        assertEquals(1, f.getNumerator());\\n        assertEquals(1, f.getDenominator());\\n        \\n        f = Fraction.getReducedFraction(2, 1);\\n        assertEquals(2, f.getNumerator());\\n        assertEquals(1, f.getDenominator());\\n        \\n        \/\/ improper\\n        f = Fraction.getReducedFraction(22, 7);\\n        assertEquals(22, f.getNumerator());\\n        assertEquals(7, f.getDenominator());\\n        \\n        \/\/ negatives\\n        f = Fraction.getReducedFraction(-6, 10);\\n        assertEquals(-3, f.getNumerator());\\n        assertEquals(5, f.getDenominator());\\n        \\n        f = Fraction.getReducedFraction(6, -10);\\n        assertEquals(-3, f.getNumerator());\\n        assertEquals(5, f.getDenominator());\\n        \\n        f = Fraction.getReducedFraction(-6, -10);\\n        assertEquals(3, f.getNumerator());\\n        assertEquals(5, f.getDenominator());\\n        \\n        \/\/ zero denominator\\n        try {\\n            f = Fraction.getReducedFraction(1, 0);\\n            fail(\\\"expecting ArithmeticException\\\");\\n        } catch (ArithmeticException ex) {}\\n        \\n        try {\\n            f = Fraction.getReducedFraction(2, 0);\\n            fail(\\\"expecting ArithmeticException\\\");\\n        } catch (ArithmeticException ex) {}\\n        \\n        try {\\n            f = Fraction.getReducedFraction(-3, 0);\\n            fail(\\\"expecting ArithmeticException\\\");\\n        } catch (ArithmeticException ex) {}\\n\\n        \/\/ reduced        \\n        f = Fraction.getReducedFraction(0, 2);\\n        assertEquals(0, f.getNumerator());\\n        assertEquals(1, f.getDenominator());\\n        \\n        f = Fraction.getReducedFraction(2, 2);\\n        assertEquals(1, f.getNumerator());\\n        assertEquals(1, f.getDenominator());\\n        \\n        f = Fraction.getReducedFraction(2, 4);\\n        assertEquals(1, f.getNumerator());\\n        assertEquals(2, f.getDenominator());\\n        \\n        f = Fraction.getReducedFraction(15, 10);\\n        assertEquals(3, f.getNumerator());\\n        assertEquals(2, f.getDenominator());\\n        \\n        f = Fraction.getReducedFraction(121, 22);\\n        assertEquals(11, f.getNumerator());\\n        assertEquals(2, f.getDenominator());\\n        \\n        \/\/ Extreme values \\n        \/\/ OK, can reduce before negating\\n        f = Fraction.getReducedFraction(-2, Integer.MIN_VALUE);\\n        assertEquals(1, f.getNumerator());\\n        assertEquals(-(Integer.MIN_VALUE \/ 2), f.getDenominator());\\n        \\n        \/\/ Can't reduce, negation will throw\\n        try { \\n            f = Fraction.getReducedFraction(-7, Integer.MIN_VALUE);  \\n            fail(\\\"Expecting ArithmeticException\\\");\\n        } catch (ArithmeticException ex) {}      \\n\\n        \/\/ LANG-662\\n        f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);\\n        assertEquals(Integer.MIN_VALUE \/ 2, f.getNumerator());\\n        assertEquals(1, f.getDenominator());\\n    }\", \"javadoc_start_line\": 250, \"annotations_start_line\": 250, \"method_start_line\": 250, \"end_line\": 338}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/Fraction.java\", \"method_name\": \"getReducedFraction\", \"content\": \"    \/**\\n     * <p>Creates a reduced <code>Fraction<\/code> instance with the 2 parts\\n     * of a fraction Y\/Z.<\/p>\\n     *\\n     * <p>For example, if the input parameters represent 2\/4, then the created\\n     * fraction will be 1\/2.<\/p>\\n     *\\n     * <p>Any negative signs are resolved to be on the numerator.<\/p>\\n     *\\n     * @param numerator  the numerator, for example the three in 'three sevenths'\\n     * @param denominator  the denominator, for example the seven in 'three sevenths'\\n     * @return a new fraction instance, with the numerator and denominator reduced\\n     * @throws ArithmeticException if the denominator is <code>zero<\/code>\\n     *\/\\n    public static Fraction getReducedFraction(int numerator, int denominator) {\\n        if (denominator == 0) {\\n            throw new ArithmeticException(\\\"The denominator must not be zero\\\");\\n        }\\n        if (numerator==0) {\\n            return ZERO; \/\/ normalize zero.\\n        }\\n        \/\/ allow 2^k\/-2^31 as a valid fraction (where k>0)\\n        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\\n            numerator\/=2; denominator\/=2;\\n        }\\n        if (denominator < 0) {\\n            if (numerator==Integer.MIN_VALUE ||\\n                    denominator==Integer.MIN_VALUE) {\\n                throw new ArithmeticException(\\\"overflow: can't negate\\\");\\n            }\\n            numerator = -numerator;\\n            denominator = -denominator;\\n        }\\n        \/\/ simplify fraction.\\n        int gcd = greatestCommonDivisor(numerator, denominator);\\n        numerator \/= gcd;\\n        denominator \/= gcd;\\n        return new Fraction(numerator, denominator);\\n    }\", \"javadoc_start_line\": 200, \"annotations_start_line\": 214, \"method_start_line\": 214, \"end_line\": 238}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/Fraction.java\", \"method_name\": \"greatestCommonDivisor\", \"content\": \"    \/**\\n     * <p>Gets the greatest common divisor of the absolute value of\\n     * two numbers, using the \\\"binary gcd\\\" method which avoids\\n     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\\n     * This algorithm is due to Josef Stein (1961).<\/p>\\n     *\\n     * @param u  a non-zero number\\n     * @param v  a non-zero number\\n     * @return the greatest common divisor, never zero\\n     *\/\\n    private static int greatestCommonDivisor(int u, int v) {\\n        \/\/ From Commons Math:\\n        \/\/if either operand is abs 1, return 1:\\n        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\\n            return 1;\\n        }\\n        \/\/ keep u and v negative, as negative integers range down to\\n        \/\/ -2^31, while positive numbers can only be as large as 2^31-1\\n        \/\/ (i.e. we can't necessarily negate a negative number without\\n        \/\/ overflow)\\n        if (u>0) { u=-u; } \/\/ make u negative\\n        if (v>0) { v=-v; } \/\/ make v negative\\n        \/\/ B1. [Find power of 2]\\n        int k=0;\\n        while ((u&1)==0 && (v&1)==0 && k<31) { \/\/ while u and v are both even...\\n            u\/=2; v\/=2; k++; \/\/ cast out twos.\\n        }\\n        if (k==31) {\\n            throw new ArithmeticException(\\\"overflow: gcd is 2^31\\\");\\n        }\\n        \/\/ B2. Initialize: u and v have been divided by 2^k and at least\\n        \/\/     one is odd.\\n        int t = ((u&1)==1) ? v : -(u\/2)\/*B3*\/;\\n        \/\/ t negative: u was odd, v may be even (t replaces v)\\n        \/\/ t positive: u was even, v is odd (t replaces u)\\n        do {\\n            \/* assert u<0 && v<0; *\/\\n            \/\/ B4\/B3: cast out twos from t.\\n            while ((t&1)==0) { \/\/ while t is even..\\n                t\/=2; \/\/ cast out twos\\n            }\\n            \/\/ B5 [reset max(u,v)]\\n            if (t>0) {\\n                u = -t;\\n            } else {\\n                v = t;\\n            }\\n            \/\/ B6\/B3. at this point both u and v should be odd.\\n            t = (v - u)\/2;\\n            \/\/ |u| larger: t positive (replace u)\\n            \/\/ |v| larger: t negative (replace v)\\n        } while (t!=0);\\n        return -u*(1<<k); \/\/ gcd is u*2^k\\n    }\", \"javadoc_start_line\": 571, \"annotations_start_line\": 581, \"method_start_line\": 581, \"end_line\": 624}"}]},{"name":"Lang","version":27,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.math.NumberUtilsTest\", \"methodName\": \"testCreateNumber\", \"error\": \"java.lang.StringIndexOutOfBoundsException\", \"message\": \"String index out of range: 4\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/NumberUtils.java\", \"method_name\": \"createNumber\", \"content\": \"    \/**\\n     * <p>Turns a string value into a java.lang.Number.<\/p>\\n     *\\n     * <p>First, the value is examined for a type qualifier on the end\\n     * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts \\n     * trying to create successively larger types from the type specified\\n     * until one is found that can represent the value.<\/p>\\n     *\\n     * <p>If a type specifier is not found, it will check for a decimal point\\n     * and then try successively larger types from <code>Integer<\/code> to\\n     * <code>BigInteger<\/code> and from <code>Float<\/code> to\\n     * <code>BigDecimal<\/code>.<\/p>\\n     *\\n     * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\\n     * will be interpreted as a hexadecimal integer.  Values with leading\\n     * <code>0<\/code>'s will not be interpreted as octal.<\/p>\\n     *\\n     * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\\n     *\\n     * <p>This method does not trim the input string, i.e., strings with leading\\n     * or trailing spaces will generate NumberFormatExceptions.<\/p>\\n     *\\n     * @param str  String containing a number, may be null\\n     * @return Number created from the string\\n     * @throws NumberFormatException if the value cannot be converted\\n     *\/\\n    public static Number createNumber(String str) throws NumberFormatException {\\n        if (str == null) {\\n            return null;\\n        }\\n        if (StringUtils.isBlank(str)) {\\n            throw new NumberFormatException(\\\"A blank string is not a valid number\\\");\\n        }  \\n        if (str.startsWith(\\\"--\\\")) {\\n            \/\/ this is protection for poorness in java.lang.BigDecimal.\\n            \/\/ it accepts this as a legal value, but it does not appear \\n            \/\/ to be in specification of class. OS X Java parses it to \\n            \/\/ a wrong value.\\n            return null;\\n        }\\n        if (str.startsWith(\\\"0x\\\") || str.startsWith(\\\"-0x\\\")) {\\n            return createInteger(str);\\n        }   \\n        char lastChar = str.charAt(str.length() - 1);\\n        String mant;\\n        String dec;\\n        String exp;\\n        int decPos = str.indexOf('.');\\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\\n\\n        if (decPos > -1) {\\n\\n            if (expPos > -1) {\\n                if (expPos < decPos) {\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n                }\\n                dec = str.substring(decPos + 1, expPos);\\n            } else {\\n                dec = str.substring(decPos + 1);\\n            }\\n            mant = str.substring(0, decPos);\\n        } else {\\n            if (expPos > -1) {\\n                mant = str.substring(0, expPos);\\n            } else {\\n                mant = str;\\n            }\\n            dec = null;\\n        }\\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\\n            if (expPos > -1 && expPos < str.length() - 1) {\\n                exp = str.substring(expPos + 1, str.length() - 1);\\n            } else {\\n                exp = null;\\n            }\\n            \/\/Requesting a specific type..\\n            String numeric = str.substring(0, str.length() - 1);\\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\\n            switch (lastChar) {\\n                case 'l' :\\n                case 'L' :\\n                    if (dec == null\\n                        && exp == null\\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\\n                        try {\\n                            return createLong(numeric);\\n                        } catch (NumberFormatException nfe) {\\n                            \/\/Too big for a long\\n                        }\\n                        return createBigInteger(numeric);\\n\\n                    }\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n                case 'f' :\\n                case 'F' :\\n                    try {\\n                        Float f = NumberUtils.createFloat(numeric);\\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\\n                            \/\/If it's too big for a float or the float value = 0 and the string\\n                            \/\/has non-zeros in it, then float does not have the precision we want\\n                            return f;\\n                        }\\n\\n                    } catch (NumberFormatException nfe) {\\n                        \/\/ ignore the bad number\\n                    }\\n                    \/\/$FALL-THROUGH$\\n                case 'd' :\\n                case 'D' :\\n                    try {\\n                        Double d = NumberUtils.createDouble(numeric);\\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\\n                            return d;\\n                        }\\n                    } catch (NumberFormatException nfe) {\\n                        \/\/ ignore the bad number\\n                    }\\n                    try {\\n                        return createBigDecimal(numeric);\\n                    } catch (NumberFormatException e) {\\n                        \/\/ ignore the bad number\\n                    }\\n                    \/\/$FALL-THROUGH$\\n                default :\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n\\n            }\\n        } else {\\n            \/\/User doesn't have a preference on the return type, so let's start\\n            \/\/small and go from there...\\n            if (expPos > -1 && expPos < str.length() - 1) {\\n                exp = str.substring(expPos + 1, str.length());\\n            } else {\\n                exp = null;\\n            }\\n            if (dec == null && exp == null) {\\n                \/\/Must be an int,long,bigint\\n                try {\\n                    return createInteger(str);\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n                try {\\n                    return createLong(str);\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n                return createBigInteger(str);\\n\\n            } else {\\n                \/\/Must be a float,double,BigDec\\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\\n                try {\\n                    Float f = createFloat(str);\\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\\n                        return f;\\n                    }\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n                try {\\n                    Double d = createDouble(str);\\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\\n                        return d;\\n                    }\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n\\n                return createBigDecimal(str);\\n\\n            }\\n        }\\n    }\", \"javadoc_start_line\": 426, \"annotations_start_line\": 452, \"method_start_line\": 452, \"end_line\": 599}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/math\/NumberUtilsTest.java\", \"method_name\": \"testCreateNumber\", \"content\": \"    public void testCreateNumber() {\\n        \/\/ a lot of things can go wrong\\n        assertEquals(\\\"createNumber(String) 1 failed\\\", new Float(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5\\\"));\\n        assertEquals(\\\"createNumber(String) 2 failed\\\", new Integer(\\\"12345\\\"), NumberUtils.createNumber(\\\"12345\\\"));\\n        assertEquals(\\\"createNumber(String) 3 failed\\\", new Double(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5D\\\"));\\n        assertEquals(\\\"createNumber(String) 3 failed\\\", new Double(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5d\\\"));\\n        assertEquals(\\\"createNumber(String) 4 failed\\\", new Float(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5F\\\"));\\n        assertEquals(\\\"createNumber(String) 4 failed\\\", new Float(\\\"1234.5\\\"), NumberUtils.createNumber(\\\"1234.5f\\\"));\\n        assertEquals(\\\"createNumber(String) 5 failed\\\", new Long(Integer.MAX_VALUE + 1L), NumberUtils.createNumber(\\\"\\\"\\n            + (Integer.MAX_VALUE + 1L)));\\n        assertEquals(\\\"createNumber(String) 6 failed\\\", new Long(12345), NumberUtils.createNumber(\\\"12345L\\\"));\\n        assertEquals(\\\"createNumber(String) 6 failed\\\", new Long(12345), NumberUtils.createNumber(\\\"12345l\\\"));\\n        assertEquals(\\\"createNumber(String) 7 failed\\\", new Float(\\\"-1234.5\\\"), NumberUtils.createNumber(\\\"-1234.5\\\"));\\n        assertEquals(\\\"createNumber(String) 8 failed\\\", new Integer(\\\"-12345\\\"), NumberUtils.createNumber(\\\"-12345\\\"));\\n        assertTrue(\\\"createNumber(String) 9 failed\\\", 0xFADE == NumberUtils.createNumber(\\\"0xFADE\\\").intValue());\\n        assertTrue(\\\"createNumber(String) 10 failed\\\", -0xFADE == NumberUtils.createNumber(\\\"-0xFADE\\\").intValue());\\n        assertEquals(\\\"createNumber(String) 11 failed\\\", new Double(\\\"1.1E200\\\"), NumberUtils.createNumber(\\\"1.1E200\\\"));\\n        assertEquals(\\\"createNumber(String) 12 failed\\\", new Float(\\\"1.1E20\\\"), NumberUtils.createNumber(\\\"1.1E20\\\"));\\n        assertEquals(\\\"createNumber(String) 13 failed\\\", new Double(\\\"-1.1E200\\\"), NumberUtils.createNumber(\\\"-1.1E200\\\"));\\n        assertEquals(\\\"createNumber(String) 14 failed\\\", new Double(\\\"1.1E-200\\\"), NumberUtils.createNumber(\\\"1.1E-200\\\"));\\n        assertEquals(\\\"createNumber(null) failed\\\", null, NumberUtils.createNumber(null));\\n        assertEquals(\\\"createNumber(String) failed\\\", new BigInteger(\\\"12345678901234567890\\\"), NumberUtils\\n                .createNumber(\\\"12345678901234567890L\\\"));\\n\\n        \/\/ jdk 1.2 doesn't support this. unsure about jdk 1.2.2\\n        if (SystemUtils.isJavaVersionAtLeast(1.3f)) {\\n            assertEquals(\\\"createNumber(String) 15 failed\\\", new BigDecimal(\\\"1.1E-700\\\"), NumberUtils\\n                    .createNumber(\\\"1.1E-700F\\\"));\\n        }\\n        assertEquals(\\\"createNumber(String) 16 failed\\\", new Long(\\\"10\\\" + Integer.MAX_VALUE), NumberUtils\\n                .createNumber(\\\"10\\\" + Integer.MAX_VALUE + \\\"L\\\"));\\n        assertEquals(\\\"createNumber(String) 17 failed\\\", new Long(\\\"10\\\" + Integer.MAX_VALUE), NumberUtils\\n                .createNumber(\\\"10\\\" + Integer.MAX_VALUE));\\n        assertEquals(\\\"createNumber(String) 18 failed\\\", new BigInteger(\\\"10\\\" + Long.MAX_VALUE), NumberUtils\\n                .createNumber(\\\"10\\\" + Long.MAX_VALUE));\\n\\n        \/\/ LANG-521\\n        assertEquals(\\\"createNumber(String) LANG-521 failed\\\", new Float(\\\"2.\\\"), NumberUtils.createNumber(\\\"2.\\\"));\\n\\n        \/\/ LANG-638\\n        assertFalse(\\\"createNumber(String) succeeded\\\", checkCreateNumber(\\\"1eE\\\"));\\n    }\", \"javadoc_start_line\": 176, \"annotations_start_line\": 176, \"method_start_line\": 176, \"end_line\": 217}"},{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/math\/NumberUtilsTest.java\", \"method_name\": \"checkCreateNumber\", \"content\": \"    private boolean checkCreateNumber(String val) {\\n        try {\\n            Object obj = NumberUtils.createNumber(val);\\n            if (obj == null) {\\n                return false;\\n            }\\n            return true;\\n        } catch (NumberFormatException e) {\\n            return false;\\n       }\\n    }\", \"javadoc_start_line\": 1144, \"annotations_start_line\": 1144, \"method_start_line\": 1144, \"end_line\": 1154}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/math\/NumberUtils.java\", \"method_name\": \"createNumber\", \"content\": \"    \/**\\n     * <p>Turns a string value into a java.lang.Number.<\/p>\\n     *\\n     * <p>First, the value is examined for a type qualifier on the end\\n     * (<code>'f','F','d','D','l','L'<\/code>).  If it is found, it starts \\n     * trying to create successively larger types from the type specified\\n     * until one is found that can represent the value.<\/p>\\n     *\\n     * <p>If a type specifier is not found, it will check for a decimal point\\n     * and then try successively larger types from <code>Integer<\/code> to\\n     * <code>BigInteger<\/code> and from <code>Float<\/code> to\\n     * <code>BigDecimal<\/code>.<\/p>\\n     *\\n     * <p>If the string starts with <code>0x<\/code> or <code>-0x<\/code>, it\\n     * will be interpreted as a hexadecimal integer.  Values with leading\\n     * <code>0<\/code>'s will not be interpreted as octal.<\/p>\\n     *\\n     * <p>Returns <code>null<\/code> if the string is <code>null<\/code>.<\/p>\\n     *\\n     * <p>This method does not trim the input string, i.e., strings with leading\\n     * or trailing spaces will generate NumberFormatExceptions.<\/p>\\n     *\\n     * @param str  String containing a number, may be null\\n     * @return Number created from the string\\n     * @throws NumberFormatException if the value cannot be converted\\n     *\/\\n    public static Number createNumber(String str) throws NumberFormatException {\\n        if (str == null) {\\n            return null;\\n        }\\n        if (StringUtils.isBlank(str)) {\\n            throw new NumberFormatException(\\\"A blank string is not a valid number\\\");\\n        }  \\n        if (str.startsWith(\\\"--\\\")) {\\n            \/\/ this is protection for poorness in java.lang.BigDecimal.\\n            \/\/ it accepts this as a legal value, but it does not appear \\n            \/\/ to be in specification of class. OS X Java parses it to \\n            \/\/ a wrong value.\\n            return null;\\n        }\\n        if (str.startsWith(\\\"0x\\\") || str.startsWith(\\\"-0x\\\")) {\\n            return createInteger(str);\\n        }   \\n        char lastChar = str.charAt(str.length() - 1);\\n        String mant;\\n        String dec;\\n        String exp;\\n        int decPos = str.indexOf('.');\\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\\n\\n        if (decPos > -1) {\\n\\n            if (expPos > -1) {\\n                if (expPos < decPos) {\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n                }\\n                dec = str.substring(decPos + 1, expPos);\\n            } else {\\n                dec = str.substring(decPos + 1);\\n            }\\n            mant = str.substring(0, decPos);\\n        } else {\\n            if (expPos > -1) {\\n                mant = str.substring(0, expPos);\\n            } else {\\n                mant = str;\\n            }\\n            dec = null;\\n        }\\n        if (!Character.isDigit(lastChar) && lastChar != '.') {\\n            if (expPos > -1 && expPos < str.length() - 1) {\\n                exp = str.substring(expPos + 1, str.length() - 1);\\n            } else {\\n                exp = null;\\n            }\\n            \/\/Requesting a specific type..\\n            String numeric = str.substring(0, str.length() - 1);\\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\\n            switch (lastChar) {\\n                case 'l' :\\n                case 'L' :\\n                    if (dec == null\\n                        && exp == null\\n                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\\n                        try {\\n                            return createLong(numeric);\\n                        } catch (NumberFormatException nfe) {\\n                            \/\/Too big for a long\\n                        }\\n                        return createBigInteger(numeric);\\n\\n                    }\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n                case 'f' :\\n                case 'F' :\\n                    try {\\n                        Float f = NumberUtils.createFloat(numeric);\\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\\n                            \/\/If it's too big for a float or the float value = 0 and the string\\n                            \/\/has non-zeros in it, then float does not have the precision we want\\n                            return f;\\n                        }\\n\\n                    } catch (NumberFormatException nfe) {\\n                        \/\/ ignore the bad number\\n                    }\\n                    \/\/$FALL-THROUGH$\\n                case 'd' :\\n                case 'D' :\\n                    try {\\n                        Double d = NumberUtils.createDouble(numeric);\\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\\n                            return d;\\n                        }\\n                    } catch (NumberFormatException nfe) {\\n                        \/\/ ignore the bad number\\n                    }\\n                    try {\\n                        return createBigDecimal(numeric);\\n                    } catch (NumberFormatException e) {\\n                        \/\/ ignore the bad number\\n                    }\\n                    \/\/$FALL-THROUGH$\\n                default :\\n                    throw new NumberFormatException(str + \\\" is not a valid number.\\\");\\n\\n            }\\n        } else {\\n            \/\/User doesn't have a preference on the return type, so let's start\\n            \/\/small and go from there...\\n            if (expPos > -1 && expPos < str.length() - 1) {\\n                exp = str.substring(expPos + 1, str.length());\\n            } else {\\n                exp = null;\\n            }\\n            if (dec == null && exp == null) {\\n                \/\/Must be an int,long,bigint\\n                try {\\n                    return createInteger(str);\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n                try {\\n                    return createLong(str);\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n                return createBigInteger(str);\\n\\n            } else {\\n                \/\/Must be a float,double,BigDec\\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\\n                try {\\n                    Float f = createFloat(str);\\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\\n                        return f;\\n                    }\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n                try {\\n                    Double d = createDouble(str);\\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\\n                        return d;\\n                    }\\n                } catch (NumberFormatException nfe) {\\n                    \/\/ ignore the bad number\\n                }\\n\\n                return createBigDecimal(str);\\n\\n            }\\n        }\\n    }\", \"javadoc_start_line\": 426, \"annotations_start_line\": 452, \"method_start_line\": 452, \"end_line\": 599}"}]},{"name":"Lang","version":32,"tour_id":0,"test":"{\"className\": \" org.apache.commons.lang3.builder.HashCodeBuilderTest\", \"methodName\": \"testReflectionObjectCycle\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"Expected: <null> but was: []\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/builder\/HashCodeBuilder.java\", \"method_name\": \"unregister\", \"content\": \"    \/**\\n     * <p>\\n     * Unregisters the given object.\\n     * <\/p>\\n     * \\n     * <p>\\n     * Used by the reflection methods to avoid infinite loops.\\n     * \\n     * @param value\\n     *            The object to unregister.\\n     * @since 2.3\\n     *\/\\n    static void unregister(Object value) {\\n        getRegistry().remove(new IDKey(value));\\n    }\", \"javadoc_start_line\": 525, \"annotations_start_line\": 537, \"method_start_line\": 537, \"end_line\": 539}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/builder\/HashCodeBuilderTest.java\", \"method_name\": \"testReflectionObjectCycle\", \"content\": \"    \/**\\n     * Test Objects pointing to each other.\\n     *\/\\n    public void testReflectionObjectCycle() {\\n        ReflectionTestCycleA a = new ReflectionTestCycleA();\\n        ReflectionTestCycleB b = new ReflectionTestCycleB();\\n        a.b = b;\\n        b.a = a;\\n        \\n        \/\/ Used to caused:\\n        \/\/ java.lang.StackOverflowError\\n        \/\/ at java.lang.ClassLoader.getCallerClassLoader(Native Method)\\n        \/\/ at java.lang.Class.getDeclaredFields(Class.java:992)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:373)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\\n        \/\/ at\\n        \/\/ org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleB.hashCode(HashCodeBuilderTest.java:53)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.reflectionAppend(HashCodeBuilder.java:383)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:349)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.reflectionHashCode(HashCodeBuilder.java:155)\\n        \/\/ at\\n        \/\/ org.apache.commons.lang.builder.HashCodeBuilderTest$ReflectionTestCycleA.hashCode(HashCodeBuilderTest.java:42)\\n        \/\/ at org.apache.commons.lang.builder.HashCodeBuilder.append(HashCodeBuilder.java:422)\\n\\n        a.hashCode();\\n        assertNull(HashCodeBuilder.getRegistry());\\n        b.hashCode();\\n        assertNull(HashCodeBuilder.getRegistry());\\n    }\", \"javadoc_start_line\": 497, \"annotations_start_line\": 500, \"method_start_line\": 500, \"end_line\": 527}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/builder\/HashCodeBuilder.java\", \"method_name\": \"reflectionHashCode\", \"content\": \"    \/**\\n     * <p>\\n     * This method uses reflection to build a valid hash code.\\n     * <\/p>\\n     * \\n     * <p>\\n     * This constructor uses two hard coded choices for the constants needed to build a hash code.\\n     * <\/p>\\n     * \\n     * <p>\\n     * It uses <code>AccessibleObject.setAccessible<\/code> to gain access to private fields. This means that it will\\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\\n     * also not as efficient as testing explicitly.\\n     * <\/p>\\n     * \\n     * <p>\\n     * Transient members will be not be used, as they are likely derived fields, and not part of the value of the\\n     * <code>Object<\/code>.\\n     * <\/p>\\n     * \\n     * <p>\\n     * Static fields will not be tested. Superclass fields will be included.\\n     * <\/p>\\n     * \\n     * @param object\\n     *            the Object to create a <code>hashCode<\/code> for\\n     * @return int hash code\\n     * @throws IllegalArgumentException\\n     *             if the object is <code>null<\/code>\\n     *\/\\n    public static int reflectionHashCode(Object object) {\\n        return reflectionHashCode(17, 37, object, false, null, null);\\n    }\", \"javadoc_start_line\": 369, \"annotations_start_line\": 399, \"method_start_line\": 399, \"end_line\": 401}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/builder\/HashCodeBuilder.java\", \"method_name\": \"reflectionHashCode\", \"content\": \"    \/**\\n     * <p>\\n     * This method uses reflection to build a valid hash code.\\n     * <\/p>\\n     * \\n     * <p>\\n     * It uses <code>AccessibleObject.setAccessible<\/code> to gain access to private fields. This means that it will\\n     * throw a security exception if run under a security manager, if the permissions are not set up correctly. It is\\n     * also not as efficient as testing explicitly.\\n     * <\/p>\\n     * \\n     * <p>\\n     * If the TestTransients parameter is set to <code>true<\/code>, transient members will be tested, otherwise they\\n     * are ignored, as they are likely derived fields, and not part of the value of the <code>Object<\/code>.\\n     * <\/p>\\n     * \\n     * <p>\\n     * Static fields will not be included. Superclass fields will be included up to and including the specified\\n     * superclass. A null superclass is treated as java.lang.Object.\\n     * <\/p>\\n     * \\n     * <p>\\n     * Two randomly chosen, non-zero, odd numbers must be passed in. Ideally these should be different for each class,\\n     * however this is not vital. Prime numbers are preferred, especially for the multiplier.\\n     * <\/p>\\n     * \\n     * @param initialNonZeroOddNumber\\n     *            a non-zero, odd number used as the initial value\\n     * @param multiplierNonZeroOddNumber\\n     *            a non-zero, odd number used as the multiplier\\n     * @param object\\n     *            the Object to create a <code>hashCode<\/code> for\\n     * @param testTransients\\n     *            whether to include transient fields\\n     * @param reflectUpToClass\\n     *            the superclass to reflect up to (inclusive), may be <code>null<\/code>\\n     * @param excludeFields\\n     *            array of field names to exclude from use in calculation of hash code\\n     * @return int hash code\\n     * @throws IllegalArgumentException\\n     *             if the Object is <code>null<\/code>\\n     * @throws IllegalArgumentException\\n     *             if the number is zero or even\\n     * @since 2.0\\n     *\/\\n    public static <T> int reflectionHashCode(int initialNonZeroOddNumber, int multiplierNonZeroOddNumber, T object,\\n            boolean testTransients, Class<? super T> reflectUpToClass, String[] excludeFields) {\\n\\n        if (object == null) {\\n            throw new IllegalArgumentException(\\\"The object to build a hash code for must not be null\\\");\\n        }\\n        HashCodeBuilder builder = new HashCodeBuilder(initialNonZeroOddNumber, multiplierNonZeroOddNumber);\\n        Class<?> clazz = object.getClass();\\n        reflectionAppend(object, clazz, builder, testTransients, excludeFields);\\n        while (clazz.getSuperclass() != null && clazz != reflectUpToClass) {\\n            clazz = clazz.getSuperclass();\\n            reflectionAppend(object, clazz, builder, testTransients, excludeFields);\\n        }\\n        return builder.toHashCode();\\n    }\", \"javadoc_start_line\": 308, \"annotations_start_line\": 353, \"method_start_line\": 354, \"end_line\": 367}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/builder\/HashCodeBuilder.java\", \"method_name\": \"reflectionAppend\", \"content\": \"    \/**\\n     * <p>\\n     * Appends the fields and values defined by the given object of the given <code>Class<\/code>.\\n     * <\/p>\\n     * \\n     * @param object\\n     *            the object to append details of\\n     * @param clazz\\n     *            the class to append details of\\n     * @param builder\\n     *            the builder to append to\\n     * @param useTransients\\n     *            whether to use transient fields\\n     * @param excludeFields\\n     *            Collection of String field names to exclude from use in calculation of hash code\\n     *\/\\n    private static void reflectionAppend(Object object, Class<?> clazz, HashCodeBuilder builder, boolean useTransients,\\n            String[] excludeFields) {\\n        if (isRegistered(object)) {\\n            return;\\n        }\\n        try {\\n            register(object);\\n            Field[] fields = clazz.getDeclaredFields();\\n            AccessibleObject.setAccessible(fields, true);\\n            for (Field field : fields) {\\n                if (!ArrayUtils.contains(excludeFields, field.getName())\\n                    && (field.getName().indexOf('$') == -1)\\n                    && (useTransients || !Modifier.isTransient(field.getModifiers()))\\n                    && (!Modifier.isStatic(field.getModifiers()))) {\\n                    try {\\n                        Object fieldValue = field.get(object);\\n                        builder.append(fieldValue);\\n                    } catch (IllegalAccessException e) {\\n                        \/\/ this can't happen. Would get a Security exception instead\\n                        \/\/ throw a runtime exception in case the impossible happens.\\n                        throw new InternalError(\\\"Unexpected IllegalAccessException\\\");\\n                    }\\n                }\\n            }\\n        } finally {\\n            unregister(object);\\n        }\\n    }\", \"javadoc_start_line\": 155, \"annotations_start_line\": 171, \"method_start_line\": 172, \"end_line\": 198}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/builder\/HashCodeBuilder.java\", \"method_name\": \"unregister\", \"content\": \"    \/**\\n     * <p>\\n     * Unregisters the given object.\\n     * <\/p>\\n     * \\n     * <p>\\n     * Used by the reflection methods to avoid infinite loops.\\n     * \\n     * @param value\\n     *            The object to unregister.\\n     * @since 2.3\\n     *\/\\n    static void unregister(Object value) {\\n        getRegistry().remove(new IDKey(value));\\n    }\", \"javadoc_start_line\": 525, \"annotations_start_line\": 537, \"method_start_line\": 537, \"end_line\": 539}"}]},{"name":"Lang","version":34,"tour_id":1,"test":"{\"className\": \" org.apache.commons.lang3.builder.ToStringBuilderTest\", \"methodName\": \"testObjectCycle\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"Expected: <null> but was: {}\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/builder\/ToStringStyle.java\", \"method_name\": \"getRegistry\", \"content\": \"    \/**\\n     * <p>\\n     * Returns the registry of objects being traversed by the <code>reflectionToString<\/code>\\n     * methods in the current thread.\\n     * <\/p>\\n     *\\n     * @return Set the registry of objects being traversed\\n     *\/\\n    static Map<Object, Object> getRegistry() {\\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\\n    }\", \"javadoc_start_line\": 139, \"annotations_start_line\": 147, \"method_start_line\": 147, \"end_line\": 149}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/builder\/ToStringBuilderTest.java\", \"method_name\": \"testObjectCycle\", \"content\": \"    public void testObjectCycle() {\\n        ObjectCycle a = new ObjectCycle();\\n        ObjectCycle b = new ObjectCycle();\\n        a.obj = b;\\n        b.obj = a;\\n\\n        String expected = toBaseString(a) + \\\"[\\\" + toBaseString(b) + \\\"[\\\" + toBaseString(a) + \\\"]]\\\";\\n        assertEquals(expected, a.toString());\\n        validateNullToStringStyleRegistry();\\n    }\", \"javadoc_start_line\": 829, \"annotations_start_line\": 829, \"method_start_line\": 829, \"end_line\": 838}"},{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/lang3\/builder\/ToStringBuilderTest.java\", \"method_name\": \"validateNullToStringStyleRegistry\", \"content\": \"    void validateNullToStringStyleRegistry() {\\n       if (ToStringStyle.getRegistry() != null) {\\n           System.out.println(ToStringStyle.getRegistry());\\n       }\\n\\n        assertNull(ToStringStyle.getRegistry());\\n    }\", \"javadoc_start_line\": 581, \"annotations_start_line\": 581, \"method_start_line\": 581, \"end_line\": 587}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/lang3\/builder\/ToStringStyle.java\", \"method_name\": \"getRegistry\", \"content\": \"    \/**\\n     * <p>\\n     * Returns the registry of objects being traversed by the <code>reflectionToString<\/code>\\n     * methods in the current thread.\\n     * <\/p>\\n     *\\n     * @return Set the registry of objects being traversed\\n     *\/\\n    static Map<Object, Object> getRegistry() {\\n        return REGISTRY.get() != null ? REGISTRY.get() : Collections.<Object, Object>emptyMap();\\n    }\", \"javadoc_start_line\": 139, \"annotations_start_line\": 147, \"method_start_line\": 147, \"end_line\": 149}"}]},{"name":"Math","version":4,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math3.geometry.euclidean.threed.SubLineTest\", \"methodName\": \"testIntersectionNotIntersecting\", \"error\": \"java.lang.NullPointerException\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/geometry\/euclidean\/threed\/SubLine.java\", \"method_name\": \"intersection\", \"content\": \"    \/** Get the intersection of the instance and another sub-line.\\n     * <p>\\n     * This method is related to the {@link Line#intersection(Line)\\n     * intersection} method in the {@link Line Line} class, but in addition\\n     * to compute the point along infinite lines, it also checks the point\\n     * lies on both sub-line ranges.\\n     * <\/p>\\n     * @param subLine other sub-line which may intersect instance\\n     * @param includeEndPoints if true, endpoints are considered to belong to\\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\\n     * occurring on endpoints lead to null being returned\\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\\n     *\/\\n    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\\n\\n        \/\/ compute the intersection on infinite line\\n        Vector3D v1D = line.intersection(subLine.line);\\n\\n        \/\/ check location of point with respect to first sub-line\\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\\n\\n        \/\/ check location of point with respect to second sub-line\\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\\n\\n        if (includeEndPoints) {\\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\\n        } else {\\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\\n        }\\n\\n    }\", \"javadoc_start_line\": 96, \"annotations_start_line\": 110, \"method_start_line\": 110, \"end_line\": 127}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math3\/geometry\/euclidean\/threed\/SubLineTest.java\", \"method_name\": \"testIntersectionNotIntersecting\", \"content\": \"    public void testIntersectionNotIntersecting() throws MathIllegalArgumentException {\\n        SubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\\n        SubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));\\n        Assert.assertNull(sub1.intersection(sub2, true));\\n        Assert.assertNull(sub1.intersection(sub2, false));\\n    }\", \"javadoc_start_line\": 157, \"annotations_start_line\": 156, \"method_start_line\": 157, \"end_line\": 162}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/geometry\/euclidean\/threed\/SubLine.java\", \"method_name\": \"intersection\", \"content\": \"    \/** Get the intersection of the instance and another sub-line.\\n     * <p>\\n     * This method is related to the {@link Line#intersection(Line)\\n     * intersection} method in the {@link Line Line} class, but in addition\\n     * to compute the point along infinite lines, it also checks the point\\n     * lies on both sub-line ranges.\\n     * <\/p>\\n     * @param subLine other sub-line which may intersect instance\\n     * @param includeEndPoints if true, endpoints are considered to belong to\\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\\n     * occurring on endpoints lead to null being returned\\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\\n     *\/\\n    public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\\n\\n        \/\/ compute the intersection on infinite line\\n        Vector3D v1D = line.intersection(subLine.line);\\n\\n        \/\/ check location of point with respect to first sub-line\\n        Location loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\\n\\n        \/\/ check location of point with respect to second sub-line\\n        Location loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\\n\\n        if (includeEndPoints) {\\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\\n        } else {\\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\\n        }\\n\\n    }\", \"javadoc_start_line\": 96, \"annotations_start_line\": 110, \"method_start_line\": 110, \"end_line\": 127}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/geometry\/euclidean\/twod\/SubLine.java\", \"method_name\": \"intersection\", \"content\": \"    \/** Get the intersection of the instance and another sub-line.\\n     * <p>\\n     * This method is related to the {@link Line#intersection(Line)\\n     * intersection} method in the {@link Line Line} class, but in addition\\n     * to compute the point along infinite lines, it also checks the point\\n     * lies on both sub-line ranges.\\n     * <\/p>\\n     * @param subLine other sub-line which may intersect instance\\n     * @param includeEndPoints if true, endpoints are considered to belong to\\n     * instance (i.e. they are closed sets) and may be returned, otherwise endpoints\\n     * are considered to not belong to instance (i.e. they are open sets) and intersection\\n     * occurring on endpoints lead to null being returned\\n     * @return the intersection point if there is one, null if the sub-lines don't intersect\\n     *\/\\n    public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\\n\\n        \/\/ retrieve the underlying lines\\n        Line line1 = (Line) getHyperplane();\\n        Line line2 = (Line) subLine.getHyperplane();\\n\\n        \/\/ compute the intersection on infinite line\\n        Vector2D v2D = line1.intersection(line2);\\n\\n        \/\/ check location of point with respect to first sub-line\\n        Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\\n\\n        \/\/ check location of point with respect to second sub-line\\n        Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\\n\\n        if (includeEndPoints) {\\n            return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\\n        } else {\\n            return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\\n        }\\n\\n    }\", \"javadoc_start_line\": 96, \"annotations_start_line\": 110, \"method_start_line\": 110, \"end_line\": 131}"}]},{"name":"Math","version":23,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math3.optimization.univariate.BrentOptimizerTest\", \"methodName\": \"testKeepInitIfBest\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"Best point not reported\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/optimization\/univariate\/BrentOptimizer.java\", \"method_name\": \"doOptimize\", \"content\": \"    \/** {@inheritDoc} *\/\\n    @Override\\n    protected UnivariatePointValuePair doOptimize() {\\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\\n        final double lo = getMin();\\n        final double mid = getStartValue();\\n        final double hi = getMax();\\n\\n        \/\/ Optional additional convergence criteria.\\n        final ConvergenceChecker<UnivariatePointValuePair> checker\\n            = getConvergenceChecker();\\n\\n        double a;\\n        double b;\\n        if (lo < hi) {\\n            a = lo;\\n            b = hi;\\n        } else {\\n            a = hi;\\n            b = lo;\\n        }\\n\\n        double x = mid;\\n        double v = x;\\n        double w = x;\\n        double d = 0;\\n        double e = 0;\\n        double fx = computeObjectiveValue(x);\\n        if (!isMinim) {\\n            fx = -fx;\\n        }\\n        double fv = fx;\\n        double fw = fx;\\n\\n        UnivariatePointValuePair previous = null;\\n        UnivariatePointValuePair current\\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\\n        \/\/ Best point encountered so far (which is the initial guess).\\n\\n        int iter = 0;\\n        while (true) {\\n            final double m = 0.5 * (a + b);\\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\\n            final double tol2 = 2 * tol1;\\n\\n            \/\/ Default stopping criterion.\\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\\n            if (!stop) {\\n                double p = 0;\\n                double q = 0;\\n                double r = 0;\\n                double u = 0;\\n\\n                if (FastMath.abs(e) > tol1) { \/\/ Fit parabola.\\n                    r = (x - w) * (fx - fv);\\n                    q = (x - v) * (fx - fw);\\n                    p = (x - v) * q - (x - w) * r;\\n                    q = 2 * (q - r);\\n\\n                    if (q > 0) {\\n                        p = -p;\\n                    } else {\\n                        q = -q;\\n                    }\\n\\n                    r = e;\\n                    e = d;\\n\\n                    if (p > q * (a - x) &&\\n                        p < q * (b - x) &&\\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\\n                        \/\/ Parabolic interpolation step.\\n                        d = p \/ q;\\n                        u = x + d;\\n\\n                        \/\/ f must not be evaluated too close to a or b.\\n                        if (u - a < tol2 || b - u < tol2) {\\n                            if (x <= m) {\\n                                d = tol1;\\n                            } else {\\n                                d = -tol1;\\n                            }\\n                        }\\n                    } else {\\n                        \/\/ Golden section step.\\n                        if (x < m) {\\n                            e = b - x;\\n                        } else {\\n                            e = a - x;\\n                        }\\n                        d = GOLDEN_SECTION * e;\\n                    }\\n                } else {\\n                    \/\/ Golden section step.\\n                    if (x < m) {\\n                        e = b - x;\\n                    } else {\\n                        e = a - x;\\n                    }\\n                    d = GOLDEN_SECTION * e;\\n                }\\n\\n                \/\/ Update by at least \\\"tol1\\\".\\n                if (FastMath.abs(d) < tol1) {\\n                    if (d >= 0) {\\n                        u = x + tol1;\\n                    } else {\\n                        u = x - tol1;\\n                    }\\n                } else {\\n                    u = x + d;\\n                }\\n\\n                double fu = computeObjectiveValue(u);\\n                if (!isMinim) {\\n                    fu = -fu;\\n                }\\n\\n                \/\/ User-defined convergence checker.\\n                previous = current;\\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\\n\\n                if (checker != null) {\\n                    if (checker.converged(iter, previous, current)) {\\n                        return best(current, previous, isMinim);\\n                    }\\n                }\\n\\n                \/\/ Update a, b, v, w and x.\\n                if (fu <= fx) {\\n                    if (u < x) {\\n                        b = x;\\n                    } else {\\n                        a = x;\\n                    }\\n                    v = w;\\n                    fv = fw;\\n                    w = x;\\n                    fw = fx;\\n                    x = u;\\n                    fx = fu;\\n                } else {\\n                    if (u < x) {\\n                        a = u;\\n                    } else {\\n                        b = u;\\n                    }\\n                    if (fu <= fw ||\\n                        Precision.equals(w, x)) {\\n                        v = w;\\n                        fv = fw;\\n                        w = u;\\n                        fw = fu;\\n                    } else if (fu <= fv ||\\n                               Precision.equals(v, x) ||\\n                               Precision.equals(v, w)) {\\n                        v = u;\\n                        fv = fu;\\n                    }\\n                }\\n            } else { \/\/ Default termination (Brent's criterion).\\n                return\\n                            best(current,\\n                                 previous,\\n                            isMinim);\\n            }\\n            ++iter;\\n        }\\n    }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 114, \"method_start_line\": 115, \"end_line\": 281}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math3\/optimization\/univariate\/BrentOptimizerTest.java\", \"method_name\": \"testKeepInitIfBest\", \"content\": \"    \/**\\n     * Contrived example showing that prior to the resolution of MATH-855\\n     * (second revision), the algorithm would not return the best point if\\n     * it happened to be the initial guess.\\n     *\/\\n    @Test\\n    public void testKeepInitIfBest() {\\n        final double minSin = 3 * Math.PI \/ 2;\\n        final double offset = 1e-8;\\n        final double delta = 1e-7;\\n        final UnivariateFunction f1 = new Sin();\\n        final UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 2 * offset},\\n                                                       new double[] { 0, -1, 0 });\\n        final UnivariateFunction f = FunctionUtils.add(f1, f2);\\n        \/\/ A slightly less stringent tolerance would make the test pass\\n        \/\/ even with the previous implementation.\\n        final double relTol = 1e-8;\\n        final UnivariateOptimizer optimizer = new BrentOptimizer(relTol, 1e-100);\\n        final double init = minSin + 1.5 * offset;\\n        final UnivariatePointValuePair result\\n            = optimizer.optimize(200, f, GoalType.MINIMIZE,\\n                                 minSin - 6.789 * delta,\\n                                 minSin + 9.876 * delta,\\n                                 init);\\n        final int numEval = optimizer.getEvaluations();\\n\\n        final double sol = result.getPoint();\\n        final double expected = init;\\n\\n\/\/         System.out.println(\\\"numEval=\\\" + numEval);\\n\/\/         System.out.println(\\\"min=\\\" + init + \\\" f=\\\" + f.value(init));\\n\/\/         System.out.println(\\\"sol=\\\" + sol + \\\" f=\\\" + f.value(sol));\\n\/\/         System.out.println(\\\"exp=\\\" + expected + \\\" f=\\\" + f.value(expected));\\n\\n        Assert.assertTrue(\\\"Best point not reported\\\", f.value(sol) <= f.value(expected));\\n    }\", \"javadoc_start_line\": 187, \"annotations_start_line\": 192, \"method_start_line\": 193, \"end_line\": 222}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/optimization\/univariate\/BaseAbstractUnivariateOptimizer.java\", \"method_name\": \"optimize\", \"content\": \"    \/** {@inheritDoc} *\/\\n    public UnivariatePointValuePair optimize(int maxEval, UnivariateFunction f,\\n                                                 GoalType goalType,\\n                                                 double min, double max,\\n                                                 double startValue) {\\n        \/\/ Checks.\\n        if (f == null) {\\n            throw new NullArgumentException();\\n        }\\n        if (goalType == null) {\\n            throw new NullArgumentException();\\n        }\\n\\n        \/\/ Reset.\\n        searchMin = min;\\n        searchMax = max;\\n        searchStart = startValue;\\n        goal = goalType;\\n        function = f;\\n        evaluations.setMaximalCount(maxEval);\\n        evaluations.resetCount();\\n\\n        \/\/ Perform computation.\\n        return doOptimize();\\n    }\", \"javadoc_start_line\": 111, \"annotations_start_line\": 112, \"method_start_line\": 115, \"end_line\": 135}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/optimization\/univariate\/BrentOptimizer.java\", \"method_name\": \"doOptimize\", \"content\": \"    \/** {@inheritDoc} *\/\\n    @Override\\n    protected UnivariatePointValuePair doOptimize() {\\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\\n        final double lo = getMin();\\n        final double mid = getStartValue();\\n        final double hi = getMax();\\n\\n        \/\/ Optional additional convergence criteria.\\n        final ConvergenceChecker<UnivariatePointValuePair> checker\\n            = getConvergenceChecker();\\n\\n        double a;\\n        double b;\\n        if (lo < hi) {\\n            a = lo;\\n            b = hi;\\n        } else {\\n            a = hi;\\n            b = lo;\\n        }\\n\\n        double x = mid;\\n        double v = x;\\n        double w = x;\\n        double d = 0;\\n        double e = 0;\\n        double fx = computeObjectiveValue(x);\\n        if (!isMinim) {\\n            fx = -fx;\\n        }\\n        double fv = fx;\\n        double fw = fx;\\n\\n        UnivariatePointValuePair previous = null;\\n        UnivariatePointValuePair current\\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\\n        \/\/ Best point encountered so far (which is the initial guess).\\n\\n        int iter = 0;\\n        while (true) {\\n            final double m = 0.5 * (a + b);\\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\\n            final double tol2 = 2 * tol1;\\n\\n            \/\/ Default stopping criterion.\\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\\n            if (!stop) {\\n                double p = 0;\\n                double q = 0;\\n                double r = 0;\\n                double u = 0;\\n\\n                if (FastMath.abs(e) > tol1) { \/\/ Fit parabola.\\n                    r = (x - w) * (fx - fv);\\n                    q = (x - v) * (fx - fw);\\n                    p = (x - v) * q - (x - w) * r;\\n                    q = 2 * (q - r);\\n\\n                    if (q > 0) {\\n                        p = -p;\\n                    } else {\\n                        q = -q;\\n                    }\\n\\n                    r = e;\\n                    e = d;\\n\\n                    if (p > q * (a - x) &&\\n                        p < q * (b - x) &&\\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\\n                        \/\/ Parabolic interpolation step.\\n                        d = p \/ q;\\n                        u = x + d;\\n\\n                        \/\/ f must not be evaluated too close to a or b.\\n                        if (u - a < tol2 || b - u < tol2) {\\n                            if (x <= m) {\\n                                d = tol1;\\n                            } else {\\n                                d = -tol1;\\n                            }\\n                        }\\n                    } else {\\n                        \/\/ Golden section step.\\n                        if (x < m) {\\n                            e = b - x;\\n                        } else {\\n                            e = a - x;\\n                        }\\n                        d = GOLDEN_SECTION * e;\\n                    }\\n                } else {\\n                    \/\/ Golden section step.\\n                    if (x < m) {\\n                        e = b - x;\\n                    } else {\\n                        e = a - x;\\n                    }\\n                    d = GOLDEN_SECTION * e;\\n                }\\n\\n                \/\/ Update by at least \\\"tol1\\\".\\n                if (FastMath.abs(d) < tol1) {\\n                    if (d >= 0) {\\n                        u = x + tol1;\\n                    } else {\\n                        u = x - tol1;\\n                    }\\n                } else {\\n                    u = x + d;\\n                }\\n\\n                double fu = computeObjectiveValue(u);\\n                if (!isMinim) {\\n                    fu = -fu;\\n                }\\n\\n                \/\/ User-defined convergence checker.\\n                previous = current;\\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\\n\\n                if (checker != null) {\\n                    if (checker.converged(iter, previous, current)) {\\n                        return best(current, previous, isMinim);\\n                    }\\n                }\\n\\n                \/\/ Update a, b, v, w and x.\\n                if (fu <= fx) {\\n                    if (u < x) {\\n                        b = x;\\n                    } else {\\n                        a = x;\\n                    }\\n                    v = w;\\n                    fv = fw;\\n                    w = x;\\n                    fw = fx;\\n                    x = u;\\n                    fx = fu;\\n                } else {\\n                    if (u < x) {\\n                        a = u;\\n                    } else {\\n                        b = u;\\n                    }\\n                    if (fu <= fw ||\\n                        Precision.equals(w, x)) {\\n                        v = w;\\n                        fv = fw;\\n                        w = u;\\n                        fw = fu;\\n                    } else if (fu <= fv ||\\n                               Precision.equals(v, x) ||\\n                               Precision.equals(v, w)) {\\n                        v = u;\\n                        fv = fu;\\n                    }\\n                }\\n            } else { \/\/ Default termination (Brent's criterion).\\n                return\\n                            best(current,\\n                                 previous,\\n                            isMinim);\\n            }\\n            ++iter;\\n        }\\n    }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 114, \"method_start_line\": 115, \"end_line\": 281}"}]},{"name":"Math","version":29,"tour_id":1,"test":"{\"className\": \" org.apache.commons.math3.linear.SparseRealVectorTest\", \"methodName\": \"testEbeDivideMixedTypes\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"entry #0, left = 0.0, right = 0.0 expected:<NaN> but was:<0.0>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/linear\/OpenMapRealVector.java\", \"method_name\": \"ebeDivide\", \"content\": \"    \/** {@inheritDoc} *\/\\n    @Override\\n    public OpenMapRealVector ebeDivide(RealVector v) {\\n        checkVectorDimensions(v.getDimension());\\n        OpenMapRealVector res = new OpenMapRealVector(this);\\n        \/*\\n         * MATH-803: it is not sufficient to loop through non zero entries of\\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\\n         * this[i] \/ v[i] = NaN, and not 0d.\\n         *\/\\n        Iterator iter = entries.iterator();\\n        while (iter.hasNext()) {\\n            iter.advance();\\n            res.setEntry(iter.key(), iter.value() \/ v.getEntry(iter.key()));\\n        }\\n        return res;\\n    }\", \"javadoc_start_line\": 339, \"annotations_start_line\": 340, \"method_start_line\": 341, \"end_line\": 355}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math3\/linear\/RealVectorAbstractTest.java\", \"method_name\": \"testEbeDivideMixedTypes\", \"content\": \"    public void testEbeDivideMixedTypes() {\\n        doTestEbeBinaryOperation(BinaryOperation.DIV, true);\\n    }\", \"javadoc_start_line\": 594, \"annotations_start_line\": 593, \"method_start_line\": 594, \"end_line\": 596}"},{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math3\/linear\/RealVectorAbstractTest.java\", \"method_name\": \"doTestEbeBinaryOperation\", \"content\": \"    private void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed) {\\n        \/*\\n         * Make sure that x, y, z are three different values. Also, x is the\\n         * preferred value (e.g. the value which is not stored in sparse\\n         * implementations).\\n         *\/\\n        final double x = getPreferredEntryValue();\\n        final double y = x + 1d;\\n        final double z = y + 1d;\\n\\n        \/*\\n         * This is an attempt at covering most particular cases of combining\\n         * two values.\\n         *\\n         * 1. Addition\\n         *    --------\\n         * The following cases should be covered\\n         * (2 * x) + (-x)\\n         * (-x) + 2 * x\\n         * x + y\\n         * y + x\\n         * y + z\\n         * y + (x - y)\\n         * (y - x) + x\\n         *\\n         * The values to be considered are: x, y, z, 2 * x, -x, x - y, y - x.\\n         *\\n         * 2. Subtraction\\n         *    -----------\\n         * The following cases should be covered\\n         * (2 * x) - x\\n         * x - y\\n         * y - x\\n         * y - z\\n         * y - (y - x)\\n         * (y + x) - y\\n         *\\n         * The values to be considered are: x, y, z, x + y, y - x.\\n         *\\n         * 3. Multiplication\\n         *    --------------\\n         * (x * x) * (1 \/ x)\\n         * (1 \/ x) * (x * x)\\n         * x * y\\n         * y * x\\n         * y * z\\n         *\\n         * The values to be considered are: x, y, z, 1 \/ x, x * x.\\n         *\\n         * 4. Division\\n         *    --------\\n         * (x * x) \/ x\\n         * x \/ y\\n         * y \/ x\\n         * y \/ z\\n         *\\n         * The values to be considered are: x, y, z, x * x.\\n         *\\n         * Also to be considered NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY.\\n         *\/\\n        final double[] values = {x, y, z, 2 * x, -x, 1 \/ x, x * x, x + y, x - y, y - x};\\n        final double[] data1 = new double[values.length * values.length];\\n        final double[] data2 = new double[values.length * values.length];\\n        int k = 0;\\n        for (int i = 0; i < values.length; i++) {\\n            for (int j = 0; j < values.length; j++) {\\n                data1[k] = values[i];\\n                data2[k] = values[j];\\n                ++k;\\n            }\\n        }\\n        final RealVector v1 = create(data1);\\n        final RealVector v2 = mixed ? createAlien(data2) : create(data2);\\n        final RealVector actual;\\n        switch (op) {\\n            case ADD:\\n                actual = v1.add(v2);\\n                break;\\n            case SUB:\\n                actual = v1.subtract(v2);\\n                break;\\n            case MUL:\\n                actual = v1.ebeMultiply(v2);\\n                break;\\n            case DIV:\\n                actual = v1.ebeDivide(v2);\\n                break;\\n            default:\\n                throw new AssertionError(\\\"unexpected value\\\");\\n        }\\n        final double[] expected = new double[data1.length];\\n        for (int i = 0; i < expected.length; i++) {\\n            switch (op) {\\n                case ADD:\\n                    expected[i] = data1[i] + data2[i];\\n                    break;\\n                case SUB:\\n                    expected[i] = data1[i] - data2[i];\\n                    break;\\n                case MUL:\\n                    expected[i] = data1[i] * data2[i];\\n                    break;\\n                case DIV:\\n                    expected[i] = data1[i] \/ data2[i];\\n                    break;\\n                default:\\n                    throw new AssertionError(\\\"unexpected value\\\");\\n            }\\n        }\\n        for (int i = 0; i < expected.length; i++) {\\n            final String msg = \\\"entry #\\\"+i+\\\", left = \\\"+data1[i]+\\\", right = \\\" + data2[i];\\n            Assert.assertEquals(msg, expected[i], actual.getEntry(i), 0.0);\\n        }\\n    }\", \"javadoc_start_line\": 408, \"annotations_start_line\": 408, \"method_start_line\": 408, \"end_line\": 521}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/linear\/OpenMapRealVector.java\", \"method_name\": \"<clinit>\", \"content\": \"public class OpenMapRealVector extends SparseRealVector\", \"javadoc_start_line\": 34, \"annotations_start_line\": 34, \"method_start_line\": 34, \"end_line\": 34}"}]},{"name":"Math","version":32,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest\", \"methodName\": \"testIssue780\", \"error\": \"java.lang.ClassCastException\", \"message\": \"org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/geometry\/euclidean\/twod\/PolygonsSet.java\", \"method_name\": \"computeGeometricalProperties\", \"content\": \"    \/** {@inheritDoc} *\/\\n    @Override\\n    protected void computeGeometricalProperties() {\\n\\n        final Vector2D[][] v = getVertices();\\n\\n        if (v.length == 0) {\\n            final BSPTree<Euclidean2D> tree = getTree(false);\\n            if ((Boolean) tree.getAttribute()) {\\n                \/\/ the instance covers the whole space\\n                setSize(Double.POSITIVE_INFINITY);\\n                setBarycenter(Vector2D.NaN);\\n            } else {\\n                setSize(0);\\n                setBarycenter(new Vector2D(0, 0));\\n            }\\n        } else if (v[0][0] == null) {\\n            \/\/ there is at least one open-loop: the polygon is infinite\\n            setSize(Double.POSITIVE_INFINITY);\\n            setBarycenter(Vector2D.NaN);\\n        } else {\\n            \/\/ all loops are closed, we compute some integrals around the shape\\n\\n            double sum  = 0;\\n            double sumX = 0;\\n            double sumY = 0;\\n\\n            for (Vector2D[] loop : v) {\\n                double x1 = loop[loop.length - 1].getX();\\n                double y1 = loop[loop.length - 1].getY();\\n                for (final Vector2D point : loop) {\\n                    final double x0 = x1;\\n                    final double y0 = y1;\\n                    x1 = point.getX();\\n                    y1 = point.getY();\\n                    final double factor = x0 * y1 - y0 * x1;\\n                    sum  += factor;\\n                    sumX += factor * (x0 + x1);\\n                    sumY += factor * (y0 + y1);\\n                }\\n            }\\n\\n            if (sum < 0) {\\n                \/\/ the polygon as a finite outside surrounded by an infinite inside\\n                setSize(Double.POSITIVE_INFINITY);\\n                setBarycenter(Vector2D.NaN);\\n            } else {\\n                setSize(sum \/ 2);\\n                setBarycenter(new Vector2D(sumX \/ (3 * sum), sumY \/ (3 * sum)));\\n            }\\n\\n        }\\n\\n    }\", \"javadoc_start_line\": 128, \"annotations_start_line\": 129, \"method_start_line\": 130, \"end_line\": 181}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math3\/geometry\/euclidean\/threed\/PolyhedronsSetTest.java\", \"method_name\": \"testIssue780\", \"content\": \"    public void testIssue780() {\\n        float[] coords = {\\n            1.000000f, -1.000000f, -1.000000f, \\n            1.000000f, -1.000000f, 1.000000f, \\n            -1.000000f, -1.000000f, 1.000000f, \\n            -1.000000f, -1.000000f, -1.000000f, \\n            1.000000f, 1.000000f, -1f, \\n            0.999999f, 1.000000f, 1.000000f,   \/\/ 1.000000f, 1.000000f, 1.000000f, \\n            -1.000000f, 1.000000f, 1.000000f, \\n            -1.000000f, 1.000000f, -1.000000f};\\n        int[] indices = {\\n            0, 1, 2, 0, 2, 3, \\n            4, 7, 6, 4, 6, 5, \\n            0, 4, 5, 0, 5, 1, \\n            1, 5, 6, 1, 6, 2, \\n            2, 6, 7, 2, 7, 3, \\n            4, 0, 3, 4, 3, 7};\\n        ArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\\n        for (int idx = 0; idx < indices.length; idx += 3) {\\n            int idxA = indices[idx] * 3;\\n            int idxB = indices[idx + 1] * 3;\\n            int idxC = indices[idx + 2] * 3;\\n            Vector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\\n            Vector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\\n            Vector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\\n            Vector3D[] vertices = {v_1, v_2, v_3};\\n            Plane polyPlane = new Plane(v_1, v_2, v_3);\\n            ArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\\n\\n            Vector2D[] projPts = new Vector2D[vertices.length];\\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\\n                projPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\\n            }\\n\\n            SubLine lineInPlane = null;\\n            for (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\\n                lineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\\n                lines.add(lineInPlane);\\n            }\\n            Region<Euclidean2D> polyRegion = new PolygonsSet(lines);\\n            SubPlane polygon = new SubPlane(polyPlane, polyRegion);\\n            subHyperplaneList.add(polygon);\\n        }\\n        PolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\\n        Assert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\\n        Assert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);\\n    }\", \"javadoc_start_line\": 237, \"annotations_start_line\": 236, \"method_start_line\": 237, \"end_line\": 283}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/geometry\/partitioning\/AbstractRegion.java\", \"method_name\": \"getSize\", \"content\": \"    \/** {@inheritDoc} *\/\\n    public double getSize() {\\n        if (barycenter == null) {\\n            computeGeometricalProperties();\\n        }\\n        return size;\\n    }\", \"javadoc_start_line\": 378, \"annotations_start_line\": 379, \"method_start_line\": 379, \"end_line\": 384}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math3\/geometry\/euclidean\/threed\/PolyhedronsSet.java\", \"method_name\": \"computeGeometricalProperties\", \"content\": \"    \/** {@inheritDoc} *\/\\n    @Override\\n    protected void computeGeometricalProperties() {\\n\\n        \/\/ compute the contribution of all boundary facets\\n        getTree(true).visit(new FacetsContributionVisitor());\\n\\n        if (getSize() < 0) {\\n            \/\/ the polyhedrons set as a finite outside\\n            \/\/ surrounded by an infinite inside\\n            setSize(Double.POSITIVE_INFINITY);\\n            setBarycenter(Vector3D.NaN);\\n        } else {\\n            \/\/ the polyhedrons set is finite, apply the remaining scaling factors\\n            setSize(getSize() \/ 3.0);\\n            setBarycenter(new Vector3D(1.0 \/ (4 * getSize()), (Vector3D) getBarycenter()));\\n        }\\n\\n    }\", \"javadoc_start_line\": 113, \"annotations_start_line\": 114, \"method_start_line\": 115, \"end_line\": 131}"}]},{"name":"Math","version":40,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolverTest\", \"methodName\": \"testIssue716\", \"error\": \"org.apache.commons.math.exception.TooManyEvaluationsException\", \"message\": \"illegal state: maximal count (100) exceeded: evaluations\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/analysis\/solvers\/BracketingNthOrderBrentSolver.java\", \"method_name\": \"doSolve\", \"content\": \"    \/**\\n     * {@inheritDoc}\\n     *\/\\n    @Override\\n    protected double doSolve() {\\n\\n        \/\/ prepare arrays with the first points\\n        final double[] x = new double[maximalOrder + 1];\\n        final double[] y = new double[maximalOrder + 1];\\n        x[0] = getMin();\\n        x[1] = getStartValue();\\n        x[2] = getMax();\\n        verifySequence(x[0], x[1], x[2]);\\n\\n        \/\/ evaluate initial guess\\n        y[1] = computeObjectiveValue(x[1]);\\n        if (Precision.equals(y[1], 0.0, 1)) {\\n            \/\/ return the initial guess if it is a perfect root.\\n            return x[1];\\n        }\\n\\n        \/\/ evaluate first  endpoint\\n        y[0] = computeObjectiveValue(x[0]);\\n        if (Precision.equals(y[0], 0.0, 1)) {\\n            \/\/ return the first endpoint if it is a perfect root.\\n            return x[0];\\n        }\\n\\n        int nbPoints;\\n        int signChangeIndex;\\n        if (y[0] * y[1] < 0) {\\n\\n            \/\/ reduce interval if it brackets the root\\n            nbPoints        = 2;\\n            signChangeIndex = 1;\\n\\n        } else {\\n\\n            \/\/ evaluate second endpoint\\n            y[2] = computeObjectiveValue(x[2]);\\n            if (Precision.equals(y[2], 0.0, 1)) {\\n                \/\/ return the second endpoint if it is a perfect root.\\n                return x[2];\\n            }\\n\\n            if (y[1] * y[2] < 0) {\\n                \/\/ use all computed point as a start sampling array for solving\\n                nbPoints        = 3;\\n                signChangeIndex = 2;\\n            } else {\\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\\n            }\\n\\n        }\\n\\n        \/\/ prepare a work array for inverse polynomial interpolation\\n        final double[] tmpX = new double[x.length];\\n\\n        \/\/ current tightest bracketing of the root\\n        double xA    = x[signChangeIndex - 1];\\n        double yA    = y[signChangeIndex - 1];\\n        double absYA = FastMath.abs(yA);\\n        int agingA   = 0;\\n        double xB    = x[signChangeIndex];\\n        double yB    = y[signChangeIndex];\\n        double absYB = FastMath.abs(yB);\\n        int agingB   = 0;\\n\\n        \/\/ search loop\\n        while (true) {\\n\\n            \/\/ check convergence of bracketing interval\\n            final double xTol = getAbsoluteAccuracy() +\\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\\n                switch (allowed) {\\n                case ANY_SIDE :\\n                    return absYA < absYB ? xA : xB;\\n                case LEFT_SIDE :\\n                    return xA;\\n                case RIGHT_SIDE :\\n                    return xB;\\n                case BELOW_SIDE :\\n                    return (yA <= 0) ? xA : xB;\\n                case ABOVE_SIDE :\\n                    return (yA <  0) ? xB : xA;\\n                default :\\n                    \/\/ this should never happen\\n                    throw new MathInternalError(null);\\n                }\\n            }\\n\\n            \/\/ target for the next evaluation point\\n            double targetY;\\n            if (agingA >= MAXIMAL_AGING) {\\n                \/\/ we keep updating the high bracket, try to compensate this\\n                targetY = -REDUCTION_FACTOR * yB;\\n            } else if (agingB >= MAXIMAL_AGING) {\\n                \/\/ we keep updating the low bracket, try to compensate this\\n                targetY = -REDUCTION_FACTOR * yA;\\n            } else {\\n                \/\/ bracketing is balanced, try to find the root itself\\n                targetY = 0;\\n            }\\n\\n            \/\/ make a few attempts to guess a root,\\n            double nextX;\\n            int start = 0;\\n            int end   = nbPoints;\\n            do {\\n\\n                \/\/ guess a value for current target, using inverse polynomial interpolation\\n                System.arraycopy(x, start, tmpX, start, end - start);\\n                nextX = guessX(targetY, tmpX, y, start, end);\\n\\n                if (!((nextX > xA) && (nextX < xB))) {\\n                    \/\/ the guessed root is not strictly inside of the tightest bracketing interval\\n\\n                    \/\/ the guessed root is either not strictly inside the interval or it\\n                    \/\/ is a NaN (which occurs when some sampling points share the same y)\\n                    \/\/ we try again with a lower interpolation order\\n                    if (signChangeIndex - start >= end - signChangeIndex) {\\n                        \/\/ we have more points before the sign change, drop the lowest point\\n                        ++start;\\n                    } else {\\n                        \/\/ we have more points after sign change, drop the highest point\\n                        --end;\\n                    }\\n\\n                    \/\/ we need to do one more attempt\\n                    nextX = Double.NaN;\\n\\n                }\\n\\n            } while (Double.isNaN(nextX) && (end - start > 1));\\n\\n            if (Double.isNaN(nextX)) {\\n                \/\/ fall back to bisection\\n                nextX = xA + 0.5 * (xB - xA);\\n                start = signChangeIndex - 1;\\n                end   = signChangeIndex;\\n            }\\n\\n            \/\/ evaluate the function at the guessed root\\n            final double nextY = computeObjectiveValue(nextX);\\n            if (Precision.equals(nextY, 0.0, 1)) {\\n                \/\/ we have found an exact root, since it is not an approximation\\n                \/\/ we don't need to bother about the allowed solutions setting\\n                return nextX;\\n            }\\n\\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\\n\\n                \/\/ we have been forced to ignore some points to keep bracketing,\\n                \/\/ they are probably too far from the root, drop them from now on\\n                nbPoints = end - start;\\n                System.arraycopy(x, start, x, 0, nbPoints);\\n                System.arraycopy(y, start, y, 0, nbPoints);\\n                signChangeIndex -= start;\\n\\n            } else  if (nbPoints == x.length) {\\n\\n                \/\/ we have to drop one point in order to insert the new one\\n                nbPoints--;\\n\\n                \/\/ keep the tightest bracketing interval as centered as possible\\n                if (signChangeIndex >= (x.length + 1) \/ 2) {\\n                    \/\/ we drop the lowest point, we have to shift the arrays and the index\\n                    System.arraycopy(x, 1, x, 0, nbPoints);\\n                    System.arraycopy(y, 1, y, 0, nbPoints);\\n                    --signChangeIndex;\\n                }\\n\\n            }\\n\\n            \/\/ insert the last computed point\\n            \/\/(by construction, we know it lies inside the tightest bracketing interval)\\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\\n            x[signChangeIndex] = nextX;\\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\\n            y[signChangeIndex] = nextY;\\n            ++nbPoints;\\n\\n            \/\/ update the bracketing interval\\n            if (nextY * yA <= 0) {\\n                \/\/ the sign change occurs before the inserted point\\n                xB = nextX;\\n                yB = nextY;\\n                absYB = FastMath.abs(yB);\\n                ++agingA;\\n                agingB = 0;\\n            } else {\\n                \/\/ the sign change occurs after the inserted point\\n                xA = nextX;\\n                yA = nextY;\\n                absYA = FastMath.abs(yA);\\n                agingA = 0;\\n                ++agingB;\\n\\n                \/\/ update the sign change index\\n                signChangeIndex++;\\n\\n            }\\n\\n        }\\n\\n    }\", \"javadoc_start_line\": 139, \"annotations_start_line\": 142, \"method_start_line\": 143, \"end_line\": 345}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math\/analysis\/solvers\/BracketingNthOrderBrentSolverTest.java\", \"method_name\": \"testIssue716\", \"content\": \"    public void testIssue716() {\\n        BracketingNthOrderBrentSolver solver =\\n                new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 1.0e-22, 5);\\n        UnivariateFunction sharpTurn = new UnivariateFunction() {\\n            public double value(double x) {\\n                return (2 * x + 1) \/ (1.0e9 * (x + 1));\\n            }\\n        };\\n        double result = solver.solve(100, sharpTurn, -0.9999999, 30, 15, AllowedSolution.RIGHT_SIDE);\\n        Assert.assertEquals(0, sharpTurn.value(result), solver.getFunctionValueAccuracy());\\n        Assert.assertTrue(sharpTurn.value(result) >= 0);\\n        Assert.assertEquals(-0.5, result, 1.0e-10);\\n    }\", \"javadoc_start_line\": 85, \"annotations_start_line\": 84, \"method_start_line\": 85, \"end_line\": 97}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/analysis\/solvers\/BaseAbstractUnivariateRealSolver.java\", \"method_name\": \"solve\", \"content\": \"    \/** {@inheritDoc} *\/\\n    public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\\n        \/\/ Initialization.\\n        setup(maxEval, f, min, max, startValue);\\n\\n        \/\/ Perform computation.\\n        return doSolve();\\n    }\", \"javadoc_start_line\": 184, \"annotations_start_line\": 185, \"method_start_line\": 185, \"end_line\": 191}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/analysis\/solvers\/BracketingNthOrderBrentSolver.java\", \"method_name\": \"doSolve\", \"content\": \"    \/**\\n     * {@inheritDoc}\\n     *\/\\n    @Override\\n    protected double doSolve() {\\n\\n        \/\/ prepare arrays with the first points\\n        final double[] x = new double[maximalOrder + 1];\\n        final double[] y = new double[maximalOrder + 1];\\n        x[0] = getMin();\\n        x[1] = getStartValue();\\n        x[2] = getMax();\\n        verifySequence(x[0], x[1], x[2]);\\n\\n        \/\/ evaluate initial guess\\n        y[1] = computeObjectiveValue(x[1]);\\n        if (Precision.equals(y[1], 0.0, 1)) {\\n            \/\/ return the initial guess if it is a perfect root.\\n            return x[1];\\n        }\\n\\n        \/\/ evaluate first  endpoint\\n        y[0] = computeObjectiveValue(x[0]);\\n        if (Precision.equals(y[0], 0.0, 1)) {\\n            \/\/ return the first endpoint if it is a perfect root.\\n            return x[0];\\n        }\\n\\n        int nbPoints;\\n        int signChangeIndex;\\n        if (y[0] * y[1] < 0) {\\n\\n            \/\/ reduce interval if it brackets the root\\n            nbPoints        = 2;\\n            signChangeIndex = 1;\\n\\n        } else {\\n\\n            \/\/ evaluate second endpoint\\n            y[2] = computeObjectiveValue(x[2]);\\n            if (Precision.equals(y[2], 0.0, 1)) {\\n                \/\/ return the second endpoint if it is a perfect root.\\n                return x[2];\\n            }\\n\\n            if (y[1] * y[2] < 0) {\\n                \/\/ use all computed point as a start sampling array for solving\\n                nbPoints        = 3;\\n                signChangeIndex = 2;\\n            } else {\\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\\n            }\\n\\n        }\\n\\n        \/\/ prepare a work array for inverse polynomial interpolation\\n        final double[] tmpX = new double[x.length];\\n\\n        \/\/ current tightest bracketing of the root\\n        double xA    = x[signChangeIndex - 1];\\n        double yA    = y[signChangeIndex - 1];\\n        double absYA = FastMath.abs(yA);\\n        int agingA   = 0;\\n        double xB    = x[signChangeIndex];\\n        double yB    = y[signChangeIndex];\\n        double absYB = FastMath.abs(yB);\\n        int agingB   = 0;\\n\\n        \/\/ search loop\\n        while (true) {\\n\\n            \/\/ check convergence of bracketing interval\\n            final double xTol = getAbsoluteAccuracy() +\\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\\n                switch (allowed) {\\n                case ANY_SIDE :\\n                    return absYA < absYB ? xA : xB;\\n                case LEFT_SIDE :\\n                    return xA;\\n                case RIGHT_SIDE :\\n                    return xB;\\n                case BELOW_SIDE :\\n                    return (yA <= 0) ? xA : xB;\\n                case ABOVE_SIDE :\\n                    return (yA <  0) ? xB : xA;\\n                default :\\n                    \/\/ this should never happen\\n                    throw new MathInternalError(null);\\n                }\\n            }\\n\\n            \/\/ target for the next evaluation point\\n            double targetY;\\n            if (agingA >= MAXIMAL_AGING) {\\n                \/\/ we keep updating the high bracket, try to compensate this\\n                targetY = -REDUCTION_FACTOR * yB;\\n            } else if (agingB >= MAXIMAL_AGING) {\\n                \/\/ we keep updating the low bracket, try to compensate this\\n                targetY = -REDUCTION_FACTOR * yA;\\n            } else {\\n                \/\/ bracketing is balanced, try to find the root itself\\n                targetY = 0;\\n            }\\n\\n            \/\/ make a few attempts to guess a root,\\n            double nextX;\\n            int start = 0;\\n            int end   = nbPoints;\\n            do {\\n\\n                \/\/ guess a value for current target, using inverse polynomial interpolation\\n                System.arraycopy(x, start, tmpX, start, end - start);\\n                nextX = guessX(targetY, tmpX, y, start, end);\\n\\n                if (!((nextX > xA) && (nextX < xB))) {\\n                    \/\/ the guessed root is not strictly inside of the tightest bracketing interval\\n\\n                    \/\/ the guessed root is either not strictly inside the interval or it\\n                    \/\/ is a NaN (which occurs when some sampling points share the same y)\\n                    \/\/ we try again with a lower interpolation order\\n                    if (signChangeIndex - start >= end - signChangeIndex) {\\n                        \/\/ we have more points before the sign change, drop the lowest point\\n                        ++start;\\n                    } else {\\n                        \/\/ we have more points after sign change, drop the highest point\\n                        --end;\\n                    }\\n\\n                    \/\/ we need to do one more attempt\\n                    nextX = Double.NaN;\\n\\n                }\\n\\n            } while (Double.isNaN(nextX) && (end - start > 1));\\n\\n            if (Double.isNaN(nextX)) {\\n                \/\/ fall back to bisection\\n                nextX = xA + 0.5 * (xB - xA);\\n                start = signChangeIndex - 1;\\n                end   = signChangeIndex;\\n            }\\n\\n            \/\/ evaluate the function at the guessed root\\n            final double nextY = computeObjectiveValue(nextX);\\n            if (Precision.equals(nextY, 0.0, 1)) {\\n                \/\/ we have found an exact root, since it is not an approximation\\n                \/\/ we don't need to bother about the allowed solutions setting\\n                return nextX;\\n            }\\n\\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\\n\\n                \/\/ we have been forced to ignore some points to keep bracketing,\\n                \/\/ they are probably too far from the root, drop them from now on\\n                nbPoints = end - start;\\n                System.arraycopy(x, start, x, 0, nbPoints);\\n                System.arraycopy(y, start, y, 0, nbPoints);\\n                signChangeIndex -= start;\\n\\n            } else  if (nbPoints == x.length) {\\n\\n                \/\/ we have to drop one point in order to insert the new one\\n                nbPoints--;\\n\\n                \/\/ keep the tightest bracketing interval as centered as possible\\n                if (signChangeIndex >= (x.length + 1) \/ 2) {\\n                    \/\/ we drop the lowest point, we have to shift the arrays and the index\\n                    System.arraycopy(x, 1, x, 0, nbPoints);\\n                    System.arraycopy(y, 1, y, 0, nbPoints);\\n                    --signChangeIndex;\\n                }\\n\\n            }\\n\\n            \/\/ insert the last computed point\\n            \/\/(by construction, we know it lies inside the tightest bracketing interval)\\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\\n            x[signChangeIndex] = nextX;\\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\\n            y[signChangeIndex] = nextY;\\n            ++nbPoints;\\n\\n            \/\/ update the bracketing interval\\n            if (nextY * yA <= 0) {\\n                \/\/ the sign change occurs before the inserted point\\n                xB = nextX;\\n                yB = nextY;\\n                absYB = FastMath.abs(yB);\\n                ++agingA;\\n                agingB = 0;\\n            } else {\\n                \/\/ the sign change occurs after the inserted point\\n                xA = nextX;\\n                yA = nextY;\\n                absYA = FastMath.abs(yA);\\n                agingA = 0;\\n                ++agingB;\\n\\n                \/\/ update the sign change index\\n                signChangeIndex++;\\n\\n            }\\n\\n        }\\n\\n    }\", \"javadoc_start_line\": 139, \"annotations_start_line\": 142, \"method_start_line\": 143, \"end_line\": 345}"}]},{"name":"Math","version":57,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest\", \"methodName\": \"testSmallDistances\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/stat\/clustering\/KMeansPlusPlusClusterer.java\", \"method_name\": \"chooseInitialCenters\", \"content\": \"    \/**\\n     * Use K-means++ to choose the initial centers.\\n     *\\n     * @param <T> type of the points to cluster\\n     * @param points the points to choose the initial centers from\\n     * @param k the number of centers to choose\\n     * @param random random generator to use\\n     * @return the initial centers\\n     *\/\\n    private static <T extends Clusterable<T>> List<Cluster<T>>\\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\\n\\n        final List<T> pointSet = new ArrayList<T>(points);\\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\\n\\n        \/\/ Choose one center uniformly at random from among the data points.\\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\\n        resultSet.add(new Cluster<T>(firstPoint));\\n\\n        final double[] dx2 = new double[pointSet.size()];\\n        while (resultSet.size() < k) {\\n            \/\/ For each data point x, compute D(x), the distance between x and\\n            \/\/ the nearest center that has already been chosen.\\n            int sum = 0;\\n            for (int i = 0; i < pointSet.size(); i++) {\\n                final T p = pointSet.get(i);\\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\\n                final double d = p.distanceFrom(nearest.getCenter());\\n                sum += d * d;\\n                dx2[i] = sum;\\n            }\\n\\n            \/\/ Add one new data point as a center. Each point x is chosen with\\n            \/\/ probability proportional to D(x)2\\n            final double r = random.nextDouble() * sum;\\n            for (int i = 0 ; i < dx2.length; i++) {\\n                if (dx2[i] >= r) {\\n                    final T p = pointSet.remove(i);\\n                    resultSet.add(new Cluster<T>(p));\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return resultSet;\\n\\n    }\", \"javadoc_start_line\": 152, \"annotations_start_line\": 162, \"method_start_line\": 162, \"end_line\": 198}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math\/stat\/clustering\/KMeansPlusPlusClustererTest.java\", \"method_name\": \"testSmallDistances\", \"content\": \"    \/**\\n     * Test points that are very close together. See issue MATH-546.\\n     *\/\\n    @Test\\n    public void testSmallDistances() {\\n        \/\/ Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a\\n        \/\/ small distance.\\n        int[] repeatedArray = { 0 };\\n        int[] uniqueArray = { 1 };\\n        CloseIntegerPoint repeatedPoint =\\n            new CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));\\n        CloseIntegerPoint uniquePoint =\\n            new CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));\\n\\n        Collection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>();\\n        final int NUM_REPEATED_POINTS = 10 * 1000;\\n        for (int i = 0; i < NUM_REPEATED_POINTS; ++i) {\\n            points.add(repeatedPoint);\\n        }\\n        points.add(uniquePoint);\\n\\n        \/\/ Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial\\n        \/\/ cluster centers).\\n        final long RANDOM_SEED = 0;\\n        final int NUM_CLUSTERS = 2;\\n        final int NUM_ITERATIONS = 0;\\n        KMeansPlusPlusClusterer<CloseIntegerPoint> clusterer =\\n            new KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));\\n        List<Cluster<CloseIntegerPoint>> clusters =\\n            clusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS);\\n\\n        \/\/ Check that one of the chosen centers is the unique point.\\n        boolean uniquePointIsCenter = false;\\n        for (Cluster<CloseIntegerPoint> cluster : clusters) {\\n            if (cluster.getCenter().equals(uniquePoint)) {\\n                uniquePointIsCenter = true;\\n            }\\n        }\\n        assertTrue(uniquePointIsCenter);\\n    }\", \"javadoc_start_line\": 211, \"annotations_start_line\": 214, \"method_start_line\": 215, \"end_line\": 250}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/stat\/clustering\/KMeansPlusPlusClusterer.java\", \"method_name\": \"cluster\", \"content\": \"    \/**\\n     * Runs the K-means++ clustering algorithm.\\n     *\\n     * @param points the points to cluster\\n     * @param k the number of clusters to split the data into\\n     * @param maxIterations the maximum number of iterations to run the algorithm\\n     *     for.  If negative, no maximum will be used\\n     * @return a list of clusters containing the points\\n     *\/\\n    public List<Cluster<T>> cluster(final Collection<T> points,\\n                                    final int k, final int maxIterations) {\\n        \/\/ create the initial clusters\\n        List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\\n        assignPointsToClusters(clusters, points);\\n\\n        \/\/ iterate through updating the centers until we're done\\n        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\\n        for (int count = 0; count < max; count++) {\\n            boolean clusteringChanged = false;\\n            List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\\n            for (final Cluster<T> cluster : clusters) {\\n                final T newCenter;\\n                if (cluster.getPoints().isEmpty()) {\\n                    switch (emptyStrategy) {\\n                        case LARGEST_VARIANCE :\\n                            newCenter = getPointFromLargestVarianceCluster(clusters);\\n                            break;\\n                        case LARGEST_POINTS_NUMBER :\\n                            newCenter = getPointFromLargestNumberCluster(clusters);\\n                            break;\\n                        case FARTHEST_POINT :\\n                            newCenter = getFarthestPoint(clusters);\\n                            break;\\n                        default :\\n                            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\\n                    }\\n                    clusteringChanged = true;\\n                } else {\\n                    newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\\n                    if (!newCenter.equals(cluster.getCenter())) {\\n                        clusteringChanged = true;\\n                    }\\n                }\\n                newClusters.add(new Cluster<T>(newCenter));\\n            }\\n            if (!clusteringChanged) {\\n                return clusters;\\n            }\\n            assignPointsToClusters(newClusters, points);\\n            clusters = newClusters;\\n        }\\n        return clusters;\\n    }\", \"javadoc_start_line\": 83, \"annotations_start_line\": 92, \"method_start_line\": 93, \"end_line\": 135}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/stat\/clustering\/KMeansPlusPlusClusterer.java\", \"method_name\": \"chooseInitialCenters\", \"content\": \"    \/**\\n     * Use K-means++ to choose the initial centers.\\n     *\\n     * @param <T> type of the points to cluster\\n     * @param points the points to choose the initial centers from\\n     * @param k the number of centers to choose\\n     * @param random random generator to use\\n     * @return the initial centers\\n     *\/\\n    private static <T extends Clusterable<T>> List<Cluster<T>>\\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\\n\\n        final List<T> pointSet = new ArrayList<T>(points);\\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\\n\\n        \/\/ Choose one center uniformly at random from among the data points.\\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\\n        resultSet.add(new Cluster<T>(firstPoint));\\n\\n        final double[] dx2 = new double[pointSet.size()];\\n        while (resultSet.size() < k) {\\n            \/\/ For each data point x, compute D(x), the distance between x and\\n            \/\/ the nearest center that has already been chosen.\\n            int sum = 0;\\n            for (int i = 0; i < pointSet.size(); i++) {\\n                final T p = pointSet.get(i);\\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\\n                final double d = p.distanceFrom(nearest.getCenter());\\n                sum += d * d;\\n                dx2[i] = sum;\\n            }\\n\\n            \/\/ Add one new data point as a center. Each point x is chosen with\\n            \/\/ probability proportional to D(x)2\\n            final double r = random.nextDouble() * sum;\\n            for (int i = 0 ; i < dx2.length; i++) {\\n                if (dx2[i] >= r) {\\n                    final T p = pointSet.remove(i);\\n                    resultSet.add(new Cluster<T>(p));\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return resultSet;\\n\\n    }\", \"javadoc_start_line\": 152, \"annotations_start_line\": 162, \"method_start_line\": 162, \"end_line\": 198}"}]},{"name":"Math","version":65,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest\", \"methodName\": \"testCircleFitting\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<0.004> but was:<0.0019737107108948474>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/optimization\/general\/AbstractLeastSquaresOptimizer.java\", \"method_name\": \"getChiSquare\", \"content\": \"    \/**\\n     * Get a Chi-Square-like value assuming the N residuals follow N\\n     * distinct normal distributions centered on 0 and whose variances are\\n     * the reciprocal of the weights.\\n     * @return chi-square value\\n     *\/\\n    public double getChiSquare() {\\n        double chiSquare = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            final double residual = residuals[i];\\n            chiSquare += residual * residual \/ residualsWeights[i];\\n        }\\n        return chiSquare;\\n    }\", \"javadoc_start_line\": 248, \"annotations_start_line\": 254, \"method_start_line\": 254, \"end_line\": 261}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math\/optimization\/general\/LevenbergMarquardtOptimizerTest.java\", \"method_name\": \"testCircleFitting\", \"content\": \"    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\\n        Circle circle = new Circle();\\n        circle.addPoint( 30.0,  68.0);\\n        circle.addPoint( 50.0,  -6.0);\\n        circle.addPoint(110.0, -20.0);\\n        circle.addPoint( 35.0,  15.0);\\n        circle.addPoint( 45.0,  97.0);\\n        LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\\n        VectorialPointValuePair optimum =\\n            optimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\\n                               new double[] { 98.680, 47.345 });\\n        assertTrue(optimizer.getEvaluations() < 10);\\n        assertTrue(optimizer.getJacobianEvaluations() < 10);\\n        double rms = optimizer.getRMS();\\n        assertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);\\n        Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\\n        assertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\\n        assertEquals(96.07590211815305, center.x,      1.0e-10);\\n        assertEquals(48.13516790438953, center.y,      1.0e-10);\\n        double[][] cov = optimizer.getCovariances();\\n        assertEquals(1.839, cov[0][0], 0.001);\\n        assertEquals(0.731, cov[0][1], 0.001);\\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\\n        assertEquals(0.786, cov[1][1], 0.001);\\n        double[] errors = optimizer.guessParametersErrors();\\n        assertEquals(1.384, errors[0], 0.001);\\n        assertEquals(0.905, errors[1], 0.001);\\n\\n        \/\/ add perfect measurements and check errors are reduced\\n        double  r = circle.getRadius(center);\\n        for (double d= 0; d < 2 * Math.PI; d += 0.01) {\\n            circle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\\n        }\\n        double[] target = new double[circle.getN()];\\n        Arrays.fill(target, 0.0);\\n        double[] weights = new double[circle.getN()];\\n        Arrays.fill(weights, 2.0);\\n        optimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\\n        cov = optimizer.getCovariances();\\n        assertEquals(0.0016, cov[0][0], 0.001);\\n        assertEquals(3.2e-7, cov[0][1], 1.0e-9);\\n        assertEquals(cov[0][1], cov[1][0], 1.0e-14);\\n        assertEquals(0.0016, cov[1][1], 0.001);\\n        errors = optimizer.guessParametersErrors();\\n        assertEquals(0.004, errors[0], 0.001);\\n        assertEquals(0.004, errors[1], 0.001);\\n\\n    }\", \"javadoc_start_line\": 398, \"annotations_start_line\": 398, \"method_start_line\": 398, \"end_line\": 445}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/optimization\/general\/AbstractLeastSquaresOptimizer.java\", \"method_name\": \"guessParametersErrors\", \"content\": \"    \/**\\n     * Guess the errors in optimized parameters.\\n     * <p>Guessing is covariance-based, it only gives rough order of magnitude.<\/p>\\n     * @return errors in optimized parameters\\n     * @exception FunctionEvaluationException if the function jacobian cannot b evaluated\\n     * @exception OptimizationException if the covariances matrix cannot be computed\\n     * or the number of degrees of freedom is not positive (number of measurements\\n     * lesser or equal to number of parameters)\\n     *\/\\n    public double[] guessParametersErrors()\\n        throws FunctionEvaluationException, OptimizationException {\\n        if (rows <= cols) {\\n            throw new OptimizationException(\\n                    LocalizedFormats.NO_DEGREES_OF_FREEDOM,\\n                    rows, cols);\\n        }\\n        double[] errors = new double[cols];\\n        final double c = Math.sqrt(getChiSquare() \/ (rows - cols));\\n        double[][] covar = getCovariances();\\n        for (int i = 0; i < errors.length; ++i) {\\n            errors[i] = Math.sqrt(covar[i][i]) * c;\\n        }\\n        return errors;\\n    }\", \"javadoc_start_line\": 301, \"annotations_start_line\": 310, \"method_start_line\": 311, \"end_line\": 324}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/optimization\/general\/AbstractLeastSquaresOptimizer.java\", \"method_name\": \"getChiSquare\", \"content\": \"    \/**\\n     * Get a Chi-Square-like value assuming the N residuals follow N\\n     * distinct normal distributions centered on 0 and whose variances are\\n     * the reciprocal of the weights.\\n     * @return chi-square value\\n     *\/\\n    public double getChiSquare() {\\n        double chiSquare = 0;\\n        for (int i = 0; i < rows; ++i) {\\n            final double residual = residuals[i];\\n            chiSquare += residual * residual \/ residualsWeights[i];\\n        }\\n        return chiSquare;\\n    }\", \"javadoc_start_line\": 248, \"annotations_start_line\": 254, \"method_start_line\": 254, \"end_line\": 261}"}]},{"name":"Math","version":76,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math.linear.SingularValueSolverTest\", \"methodName\": \"testMath320A\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<0.0> but was:<0.09336767546650937>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/linear\/SingularValueDecompositionImpl.java\", \"method_name\": \"getV\", \"content\": \"    \/** {@inheritDoc} *\/\\n    public RealMatrix getV()\\n        throws InvalidMatrixException {\\n\\n        if (cachedV == null) {\\n\\n            final int p = singularValues.length;\\n            if (m >= n) {\\n                \/\/ the tridiagonal matrix is Bt.B, where B is upper bidiagonal\\n                final RealMatrix e =\\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\\n                cachedV = transformer.getV().multiply(e);\\n            } else {\\n                \/\/ the tridiagonal matrix is B.Bt, where B is lower bidiagonal\\n                \/\/ compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\\n                final RealMatrix e =\\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\\n                final double[][] eData = e.getData();\\n                final double[][] wData = new double[n][p];\\n                double[] ei1 = eData[0];\\n                for (int i = 0; i < p - 1; ++i) {\\n                    final double mi = mainBidiagonal[i];\\n                    final double[] ei0 = ei1;\\n                    final double[] wi  = wData[i];\\n                        ei1 = eData[i + 1];\\n                        final double si = secondaryBidiagonal[i];\\n                        for (int j = 0; j < p; ++j) {\\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\\n                        }\\n                }\\n                        for (int j = 0; j < p; ++j) {\\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] \/ singularValues[j];\\n                        }\\n                for (int i = p; i < n; ++i) {\\n                    wData[i] = new double[p];\\n                }\\n                cachedV =\\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\\n            }\\n\\n        }\\n\\n        \/\/ return the cached matrix\\n        return cachedV;\\n\\n    }\", \"javadoc_start_line\": 232, \"annotations_start_line\": 233, \"method_start_line\": 234, \"end_line\": 277}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math\/linear\/SingularValueSolverTest.java\", \"method_name\": \"testMath320A\", \"content\": \"    public void testMath320A() {\\n        RealMatrix rm = new Array2DRowRealMatrix(new double[][] {\\n            { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 4.0 }, { 3.0, 5.0, 7.0 }\\n        });\\n        double s439  = Math.sqrt(439.0);\\n        double[] reference = new double[] {\\n            Math.sqrt(3.0 * (21.0 + s439)), Math.sqrt(3.0 * (21.0 - s439))\\n        };\\n        SingularValueDecomposition svd =\\n            new SingularValueDecompositionImpl(rm);\\n\\n        \/\/ check we get the expected theoretical singular values\\n        double[] singularValues = svd.getSingularValues();\\n        Assert.assertEquals(reference.length, singularValues.length);\\n        for (int i = 0; i < reference.length; ++i) {\\n            Assert.assertEquals(reference[i], singularValues[i], 4.0e-13);\\n        }\\n\\n        \/\/ check the decomposition allows to recover the original matrix\\n        RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\\n        Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 5.0e-13);\\n\\n        \/\/ check we can solve a singular system\\n        double[] b = new double[] { 5.0, 6.0, 7.0 };\\n        double[] resSVD = svd.getSolver().solve(b);\\n        Assert.assertEquals(rm.getColumnDimension(), resSVD.length);\\n\\n        \/\/ check the solution really minimizes the residuals\\n        double svdMinResidual = residual(rm, resSVD, b);\\n        double epsilon = 2 * Math.ulp(svdMinResidual);\\n        double h = 0.1;\\n        int    k = 3;\\n        for (double d0 = -k * h; d0 <= k * h; d0 += h) {\\n            for (double d1 = -k * h ; d1 <= k * h; d1 += h) {\\n                for (double d2 = -k * h; d2 <= k * h; d2 += h) {\\n                    double[] x = new double[] { resSVD[0] + d0, resSVD[1] + d1, resSVD[2] + d2 };\\n                    Assert.assertTrue((residual(rm, x, b) - svdMinResidual) > -epsilon);\\n                }\\n            }\\n        }\\n\\n    }\", \"javadoc_start_line\": 168, \"annotations_start_line\": 167, \"method_start_line\": 168, \"end_line\": 209}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/linear\/SingularValueDecompositionImpl.java\", \"method_name\": \"getVT\", \"content\": \"    \/** {@inheritDoc} *\/\\n    public RealMatrix getVT()\\n        throws InvalidMatrixException {\\n\\n        if (cachedVt == null) {\\n            cachedVt = getV().transpose();\\n        }\\n\\n        \/\/ return the cached matrix\\n        return cachedVt;\\n\\n    }\", \"javadoc_start_line\": 279, \"annotations_start_line\": 280, \"method_start_line\": 281, \"end_line\": 290}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/linear\/SingularValueDecompositionImpl.java\", \"method_name\": \"getV\", \"content\": \"    \/** {@inheritDoc} *\/\\n    public RealMatrix getV()\\n        throws InvalidMatrixException {\\n\\n        if (cachedV == null) {\\n\\n            final int p = singularValues.length;\\n            if (m >= n) {\\n                \/\/ the tridiagonal matrix is Bt.B, where B is upper bidiagonal\\n                final RealMatrix e =\\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\\n                cachedV = transformer.getV().multiply(e);\\n            } else {\\n                \/\/ the tridiagonal matrix is B.Bt, where B is lower bidiagonal\\n                \/\/ compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\\n                final RealMatrix e =\\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\\n                final double[][] eData = e.getData();\\n                final double[][] wData = new double[n][p];\\n                double[] ei1 = eData[0];\\n                for (int i = 0; i < p - 1; ++i) {\\n                    final double mi = mainBidiagonal[i];\\n                    final double[] ei0 = ei1;\\n                    final double[] wi  = wData[i];\\n                        ei1 = eData[i + 1];\\n                        final double si = secondaryBidiagonal[i];\\n                        for (int j = 0; j < p; ++j) {\\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) \/ singularValues[j];\\n                        }\\n                }\\n                        for (int j = 0; j < p; ++j) {\\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] \/ singularValues[j];\\n                        }\\n                for (int i = p; i < n; ++i) {\\n                    wData[i] = new double[p];\\n                }\\n                cachedV =\\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\\n            }\\n\\n        }\\n\\n        \/\/ return the cached matrix\\n        return cachedV;\\n\\n    }\", \"javadoc_start_line\": 232, \"annotations_start_line\": 233, \"method_start_line\": 234, \"end_line\": 277}"}]},{"name":"Math","version":84,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math.optimization.direct.MultiDirectionalTest\", \"methodName\": \"testMinimizeMaximize\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/optimization\/direct\/MultiDirectional.java\", \"method_name\": \"iterateSimplex\", \"content\": \"    \/** {@inheritDoc} *\/\\n    @Override\\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\\n\\n        while (true) {\\n\\n            incrementIterationsCounter();\\n\\n            \/\/ save the original vertex\\n            final RealPointValuePair[] original = simplex;\\n            final RealPointValuePair best = original[0];\\n\\n            \/\/ perform a reflection step\\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\\n            if (comparator.compare(reflected, best) < 0) {\\n\\n                \/\/ compute the expanded simplex\\n                final RealPointValuePair[] reflectedSimplex = simplex;\\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\\n                if (comparator.compare(reflected, expanded) <= 0) {\\n                    \/\/ accept the reflected simplex\\n                    simplex = reflectedSimplex;\\n                }\\n\\n                return;\\n\\n            }\\n\\n            \/\/ compute the contracted simplex\\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\\n            if (comparator.compare(contracted, best) < 0) {\\n                \/\/ accept the contracted simplex\\n\\n            \/\/ check convergence\\n                return;\\n            }\\n\\n        }\\n\\n    }\", \"javadoc_start_line\": 59, \"annotations_start_line\": 60, \"method_start_line\": 62, \"end_line\": 99}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/apache\/commons\/math\/optimization\/direct\/MultiDirectionalTest.java\", \"method_name\": \"testMinimizeMaximize\", \"content\": \"  public void testMinimizeMaximize()\\n      throws FunctionEvaluationException, ConvergenceException {\\n\\n      \/\/ the following function has 4 local extrema:\\n      final double xM        = -3.841947088256863675365;\\n      final double yM        = -1.391745200270734924416;\\n      final double xP        =  0.2286682237349059125691;\\n      final double yP        = -yM;\\n      final double valueXmYm =  0.2373295333134216789769; \/\/ local  maximum\\n      final double valueXmYp = -valueXmYm;                \/\/ local  minimum\\n      final double valueXpYm = -0.7290400707055187115322; \/\/ global minimum\\n      final double valueXpYp = -valueXpYm;                \/\/ global maximum\\n      MultivariateRealFunction fourExtrema = new MultivariateRealFunction() {\\n          private static final long serialVersionUID = -7039124064449091152L;\\n          public double value(double[] variables) throws FunctionEvaluationException {\\n              final double x = variables[0];\\n              final double y = variables[1];\\n              return ((x == 0) || (y == 0)) ? 0 : (Math.atan(x) * Math.atan(x + 2) * Math.atan(y) * Math.atan(y) \/ (x * y));\\n          }\\n      };\\n\\n      MultiDirectional optimizer = new MultiDirectional();\\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-11, 1.0e-30));\\n      optimizer.setMaxIterations(200);\\n      optimizer.setStartConfiguration(new double[] { 0.2, 0.2 });\\n      RealPointValuePair optimum;\\n\\n      \/\/ minimization\\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { -3.0, 0 });\\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 4.0e-6);\\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\\n      Assert.assertEquals(valueXmYp, optimum.getValue(),    8.0e-13);\\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\\n\\n      optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\\n      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\\n\\n      \/\/ maximization\\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { -3.0, 0.0 });\\n      Assert.assertEquals(xM,        optimum.getPoint()[0], 7.0e-7);\\n      Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-7);\\n      Assert.assertEquals(valueXmYm, optimum.getValue(),    2.0e-14);\\n      Assert.assertTrue(optimizer.getEvaluations() > 120);\\n      Assert.assertTrue(optimizer.getEvaluations() < 150);\\n\\n      optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-15, 1.0e-30));\\n      optimum = optimizer.optimize(fourExtrema, GoalType.MAXIMIZE, new double[] { +1, 0 });\\n      Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\\n      Assert.assertEquals(yP,        optimum.getPoint()[1], 3.0e-6);\\n      Assert.assertEquals(valueXpYp, optimum.getValue(),    2.0e-12);\\n      Assert.assertTrue(optimizer.getEvaluations() > 180);\\n      Assert.assertTrue(optimizer.getEvaluations() < 220);\\n\\n  }\", \"javadoc_start_line\": 70, \"annotations_start_line\": 69, \"method_start_line\": 71, \"end_line\": 128}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/optimization\/direct\/DirectSearchOptimizer.java\", \"method_name\": \"optimize\", \"content\": \"    \/** {@inheritDoc} *\/\\n    public RealPointValuePair optimize(final MultivariateRealFunction f,\\n                                         final GoalType goalType,\\n                                         final double[] startPoint)\\n        throws FunctionEvaluationException, OptimizationException,\\n        IllegalArgumentException {\\n\\n        if (startConfiguration == null) {\\n            \/\/ no initial configuration has been set up for simplex\\n            \/\/ build a default one from a unit hypercube\\n            final double[] unit = new double[startPoint.length];\\n            Arrays.fill(unit, 1.0);\\n            setStartConfiguration(unit);\\n        }\\n\\n        this.f = f;\\n        final Comparator<RealPointValuePair> comparator =\\n            new Comparator<RealPointValuePair>() {\\n                public int compare(final RealPointValuePair o1,\\n                                   final RealPointValuePair o2) {\\n                    final double v1 = o1.getValue();\\n                    final double v2 = o2.getValue();\\n                    return (goalType == GoalType.MINIMIZE) ?\\n                            Double.compare(v1, v2) : Double.compare(v2, v1);\\n                }\\n            };\\n\\n        \/\/ initialize search\\n        iterations  = 0;\\n        evaluations = 0;\\n        buildSimplex(startPoint);\\n        evaluateSimplex(comparator);\\n\\n        RealPointValuePair[] previous = new RealPointValuePair[simplex.length];\\n        while (true) {\\n\\n            if (iterations > 0) {\\n                boolean converged = true;\\n                for (int i = 0; i < simplex.length; ++i) {\\n                    converged &= checker.converged(iterations, previous[i], simplex[i]);\\n                }\\n                if (converged) {\\n                    \/\/ we have found an optimum\\n                    return simplex[0];\\n                }\\n            }\\n\\n            \/\/ we still need to search\\n            System.arraycopy(simplex, 0, previous, 0, simplex.length);\\n            iterateSimplex(comparator);\\n\\n        }\\n\\n    }\", \"javadoc_start_line\": 258, \"annotations_start_line\": 259, \"method_start_line\": 263, \"end_line\": 311}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/apache\/commons\/math\/optimization\/direct\/MultiDirectional.java\", \"method_name\": \"iterateSimplex\", \"content\": \"    \/** {@inheritDoc} *\/\\n    @Override\\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\\n\\n        while (true) {\\n\\n            incrementIterationsCounter();\\n\\n            \/\/ save the original vertex\\n            final RealPointValuePair[] original = simplex;\\n            final RealPointValuePair best = original[0];\\n\\n            \/\/ perform a reflection step\\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\\n            if (comparator.compare(reflected, best) < 0) {\\n\\n                \/\/ compute the expanded simplex\\n                final RealPointValuePair[] reflectedSimplex = simplex;\\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\\n                if (comparator.compare(reflected, expanded) <= 0) {\\n                    \/\/ accept the reflected simplex\\n                    simplex = reflectedSimplex;\\n                }\\n\\n                return;\\n\\n            }\\n\\n            \/\/ compute the contracted simplex\\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\\n            if (comparator.compare(contracted, best) < 0) {\\n                \/\/ accept the contracted simplex\\n\\n            \/\/ check convergence\\n                return;\\n            }\\n\\n        }\\n\\n    }\", \"javadoc_start_line\": 59, \"annotations_start_line\": 60, \"method_start_line\": 62, \"end_line\": 99}"}]},{"name":"Math","version":93,"tour_id":0,"test":"{\"className\": \" org.apache.commons.math.util.MathUtilsTest\", \"methodName\": \"testFactorial\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"17!  expected:<3.55687428096E14> but was:<3.55687428096001E14>\"}","method":"{\"file_path\": \"\/src\/java\/org\/apache\/commons\/math\/util\/MathUtils.java\", \"method_name\": \"factorialLog\", \"content\": \"    \/**\\n     * Returns the natural logarithm of n!.\\n     * <p>\\n     * <Strong>Preconditions<\/strong>:\\n     * <ul>\\n     * <li> <code>n >= 0<\/code> (otherwise\\n     * <code>IllegalArgumentException<\/code> is thrown)<\/li>\\n     * <\/ul><\/p>\\n     * \\n     * @param n argument\\n     * @return <code>n!<\/code>\\n     * @throws IllegalArgumentException if preconditions are not met.\\n     *\/\\n    public static double factorialLog(final int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"must have n > 0 for n!\\\");\\n        }\\n        double logSum = 0;\\n        for (int i = 2; i <= n; i++) {\\n            logSum += Math.log((double)i);\\n        }\\n        return logSum;\\n    }\", \"javadoc_start_line\": 380, \"annotations_start_line\": 393, \"method_start_line\": 393, \"end_line\": 402}","steps":[{"step":"{\"file_path\": \"\/src\/test\/org\/apache\/commons\/math\/util\/MathUtilsTest.java\", \"method_name\": \"testFactorial\", \"content\": \"    public void testFactorial() {\\n        for (int i = 1; i < 21; i++) {\\n            assertEquals(i + \\\"! \\\", factorial(i), MathUtils.factorial(i));\\n            assertEquals(i + \\\"! \\\", (double)factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\\n            assertEquals(i + \\\"! \\\", Math.log((double)factorial(i)), MathUtils.factorialLog(i), 10E-12);\\n        }\\n        \\n        assertEquals(\\\"0\\\", 1, MathUtils.factorial(0));\\n        assertEquals(\\\"0\\\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\\n        assertEquals(\\\"0\\\", 0.0d, MathUtils.factorialLog(0), 1E-14);\\n    }\", \"javadoc_start_line\": 234, \"annotations_start_line\": 234, \"method_start_line\": 234, \"end_line\": 244}"},{"step":"{\"file_path\": \"\/src\/java\/org\/apache\/commons\/math\/util\/MathUtils.java\", \"method_name\": \"factorialDouble\", \"content\": \"    \/**\\n     * Returns n!. Shorthand for <code>n<\/code> <a\\n     * href=\\\"http:\/\/mathworld.wolfram.com\/Factorial.html\\\"> Factorial<\/a>, the\\n     * product of the numbers <code>1,...,n<\/code> as a <code>double<\/code>.\\n     * <p>\\n     * <Strong>Preconditions<\/strong>:\\n     * <ul>\\n     * <li> <code>n >= 0<\/code> (otherwise\\n     * <code>IllegalArgumentException<\/code> is thrown)<\/li>\\n     * <li> The result is small enough to fit into a <code>double<\/code>. The\\n     * largest value of <code>n<\/code> for which <code>n!<\/code> <\\n     * Double.MAX_VALUE<\/code> is 170. If the computed value exceeds\\n     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned<\/li>\\n     * <\/ul>\\n     * <\/p>\\n     * \\n     * @param n argument\\n     * @return <code>n!<\/code>\\n     * @throws IllegalArgumentException if n < 0\\n     *\/\\n    public static double factorialDouble(final int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"must have n >= 0 for n!\\\");\\n        }\\n        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\\n    }\", \"javadoc_start_line\": 353, \"annotations_start_line\": 373, \"method_start_line\": 373, \"end_line\": 378}"},{"step":"{\"file_path\": \"\/src\/java\/org\/apache\/commons\/math\/util\/MathUtils.java\", \"method_name\": \"factorialLog\", \"content\": \"    \/**\\n     * Returns the natural logarithm of n!.\\n     * <p>\\n     * <Strong>Preconditions<\/strong>:\\n     * <ul>\\n     * <li> <code>n >= 0<\/code> (otherwise\\n     * <code>IllegalArgumentException<\/code> is thrown)<\/li>\\n     * <\/ul><\/p>\\n     * \\n     * @param n argument\\n     * @return <code>n!<\/code>\\n     * @throws IllegalArgumentException if preconditions are not met.\\n     *\/\\n    public static double factorialLog(final int n) {\\n        if (n < 0) {\\n            throw new IllegalArgumentException(\\\"must have n > 0 for n!\\\");\\n        }\\n        double logSum = 0;\\n        for (int i = 2; i <= n; i++) {\\n            logSum += Math.log((double)i);\\n        }\\n        return logSum;\\n    }\", \"javadoc_start_line\": 380, \"annotations_start_line\": 393, \"method_start_line\": 393, \"end_line\": 402}"}]},{"name":"Time","version":9,"tour_id":0,"test":"{\"className\": \" org.joda.time.TestDateTimeZone\", \"methodName\": \"testForOffsetHoursMinutes_int_int\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"forOffsetMillis\", \"content\": \"    \/**\\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\\n     *\\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\\n     * @return the DateTimeZone object for the offset\\n     *\/\\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\\n        String id = printOffset(millisOffset);\\n        return fixedOffsetZone(id, millisOffset);\\n    }\", \"javadoc_start_line\": 275, \"annotations_start_line\": 281, \"method_start_line\": 281, \"end_line\": 284}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestDateTimeZone.java\", \"method_name\": \"testForOffsetHoursMinutes_int_int\", \"content\": \"    public void testForOffsetHoursMinutes_int_int() {\\n        assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\\n        assertEquals(DateTimeZone.forID(\\\"+23:59\\\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\\n        assertEquals(DateTimeZone.forID(\\\"+03:15\\\"), DateTimeZone.forOffsetHoursMinutes(3, 15));\\n        assertEquals(DateTimeZone.forID(\\\"-02:00\\\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\\n        assertEquals(DateTimeZone.forID(\\\"-02:30\\\"), DateTimeZone.forOffsetHoursMinutes(-2, 30));\\n        assertEquals(DateTimeZone.forID(\\\"-23:59\\\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\\n        try {\\n            DateTimeZone.forOffsetHoursMinutes(2, 60);\\n            fail();\\n        } catch (IllegalArgumentException ex) {}\\n        try {\\n            DateTimeZone.forOffsetHoursMinutes(-2, 60);\\n            fail();\\n        } catch (IllegalArgumentException ex) {}\\n        try {\\n            DateTimeZone.forOffsetHoursMinutes(2, -1);\\n            fail();\\n        } catch (IllegalArgumentException ex) {}\\n        try {\\n            DateTimeZone.forOffsetHoursMinutes(-2, -1);\\n            fail();\\n        } catch (IllegalArgumentException ex) {}\\n        try {\\n            DateTimeZone.forOffsetHoursMinutes(24, 0);\\n            fail();\\n        } catch (IllegalArgumentException ex) {}\\n        try {\\n            DateTimeZone.forOffsetHoursMinutes(-24, 0);\\n            fail();\\n        } catch (IllegalArgumentException ex) {}\\n    }        \", \"javadoc_start_line\": 303, \"annotations_start_line\": 303, \"method_start_line\": 303, \"end_line\": 334}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"forOffsetHoursMinutes\", \"content\": \"    \/**\\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\\n     * This method assumes 60 minutes in an hour, and standard length minutes.\\n     * <p>\\n     * This factory is a convenient way of constructing zones with a fixed offset.\\n     * The minutes value is always positive and in the range 0 to 59.\\n     * If constructed with the values (-2, 30), the resulting zone is '-02:30'.\\n     * \\n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\\n     * @param minutesOffset  the offset in minutes from UTC, must be between 0 and 59 inclusive\\n     * @return the DateTimeZone object for the offset\\n     * @throws IllegalArgumentException if the offset or minute is too large or too small\\n     *\/\\n    public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\\n        if (hoursOffset == 0 && minutesOffset == 0) {\\n            return DateTimeZone.UTC;\\n        }\\n        if (minutesOffset < 0 || minutesOffset > 59) {\\n            throw new IllegalArgumentException(\\\"Minutes out of range: \\\" + minutesOffset);\\n        }\\n        int offset = 0;\\n        try {\\n            int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\\n            if (hoursInMinutes < 0) {\\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\\n            } else {\\n                minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\\n            }\\n            offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\\n        } catch (ArithmeticException ex) {\\n            throw new IllegalArgumentException(\\\"Offset is too large\\\");\\n        }\\n        return forOffsetMillis(offset);\\n    }\", \"javadoc_start_line\": 240, \"annotations_start_line\": 253, \"method_start_line\": 253, \"end_line\": 273}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"forOffsetMillis\", \"content\": \"    \/**\\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\\n     *\\n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\\n     * @return the DateTimeZone object for the offset\\n     *\/\\n    public static DateTimeZone forOffsetMillis(int millisOffset) {\\n        String id = printOffset(millisOffset);\\n        return fixedOffsetZone(id, millisOffset);\\n    }\", \"javadoc_start_line\": 275, \"annotations_start_line\": 281, \"method_start_line\": 281, \"end_line\": 284}"}]},{"name":"Time","version":10,"tour_id":0,"test":"{\"className\": \" org.joda.time.TestDays\", \"methodName\": \"testFactory_daysBetween_RPartial_MonthDay\", \"error\": \"org.joda.time.IllegalFieldValueException\", \"message\": \"Value 29 for dayOfMonth must be in the range [1,28]\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/base\/BaseSingleFieldPeriod.java\", \"method_name\": \"between\", \"content\": \"    \/**\\n     * Calculates the number of whole units between the two specified partial datetimes.\\n     * <p>\\n     * The two partials must contain the same fields, for example you can specify\\n     * two <code>LocalDate<\/code> objects.\\n     *\\n     * @param start  the start partial date, validated to not be null\\n     * @param end  the end partial date, validated to not be null\\n     * @param zeroInstance  the zero instance constant, must not be null\\n     * @return the period\\n     * @throws IllegalArgumentException if the partials are null or invalid\\n     *\/\\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\\n        if (start == null || end == null) {\\n            throw new IllegalArgumentException(\\\"ReadablePartial objects must not be null\\\");\\n        }\\n        if (start.size() != end.size()) {\\n            throw new IllegalArgumentException(\\\"ReadablePartial objects must have the same set of fields\\\");\\n        }\\n        for (int i = 0, isize = start.size(); i < isize; i++) {\\n            if (start.getFieldType(i) != end.getFieldType(i)) {\\n                throw new IllegalArgumentException(\\\"ReadablePartial objects must have the same set of fields\\\");\\n            }\\n        }\\n        if (DateTimeUtils.isContiguous(start) == false) {\\n            throw new IllegalArgumentException(\\\"ReadablePartial objects must be contiguous\\\");\\n        }\\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\\n        return values[0];\\n    }\", \"javadoc_start_line\": 76, \"annotations_start_line\": 88, \"method_start_line\": 88, \"end_line\": 106}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestDays.java\", \"method_name\": \"testFactory_daysBetween_RPartial_MonthDay\", \"content\": \"    public void testFactory_daysBetween_RPartial_MonthDay() {\\n        MonthDay start1 = new MonthDay(2, 1);\\n        MonthDay start2 = new MonthDay(2, 28);\\n        MonthDay end1 = new MonthDay(2, 28);\\n        MonthDay end2 = new MonthDay(2, 29);\\n        \\n        assertEquals(27, Days.daysBetween(start1, end1).getDays());\\n        assertEquals(28, Days.daysBetween(start1, end2).getDays());\\n        assertEquals(0, Days.daysBetween(start2, end1).getDays());\\n        assertEquals(1, Days.daysBetween(start2, end2).getDays());\\n        \\n        assertEquals(-27, Days.daysBetween(end1, start1).getDays());\\n        assertEquals(-28, Days.daysBetween(end2, start1).getDays());\\n        assertEquals(0, Days.daysBetween(end1, start2).getDays());\\n        assertEquals(-1, Days.daysBetween(end2, start2).getDays());\\n    }\", \"javadoc_start_line\": 123, \"annotations_start_line\": 123, \"method_start_line\": 123, \"end_line\": 138}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/Days.java\", \"method_name\": \"daysBetween\", \"content\": \"    \/**\\n     * Creates a <code>Days<\/code> representing the number of whole days\\n     * between the two specified partial datetimes.\\n     * <p>\\n     * The two partials must contain the same fields, for example you can specify\\n     * two <code>LocalDate<\/code> objects.\\n     *\\n     * @param start  the start partial date, must not be null\\n     * @param end  the end partial date, must not be null\\n     * @return the period in days\\n     * @throws IllegalArgumentException if the partials are null or invalid\\n     *\/\\n    public static Days daysBetween(ReadablePartial start, ReadablePartial end) {\\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\\n            int days = chrono.days().getDifference(\\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\\n            return Days.days(days);\\n        }\\n        int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\\n        return Days.days(amount);\\n    }\", \"javadoc_start_line\": 122, \"annotations_start_line\": 134, \"method_start_line\": 134, \"end_line\": 143}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/base\/BaseSingleFieldPeriod.java\", \"method_name\": \"between\", \"content\": \"    \/**\\n     * Calculates the number of whole units between the two specified partial datetimes.\\n     * <p>\\n     * The two partials must contain the same fields, for example you can specify\\n     * two <code>LocalDate<\/code> objects.\\n     *\\n     * @param start  the start partial date, validated to not be null\\n     * @param end  the end partial date, validated to not be null\\n     * @param zeroInstance  the zero instance constant, must not be null\\n     * @return the period\\n     * @throws IllegalArgumentException if the partials are null or invalid\\n     *\/\\n    protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\\n        if (start == null || end == null) {\\n            throw new IllegalArgumentException(\\\"ReadablePartial objects must not be null\\\");\\n        }\\n        if (start.size() != end.size()) {\\n            throw new IllegalArgumentException(\\\"ReadablePartial objects must have the same set of fields\\\");\\n        }\\n        for (int i = 0, isize = start.size(); i < isize; i++) {\\n            if (start.getFieldType(i) != end.getFieldType(i)) {\\n                throw new IllegalArgumentException(\\\"ReadablePartial objects must have the same set of fields\\\");\\n            }\\n        }\\n        if (DateTimeUtils.isContiguous(start) == false) {\\n            throw new IllegalArgumentException(\\\"ReadablePartial objects must be contiguous\\\");\\n        }\\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\\n        int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\\n        return values[0];\\n    }\", \"javadoc_start_line\": 76, \"annotations_start_line\": 88, \"method_start_line\": 88, \"end_line\": 106}"}]},{"name":"Time","version":14,"tour_id":0,"test":"{\"className\": \" org.joda.time.TestMonthDay_Basics\", \"methodName\": \"testPlusMonths_int_negativeFromLeap\", \"error\": \"org.joda.time.IllegalFieldValueException\", \"message\": \"Value 29 for dayOfMonth must be in the range [1,28]\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/chrono\/BasicMonthOfYearDateTimeField.java\", \"method_name\": \"add\", \"content\": \"    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\\n        \/\/ overridden as superclass algorithm can't handle\\n        \/\/ 2004-02-29 + 48 months -> 2008-02-29 type dates\\n        if (valueToAdd == 0) {\\n            return values;\\n        }\\n            \/\/ month is largest field and being added to, such as month-day\\n        if (DateTimeUtils.isContiguous(partial)) {\\n            long instant = 0L;\\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\\n            }\\n            instant = add(instant, valueToAdd);\\n            return iChronology.get(partial, instant);\\n        } else {\\n            return super.add(partial, fieldIndex, values, valueToAdd);\\n        }\\n    }\", \"javadoc_start_line\": 203, \"annotations_start_line\": 203, \"method_start_line\": 203, \"end_line\": 220}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestMonthDay_Basics.java\", \"method_name\": \"testPlusMonths_int_negativeFromLeap\", \"content\": \"    public void testPlusMonths_int_negativeFromLeap() {\\n        MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\\n        MonthDay result = test.plusMonths(-1);\\n        MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\\n        assertEquals(expected, result);\\n    }\", \"javadoc_start_line\": 458, \"annotations_start_line\": 458, \"method_start_line\": 458, \"end_line\": 463}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/MonthDay.java\", \"method_name\": \"plusMonths\", \"content\": \"    \/**\\n     * Returns a copy of this month-day plus the specified number of months.\\n     * <p>\\n     * This month-day instance is immutable and unaffected by this method call.\\n     * The month will wrap at the end of the year from December to January.\\n     * The day will be adjusted to the last valid value if necessary.\\n     * <p>\\n     * The following three lines are identical in effect:\\n     * <pre>\\n     * MonthDay added = md.plusMonths(6);\\n     * MonthDay added = md.plus(Period.months(6));\\n     * MonthDay added = md.withFieldAdded(DurationFieldType.months(), 6);\\n     * <\/pre>\\n     *\\n     * @param months  the amount of months to add, may be negative\\n     * @return the new month-day plus the increased months, never null\\n     *\/\\n    public MonthDay plusMonths(int months) {\\n        return withFieldAdded(DurationFieldType.months(), months);\\n    }\", \"javadoc_start_line\": 574, \"annotations_start_line\": 591, \"method_start_line\": 591, \"end_line\": 593}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/MonthDay.java\", \"method_name\": \"withFieldAdded\", \"content\": \"    \/**\\n     * Returns a copy of this month-day with the value of the specified field increased.\\n     * <p>\\n     * If the addition is zero, then <code>this<\/code> is returned.\\n     * <p>\\n     * These three lines are equivalent:\\n     * <pre>\\n     * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\\n     * MonthDay added = md.plusDays(6);\\n     * MonthDay added = md.dayOfMonth().addToCopy(6);\\n     * <\/pre>\\n     * \\n     * @param fieldType  the field type to add to, not null\\n     * @param amount  the amount to add\\n     * @return a copy of this instance with the field updated, never null\\n     * @throws IllegalArgumentException if the value is null or invalid\\n     * @throws ArithmeticException if the new date-time exceeds the capacity\\n     *\/\\n    public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\\n        int index = indexOfSupported(fieldType);\\n        if (amount == 0) {\\n            return this;\\n        }\\n        int[] newValues = getValues();\\n        newValues = getField(index).add(this, index, newValues, amount);\\n        return new MonthDay(this, newValues);\\n    }\", \"javadoc_start_line\": 495, \"annotations_start_line\": 513, \"method_start_line\": 513, \"end_line\": 521}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/chrono\/BasicMonthOfYearDateTimeField.java\", \"method_name\": \"add\", \"content\": \"    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\\n        \/\/ overridden as superclass algorithm can't handle\\n        \/\/ 2004-02-29 + 48 months -> 2008-02-29 type dates\\n        if (valueToAdd == 0) {\\n            return values;\\n        }\\n            \/\/ month is largest field and being added to, such as month-day\\n        if (DateTimeUtils.isContiguous(partial)) {\\n            long instant = 0L;\\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\\n            }\\n            instant = add(instant, valueToAdd);\\n            return iChronology.get(partial, instant);\\n        } else {\\n            return super.add(partial, fieldIndex, values, valueToAdd);\\n        }\\n    }\", \"javadoc_start_line\": 203, \"annotations_start_line\": 203, \"method_start_line\": 203, \"end_line\": 220}"}]},{"name":"Time","version":17,"tour_id":0,"test":"{\"className\": \" org.joda.time.TestDateTimeZoneCutover\", \"methodName\": \"testBug3476684_adjustOffset\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<2012-02-25T23:15:00.000-03:00> but was:<2012-02-25T23:15:00.000-02:00>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"adjustOffset\", \"content\": \"    \/**\\n     * Adjusts the offset to be the earlier or later one during an overlap.\\n     * \\n     * @param instant  the instant to adjust\\n     * @param earlierOrLater  false for earlier, true for later\\n     * @return the adjusted instant millis\\n     *\/\\n    public long adjustOffset(long instant, boolean earlierOrLater) {\\n        \/\/ a bit messy, but will work in all non-pathological cases\\n        \\n        \/\/ evaluate 3 hours before and after to work out if anything is happening\\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\\n        if (instantBefore == instantAfter) {\\n            return instant;  \/\/ not an overlap (less than is a gap, equal is normal case)\\n        }\\n        \\n        \/\/ work out range of instants that have duplicate local times\\n        long local = convertUTCToLocal(instant);\\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\\n        \\n        \/\/ calculate result\\n          \/\/ currently in later offset\\n          \/\/ currently in earlier offset\\n    }\", \"javadoc_start_line\": 1156, \"annotations_start_line\": 1163, \"method_start_line\": 1163, \"end_line\": 1180}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestDateTimeZoneCutover.java\", \"method_name\": \"testBug3476684_adjustOffset\", \"content\": \"    public void testBug3476684_adjustOffset() {\\n        final DateTimeZone zone = DateTimeZone.forID(\\\"America\/Sao_Paulo\\\");\\n        DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\\n        DateTime baseBefore = base.plusHours(1);  \/\/ 23:15 (first)\\n        DateTime baseAfter = base.plusHours(2);  \/\/ 23:15 (second)\\n        \\n        assertSame(base, base.withEarlierOffsetAtOverlap());\\n        assertSame(base, base.withLaterOffsetAtOverlap());\\n        \\n        assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\\n        assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\\n        \\n        assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\\n        assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\\n    }\", \"javadoc_start_line\": 1249, \"annotations_start_line\": 1249, \"method_start_line\": 1249, \"end_line\": 1263}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTime.java\", \"method_name\": \"withLaterOffsetAtOverlap\", \"content\": \"    \/**\\n     * Returns a copy of this ZonedDateTime changing the zone offset to the later\\n     * of the two valid offsets at a local time-line overlap.\\n     * <p>\\n     * This method only has any effect when the local time-line overlaps, such as at\\n     * an autumn daylight savings cutover. In this scenario, there are two valid offsets\\n     * for the local date-time. Calling this method will return a date-time with the\\n     * later of the two selected.\\n     * <p>\\n     * If this method is called when it is not an overlap, this is returned.\\n     * <p>\\n     * This instance is immutable and unaffected by this method call.\\n     *\\n     * @return a copy of this datetime with the latest valid offset for the local datetime\\n     *\/\\n    public DateTime withLaterOffsetAtOverlap() {\\n        long newMillis = getZone().adjustOffset(getMillis(), true);\\n        return withMillis(newMillis);\\n    }\", \"javadoc_start_line\": 669, \"annotations_start_line\": 684, \"method_start_line\": 684, \"end_line\": 687}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"adjustOffset\", \"content\": \"    \/**\\n     * Adjusts the offset to be the earlier or later one during an overlap.\\n     * \\n     * @param instant  the instant to adjust\\n     * @param earlierOrLater  false for earlier, true for later\\n     * @return the adjusted instant millis\\n     *\/\\n    public long adjustOffset(long instant, boolean earlierOrLater) {\\n        \/\/ a bit messy, but will work in all non-pathological cases\\n        \\n        \/\/ evaluate 3 hours before and after to work out if anything is happening\\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\\n        if (instantBefore == instantAfter) {\\n            return instant;  \/\/ not an overlap (less than is a gap, equal is normal case)\\n        }\\n        \\n        \/\/ work out range of instants that have duplicate local times\\n        long local = convertUTCToLocal(instant);\\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\\n        \\n        \/\/ calculate result\\n          \/\/ currently in later offset\\n          \/\/ currently in earlier offset\\n    }\", \"javadoc_start_line\": 1156, \"annotations_start_line\": 1163, \"method_start_line\": 1163, \"end_line\": 1180}"}]},{"name":"Time","version":18,"tour_id":0,"test":"{\"className\": \" org.joda.time.chrono.TestGJChronology\", \"methodName\": \"testLeapYearRulesConstruction\", \"error\": \"org.joda.time.IllegalFieldValueException\", \"message\": \"Value 29 for dayOfMonth must be in the range [1,28]\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/chrono\/GJChronology.java\", \"method_name\": \"getDateTimeMillis\", \"content\": \"    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\\n                                  int hourOfDay, int minuteOfHour,\\n                                  int secondOfMinute, int millisOfSecond)\\n        throws IllegalArgumentException\\n    {\\n        Chronology base;\\n        if ((base = getBase()) != null) {\\n            return base.getDateTimeMillis\\n                (year, monthOfYear, dayOfMonth,\\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\\n        }\\n\\n        \/\/ Assume date is Gregorian.\\n        long instant;\\n            instant = iGregorianChronology.getDateTimeMillis\\n                (year, monthOfYear, dayOfMonth,\\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\\n        if (instant < iCutoverMillis) {\\n            \/\/ Maybe it's Julian.\\n            instant = iJulianChronology.getDateTimeMillis\\n                (year, monthOfYear, dayOfMonth,\\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\\n            if (instant >= iCutoverMillis) {\\n                \/\/ Okay, it's in the illegal cutover gap.\\n                throw new IllegalArgumentException(\\\"Specified date does not exist\\\");\\n            }\\n        }\\n        return instant;\\n    }\", \"javadoc_start_line\": 350, \"annotations_start_line\": 350, \"method_start_line\": 354, \"end_line\": 378}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/chrono\/TestGJChronology.java\", \"method_name\": \"testLeapYearRulesConstruction\", \"content\": \"    public void testLeapYearRulesConstruction() {\\n        \/\/ 1500 not leap in Gregorian, but is leap in Julian\\n        DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC());\\n        assertEquals(dt.getYear(), 1500);\\n        assertEquals(dt.getMonthOfYear(), 2);\\n        assertEquals(dt.getDayOfMonth(), 29);\\n    }\", \"javadoc_start_line\": 494, \"annotations_start_line\": 494, \"method_start_line\": 494, \"end_line\": 500}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateMidnight.java\", \"method_name\": \"DateMidnight\", \"content\": \"    \/**\\n     * Constructs an instance from datetime field values\\n     * using the specified chronology.\\n     * The constructed object will have a local time of midnight.\\n     * <p>\\n     * If the chronology is null, <code>ISOChronology<\/code>\\n     * in the default time zone is used.\\n     *\\n     * @param year  the year\\n     * @param monthOfYear  the month of the year\\n     * @param dayOfMonth  the day of the month\\n     * @param chronology  the chronology, null means ISOChronology in default zone\\n     *\/\\n    public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\\n        super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);\\n    }\", \"javadoc_start_line\": 329, \"annotations_start_line\": 342, \"method_start_line\": 342, \"end_line\": 344}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/base\/BaseDateTime.java\", \"method_name\": \"BaseDateTime\", \"content\": \"    \/**\\n     * Constructs an instance from datetime field values\\n     * using the specified chronology.\\n     * <p>\\n     * If the chronology is null, <code>ISOChronology<\/code>\\n     * in the default time zone is used.\\n     *\\n     * @param year  the year\\n     * @param monthOfYear  the month of the year\\n     * @param dayOfMonth  the day of the month\\n     * @param hourOfDay  the hour of the day\\n     * @param minuteOfHour  the minute of the hour\\n     * @param secondOfMinute  the second of the minute\\n     * @param millisOfSecond  the millisecond of the second\\n     * @param chronology  the chronology, null means ISOChronology in default zone\\n     *\/\\n    public BaseDateTime(\\n            int year,\\n            int monthOfYear,\\n            int dayOfMonth,\\n            int hourOfDay,\\n            int minuteOfHour,\\n            int secondOfMinute,\\n            int millisOfSecond,\\n            Chronology chronology) {\\n        super();\\n        iChronology = checkChronology(chronology);\\n        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\\n        iMillis = checkInstant(instant, iChronology);\\n    }\", \"javadoc_start_line\": 227, \"annotations_start_line\": 243, \"method_start_line\": 251, \"end_line\": 257}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/chrono\/GJChronology.java\", \"method_name\": \"getDateTimeMillis\", \"content\": \"    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\\n                                  int hourOfDay, int minuteOfHour,\\n                                  int secondOfMinute, int millisOfSecond)\\n        throws IllegalArgumentException\\n    {\\n        Chronology base;\\n        if ((base = getBase()) != null) {\\n            return base.getDateTimeMillis\\n                (year, monthOfYear, dayOfMonth,\\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\\n        }\\n\\n        \/\/ Assume date is Gregorian.\\n        long instant;\\n            instant = iGregorianChronology.getDateTimeMillis\\n                (year, monthOfYear, dayOfMonth,\\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\\n        if (instant < iCutoverMillis) {\\n            \/\/ Maybe it's Julian.\\n            instant = iJulianChronology.getDateTimeMillis\\n                (year, monthOfYear, dayOfMonth,\\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\\n            if (instant >= iCutoverMillis) {\\n                \/\/ Okay, it's in the illegal cutover gap.\\n                throw new IllegalArgumentException(\\\"Specified date does not exist\\\");\\n            }\\n        }\\n        return instant;\\n    }\", \"javadoc_start_line\": 350, \"annotations_start_line\": 350, \"method_start_line\": 354, \"end_line\": 378}"}]},{"name":"Time","version":23,"tour_id":0,"test":"{\"className\": \" org.joda.time.TestDateTimeZone\", \"methodName\": \"testForID_String_old\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"expected:<[WET]> but was:<[Europe\/London]>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"getConvertedId\", \"content\": \"    \/**\\n     * Converts an old style id to a new style id.\\n     * \\n     * @param id  the old style id\\n     * @return the new style id, null if not found\\n     *\/\\n    private static synchronized String getConvertedId(String id) {\\n        Map<String, String> map = cZoneIdConversion;\\n        if (map == null) {\\n            \/\/ Backwards compatibility with TimeZone.\\n            map = new HashMap<String, String>();\\n            map.put(\\\"GMT\\\", \\\"UTC\\\");\\n            map.put(\\\"MIT\\\", \\\"Pacific\/Apia\\\");\\n            map.put(\\\"HST\\\", \\\"Pacific\/Honolulu\\\");  \/\/ JDK 1.1 compatible\\n            map.put(\\\"AST\\\", \\\"America\/Anchorage\\\");\\n            map.put(\\\"PST\\\", \\\"America\/Los_Angeles\\\");\\n            map.put(\\\"MST\\\", \\\"America\/Denver\\\");  \/\/ JDK 1.1 compatible\\n            map.put(\\\"PNT\\\", \\\"America\/Phoenix\\\");\\n            map.put(\\\"CST\\\", \\\"America\/Chicago\\\");\\n            map.put(\\\"EST\\\", \\\"America\/New_York\\\");  \/\/ JDK 1.1 compatible\\n            map.put(\\\"IET\\\", \\\"America\/Indianapolis\\\");\\n            map.put(\\\"PRT\\\", \\\"America\/Puerto_Rico\\\");\\n            map.put(\\\"CNT\\\", \\\"America\/St_Johns\\\");\\n            map.put(\\\"AGT\\\", \\\"America\/Buenos_Aires\\\");\\n            map.put(\\\"BET\\\", \\\"America\/Sao_Paulo\\\");\\n            map.put(\\\"WET\\\", \\\"Europe\/London\\\");\\n            map.put(\\\"ECT\\\", \\\"Europe\/Paris\\\");\\n            map.put(\\\"ART\\\", \\\"Africa\/Cairo\\\");\\n            map.put(\\\"CAT\\\", \\\"Africa\/Harare\\\");\\n            map.put(\\\"EET\\\", \\\"Europe\/Bucharest\\\");\\n            map.put(\\\"EAT\\\", \\\"Africa\/Addis_Ababa\\\");\\n            map.put(\\\"MET\\\", \\\"Asia\/Tehran\\\");\\n            map.put(\\\"NET\\\", \\\"Asia\/Yerevan\\\");\\n            map.put(\\\"PLT\\\", \\\"Asia\/Karachi\\\");\\n            map.put(\\\"IST\\\", \\\"Asia\/Calcutta\\\");\\n            map.put(\\\"BST\\\", \\\"Asia\/Dhaka\\\");\\n            map.put(\\\"VST\\\", \\\"Asia\/Saigon\\\");\\n            map.put(\\\"CTT\\\", \\\"Asia\/Shanghai\\\");\\n            map.put(\\\"JST\\\", \\\"Asia\/Tokyo\\\");\\n            map.put(\\\"ACT\\\", \\\"Australia\/Darwin\\\");\\n            map.put(\\\"AET\\\", \\\"Australia\/Sydney\\\");\\n            map.put(\\\"SST\\\", \\\"Pacific\/Guadalcanal\\\");\\n            map.put(\\\"NST\\\", \\\"Pacific\/Auckland\\\");\\n            cZoneIdConversion = map;\\n        }\\n        return map.get(id);\\n    }\", \"javadoc_start_line\": 552, \"annotations_start_line\": 558, \"method_start_line\": 558, \"end_line\": 598}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestDateTimeZone.java\", \"method_name\": \"testForID_String_old\", \"content\": \"    public void testForID_String_old() {\\n        Map<String, String> map = new LinkedHashMap<String, String>();\\n        map.put(\\\"GMT\\\", \\\"UTC\\\");\\n        map.put(\\\"WET\\\", \\\"WET\\\");\\n        map.put(\\\"CET\\\", \\\"CET\\\");\\n        map.put(\\\"MET\\\", \\\"CET\\\");\\n        map.put(\\\"ECT\\\", \\\"CET\\\");\\n        map.put(\\\"EET\\\", \\\"EET\\\");\\n        map.put(\\\"MIT\\\", \\\"Pacific\/Apia\\\");\\n        map.put(\\\"HST\\\", \\\"Pacific\/Honolulu\\\");\\n        map.put(\\\"AST\\\", \\\"America\/Anchorage\\\");\\n        map.put(\\\"PST\\\", \\\"America\/Los_Angeles\\\");\\n        map.put(\\\"MST\\\", \\\"America\/Denver\\\");\\n        map.put(\\\"PNT\\\", \\\"America\/Phoenix\\\");\\n        map.put(\\\"CST\\\", \\\"America\/Chicago\\\");\\n        map.put(\\\"EST\\\", \\\"America\/New_York\\\");\\n        map.put(\\\"IET\\\", \\\"America\/Indiana\/Indianapolis\\\");\\n        map.put(\\\"PRT\\\", \\\"America\/Puerto_Rico\\\");\\n        map.put(\\\"CNT\\\", \\\"America\/St_Johns\\\");\\n        map.put(\\\"AGT\\\", \\\"America\/Argentina\/Buenos_Aires\\\");\\n        map.put(\\\"BET\\\", \\\"America\/Sao_Paulo\\\");\\n        map.put(\\\"ART\\\", \\\"Africa\/Cairo\\\");\\n        map.put(\\\"CAT\\\", \\\"Africa\/Harare\\\");\\n        map.put(\\\"EAT\\\", \\\"Africa\/Addis_Ababa\\\");\\n        map.put(\\\"NET\\\", \\\"Asia\/Yerevan\\\");\\n        map.put(\\\"PLT\\\", \\\"Asia\/Karachi\\\");\\n        map.put(\\\"IST\\\", \\\"Asia\/Kolkata\\\");\\n        map.put(\\\"BST\\\", \\\"Asia\/Dhaka\\\");\\n        map.put(\\\"VST\\\", \\\"Asia\/Ho_Chi_Minh\\\");\\n        map.put(\\\"CTT\\\", \\\"Asia\/Shanghai\\\");\\n        map.put(\\\"JST\\\", \\\"Asia\/Tokyo\\\");\\n        map.put(\\\"ACT\\\", \\\"Australia\/Darwin\\\");\\n        map.put(\\\"AET\\\", \\\"Australia\/Sydney\\\");\\n        map.put(\\\"SST\\\", \\\"Pacific\/Guadalcanal\\\");\\n        map.put(\\\"NST\\\", \\\"Pacific\/Auckland\\\");\\n        for (String key : map.keySet()) {\\n            String value = map.get(key);\\n            TimeZone juZone = TimeZone.getTimeZone(key);\\n            DateTimeZone zone = DateTimeZone.forTimeZone(juZone);\\n            assertEquals(value, zone.getID());\\n\/\/            System.out.println(juZone);\\n\/\/            System.out.println(juZone.getDisplayName());\\n\/\/            System.out.println(zone);\\n\/\/            System.out.println(\\\"------\\\");\\n        }\\n    }\", \"javadoc_start_line\": 243, \"annotations_start_line\": 243, \"method_start_line\": 243, \"end_line\": 288}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"forTimeZone\", \"content\": \"    \/**\\n     * Gets a time zone instance for a JDK TimeZone.\\n     * <p>\\n     * DateTimeZone only accepts a subset of the IDs from TimeZone. The\\n     * excluded IDs are the short three letter form (except UTC). This \\n     * method will attempt to convert between time zones created using the\\n     * short IDs and the full version.\\n     * <p>\\n     * This method is not designed to parse time zones with rules created by\\n     * applications using <code>SimpleTimeZone<\/code> directly.\\n     * \\n     * @param zone  the zone to convert, null means default\\n     * @return the DateTimeZone object for the zone\\n     * @throws IllegalArgumentException if the zone is not recognised\\n     *\/\\n    public static DateTimeZone forTimeZone(TimeZone zone) {\\n        if (zone == null) {\\n            return getDefault();\\n        }\\n        final String id = zone.getID();\\n        if (id.equals(\\\"UTC\\\")) {\\n            return DateTimeZone.UTC;\\n        }\\n\\n        \/\/ Convert from old alias before consulting provider since they may differ.\\n        DateTimeZone dtz = null;\\n        String convId = getConvertedId(id);\\n        if (convId != null) {\\n            dtz = cProvider.getZone(convId);\\n        }\\n        if (dtz == null) {\\n            dtz = cProvider.getZone(id);\\n        }\\n        if (dtz != null) {\\n            return dtz;\\n        }\\n\\n        \/\/ Support GMT+\/-hh:mm formats\\n        if (convId == null) {\\n            convId = zone.getDisplayName();\\n            if (convId.startsWith(\\\"GMT+\\\") || convId.startsWith(\\\"GMT-\\\")) {\\n                convId = convId.substring(3);\\n                int offset = parseOffset(convId);\\n                if (offset == 0L) {\\n                    return DateTimeZone.UTC;\\n                } else {\\n                    convId = printOffset(offset);\\n                    return fixedOffsetZone(convId, offset);\\n                }\\n            }\\n        }\\n        throw new IllegalArgumentException(\\\"The datetime zone id '\\\" + id + \\\"' is not recognised\\\");\\n    }\", \"javadoc_start_line\": 286, \"annotations_start_line\": 301, \"method_start_line\": 301, \"end_line\": 338}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"getConvertedId\", \"content\": \"    \/**\\n     * Converts an old style id to a new style id.\\n     * \\n     * @param id  the old style id\\n     * @return the new style id, null if not found\\n     *\/\\n    private static synchronized String getConvertedId(String id) {\\n        Map<String, String> map = cZoneIdConversion;\\n        if (map == null) {\\n            \/\/ Backwards compatibility with TimeZone.\\n            map = new HashMap<String, String>();\\n            map.put(\\\"GMT\\\", \\\"UTC\\\");\\n            map.put(\\\"MIT\\\", \\\"Pacific\/Apia\\\");\\n            map.put(\\\"HST\\\", \\\"Pacific\/Honolulu\\\");  \/\/ JDK 1.1 compatible\\n            map.put(\\\"AST\\\", \\\"America\/Anchorage\\\");\\n            map.put(\\\"PST\\\", \\\"America\/Los_Angeles\\\");\\n            map.put(\\\"MST\\\", \\\"America\/Denver\\\");  \/\/ JDK 1.1 compatible\\n            map.put(\\\"PNT\\\", \\\"America\/Phoenix\\\");\\n            map.put(\\\"CST\\\", \\\"America\/Chicago\\\");\\n            map.put(\\\"EST\\\", \\\"America\/New_York\\\");  \/\/ JDK 1.1 compatible\\n            map.put(\\\"IET\\\", \\\"America\/Indianapolis\\\");\\n            map.put(\\\"PRT\\\", \\\"America\/Puerto_Rico\\\");\\n            map.put(\\\"CNT\\\", \\\"America\/St_Johns\\\");\\n            map.put(\\\"AGT\\\", \\\"America\/Buenos_Aires\\\");\\n            map.put(\\\"BET\\\", \\\"America\/Sao_Paulo\\\");\\n            map.put(\\\"WET\\\", \\\"Europe\/London\\\");\\n            map.put(\\\"ECT\\\", \\\"Europe\/Paris\\\");\\n            map.put(\\\"ART\\\", \\\"Africa\/Cairo\\\");\\n            map.put(\\\"CAT\\\", \\\"Africa\/Harare\\\");\\n            map.put(\\\"EET\\\", \\\"Europe\/Bucharest\\\");\\n            map.put(\\\"EAT\\\", \\\"Africa\/Addis_Ababa\\\");\\n            map.put(\\\"MET\\\", \\\"Asia\/Tehran\\\");\\n            map.put(\\\"NET\\\", \\\"Asia\/Yerevan\\\");\\n            map.put(\\\"PLT\\\", \\\"Asia\/Karachi\\\");\\n            map.put(\\\"IST\\\", \\\"Asia\/Calcutta\\\");\\n            map.put(\\\"BST\\\", \\\"Asia\/Dhaka\\\");\\n            map.put(\\\"VST\\\", \\\"Asia\/Saigon\\\");\\n            map.put(\\\"CTT\\\", \\\"Asia\/Shanghai\\\");\\n            map.put(\\\"JST\\\", \\\"Asia\/Tokyo\\\");\\n            map.put(\\\"ACT\\\", \\\"Australia\/Darwin\\\");\\n            map.put(\\\"AET\\\", \\\"Australia\/Sydney\\\");\\n            map.put(\\\"SST\\\", \\\"Pacific\/Guadalcanal\\\");\\n            map.put(\\\"NST\\\", \\\"Pacific\/Auckland\\\");\\n            cZoneIdConversion = map;\\n        }\\n        return map.get(id);\\n    }\", \"javadoc_start_line\": 552, \"annotations_start_line\": 558, \"method_start_line\": 558, \"end_line\": 598}"}]},{"name":"Time","version":24,"tour_id":0,"test":"{\"className\": \" org.joda.time.format.TestDateTimeFormatter\", \"methodName\": \"testParseLocalDate_weekyear_month_week_2010\", \"error\": \"junit.framework.AssertionFailedError\", \"message\": \"expected:<2010-01-04> but was:<2008-12-29>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/format\/DateTimeParserBucket.java\", \"method_name\": \"computeMillis\", \"content\": \"    \/**\\n     * Computes the parsed datetime by setting the saved fields.\\n     * This method is idempotent, but it is not thread-safe.\\n     *\\n     * @param resetFields false by default, but when true, unsaved field values are cleared\\n     * @param text optional text being parsed, to be included in any error message\\n     * @return milliseconds since 1970-01-01T00:00:00Z\\n     * @throws IllegalArgumentException if any field is out of range\\n     * @since 1.3\\n     *\/\\n    public long computeMillis(boolean resetFields, String text) {\\n        SavedField[] savedFields = iSavedFields;\\n        int count = iSavedFieldsCount;\\n        if (iSavedFieldsShared) {\\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\\n            iSavedFieldsShared = false;\\n        }\\n        sort(savedFields, count);\\n        if (count > 0) {\\n            \/\/ alter base year for parsing if first field is month or day\\n            DurationField months = DurationFieldType.months().getField(iChrono);\\n            DurationField days = DurationFieldType.days().getField(iChrono);\\n            DurationField first = savedFields[0].iField.getDurationField();\\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\\n                saveField(DateTimeFieldType.year(), iDefaultYear);\\n                return computeMillis(resetFields, text);\\n            }\\n        }\\n\\n        long millis = iMillis;\\n        try {\\n            for (int i = 0; i < count; i++) {\\n                millis = savedFields[i].set(millis, resetFields);\\n            }\\n        } catch (IllegalFieldValueException e) {\\n            if (text != null) {\\n                e.prependMessage(\\\"Cannot parse \\\\\\\"\\\" + text + '\\\"');\\n            }\\n            throw e;\\n        }\\n        \\n        if (iZone == null) {\\n            millis -= iOffset;\\n        } else {\\n            int offset = iZone.getOffsetFromLocal(millis);\\n            millis -= offset;\\n            if (offset != iZone.getOffset(millis)) {\\n                String message =\\n                    \\\"Illegal instant due to time zone offset transition (\\\" + iZone + ')';\\n                if (text != null) {\\n                    message = \\\"Cannot parse \\\\\\\"\\\" + text + \\\"\\\\\\\": \\\" + message;\\n                }\\n                throw new IllegalArgumentException(message);\\n            }\\n        }\\n        \\n        return millis;\\n    }\", \"javadoc_start_line\": 321, \"annotations_start_line\": 331, \"method_start_line\": 331, \"end_line\": 378}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/format\/TestDateTimeFormatter.java\", \"method_name\": \"testParseLocalDate_weekyear_month_week_2010\", \"content\": \"    public void testParseLocalDate_weekyear_month_week_2010() {\\n        Chronology chrono = GJChronology.getInstanceUTC();\\n        DateTimeFormatter f = DateTimeFormat.forPattern(\\\"xxxx-MM-ww\\\").withChronology(chrono);\\n        assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\\\"2010-01-01\\\"));\\n    }\", \"javadoc_start_line\": 425, \"annotations_start_line\": 425, \"method_start_line\": 425, \"end_line\": 429}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/format\/DateTimeFormatter.java\", \"method_name\": \"parseLocalDate\", \"content\": \"    \/**\\n     * Parses only the local date from the given text, returning a new LocalDate.\\n     * <p>\\n     * This will parse the text fully according to the formatter, using the UTC zone.\\n     * Once parsed, only the local date will be used.\\n     * This means that any parsed time, time-zone or offset field is completely ignored.\\n     * It also means that the zone and offset-parsed settings are ignored.\\n     *\\n     * @param text  the text to parse, not null\\n     * @return the parsed date, never null\\n     * @throws UnsupportedOperationException if parsing is not supported\\n     * @throws IllegalArgumentException if the text to parse is invalid\\n     * @since 2.0\\n     *\/\\n    public LocalDate parseLocalDate(String text) {\\n        return parseLocalDateTime(text).toLocalDate();\\n    }\", \"javadoc_start_line\": 744, \"annotations_start_line\": 758, \"method_start_line\": 758, \"end_line\": 760}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/format\/DateTimeFormatter.java\", \"method_name\": \"parseLocalDateTime\", \"content\": \"    \/**\\n     * Parses only the local date-time from the given text, returning a new LocalDate.\\n     * <p>\\n     * This will parse the text fully according to the formatter, using the UTC zone.\\n     * Once parsed, only the local date-time will be used.\\n     * This means that any parsed time-zone or offset field is completely ignored.\\n     * It also means that the zone and offset-parsed settings are ignored.\\n     *\\n     * @param text  the text to parse, not null\\n     * @return the parsed date-time, never null\\n     * @throws UnsupportedOperationException if parsing is not supported\\n     * @throws IllegalArgumentException if the text to parse is invalid\\n     * @since 2.0\\n     *\/\\n    public LocalDateTime parseLocalDateTime(String text) {\\n        DateTimeParser parser = requireParser();\\n        \\n        Chronology chrono = selectChronology(null).withUTC();  \/\/ always use UTC, avoiding DST gaps\\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\\n        int newPos = parser.parseInto(bucket, text, 0);\\n        if (newPos >= 0) {\\n            if (newPos >= text.length()) {\\n                long millis = bucket.computeMillis(true, text);\\n                if (bucket.getZone() == null) {  \/\/ treat withOffsetParsed() as being true\\n                    int parsedOffset = bucket.getOffset();\\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\\n                    chrono = chrono.withZone(parsedZone);\\n                }\\n                return new LocalDateTime(millis, chrono);\\n            }\\n        } else {\\n            newPos = ~newPos;\\n        }\\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\\n    }\", \"javadoc_start_line\": 780, \"annotations_start_line\": 794, \"method_start_line\": 794, \"end_line\": 814}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/format\/DateTimeParserBucket.java\", \"method_name\": \"computeMillis\", \"content\": \"    \/**\\n     * Computes the parsed datetime by setting the saved fields.\\n     * This method is idempotent, but it is not thread-safe.\\n     *\\n     * @param resetFields false by default, but when true, unsaved field values are cleared\\n     * @param text optional text being parsed, to be included in any error message\\n     * @return milliseconds since 1970-01-01T00:00:00Z\\n     * @throws IllegalArgumentException if any field is out of range\\n     * @since 1.3\\n     *\/\\n    public long computeMillis(boolean resetFields, String text) {\\n        SavedField[] savedFields = iSavedFields;\\n        int count = iSavedFieldsCount;\\n        if (iSavedFieldsShared) {\\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\\n            iSavedFieldsShared = false;\\n        }\\n        sort(savedFields, count);\\n        if (count > 0) {\\n            \/\/ alter base year for parsing if first field is month or day\\n            DurationField months = DurationFieldType.months().getField(iChrono);\\n            DurationField days = DurationFieldType.days().getField(iChrono);\\n            DurationField first = savedFields[0].iField.getDurationField();\\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\\n                saveField(DateTimeFieldType.year(), iDefaultYear);\\n                return computeMillis(resetFields, text);\\n            }\\n        }\\n\\n        long millis = iMillis;\\n        try {\\n            for (int i = 0; i < count; i++) {\\n                millis = savedFields[i].set(millis, resetFields);\\n            }\\n        } catch (IllegalFieldValueException e) {\\n            if (text != null) {\\n                e.prependMessage(\\\"Cannot parse \\\\\\\"\\\" + text + '\\\"');\\n            }\\n            throw e;\\n        }\\n        \\n        if (iZone == null) {\\n            millis -= iOffset;\\n        } else {\\n            int offset = iZone.getOffsetFromLocal(millis);\\n            millis -= offset;\\n            if (offset != iZone.getOffset(millis)) {\\n                String message =\\n                    \\\"Illegal instant due to time zone offset transition (\\\" + iZone + ')';\\n                if (text != null) {\\n                    message = \\\"Cannot parse \\\\\\\"\\\" + text + \\\"\\\\\\\": \\\" + message;\\n                }\\n                throw new IllegalArgumentException(message);\\n            }\\n        }\\n        \\n        return millis;\\n    }\", \"javadoc_start_line\": 321, \"annotations_start_line\": 331, \"method_start_line\": 331, \"end_line\": 378}"}]},{"name":"Time","version":25,"tour_id":1,"test":"{\"className\": \" org.joda.time.TestDateTimeZoneCutover\", \"methodName\": \"test_getOffsetFromLocal_Moscow_Autumn_overlap_mins\", \"error\": \"junit.framework.ComparisonFailure\", \"message\": \"2007-10-28T02:00:00.000+03:00 expected:<...10-28T02:00:00.000+0[4]:00> but was:<...10-28T02:00:00.000+0[3]:00>\"}","method":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"getOffsetFromLocal\", \"content\": \"    \/**\\n     * Gets the millisecond offset to subtract from local time to get UTC time.\\n     * This offset can be used to undo adding the offset obtained by getOffset.\\n     *\\n     * <pre>\\n     * millisLocal == millisUTC   + getOffset(millisUTC)\\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\\n     * <\/pre>\\n     *\\n     * NOTE: After calculating millisLocal, some error may be introduced. At\\n     * offset transitions (due to DST or other historical changes), ranges of\\n     * local times may map to different UTC times.\\n     * <p>\\n     * This method will return an offset suitable for calculating an instant\\n     * after any DST gap. For example, consider a zone with a cutover\\n     * from 01:00 to 01:59:<br \/>\\n     * Input: 00:00  Output: 00:00<br \/>\\n     * Input: 00:30  Output: 00:30<br \/>\\n     * Input: 01:00  Output: 02:00<br \/>\\n     * Input: 01:30  Output: 02:30<br \/>\\n     * Input: 02:00  Output: 02:00<br \/>\\n     * Input: 02:30  Output: 02:30<br \/>\\n     * <p>\\n     * During a DST overlap (where the local time is ambiguous) this method will return\\n     * the earlier instant. The combination of these two rules is to always favour\\n     * daylight (summer) time over standard (winter) time.\\n     * <p>\\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\\n     * Prior to v1.5, the DST gap behaviour was also not defined.\\n     *\\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\\n     * @return the millisecond offset to subtract from local time to get UTC time\\n     *\/\\n    public int getOffsetFromLocal(long instantLocal) {\\n        \/\/ get the offset at instantLocal (first estimate)\\n        final int offsetLocal = getOffset(instantLocal);\\n        \/\/ adjust instantLocal using the estimate and recalc the offset\\n        final long instantAdjusted = instantLocal - offsetLocal;\\n        final int offsetAdjusted = getOffset(instantAdjusted);\\n        \/\/ if the offsets differ, we must be near a DST boundary\\n        if (offsetLocal != offsetAdjusted) {\\n            \/\/ we need to ensure that time is always after the DST gap\\n            \/\/ this happens naturally for positive offsets, but not for negative\\n            if ((offsetLocal - offsetAdjusted) < 0) {\\n                \/\/ if we just return offsetAdjusted then the time is pushed\\n                \/\/ back before the transition, whereas it should be\\n                \/\/ on or after the transition\\n                long nextLocal = nextTransition(instantAdjusted);\\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\\n                if (nextLocal != nextAdjusted) {\\n                    return offsetLocal;\\n                }\\n            }\\n        }\\n        return offsetAdjusted;\\n    }\", \"javadoc_start_line\": 846, \"annotations_start_line\": 879, \"method_start_line\": 879, \"end_line\": 901}","steps":[{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestDateTimeZoneCutover.java\", \"method_name\": \"test_getOffsetFromLocal_Moscow_Autumn_overlap_mins\", \"content\": \"    public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {\\n        for (int min = 0; min < 60; min++) {\\n            if (min < 10) {\\n                doTest_getOffsetFromLocal(10, 28, 2, min, \\\"2007-10-28T02:0\\\" + min + \\\":00.000+04:00\\\", ZONE_MOSCOW);\\n            } else {\\n                doTest_getOffsetFromLocal(10, 28, 2, min, \\\"2007-10-28T02:\\\" + min + \\\":00.000+04:00\\\", ZONE_MOSCOW);\\n            }\\n        }\\n    }\", \"javadoc_start_line\": 910, \"annotations_start_line\": 910, \"method_start_line\": 910, \"end_line\": 918}"},{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestDateTimeZoneCutover.java\", \"method_name\": \"doTest_getOffsetFromLocal\", \"content\": \"    private void doTest_getOffsetFromLocal(int month, int day, int hour, int min, String expected, DateTimeZone zone) {\\n        doTest_getOffsetFromLocal(2007, month, day, hour, min, 0, 0, expected, zone);\\n    }\", \"javadoc_start_line\": 1216, \"annotations_start_line\": 1216, \"method_start_line\": 1216, \"end_line\": 1218}"},{"step":"{\"file_path\": \"\/src\/test\/java\/org\/joda\/time\/TestDateTimeZoneCutover.java\", \"method_name\": \"doTest_getOffsetFromLocal\", \"content\": \"    private void doTest_getOffsetFromLocal(int year, int month, int day, int hour, int min, int sec, int milli, String expected, DateTimeZone zone) {\\n        DateTime dt = new DateTime(year, month, day, hour, min, sec, milli, DateTimeZone.UTC);\\n        int offset = zone.getOffsetFromLocal(dt.getMillis());\\n        DateTime res = new DateTime(dt.getMillis() - offset, zone);\\n        assertEquals(res.toString(), expected, res.toString());\\n    }\", \"javadoc_start_line\": 1228, \"annotations_start_line\": 1228, \"method_start_line\": 1228, \"end_line\": 1233}"},{"step":"{\"file_path\": \"\/src\/main\/java\/org\/joda\/time\/DateTimeZone.java\", \"method_name\": \"getOffsetFromLocal\", \"content\": \"    \/**\\n     * Gets the millisecond offset to subtract from local time to get UTC time.\\n     * This offset can be used to undo adding the offset obtained by getOffset.\\n     *\\n     * <pre>\\n     * millisLocal == millisUTC   + getOffset(millisUTC)\\n     * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\\n     * <\/pre>\\n     *\\n     * NOTE: After calculating millisLocal, some error may be introduced. At\\n     * offset transitions (due to DST or other historical changes), ranges of\\n     * local times may map to different UTC times.\\n     * <p>\\n     * This method will return an offset suitable for calculating an instant\\n     * after any DST gap. For example, consider a zone with a cutover\\n     * from 01:00 to 01:59:<br \/>\\n     * Input: 00:00  Output: 00:00<br \/>\\n     * Input: 00:30  Output: 00:30<br \/>\\n     * Input: 01:00  Output: 02:00<br \/>\\n     * Input: 01:30  Output: 02:30<br \/>\\n     * Input: 02:00  Output: 02:00<br \/>\\n     * Input: 02:30  Output: 02:30<br \/>\\n     * <p>\\n     * During a DST overlap (where the local time is ambiguous) this method will return\\n     * the earlier instant. The combination of these two rules is to always favour\\n     * daylight (summer) time over standard (winter) time.\\n     * <p>\\n     * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\\n     * Prior to v1.5, the DST gap behaviour was also not defined.\\n     *\\n     * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\\n     * @return the millisecond offset to subtract from local time to get UTC time\\n     *\/\\n    public int getOffsetFromLocal(long instantLocal) {\\n        \/\/ get the offset at instantLocal (first estimate)\\n        final int offsetLocal = getOffset(instantLocal);\\n        \/\/ adjust instantLocal using the estimate and recalc the offset\\n        final long instantAdjusted = instantLocal - offsetLocal;\\n        final int offsetAdjusted = getOffset(instantAdjusted);\\n        \/\/ if the offsets differ, we must be near a DST boundary\\n        if (offsetLocal != offsetAdjusted) {\\n            \/\/ we need to ensure that time is always after the DST gap\\n            \/\/ this happens naturally for positive offsets, but not for negative\\n            if ((offsetLocal - offsetAdjusted) < 0) {\\n                \/\/ if we just return offsetAdjusted then the time is pushed\\n                \/\/ back before the transition, whereas it should be\\n                \/\/ on or after the transition\\n                long nextLocal = nextTransition(instantAdjusted);\\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\\n                if (nextLocal != nextAdjusted) {\\n                    return offsetLocal;\\n                }\\n            }\\n        }\\n        return offsetAdjusted;\\n    }\", \"javadoc_start_line\": 846, \"annotations_start_line\": 879, \"method_start_line\": 879, \"end_line\": 901}"}]}]